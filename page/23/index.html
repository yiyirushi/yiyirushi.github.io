<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/uploads/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/uploads/favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.ligoudan.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="天气不错哇，你看这大冰雹下得">
<meta property="og:type" content="website">
<meta property="og:title" content="LIGOUDAN">
<meta property="og:url" content="https://www.ligoudan.cn/page/23/index.html">
<meta property="og:site_name" content="LIGOUDAN">
<meta property="og:description" content="天气不错哇，你看这大冰雹下得">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="李狗蛋">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://www.ligoudan.cn/page/23/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/23/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>LIGOUDAN</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">LIGOUDAN</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">好好学习，天天向上</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">326</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">137</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">461</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="李狗蛋"
      src="/uploads/ligoudan.png">
  <p class="site-author-name" itemprop="name">李狗蛋</p>
  <div class="site-description" itemprop="description">天气不错哇，你看这大冰雹下得</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">461</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">137</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">326</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/yiyirushi" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yiyirushi" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yuanhaohoo@163.com" title="E-Mail → mailto:yuanhaohoo@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/62f8d9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/62f8d9/" class="post-title-link" itemprop="url">HBase 架构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-07-24 06:52:07" itemprop="dateCreated datePublished" datetime="2020-07-24T06:52:07+08:00">2020-07-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%88%97%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">列式数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%88%97%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/HBase/" itemprop="url" rel="index"><span itemprop="name">HBase</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="HBase-架构"><a href="#HBase-架构" class="headerlink" title="HBase 架构"></a>HBase 架构</h1><blockquote>
<p><strong><em>HBase 是一个在 HDFS 上开发的面向列的分布式数据库。</em></strong></p>
</blockquote>
<h2 id="HBase-存储架构"><a href="#HBase-存储架构" class="headerlink" title="HBase 存储架构"></a>HBase 存储架构</h2><blockquote>
<p>在 HBase 中，表被分割成多个更小的块然后分散的存储在不同的服务器上，这些小块叫做 Regions，存放 Regions 的地方叫做 RegionServer。Master 进程负责处理不同的 RegionServer 之间的 Region 的分发。</p>
</blockquote>
<h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200612151239.png" alt="img"></p>
<p>HBase 主要处理两种文件：预写日志（WAL）和实际数据文件 HFile。一个基本的流程是客户端首先联系 ZooKeeper 集群查找行键。上述过程是通过 ZooKeeper 获取欧含有 <code>-ROOT-</code> 的  region 服务器来完成的。通过含有 <code>-ROOT-</code> 的 region 服务器可以查询到含有 <code>.META.</code> 表中对应的 region 服务器名，其中包含请求的行键信息。这两种内容都会被缓存下来，并且只查询一次。最终，通过查询 .META. 服务器来获取客户端查询的行键数据所在 region 的服务器名。</p>
<h3 id="Region"><a href="#Region" class="headerlink" title="Region"></a>Region</h3><p>HBase Table 中的所有行按照 <code>Row Key</code> 的字典序排列。HBase Table 根据 Row Key 的范围分片，每个分片叫做 <code>Region</code>。一个 <code>Region</code> 包含了在 start key 和 end key 之间的所有行。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/bigdata/hbase/1551165887616.png" alt="img"></p>
<p><strong>HBase 支持自动分区</strong>：每个表初始只有一个 <code>Region</code>，随着数据不断增加，<code>Region</code> 会不断增大，当增大到一个阀值的时候，<code>Region</code> 就会分裂为两个新的 <code>Region</code>。当 Table 中的行不断增多，就会有越来越多的 <code>Region</code>。</p>
<p><code>Region</code> 是 HBase 中<strong>分布式存储和负载均衡的最小单元</strong>。这意味着不同的 <code>Region</code> 可以分布在不同的 <code>Region Server</code> 上。但一个 <code>Region</code> 是不会拆分到多个 Server 上的。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200601181219.png" alt="img"></p>
<h3 id="Region-Server"><a href="#Region-Server" class="headerlink" title="Region Server"></a>Region Server</h3><p><code>Region</code> 只不过是表被拆分，并分布在 Region Server。</p>
<p><code>Region Server</code> 运行在 HDFS 的 DataNode 上。它具有以下组件：</p>
<ul>
<li>**WAL(Write Ahead Log，预写日志)**：用于存储尚未进持久化存储的数据记录，以便在发生故障时进行恢复。如果写 WAL 失败了，那么修改数据的完整操作就是失败的。<ul>
<li>通常情况，每个 RegionServer 只有一个 WAL 实例。在 2.0 之前，WAL 的实现叫做 HLog</li>
<li>WAL 位于 <code>/hbase/WALs/</code> 目录下</li>
<li>如果每个 RegionServer 只有一个 WAL，由于 HDFS 必须是连续的，导致必须写 WAL 连续的，然后出现性能问题。MultiWAL 可以让 RegionServer 同时写多个 WAL 并行的，通过 HDFS 底层的多管道，最终提升总的吞吐量，但是不会提升单个 Region 的吞吐量。</li>
</ul>
</li>
<li><strong>BlockCache</strong>：<strong>读缓存</strong>。它将频繁读取的数据存储在内存中，如果存储不足，它将按照 <code>最近最少使用原则</code> 清除多余的数据。</li>
<li><strong>MemStore</strong>：<strong>写缓存</strong>。它存储尚未写入磁盘的新数据，并会在数据写入磁盘之前对其进行排序。每个 Region 上的每个列族都有一个 MemStore。</li>
<li><strong>HFile</strong>：<strong>将行数据按照 Key&#x2F;Values 的形式存储在文件系统上</strong>。HFile 是 HBase 在 HDFS 中存储数据的格式，它包含多层的索引，这样在 HBase 检索数据的时候就不用完全的加载整个文件。HFile 存储的根目录默认为为 <code>/hbase</code>。索引的大小(keys 的大小，数据量的大小)影响 block 的大小，在大数据集的情况下，block 的大小设置为每个 RegionServer 1GB 也是常见的。<ul>
<li>起初，HFile 中并没有任何 Block，数据还存在于 MemStore 中。</li>
<li>Flush 发生时，创建 HFile Writer，第一个空的 Data Block 出现，初始化后的 Data Block 中为 Header 部分预留了空间，Header 部分用来存放一个 Data Block 的元数据信息。</li>
<li>而后，位于 MemStore 中的 KeyValues 被一个个 append 到位于内存中的第一个 Data Block 中：</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/bigdata/hbase/1551166602999.png" alt="img"></p>
<p>Region Server 存取一个子表时，会创建一个 Region 对象，然后对表的每个列族创建一个 <code>Store</code> 实例，每个 <code>Store</code> 会有 0 个或多个 <code>StoreFile</code> 与之对应，每个 <code>StoreFile</code> 则对应一个 <code>HFile</code>，HFile 就是实际存储在 HDFS 上的文件。</p>
<h2 id="HBase-系统架构"><a href="#HBase-系统架构" class="headerlink" title="HBase 系统架构"></a>HBase 系统架构</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/bigdata/hbase/1551164744748.png" alt="img"></p>
<p>和 HDFS、YARN 一样，<strong>HBase 也遵循 master &#x2F; slave 架构</strong>：</p>
<ul>
<li>HBase 有一个 master 节点。<strong>master 节点负责协调管理 region server 节点</strong>。<ul>
<li>master 负责将 region 分配给 region server 节点；</li>
<li>master 负责恢复 region server 节点的故障。</li>
</ul>
</li>
<li>HBase 有多个 region server 节点。<strong>region server 节点负责零个或多个 region 的管理并响应客户端的读写请求。region server 节点还负责 region 的划分并通知 master 节点有了新的子 region</strong>。</li>
<li>HBase 依赖 ZooKeeper 来实现故障恢复。</li>
</ul>
<h3 id="Master-Server"><a href="#Master-Server" class="headerlink" title="Master Server"></a>Master Server</h3><p><strong>Master Server 负责协调 Region Server</strong>。具体职责如下：</p>
<ul>
<li>为 Region Server 分配 Region ；</li>
<li>负责 Region Server 的负载均衡 ；</li>
<li>发现失效的 Region Server 并重新分配其上的 Region；</li>
<li>GFS 上的垃圾文件回收；</li>
<li>处理 Schema 的更新请求。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/bigdata/hbase/1551166513572.png" alt="img"></p>
<h3 id="Region-Server-1"><a href="#Region-Server-1" class="headerlink" title="Region Server"></a>Region Server</h3><ul>
<li>Region Server 负责维护 Master Server 分配给它的 Region，并处理发送到 Region 上的 IO 请求；</li>
<li>当 Region 过大，Region Server 负责自动分区，并通知 Master Server 记录更新。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200612151602.png" alt="img"></p>
<h3 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h3><p><strong>HBase 依赖 ZooKeeper 作为分布式协调服务来维护集群中的服务器状态</strong>。Zookeeper 维护哪些服务器是活动的和可用的，并提供服务器故障通知。集群至少应该有 3 个节点。</p>
<p>ZooKeeper 的作用：</p>
<ul>
<li>保证任何时候，集群中只有一个 Master；</li>
<li>存储所有 Region 的寻址入口；</li>
<li>实时监控 Region Server 的状态，将 Region Server 的上线和下线信息实时通知给 Master；</li>
<li>存储 HBase 的 Schema，包括有哪些 Table，每个 Table 有哪些 Column Family 等信息。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/bigdata/hbase/1551166447147.png" alt="img"></p>
<p>以上，最重要的一点是 ZooKeeper 如何保证 HBase 集群中只有一个 Master Server 的呢？</p>
<ul>
<li>所有 Master Server 会竞争 Zookeeper 的 znode 锁（一个临时节点），只有一个 Master Server 能够创建成功，此时该 Master 就是主 Master。</li>
<li>主 Master 会定期向 Zookeeper 发送心跳。从 Master 则通过 Watcher 机制对主 Master 所在节点进行监听。</li>
<li>如果，主 Master 未能及时发送心跳，则其持有的 ZooKeeper 会话会过期，相应的 znode 锁（一个临时节点）会被自动删除。这会触发定义在该节点上的 Watcher 事件，所有从 Master 会得到通知，并再次开始竞争 znode 锁，直到完成主 Master 的选举。</li>
</ul>
<p>HBase 内部保留名为 hbase:meta 的特殊目录表（catalog table）。它维护着当前集群上所有 region 的列表、状态和位置。hbase:meta 表中的项使用 region 作为键。region 名由所属的表名、region 的起始行、region的创建时间以及基于整体计算得出的 MD5 组成。</p>
<h2 id="HBase-读写流程"><a href="#HBase-读写流程" class="headerlink" title="HBase 读写流程"></a>HBase 读写流程</h2><h3 id="写入数据的流程"><a href="#写入数据的流程" class="headerlink" title="写入数据的流程"></a>写入数据的流程</h3><ol>
<li>Client 向 Region Server 提交写请求；</li>
<li>Region Server 找到目标 Region；</li>
<li>Region 检查数据是否与 Schema 一致；</li>
<li>如果客户端没有指定版本，则获取当前系统时间作为数据版本；</li>
<li>将更新写入 WAL Log；</li>
<li>将更新写入 Memstore；</li>
<li>判断 Memstore 存储是否已满，如果存储已满则需要 flush 为 Store Hfile 文件。</li>
</ol>
<blockquote>
<p>更为详细写入流程可以参考：<a target="_blank" rel="noopener" href="http://hbasefly.com/2016/03/23/hbase_writer/">HBase － 数据写入流程解析</a></p>
</blockquote>
<h3 id="读取数据的流程"><a href="#读取数据的流程" class="headerlink" title="读取数据的流程"></a>读取数据的流程</h3><p>以下是客户端首次读写 HBase 上数据的流程：</p>
<ol>
<li>客户端从 Zookeeper 获取 <code>META</code> 表所在的 Region Server；</li>
<li>客户端访问 <code>META</code> 表所在的 Region Server，从 <code>META</code> 表中查询到访问行键所在的 Region Server，之后客户端将缓存这些信息以及 <code>META</code> 表的位置；</li>
<li>客户端从行键所在的 Region Server 上获取数据。</li>
</ol>
<p>如果再次读取，客户端将从缓存中获取行键所在的 Region Server。这样客户端就不需要再次查询 <code>META</code> 表，除非 Region 移动导致缓存失效，这样的话，则将会重新查询并更新缓存。</p>
<p>注：<code>META</code> 表是 HBase 中一张特殊的表，它保存了所有 Region 的位置信息，META 表自己的位置信息则存储在 ZooKeeper 上。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200601182655.png" alt="img"></p>
<blockquote>
<p>更为详细读取数据流程参考：</p>
<p><a target="_blank" rel="noopener" href="http://hbasefly.com/2016/12/21/hbase-getorscan/">HBase 原理－数据读取流程解析</a></p>
<p><a target="_blank" rel="noopener" href="http://hbasefly.com/2017/06/11/hbase-scan-2/">HBase 原理－迟到的‘数据读取流程部分细节</a></p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><strong>官方</strong><ul>
<li><a target="_blank" rel="noopener" href="http://hbase.apache.org/">HBase 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://hbase.apache.org/book.html">HBase 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="http://abloz.com/hbase/book.html">HBase 官方文档中文版</a></li>
<li><a target="_blank" rel="noopener" href="https://hbase.apache.org/apidocs/index.html">HBase API</a></li>
</ul>
</li>
<li><strong>教程</strong><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/heibaiying/BigData-Notes">BigData-Notes</a></li>
</ul>
</li>
<li><strong>文章</strong><ul>
<li><a target="_blank" rel="noopener" href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/bigtable-osdi06.pdf">Bigtable: A Distributed Storage System for Structured Data</a></li>
<li><a target="_blank" rel="noopener" href="https://mapr.com/blog/in-depth-look-hbase-architecture/">An In-Depth Look at the HBase Architecture</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5c666cc4f265da2da53eb714">入门 HBase，看这一篇就够了</a></li>
<li><a target="_blank" rel="noopener" href="https://bighadoop.wordpress.com/tag/hbase/">https://bighadoop.wordpress.com/tag/hbase/</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/55f66f/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/55f66f/" class="post-title-link" itemprop="url">Kafka 流式处理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-07-24 06:52:07" itemprop="dateCreated datePublished" datetime="2020-07-24T06:52:07+08:00">2020-07-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:53" itemprop="dateModified" datetime="2024-12-12T10:02:53+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/" itemprop="url" rel="index"><span itemprop="name">分布式通信</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/MQ/" itemprop="url" rel="index"><span itemprop="name">MQ</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/MQ/Kafka/" itemprop="url" rel="index"><span itemprop="name">Kafka</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Kafka-流式处理"><a href="#Kafka-流式处理" class="headerlink" title="Kafka 流式处理"></a>Kafka 流式处理</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="什么是流式处理"><a href="#什么是流式处理" class="headerlink" title="什么是流式处理"></a>什么是流式处理</h3><p><strong>数据流是无边界数据集的抽象表示</strong>。无边界意味着无限和持续增长。无边界数据集之所以是无限的，是因为随着时间的推移，新的记录会不断加入进来。</p>
<ul>
<li><strong>事件流是有序的</strong>。事件的发生总是有先后顺序。而数据库里的记录是无序的。</li>
<li><strong>不可变的数据记录</strong>。事件一旦发生，就不能被改变。</li>
<li><strong>事件流是可重播的</strong>。对于大多数业务来说，重播发生在几个月前（甚至几年前）的原始事件流是一个很重要的需求。可能是为了尝试使用新的分析方法纠正过去的错误，或是为了进行审计。如果没有这项能力，流式处理充其量只是数据科学实验室里的一个玩具而已。</li>
</ul>
<p><strong>流式处理是指实时地处理一个或多个事件流</strong>。流式处理是一种编程范式，就像请求与响应范式和批处理范式那样。</p>
<h3 id="编程范式对比"><a href="#编程范式对比" class="headerlink" title="编程范式对比"></a>编程范式对比</h3><ul>
<li><strong>请求与响应</strong> - 这是<strong>延迟最小</strong>的一种范式，响应时间处于亚毫秒到毫秒之间，而且响应时间一般非常稳定。这种处理模式一般是阻塞的，应用程序向处理系统发出请求，然后等待响应。</li>
<li><strong>批处理</strong> - 这种范式具有<strong>高延迟</strong>和<strong>高吞吐量</strong>的特点。处理系统按照设定的时间启动处理进程，读取所有的输入数据（从上一次执行之后的所有可用数据，或者从月初开始的所有数据等），输出结果，然后等待下一次启动。处理时间从几分钟到几小时不等，并且用户从结果里读到的都是旧数据。一般用于 BI 生成分析报表。</li>
<li><strong>流式处理</strong> - 这种范式介于上述两者之间。大部分的业务不要求亚毫秒级的响应，不过也接受不了长时间的等待。大部分业务流程都是持续进行的，只要业务报告保持更新，业务产品线能够持续响应，那么业务流程就可以进行下去，而无需等待特定的响应，也不要求在几毫秒内得到响应。一些业务流程具有持续性和非阻塞的特点。</li>
</ul>
<p>流的定义不依赖任何一个特定的框架、 API 或特性。只要持续地从一个无边界的数据集读取数据，然后对它们进行处理并生成结果，那就是在进行流式处理。重点是，<strong>整个处理过程必须是持续的</strong>。</p>
<h3 id="流处理的核心概念"><a href="#流处理的核心概念" class="headerlink" title="流处理的核心概念"></a>流处理的核心概念</h3><h4 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h4><p>时间或许是流式处理最为重要的概念。大部分流式应用的操作都是基于时间窗口的。有这么几个时间概念：</p>
<ul>
<li><strong>事件时间</strong> - 事件时间是指所追踪事件的发生时间和记录的创建时间。</li>
<li><strong>日志追加时间</strong> - 日志追加时间是指事件保存到 broker 的时间。</li>
<li><strong>处理时间</strong> - 处理时间是指应用程序在收到事件之后要对其进行处理的时间。这个时间可以是在事件发生之后的几毫秒、几小时或几天。同一个事件可能会被分配不同的时间戳，这取决于应用程序何时读取这个事件。如果应用程序使用了两个线程来读取同一个事件，这个时间戳也会不一样！所以这个时间戳非常不可靠，应该避免使用它。</li>
</ul>
<blockquote>
<p>注意：在处理与时间有关的问题时，需要注意时区问题。整个数据管道应该使用同一个时区。</p>
</blockquote>
<h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><p>如果只是单独处理每一个事件，那么流式处理就很简单。</p>
<p>如果操作里包含了多个事件，流式处理就会变得复杂而有趣。<strong>事件与事件之间的信息被称为状态</strong>。这些状态一般被保存在应用程序的本地变量里。</p>
<p>流式处理含以下几种状态：</p>
<ul>
<li><strong>本地状态或内部状态</strong> - 这种状态只能被单个应用程序实例访问，它们一般使用内嵌在应用程序里的数据库进行维护和管理。本地状态的优势在于它的速度，不足之处在于它受到内存大小的限制 。 所以，流式处理的很多设计模式都将数据拆分到多个子流，这样就可以使用有限的本地状态来处理它们。</li>
<li><strong>外部状态</strong> - 这种状态使用外部的数据存储来维护，一般使用 NoSQL 系统，比如 Cassandra。大部分流式处理应用尽量避免使用外部存储，或者将信息缓存在本地，减少与外部存储发生交互，以此来降低延迟，而这就引入了如何维护内部和外部状态一致性的问题。</li>
</ul>
<h4 id="流和表"><a href="#流和表" class="headerlink" title="流和表"></a>流和表</h4><p><strong>流是一系列事件，每个事件就是一个变更。表包含了当前的状态，是多个变更所产生的结果</strong>。所以说， 表和流是同一个硬币的两面，世界总是在发生变化，用户有时候关注变更事件，有时候则关注世界的当前状态。如果一个系统允许使用这两种方式来查看数据，那么它就比只支持一种方式的系统强大。</p>
<h4 id="时间窗口"><a href="#时间窗口" class="headerlink" title="时间窗口"></a>时间窗口</h4><p>时间窗口有不同的类型，基于以下属性决定：</p>
<ul>
<li>窗口的大小</li>
<li>窗口移动的频率</li>
<li>窗口的可更新时间多长</li>
</ul>
<h2 id="流处理的设计模式"><a href="#流处理的设计模式" class="headerlink" title="流处理的设计模式"></a>流处理的设计模式</h2><h3 id="单个事件处理"><a href="#单个事件处理" class="headerlink" title="单个事件处理"></a>单个事件处理</h3><p>处理单个事件是流式处理最基本的模式。这个模式也叫 <code>map</code> 或 <code>filter</code> 模式，因为它经常被用于过滤无用的事件或者用于转换事件（ map 这个术语是从 Map-Reduce 模式中来的， <code>map</code> 阶段转换事件， <code>reduce</code> 阶段聚合转换过的事件）。</p>
<p>在这种模式下，应用程序读取流中的事件 ，修改它们，然后把事件生成到另一个流上。</p>
<h3 id="使用本地状态"><a href="#使用本地状态" class="headerlink" title="使用本地状态"></a>使用本地状态</h3><p>大部分流式处理应用程序关心的是如何聚合信息，特别是基于时间窗口进行聚合。</p>
<p>要实现这些聚合操作，需要维护流的状态，可以通过本地状态（而不是共享状态）来实现。</p>
<p>如果流式处理应用包含了本地状态，会变得非常复杂，还需要解决下列问题：</p>
<ul>
<li><strong>内存使用</strong> - 应用实例必须有可用的内存来保存本地状态。</li>
<li><strong>持久化</strong> - 要确保在应用程序关闭时不会丢失状态，并且在应用程序重启后或者切换到另一个应用实例时可以恢复状态。</li>
<li><strong>再均衡</strong> - 有时候，分区会被重新分配给不同的消费者。在这种情况下，失去分区的实例必须把最后的状态保存起来 ， 同时获得分区的实例必须知道如何恢复到正确的状态。</li>
</ul>
<h3 id="多阶段处理和重分区"><a href="#多阶段处理和重分区" class="headerlink" title="多阶段处理和重分区"></a>多阶段处理和重分区</h3><p>数据量不大的时候，可以使用本地状态。但面对海量的流数据时，可以使用多阶段处理（类似 Hadoop 的 map reduce）</p>
<h3 id="流和表的连接"><a href="#流和表的连接" class="headerlink" title="流和表的连接"></a>流和表的连接</h3><p>有些场景下，流式处理需要将外部数据和流集成在一起。</p>
<p>可以考虑将外部的数据信息（如数据库存储）缓存到流式处理应用程序里。</p>
<h3 id="流和流的连接"><a href="#流和流的连接" class="headerlink" title="流和流的连接"></a>流和流的连接</h3><p>有些场景下，需要连接两个真实的事件流。</p>
<p>将两个流里具有相同键和发生在相同时间窗口内的事件匹配起来。这就是为什么流和流的连接也叫作基于时间窗口的连接（ windowed-join ）。</p>
<h3 id="乱序的事件"><a href="#乱序的事件" class="headerlink" title="乱序的事件"></a>乱序的事件</h3><p>不管是对于流式处理还是传统的 ETL 系统来说，处理乱序事件都是一个挑战。</p>
<p>要让流处理应用程序处理好这些场景，需要做到以下几点：</p>
<ul>
<li><strong>识别乱序的事件</strong>。应用程序需要检查事件的时间，并将其与当前时间进行比较。</li>
<li><strong>规定一个时间段用于重排乱序的事件</strong>。比如 3 个小时以内的事件可以重排，但 3 周以外的事件就可以直接扔掉。</li>
<li><strong>具有在一定时间段内重排乱序事件的能力</strong>。这是流式处理应用与批处理作业的一个主要不同点。假设有一个每天运行的作业， 一些事件在作业结束之后才到达，那么可以重新运行昨天的作业来更新事件。而在流式处理中，“重新运行昨天的作业”这种情况是不存在的，乱序事件和新到达的事件必须一起处理。</li>
<li><strong>具备更新结果的能力</strong>。如果处理的结果保存到数据库里，那么可以通过 put 或 update 对结果进行更新。如果流应用程序通过邮件发送结果，那么要对结果进行更新，就需要很巧妙的手段。</li>
</ul>
<h3 id="重新处理"><a href="#重新处理" class="headerlink" title="重新处理"></a>重新处理</h3><p>有两种模式：</p>
<p>模式一：使用新版本应用处理同一个事件流，生成新的结果，并比较两种版本的结果，然后在某个时间点将客户端切换到新的结果流上。</p>
<p>模式二：重置应用，让应用回到输入流的起始位置开始处理，同时重置本地状态（这样就不会将两个版本应用的处理结果棍淆起来了），而且还可能需要清理之前的输出流。</p>
<h2 id="Kafka-Streams-的架构"><a href="#Kafka-Streams-的架构" class="headerlink" title="Kafka Streams 的架构"></a>Kafka Streams 的架构</h2><p>每个流式应用程序至少会实现和执行一个拓扑。拓扑（在其他流式处理框架里叫作 DAG，即有向无环图）是一个操作和变换的集合，每个事件从输入到输出都会流经它。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200622112309.png" alt="img"></p>
<h3 id="分区和任务"><a href="#分区和任务" class="headerlink" title="分区和任务"></a>分区和任务</h3><p>Kafka 的消息传递层对数据进行分区以进行存储和传输。 Kafka Streams 对数据进行分区以进行处理。Kafka Streams 使用分区和任务的概念作为基于 Kafka 主题分区的并行模型的逻辑单元。</p>
<p>每个流分区都是数据记录的完全有序序列，并映射到 Kafka 主题分区。流中的数据记录映射到该主题的 Kafka 消息。更具体地说，Kafka Streams 根据应用程序的输入流分区创建固定数量的任务，每个任务分配了输入流中的分区列表（即 Kafka 主题）。分区对任务的分配永远不会改变，因此每个任务都是应用程序并行性的固定单元。然后，任务可以根据分配的分区实例化其自己的处理器拓扑。它们还为其分配的每个分区维护一个缓冲区，并一次从这些记录缓冲区处理消息。结果，可以在没有人工干预的情况下独立且并行地处理流任务。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200622113822.png" alt="img"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><strong>官方</strong><ul>
<li><a target="_blank" rel="noopener" href="http://kafka.apache.org/">Kafka 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/kafka">Kafka Github</a></li>
<li><a target="_blank" rel="noopener" href="https://kafka.apache.org/documentation/">Kafka 官方文档</a></li>
</ul>
</li>
<li><strong>书籍</strong><ul>
<li><a target="_blank" rel="noopener" href="https://item.jd.com/12270295.html">《Kafka 权威指南》</a></li>
</ul>
</li>
<li><strong>教程</strong><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/apachecn/kafka-doc-zh">Kafka 中文文档</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100029201">Kafka 核心技术与实战</a></li>
</ul>
</li>
<li><strong>文章</strong><ul>
<li><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/kafka-analysis-part-7">Kafka 设计解析（七）：流式计算的新贵 Kafka Stream</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/aa7497/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/aa7497/" class="post-title-link" itemprop="url">微服务基本原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-07-21 15:35:00" itemprop="dateCreated datePublished" datetime="2020-07-21T15:35:00+08:00">2020-07-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">设计</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">架构</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1/%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" itemprop="url" rel="index"><span itemprop="name">微服务</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>11k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>10 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="微服务基本原理"><a href="#微服务基本原理" class="headerlink" title="微服务基本原理"></a>微服务基本原理</h1><h2 id="微服务技术架构"><a href="#微服务技术架构" class="headerlink" title="微服务技术架构"></a>微服务技术架构</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200716195006.png" alt="img"></p>
<p><strong>第一层：接入层</strong></p>
<p>外部设备访问的统一接入层。</p>
<p><strong>第二层：聚合服务层</strong></p>
<p>对下层的基础服务做一些聚合，剪裁的工作，适配上层不同设备的数据输出。</p>
<p><strong>第三层：基础服务层</strong></p>
<p>比较细粒度的微服务层，提供基础的核心服务，公共服务。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200716195117.png" alt="img"></p>
<h2 id="服务通信"><a href="#服务通信" class="headerlink" title="服务通信"></a>服务通信</h2><p>通过注册中心，服务消费者和服务提供者就可以感知彼此，但是，要实现交互还必须解决通信问题：</p>
<ul>
<li><strong>通信协议</strong>。即服务提供者和服务消费者之间以什么样的 <strong>协议</strong> 进行网络通信，说白了，是要解决客户端和服务端如何建立连接、管理连接以及服务端如何处理请求的问题。是采用四层 TCP、UDP 协议，还是采用七层 HTTP 协议，还是采用其他协议？例如：Dubbo 基于 TCP 通信；而 Spring Cloud 基于 HTTP REST 通信。TCP 通信方式，传输效率更高；但是 HTTP 方式天然可以提供对外服务。</li>
<li><strong>传输方式</strong>。即服务提供者和服务消费者之间的数据传输采用哪种方式。是同步还是异步？是在单连接上传输，还是多路复用。</li>
<li><strong>序列化和反序列化</strong>。它主要解决客户端和服务端采用哪种数据编解码的问题。常见的序列化方式包括：XML、JSON；二进制类如：<a target="_blank" rel="noopener" href="https://github.com/apache/thrift">thrift</a>、<a target="_blank" rel="noopener" href="https://github.com/protocolbuffers/protobuf">protobuf</a>、<a target="_blank" rel="noopener" href="http://hessian.caucho.com/doc/hessian-overview.xtp">hessian</a>、JDK。</li>
</ul>
<h3 id="序列化方式"><a href="#序列化方式" class="headerlink" title="序列化方式"></a>序列化方式</h3><p>序列化方式的选型，一般基于以下考虑：</p>
<ul>
<li>支持数据结构类型的丰富度</li>
<li>跨语言支持</li>
<li>性能</li>
</ul>
<blockquote>
<p>👉 参考：<a target="_blank" rel="noopener" href="https://dunwu.github.io/waterdrop/pages/2b2f0f/">Java 序列化</a></p>
</blockquote>
<h3 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h3><p>微服务框架对比：</p>
<table>
<thead>
<tr>
<th></th>
<th>RPC</th>
<th>REST</th>
</tr>
</thead>
<tbody><tr>
<td>耦合性</td>
<td>强耦合</td>
<td>松散耦合</td>
</tr>
<tr>
<td>协议</td>
<td>Tcp</td>
<td>Http、Http2</td>
</tr>
<tr>
<td>序列化</td>
<td>二进制（Thrift、Protobuf、Hessian、Avro、JDK 等）</td>
<td>Xml、Json</td>
</tr>
<tr>
<td>性能</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>客户端</td>
<td>对编程语言有限制</td>
<td>跨语言支持更好（支持 Http 即可）</td>
</tr>
<tr>
<td>代表技术</td>
<td>Dubbo、Motan、Tars、gRpc、Thrift</td>
<td>Spring Cloud</td>
</tr>
</tbody></table>
<h2 id="服务监控"><a href="#服务监控" class="headerlink" title="服务监控"></a>服务监控</h2><p>当服务消费者与服务提供者之间建立了通信，作为管理者需要通过监控手段来观察服务是否正常，调用是否成功。服务监控是很复杂的，在微服务架构下，一次用户调用会因为服务化拆分后，变成多个不同服务之间的相互调用，这也就需要对拆分后的每个服务都监控起来。</p>
<h3 id="监控对象"><a href="#监控对象" class="headerlink" title="监控对象"></a>监控对象</h3><p>服务监控一定是通过观察数据来量化分析，所以首先要明确需要监控什么。</p>
<p>一般来说，服务监控数据有以下分类：</p>
<ul>
<li><strong>业务监控</strong>：核心指标、登录、登出、下单、支付等。</li>
<li><strong>应用监控</strong>：访问接口、访问服务、SQL、内存使用率、响应时间、TPS、QPS 等。</li>
<li><strong>系统监控</strong>：CPU、内存、网络、磁盘等。</li>
<li><strong>基础监控</strong>：网络流量、丢包数、错包数、连接数等。</li>
<li><strong>客户端监控</strong>：性能、返回码、地域、运营商、版本、系统等。</li>
</ul>
<h3 id="系统监控原理"><a href="#系统监控原理" class="headerlink" title="系统监控原理"></a>系统监控原理</h3><p>一旦明确了要监控的对象，接下就是考虑如何监控。</p>
<p><strong>监控系统主要包括四个环节：数据采集、数据传输、数据处理和数据展示</strong></p>
<h4 id="数据采集"><a href="#数据采集" class="headerlink" title="数据采集"></a>数据采集</h4><p>通常有两种数据收集方式：</p>
<ul>
<li><strong>服务主动上报</strong>：这种处理方式通过在业务代码或者服务框架里加入数据收集代码逻辑，在每一次服务调用完成后，主动上报服务的调用信息。这种方式在链路跟踪中较为常见，主流的技术方案有：Zipkin。</li>
<li><strong>代理收集</strong>：这种处理方式通过服务调用后把调用的详细信息记录到本地日志文件中，然后再通过代理去解析本地日志文件，然后再上报服务的调用信息。主流的技术方案有：ELK、Flume。</li>
</ul>
<h4 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h4><p>数据传输最常用的方式有两种：</p>
<ul>
<li><strong>UDP 传输</strong>：这种处理方式是数据处理单元提供服务器的请求地址，数据采集后通过 UDP 协议与服务器建立连接，然后把数据发送过去。</li>
<li><strong>Kafka 传输</strong>：这种处理方式是数据采集后发送到指定的 Topic，然后数据处理单元再订阅对应的 Topic，就可以从 Kafka 消息队列中读取到对应的数据。由于 Kafka 有非常高的吞吐能力，所以很适合作为大数据量的缓冲池。</li>
</ul>
<h4 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h4><p>数据处理是对收集来的原始数据进行聚合并存储。数据聚合通常有两个维度：</p>
<ul>
<li><strong>接口维度聚合</strong>：这个维度是把实时收到的数据按照接口名维度实时聚合在一起，这样就可以得到每个接口的每秒请求量、平均耗时、成功率等信息。</li>
<li><strong>机器维度聚合</strong>：这个维度是把实时收到的数据按照调用的节点维度聚合在一起，这样就可以从单机维度去查看每个接口的实时请求量、平均耗时等信息。</li>
</ul>
<p>聚合后的数据需要持久化到数据库中存储，所选用的数据库一般分为两种：</p>
<ul>
<li><strong>全文检索数据库</strong>：比如 Elasticsearch，以倒排索引的数据结构存储，需要查询的时候，根据索引来查询。</li>
<li><strong>时序数据库</strong>：比如 OpenTSDB，以时序序列数据的方式存储，查询的时候按照时序如 1min、5min 等维度来查询。</li>
</ul>
<h4 id="数据展示"><a href="#数据展示" class="headerlink" title="数据展示"></a>数据展示</h4><p>数据展示是把处理后的数据以 Dashboard 的方式展示给用户。数据展示有多种方式，比如曲线图、饼状图、格子图展示等。</p>
<h3 id="监控技术"><a href="#监控技术" class="headerlink" title="监控技术"></a>监控技术</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200716204432.png" alt="img"></p>
<ul>
<li>ELK 的技术栈比较成熟，应用范围也比较广，除了可用作监控系统外，还可以用作日志查询和分析。</li>
<li>Graphite 是基于时间序列数据库存储的监控系统，并且提供了功能强大的各种聚合函数比如 sum、average、top5 等可用于监控分析，而且对外提供了 API 也可以接入其他图形化监控系统如 Grafana。</li>
<li>TICK 的核心在于其时间序列数据库 InfluxDB 的存储功能强大，且支持类似 SQL 语言的复杂数据处理操作。</li>
<li>Prometheus 的独特之处在于它采用了拉数据的方式，对业务影响较小，同时也采用了时间序列数据库存储，而且支持独有的 PromQL 查询语言，功能强大而且简洁。</li>
</ul>
<h2 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h2><p>微服务治理平台就是<strong>与服务打交道的统一入口</strong>，无论是开发人员还是运维人员，都能通过这个平台对服务进行各种操作，比如开发人员可以通过这个平台对服务进行降级操作，运维人员可以通过这个平台对服务进行上下线操作，而不需要关心这个操作背后的具体实现。</p>
<p>微服务治理平台关键之处就在于它能够封装对微服务架构内的各个基础设施组件的调用，从而对外提供统一的服务操作 API，而且还提供了可视化的界面，以方便开发人员和运维人员操作。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200716203729.png" alt="img"></p>
<p>服务治理的常用手段有：</p>
<ul>
<li>节点管理<ul>
<li>注册中心主动摘除机制</li>
<li>服务消费者摘除机制</li>
</ul>
</li>
<li>负载均衡<ul>
<li>轮询</li>
<li>随机</li>
<li>最近最少连接</li>
<li>一致性 Hash</li>
</ul>
</li>
<li>服务路由<ul>
<li>业务存在灰度发布的需求</li>
<li>多机房就近访问的需求</li>
</ul>
</li>
<li>服务容错<ul>
<li>FailOver：失败自动切换</li>
<li>FailBack：失败通知</li>
<li>FailCache：失败缓存</li>
<li>FailFast：快速失败</li>
</ul>
</li>
</ul>
<h2 id="API-网关"><a href="#API-网关" class="headerlink" title="API 网关"></a>API 网关</h2><p>API 网关是一个服务器，是系统的唯一入口。从面向对象设计的角度看，它与外观模式类似。API 网关封装了系统内部架构，为每个客户端提供一个定制的 API。它可能还具有其它职责，如身份验证、监控、负载均衡、缓存、请求分片与管理、静态响应处理。<br>API 网关方式的核心要点是，所有的客户端和消费端都通过统一的网关接入微服务，在网关层处理所有的非业务功能。通常，网关也是提供 REST&#x2F;HTTP 的访问 API。服务端通过 API-GW 注册和管理服务。</p>
<h3 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a>Zuul</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200716201640.png" alt="img"></p>
<p>在 zuul 中， 整个请求的过程是这样的，首先将请求给 zuulservlet 处理，zuulservlet 中有一个 zuulRunner 对象，该对象中初始化了 RequestContext：作为存储整个请求的一些数据，并被所有的 zuulfilter 共享。zuulRunner 中还有 FilterProcessor，FilterProcessor 作为执行所有的 zuulfilter 的管理器。FilterProcessor 从 filterloader 中获取 zuulfilter，而 zuulfilter 是被 filterFileManager 所加载，并支持 groovy 热加载，采用了轮询的方式热加载。有了这些 filter 之后，zuulservelet 首先执行的 Pre 类型的过滤器，再执行 route 类型的过滤器，最后执行的是 post 类型的过滤器，如果在执行这些过滤器有错误的时候则会执行 error 类型的过滤器。执行完这些过滤器，最终将请求的结果返回给客户端。</p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://dunwu.github.io/waterdrop/pages/98a1c1/">负载均衡基本原理</a></p>
</blockquote>
<h2 id="服务路由"><a href="#服务路由" class="headerlink" title="服务路由"></a>服务路由</h2><p><strong>服务路由就是服务消费者在发起服务调用时，必须根据特定的规则来选择服务节点，从而满足某些特定的需求</strong>。</p>
<h3 id="服务路由的应用场景"><a href="#服务路由的应用场景" class="headerlink" title="服务路由的应用场景"></a>服务路由的应用场景</h3><ul>
<li><strong>分组调用</strong>。一般来讲，为了保证服务的高可用性，实现异地多活的需求，一个服务往往不止部署在一个数据中心，而且出于节省成本等考虑，有些业务可能不仅在私有机房部署，还会采用公有云部署，甚至采用多家公有云部署。服务节点也会按照不同的数据中心分成不同的分组，这时对于服务消费者来说，选择哪一个分组调用，就必须有相应的路由规则。</li>
<li><strong>灰度发布</strong>。在服务上线发布的过程中，一般需要先在一小部分规模的服务节点上先发布服务，然后验证功能是否正常。如果正常的话就继续扩大发布范围；如果不正常的话，就需要排查问题，解决问题后继续发布。这个过程就叫作灰度发布，也叫金丝雀部署。</li>
<li><strong>流量切换</strong>。在业务线上运行过程中，经常会遇到一些不可抗力因素导致业务故障，比如某个机房的光缆被挖断，或者发生着火等事故导致整个机房的服务都不可用。这个时候就需要按照某个指令，能够把原来调用这个机房服务的流量切换到其他正常的机房。</li>
<li><strong>读写分离</strong>。对于大多数互联网业务来说都是读多写少，所以在进行服务部署的时候，可以把读写分开部署，所有写接口可以部署在一起，而读接口部署在另外的节点上。</li>
</ul>
<h3 id="服务路由的规则"><a href="#服务路由的规则" class="headerlink" title="服务路由的规则"></a>服务路由的规则</h3><p>服务路由主要有两种规则：一种是条件路由，一种是脚本路由。</p>
<h4 id="条件路由"><a href="#条件路由" class="headerlink" title="条件路由"></a>条件路由</h4><p>条件路由是基于条件表达式的路由规则。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">condition</span>://<span class="number">0.0.0.0</span>/dubbo.test.interfaces.TestService?category=routers&amp;dynamic=true&amp;priority=<span class="number">2</span>&amp;enabled=true&amp;rule=<span class="string">&quot; + URL.encode(&quot;</span> host = <span class="number">10.20.153.10</span>=&gt; host = <span class="number">10.20.153.11</span><span class="string">&quot;)</span></span><br></pre></td></tr></table></figure>

<p>这里面 <code>condition://</code> 代表了这是一段用条件表达式编写的路由规则，具体的规则是</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">host</span> <span class="operator">=</span> <span class="number">10.20</span>.<span class="number">153.10</span> <span class="operator">=</span>&gt; host <span class="operator">=</span> <span class="number">10.20</span>.<span class="number">153.11</span></span><br></pre></td></tr></table></figure>

<p>分隔符“&#x3D;&gt;”前面是服务消费者的匹配条件，后面是服务提供者的过滤条件。当服务消费者节点满足匹配条件时，就对该服务消费者执行后面的过滤规则。那么上面这段表达式表达的意义就是 IP 为“10.20.153.10”的服务消费者都调用 IP 为“10.20.153.11”的服务提供者节点。</p>
<p>如果服务消费者的匹配条件为空，就表示对所有的服务消费者应用，就像下面的表达式一样。</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=&gt; host ！= <span class="number">10.20</span>.<span class="number">153.11</span></span><br></pre></td></tr></table></figure>

<p>如果服务提供者的过滤条件为空，就表示禁止服务消费者访问，就像下面的表达式一样。</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">host</span> <span class="operator">=</span> <span class="number">10.20</span>.<span class="number">153.10</span><span class="operator">=</span>&gt;</span><br></pre></td></tr></table></figure>

<p>下面我举一些 Dubbo 框架中的条件路由，来给你讲解下条件路由的具体应用场景。</p>
<ul>
<li>排除某个服务节点</li>
</ul>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=&gt; host != <span class="number">172.22</span>.<span class="number">3.91</span></span><br></pre></td></tr></table></figure>

<p>一旦这条路由规则被应用到线上，所有的服务消费者都不会访问 IP 为 172.22.3.91 的服务节点，这种路由规则一般应用在线上流量排除预发布机以及摘除某个故障节点的场景。</p>
<ul>
<li>白名单和黑名单功能</li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">host</span> != <span class="number">10.20.153.10</span>,<span class="number">10.20.153.11</span> =&gt;</span><br></pre></td></tr></table></figure>

<p>这条路由规则意思是除了 IP 为 10.20.153.10 和 10.20.153.11 的服务消费者可以发起服务调用以外，其他服务消费者都不可以，主要用于白名单访问逻辑，比如某个后台服务只允许特定的几台机器才可以访问，这样的话可以机器控制访问权限。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">host</span> = <span class="number">10.20.153.10</span>,<span class="number">10.20.153.11</span> =&gt;</span><br></pre></td></tr></table></figure>

<p>同理，这条路由规则意思是除了 IP 为 10.20.153.10 和 10.20.153.11 的服务消费者不能发起服务调用以外，其他服务消费者都可以，也就是实现了黑名单功能，比如线上经常会遇到某些调用方不管是出于有意还是无意的不合理调用，影响了服务的稳定性，这时候可以通过黑名单功能暂时予以封杀。</p>
<ul>
<li>机房隔离</li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">host</span> = <span class="number">172</span>.<span class="number">22</span>.<span class="number">3</span>.* =&gt; host = <span class="number">172</span>.<span class="number">22</span>.<span class="number">3</span>.*</span><br></pre></td></tr></table></figure>

<p>这条路由规则意思是 IP 网段为 172.22.3.* 的服务消费者，才可以访问同网段的服务节点，这种规则一般应用于服务部署在多个 IDC，理论上同一个 IDC 内的调用性能要比跨 IDC 调用性能要好，应用这个规则是为了实现同 IDC 就近访问。</p>
<ul>
<li>读写分离</li>
</ul>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">method</span> = <span class="title function_">find</span>*,<span class="title function_">list</span>*,<span class="title function_">get</span>*,<span class="title function_">is</span>* =&gt; <span class="title function_">host</span> =172.22.3.94,172.22.3.95</span><br><span class="line"><span class="title function_">method</span> != <span class="title function_">find</span>*,<span class="title function_">list</span>*,<span class="title function_">get</span>*,<span class="title function_">is</span>* =&gt; <span class="title function_">host</span> = 172.22.3.97,172.22.3.98</span><br></pre></td></tr></table></figure>

<p>这条路由规则意思是 find<em>、get</em>、is* 等读方法调用 IP 为 172.22.3.94 和 172.22.3.95 的节点，除此以外的写方法调用 IP 为 172.22.3.97 和 172.22.3.98 的节点。对于大部分互联网业务来说，往往读请求要远远大于写请求，而写请求的重要性往往要远远高于读请求，所以需要把读写请求进行分离，以避免读请求异常影响到写请求，这时候就可以应用这种规则。</p>
<h4 id="脚本路由"><a href="#脚本路由" class="headerlink" title="脚本路由"></a>脚本路由</h4><p>脚本路由是基于脚本语言的路由规则，常用的脚本语言比如 JavaScript、Groovy、JRuby 等。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;script://<span class="number">0.0</span>.<span class="number">0.0</span>/com.foo.BarService?category=routers&amp;dynamic=false&amp;rule=<span class="string">&quot; + URL.encode(&quot;</span>（function <span class="built_in">route</span>(invokers) &#123; ... &#125; (invokers)）&quot;)</span><br></pre></td></tr></table></figure>

<p>这里面“script:&#x2F;&#x2F;”就代表了这是一段脚本语言编写的路由规则，具体规则定义在脚本语言的 route 方法实现里，比如下面这段用 JavaScript 编写的 route() 方法表达的意思是，只有 IP 为 10.20.153.10 的服务消费者可以发起服务调用。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">route</span>(<span class="params">invokers</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">new</span> java.util.ArrayList(invokers.size());</span><br><span class="line">  <span class="keyword">for</span>(i =<span class="number">0</span>; i &lt; invokers.size(); i ++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;10.20.153.10&quot;</span>.<span class="keyword">equals</span>(invokers.<span class="keyword">get</span>(i).getUrl().getHost()))&#123;</span><br><span class="line">       result.<span class="keyword">add</span>(invokers.<span class="keyword">get</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line"> &#125; (invokers)）;</span><br></pre></td></tr></table></figure>

<h3 id="服务路由的获取方式"><a href="#服务路由的获取方式" class="headerlink" title="服务路由的获取方式"></a>服务路由的获取方式</h3><p>服务路由的获取方式主要有三种：</p>
<ul>
<li>本地配置</li>
</ul>
<p>顾名思义就是路由规则存储在服务消费者本地上。服务消费者发起调用时，从本地固定位置读取路由规则，然后按照路由规则选取一个服务节点发起调用。</p>
<ul>
<li>配置中心管理</li>
</ul>
<p>这种方式下，所有的服务消费者都从配置中心获取路由规则，由配置中心来统一管理。</p>
<ul>
<li>动态下发</li>
</ul>
<p>这种方式下，一般是运维人员或者开发人员，通过服务治理平台修改路由规则，服务治理平台调用配置中心接口，把修改后的路由规则持久化到配置中心。因为服务消费者订阅了路由规则的变更，于是就会从配置中心获取最新的路由规则，按照最新的路由规则来执行。</p>
<h3 id="内部服务调用"><a href="#内部服务调用" class="headerlink" title="内部服务调用"></a>内部服务调用</h3><p>基础服务之间的调用：结合服务注册中心以及专属的具有负载均衡功能的客户端，如 Eureka+（restTemplate+Ribbon）或者 Eureka+Feign<br>聚合服务调用：结合服务注册中心以及专属的具有负载均衡功能的客户端，如 Eureka+（restTemplate+Ribbon）或者 Eureka+Feign</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200716202409.png" alt="img"></p>
<h3 id="外部服务调用"><a href="#外部服务调用" class="headerlink" title="外部服务调用"></a>外部服务调用</h3><p>基于 Netflix 的 zuul，做了简单了解，SpringCloud 与 zuul 集成的方式。这里先对核心流程做个简单了解，后续会有深入的应用、分析。</p>
<p>Spring Cloud 很好的集成了 zuul，并且可以通过注解的形式来进行请求的反向路由以及 API 网关功能<br>Spring Cloud 集成 zuul，对与 url 映射的处理方式与 SpringMVC 对 url 的请求方式类似，都是通过 RequestMapping 来进行请求绑定的。核心类：ZuulHandlerMapping<br>zuul 的核心是 ZuulServlet，一个请求核心流程：HttpServletRequest –&gt;ZuulHandlerMapping –&gt;ZuulController –&gt; ZuulServlet –&gt; ZuulFilter –&gt; HttpServletResponse</p>
<h2 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h2><p>配置中心的思路就是把服务的各种配置，如代码里配置的各种参数、服务降级的开关甚至依赖的资源等都在一个地方统一进行管理。服务启动时，可以自动从配置中心中拉取所需的配置，并且如果有配置变更的情况，同样可以自动从配置中心拉取最新的配置信息，服务无须重新发布。</p>
<p>配置中心一般包含下面几个功能：</p>
<ul>
<li>配置注册功能</li>
<li>配置反注册功能</li>
<li>配置查看功能</li>
<li>配置变更订阅功能</li>
</ul>
<h3 id="Apollo"><a href="#Apollo" class="headerlink" title="Apollo"></a>Apollo</h3><p>携程开源的分布式配置中心，支持 Java 和.Net 语言，客户端和配置中心通过 HTTP 长连接实现实时推送，并且有统一的管理界面来实现配置管理。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ELH62gpbFmGdnIjxDT7AOQyZgl2KQnz68zZFSDpHfa80ppne7gbP4ROOLJSuZT7E2uEdf1OTR9zthLNFkIZSLQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h3 id="Spring-Cloud-Git"><a href="#Spring-Cloud-Git" class="headerlink" title="Spring Cloud Git"></a>Spring Cloud Git</h3><p>Spring Cloud 中使用的配置中心组件，只支持 Java 语言，配置存储在 git 中，变更配置也需要通过 git 操作，如果配置中心有配置变更，需要手动刷新。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200716202911.png" alt="img"></p>
<h2 id="链路追踪"><a href="#链路追踪" class="headerlink" title="链路追踪"></a>链路追踪</h2><h3 id="链路追踪的作用"><a href="#链路追踪的作用" class="headerlink" title="链路追踪的作用"></a>链路追踪的作用</h3><ul>
<li>优化系统瓶颈</li>
<li>优化链路调用</li>
<li>生成网络拓扑</li>
<li>透明传输数据</li>
</ul>
<h3 id="链路追踪的原理"><a href="#链路追踪的原理" class="headerlink" title="链路追踪的原理"></a>链路追踪的原理</h3><p>理解链路追踪必须先了解以下概念：</p>
<ul>
<li><strong>traceId</strong>，用于标识某一次具体的请求 ID。当用户的请求进入系统后，会在 RPC 调用网络的第一层生成一个全局唯一的 traceId，并且会随着每一层的 RPC 调用，不断往后传递，这样的话通过 traceId 就可以把一次用户请求在系统中调用的路径串联起来。</li>
<li><strong>spanId</strong>，用于标识一次 RPC 调用在分布式请求中的位置。当用户的请求进入系统后，处在 RPC 调用网络的第一层 A 时 spanId 初始值是 0，进入下一层 RPC 调用 B 的时候 spanId 是 0.1，继续进入下一层 RPC 调用 C 时 spanId 是 0.1.1，而与 B 处在同一层的 RPC 调用 E 的 spanId 是 0.2，这样的话通过 spanId 就可以定位某一次 RPC 请求在系统调用中所处的位置，以及它的上下游依赖分别是谁。</li>
<li><strong>annotation</strong>，用于业务自定义埋点数据，可以是业务感兴趣的想上传到后端的数据，比如一次请求的用户 UID。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200716204658.png" alt="img"></p>
<h3 id="链路追踪的实现"><a href="#链路追踪的实现" class="headerlink" title="链路追踪的实现"></a>链路追踪的实现</h3><p>一个服务追踪系统一般可以分为三层：</p>
<ul>
<li><strong>数据采集</strong>层，负责数据埋点并上报。</li>
<li><strong>数据处理</strong>层，负责数据的存储与计算。</li>
<li><strong>数据展示</strong>层，负责数据的图形化展示。</li>
</ul>
<h4 id="数据采集层"><a href="#数据采集层" class="headerlink" title="数据采集层"></a>数据采集层</h4><p>一次 RPC 请求可以分为四个阶段。</p>
<ul>
<li>CS（Client Send）阶段 : 客户端发起请求，并生成调用的上下文。</li>
<li>SR（Server Recieve）阶段 : 服务端接收请求，并生成上下文。</li>
<li>SS（Server Send）阶段 : 服务端返回请求，这个阶段会将服务端上下文数据上报，下面这张图可以说明上报的数据有：traceId&#x3D;123456，spanId&#x3D;0.1，appKey&#x3D;B，method&#x3D;B.method，start&#x3D;103，duration&#x3D;38。</li>
<li>CR（Client Recieve）阶段 : 客户端接收返回结果，这个阶段会将客户端上下文数据上报，上报的数据有：traceid&#x3D;123456，spanId&#x3D;0.1，appKey&#x3D;A，method&#x3D;B.method，start&#x3D;103，duration&#x3D;38。</li>
</ul>
<h4 id="数据处理层"><a href="#数据处理层" class="headerlink" title="数据处理层"></a>数据处理层</h4><p>数据处理层的作用就是把数据采集层上报的数据按需计算，然后落地存储供查询使用。</p>
<ul>
<li>实时数据处理</li>
</ul>
<p>针对实时数据处理，一般采用 Storm 或者 Spark Streaming 来对链路数据进行实时聚合加工，存储一般使用 OLTP 数据仓库，比如 HBase，使用 traceId 作为 RowKey，能天然地把一整条调用链聚合在一起，提高查询效率。</p>
<ul>
<li>离线数据处理</li>
</ul>
<p>针对离线数据处理，一般通过运行 MapReduce 或者 Spark 批处理程序来对链路数据进行离线计算，存储一般使用 Hive。</p>
<h4 id="数据展示层"><a href="#数据展示层" class="headerlink" title="数据展示层"></a>数据展示层</h4><p>数据展示层的作用就是将处理后的链路信息以图形化的方式展示给用户。</p>
<p>实际项目中主要用到两种图形展示，一种是调用链路图，一种是调用拓扑图。</p>
<h3 id="链路追踪方案对比"><a href="#链路追踪方案对比" class="headerlink" title="链路追踪方案对比"></a>链路追踪方案对比</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200716205052.png" alt="img"></p>
<h2 id="限流熔断"><a href="#限流熔断" class="headerlink" title="限流熔断"></a>限流熔断</h2><p>一般而言，集群故障的产生原因不外乎有两种：</p>
<p>一种是代码 bug 所导致，比如说某一段 Java 代码不断地分配大对象，但没有及时回收导致 JVM OOM 退出；</p>
<p>另一种是突发的流量冲击，超出了系统的最大承载能力，比如“双 11”这种购物活动，电商系统会在零点一瞬间涌入大量流量，超出系统的最大承载能力，一下子就把整个系统给压垮了。</p>
<p>应付集群故障的思路，主要有两种：<strong>限流</strong>和<strong>降级</strong>。</p>
<h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h3><p>限流就是限制流量。通常情况下，系统能够承载的流量根据集群规模的大小是固定的，可以称之为系统的最大容量。当真实流量超过了系统的最大容量后，就会导致系统响应变慢，服务调用出现大量超时，反映给用户的感觉就是卡顿、无响应。所以，应该根据系统的最大容量，给系统设置一个阈值，超过这个阈值的请求会被自动抛弃，这样的话可以最大限度地保证系统提供的服务正常。</p>
<p>除此之外，通常一个微服务系统会同时提供多个服务，每个服务在同一时刻的请求量也是不同的，很可能出现的一种情况就是，系统中某个服务的请求量突增，占用了系统中大部分资源，导致其他服务没有资源可用。因此，还要针对系统中每个服务的请求量也设置一个阈值，超过这个阈值的请求也要被自动抛弃，这样的话不至于因为一个服务影响了其他所有服务。</p>
<p>在实际项目中，可以用两个指标来衡量服务的请求量，一个是 QPS 即每秒请求量，一个是工作线程数。不过 QPS 因为不同服务的响应快慢不同，所以系统能够承载的 QPS 相差很大，因此一般选择工作线程数来作为限流的指标，给系统设置一个总的最大工作线程数以及单个服务的最大工作线程数，这样的话无论是系统的总请求量过大导致整体工作线程数量达到最大工作线程数，还是某个服务的请求量超过单个服务的最大工作线程数，都会被限流，以起到保护整个系统的作用。</p>
<h3 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h3><p>什么是降级呢？在我看来，降级就是通过停止系统中的某些功能，来保证系统整体的可用性。降级可以说是一种被动防御的措施，为什么这么说呢？因为它一般是系统已经出现故障后所采取的一种止损措施。</p>
<p>那么降级一般是如何实现的呢？根据我的实践来看， 一种可行的方案是通过开关来实现。</p>
<p>具体来讲，就是在系统运行的内存中开辟一块区域，专门用于存储开关的状态，也就是开启还是关闭。并且需要监听某个端口，通过这个端口可以向系统下发命令，来改变内存中开关的状态。当开关开启时，业务的某一段逻辑就不再执行，而正常情况下，开关是关闭的状态。</p>
<p>开关一般用在两种地方，一种是新增的业务逻辑，因为新增的业务逻辑相对来说不成熟，往往具备一定的风险，所以需要加开关来控制新业务逻辑是否执行；另一种是依赖的服务或资源，因为依赖的服务或者资源不总是可靠的，所以最好是有开关能够控制是否对依赖服务或资源发起调用，来保证即使依赖出现问题，也能通过降级来避免影响。</p>
<p>在实际业务应用的时候，降级要按照对业务的影响程度进行分级，一般分为三级：一级降级是对业务影响最小的降级，在故障的情况下，首先执行一级降级，所以一级降级也可以设置成自动降级，不需要人为干预；二级降级是对业务有一定影响的降级，在故障的情况下，如果一级降级起不到多大作用的时候，可以人为采取措施，执行二级降级；三级降级是对业务有较大影响的降级，这种降级要么是对商业收入有重大影响，要么是对用户体验有重大影响，所以操作起来要非常谨慎，不在最后时刻一般不予采用。</p>
<h2 id="DEVOPS"><a href="#DEVOPS" class="headerlink" title="DEVOPS"></a>DEVOPS</h2><h3 id="容器和容器平台"><a href="#容器和容器平台" class="headerlink" title="容器和容器平台"></a>容器和容器平台</h3><p>Mesos、Marathon、Kubernetes</p>
<h2 id="RPC-选型"><a href="#RPC-选型" class="headerlink" title="RPC 选型"></a>RPC 选型</h2><h3 id="限定语言-RPC"><a href="#限定语言-RPC" class="headerlink" title="限定语言 RPC"></a>限定语言 RPC</h3><p>跟语言平台绑定的开源 RPC 框架主要有下面几种。</p>
<ul>
<li>Dubbo：国内最早开源的 RPC 框架，由阿里巴巴公司开发并于 2011 年末对外开源，仅支持 Java 语言。</li>
<li>Motan：微博内部使用的 RPC 框架，于 2016 年对外开源，仅支持 Java 语言。</li>
<li>Tars：腾讯内部使用的 RPC 框架，于 2017 年对外开源，仅支持 C++ 语言。</li>
<li>Spring Cloud：国外 Pivotal 公司 2014 年对外开源的 RPC 框架，仅支持 Java 语言，最近几年生态发展得比较好，是比较火的 RPC 框架。</li>
</ul>
<p>所以很明显，如果你的业务场景仅仅局限于一种语言的话，可以选择跟语言绑定的 RPC 框架中的一种；如果涉及多个语言平台之间的相互调用，就应该选择跨语言平台的 RPC 框架。</p>
<p>仔细分析，可以看出 Spring Cloud 不仅提供了基本的 RPC 框架功能，还提供了服务注册组件、配置中心组件、负载均衡组件、断路器组件、分布式消息追踪组件等一系列组件，也难怪被技术圈的人称之为“Spring Cloud 全家桶”。如果你不想自己实现以上这些功能，那么 Spring Cloud 基本可以满足你的全部需求。而 Dubbo、Motan 基本上只提供了最基础的 RPC 框架的功能，其他微服务组件都需要自己去实现。不过由于 Spring Cloud 的 RPC 通信采用了 HTTP 协议，相比 Dubbo 和 Motan 所采用的私有协议来说，在高并发的通信场景下，性能相对要差一些，所以对性能有苛刻要求的情况下，可以考虑 Dubbo 和 Motan。</p>
<h3 id="跨语言-RPC"><a href="#跨语言-RPC" class="headerlink" title="跨语言 RPC"></a>跨语言 RPC</h3><p>而跨语言平台的开源 RPC 框架主要有以下几种。</p>
<ul>
<li>gRPC：Google 于 2015 年对外开源的跨语言 RPC 框架，支持常用的 C++、Java、Python、Go、Ruby、PHP、Android Java、Objective-C 等多种语言。</li>
<li>Thrift：最初是由 Facebook 开发的内部系统跨语言的 RPC 框架，2007 年贡献给了 Apache 基金，成为 Apache 开源项目之一，支持常用的 C++、Java、PHP、Python、Ruby、Erlang 等多种语言。</li>
</ul>
<p>从成熟度上来讲，Thrift 因为诞生的时间要早于 gRPC，所以使用的范围要高于 gRPC，在 HBase、Hadoop、Scribe、Cassandra 等许多开源组件中都得到了广泛地应用。而且 Thrift 支持多达 25 种语言，这要比 gRPC 支持的语言更多，所以如果遇到 gRPC 不支持的语言场景下，选择 Thrift 更合适。</p>
<p>但 gRPC 作为后起之秀，因为采用了 HTTP&#x2F;2 作为通信协议、ProtoBuf 作为数据序列化格式，在移动端设备的应用以及对传输带宽比较敏感的场景下具有很大的优势，而且开发文档丰富，根据 ProtoBuf 文件生成的代码要比 Thrift 更简洁一些，从使用难易程度上更占优势，所以如果使用的语言平台 gRPC 支持的话，建议还是采用 gRPC 比较好。</p>
<h2 id="Service-Mesh"><a href="#Service-Mesh" class="headerlink" title="Service Mesh"></a>Service Mesh</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200721154106.png" alt="img"></p>
<h3 id="Service-Mesh-的实现原理"><a href="#Service-Mesh-的实现原理" class="headerlink" title="Service Mesh 的实现原理"></a>Service Mesh 的实现原理</h3><p>Service Mesh 实现的关键就在于两点：</p>
<p>一个是上面提到的轻量级的网络代理也叫 SideCar，它的作用就是转发服务之间的调用；</p>
<p>一个是基于 SideCar 的服务治理也被叫作 Control Plane，它的作用是向 SideCar 发送各种指令，以完成各种服务治理功能。下面我就来详细讲解这两点是如何实现的。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100014401">从 0 开始学微服务</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100046201">RPC 实战与核心原理</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/course/intro/100003901">微服务架构核心 20 讲</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/savorboard/p/api-gateway.html">谈谈微服务中的 API 网关（API Gateway）</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/fcb19c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/fcb19c/" class="post-title-link" itemprop="url">Mysql 索引</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-07-16 11:14:07" itemprop="dateCreated datePublished" datetime="2020-07-16T11:14:07+08:00">2020-07-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">关系型数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/" itemprop="url" rel="index"><span itemprop="name">Mysql</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>11 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Mysql-索引"><a href="#Mysql-索引" class="headerlink" title="Mysql 索引"></a>Mysql 索引</h1><blockquote>
<p>索引是提高 MySQL 查询性能的一个重要途径，但过多的索引可能会导致过高的磁盘使用率以及过高的内存占用，从而影响应用程序的整体性能。应当尽量避免事后才想起添加索引，因为事后可能需要监控大量的 SQL 才能定位到问题所在，而且添加索引的时间肯定是远大于初始添加索引所需要的时间，可见索引的添加也是非常有技术含量的。</p>
<p>接下来将向你展示一系列创建高性能索引的策略，以及每条策略其背后的工作原理。但在此之前，先了解与索引相关的一些算法和数据结构，将有助于更好的理解后文的内容。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310162333557.png"></p>
<h2 id="索引简介"><a href="#索引简介" class="headerlink" title="索引简介"></a>索引简介</h2><p><strong>“索引”是数据库为了提高查找效率的一种数据结构</strong>。</p>
<p>日常生活中，我们可以通过检索目录，来快速定位书本中的内容。索引和数据表，就好比目录和书，想要高效查询数据表，索引至关重要。在数据量小且负载较低时，不恰当的索引对于性能的影响可能还不明显；但随着数据量逐渐增大，性能则会急剧下降。因此，<strong>设置合理的索引是数据库查询性能优化的最有效手段</strong>。</p>
<h3 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h3><p>B 树是最常见的索引，按照顺序存储数据，所以 Mysql 可以用来做 <code>ORDER BY</code> 和 <code>GROUP BY</code> 操作。因为数据是有序的，所以 B 树也就会将相关的列值都存储在一起。最后，因为索引中存储了实际的列值，所以某些查询只使用索引就能够完成全部查询。</p>
<p>✔️️️️ 索引的优点：</p>
<ul>
<li><strong>索引大大减少了服务器需要扫描的数据量</strong>，从而加快检索速度。</li>
<li><strong>索引可以帮助服务器避免排序和临时表</strong>。</li>
<li><strong>索引可以将随机 I&#x2F;O 变为顺序 I&#x2F;O</strong>。</li>
<li>支持行级锁的数据库，如 InnoDB 会在访问行的时候加锁。<strong>使用索引可以减少访问的行数，从而减少锁的竞争，提高并发</strong>。</li>
<li>唯一索引可以确保每一行数据的唯一性，通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能。</li>
</ul>
<p>❌ 索引的缺点：</p>
<ul>
<li><strong>创建和维护索引要耗费时间</strong>，这会随着数据量的增加而增加。</li>
<li><strong>索引需要占用额外的物理空间</strong>，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立组合索引那么需要的空间就会更大。</li>
<li><strong>写操作（<code>INSERT</code>&#x2F;<code>UPDATE</code>&#x2F;<code>DELETE</code>）时很可能需要更新索引，导致数据库的写操作性能降低</strong>。</li>
</ul>
<p>基于以上，可以归纳出索引的基本使用规则：</p>
<ul>
<li>索引不是越多越好，不要为所有列都创建索引</li>
<li>要尽量避免冗余和重复索引</li>
<li>要考虑删除未使用的索引</li>
<li>尽量的扩展索引，不要新建索引</li>
<li>频繁作为 <code>WHERE</code> 过滤条件的列应该考虑添加索引</li>
</ul>
<h3 id="何时使用索引"><a href="#何时使用索引" class="headerlink" title="何时使用索引"></a>何时使用索引</h3><p>✔️️️️ 什么情况<strong>适用</strong>索引？</p>
<ul>
<li><strong>字段的数值有唯一性的限制</strong>，如用户名。</li>
<li><strong>频繁作为 <code>WHERE</code> 条件或 <code>JOIN</code> 条件的字段，尤其在数据表大的情况下</strong></li>
<li><strong>频繁用于 <code>GROUP BY</code> 或 <code>ORDER BY</code> 的字段</strong>。将该字段作为索引，查询时就无需再排序了，因为 B+ 树</li>
<li><strong>DISTINCT 字段需要创建索引</strong>。</li>
</ul>
<p>❌ 什么情况<strong>不适用</strong>索引？</p>
<ul>
<li><strong>频繁写操作</strong>（ <code>INSERT</code>&#x2F;<code>UPDATE</code>&#x2F;<code>DELETE</code> ），也就意味着需要更新索引。</li>
<li><strong>很少作为 <code>WHERE</code> 条件或 <code>JOIN</code> 条件的字段</strong>，也就意味着索引会经常无法命中，没有意义，还增加空间开销。</li>
<li><strong>非常小的表</strong>，对于非常小的表，大部分情况下简单的全表扫描更高效。</li>
<li><strong>特大型的表</strong>，建立和使用索引的代价将随之增长。可以考虑使用分区技术或 Nosql。</li>
</ul>
<h2 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h2><p>在 Mysql 中，<strong>索引是在存储引擎层而不是服务器层实现的</strong>，所以，并没有统一的索引标准。不同存储引擎的索引的数据结构也不相同。下面是 Mysql 常用存储引擎对一些主要索引数据结构的支持：</p>
<table>
<thead>
<tr>
<th>索引数据结构&#x2F;存储引擎</th>
<th>InnoDB 引擎</th>
<th>MyISAM 引擎</th>
<th>Memory 引擎</th>
</tr>
</thead>
<tbody><tr>
<td><strong>B+Tree 索引</strong></td>
<td>✔️️️️️</td>
<td>✔️️️️️</td>
<td>✔️️️️️</td>
</tr>
<tr>
<td><strong>Hash 索引</strong></td>
<td>❌</td>
<td>❌</td>
<td>✔️️️️️</td>
</tr>
<tr>
<td><strong>Full Text 索引</strong></td>
<td>✔️️️️️</td>
<td>✔️️️️️</td>
<td>❌</td>
</tr>
</tbody></table>
<p>下面，我们将逐一探讨各种可能作为索引的数据结构，了解其特性、利弊、应用场景。相信通过这样的对比，可以让读者更加明确 Mysql 中为什么选择某些数据结构作为索引，而放弃了另外一些数据结构，依据是什么。</p>
<h3 id="有序数组"><a href="#有序数组" class="headerlink" title="有序数组"></a>有序数组</h3><p><strong>“数组”用连续的内存空间来存储数据，并且支持随机访问</strong>。</p>
<p>有序数组可以使用二分查找法，其时间复杂度为 <code>O(log n)</code>，无论是等值查询还是范围查询，都非常高效。</p>
<p>但有序数组有两个重要限制：</p>
<ul>
<li><strong>数组的空间大小固定</strong>，如果要扩容只能采用复制数组的方式，比较低效。</li>
<li><strong>插入、删除操作开销较大</strong>，时间复杂度为 <code>O(n)</code> （要保证数组有序）。</li>
</ul>
<p>这意味着，如果直接使用有序数组作为索引，为了保证数组有序，其更新操作代价高昂。正因为如此，几乎没有数据库会采用有序数组作为索引。</p>
<h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>哈希表是一种以键 - 值（key-value）对形式存储数据的结构，我们只要输入待查找的值即 key，就可以找到其对应的值即 Value。</p>
<p><strong>“哈希表”使用哈希函数组织数据，以支持快速插入和搜索的数据结构</strong>。哈希表的本质是一个数组，其思路是：使用哈希函数将 Key 转换为数组下标，利用数组的随机访问特性，使得我们能在 <code>O(1)</code> 的时间代价内完成检索。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220320201844.png" alt="img"></p>
<p>有两种不同类型的哈希表：<strong>哈希集合</strong> 和 <strong>哈希映射</strong>。</p>
<ul>
<li><strong>哈希集合</strong>是集合数据结构的实现之一，用于存储非重复值。</li>
<li><strong>哈希映射</strong>是映射数据结构的实现之一，用于存储键值对。</li>
</ul>
<p>哈希索引基于哈希表实现，<strong>只适用于等值查询</strong>。对于每一行数据，哈希索引都会将所有的索引列计算一个哈希码（<code>hashcode</code>），哈希码是一个较小的值。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。</p>
<p>在 Mysql 中，只有 Memory 存储引擎显示支持哈希索引。</p>
<p>✔️️️️️ 哈希索引的<strong>优点</strong>：</p>
<ul>
<li>因为索引数据结构紧凑，所以<strong>查询速度非常快</strong>。</li>
</ul>
<p>❌ 哈希索引的<strong>缺点</strong>：</p>
<ul>
<li><strong>只支持等值比较查询</strong> - 包括 <code>=</code>、<code>IN()</code>、<code>&lt;=&gt;</code>。<ul>
<li><strong>不支持范围查询</strong>，如 <code>WHERE price &gt; 100</code>。</li>
<li><strong>不支持模糊查询</strong>，如 <code>%</code> 开头。</li>
</ul>
</li>
<li><strong>无法用于排序</strong> - 因为 Hash 索引指向的数据是无序的，因此无法起到排序优化的作用。</li>
<li><strong>不支持联合索引的最左侧原则</strong> - 对于联合索引来说，Hash 索引在计算 Hash 值的时候是将索引键合并后再一起计算 Hash 值，所以不会针对每个索引单独计算 Hash 值。因此如果用到联合索引的一个或者几个索引时，联合索引无法被利用。例如：在数据列 (A,B) 上建立哈希索引，如果查询只有数据列 A，无法使用该索引。</li>
<li><strong>不能用索引中的值来避免读取行</strong> - 因为哈希索引只包含哈希值和行指针，不存储字段，所以不能使用索引中的值来避免读取行。不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能影响不大。</li>
<li>哈希索引有<strong>可能出现哈希冲突</strong><ul>
<li>出现哈希冲突时，必须遍历链表中所有的行指针，逐行比较，直到找到符合条件的行。</li>
<li>如果哈希冲突多的话，维护索引的代价会很高。</li>
</ul>
</li>
</ul>
<blockquote>
<p>提示：因为种种限制，所以哈希索引只适用于特定的场合。而一旦使用哈希索引，则它带来的性能提升会非常显著。</p>
</blockquote>
<h3 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+ 树索引"></a>B+ 树索引</h3><p>B 树是最常见的索引，按照顺序存储数据，所以 Mysql 可以用来做 <code>ORDER BY</code> 和 <code>GROUP BY</code> 操作。因为数据是有序的，所以 B 树也就会将相关的列值都存储在一起。最后，因为索引中存储了实际的列值，所以某些查询只使用索引就能够完成全部查询。</p>
<p>通常我们所说的索引是指 B-Tree 索引，它是目前关系型数据库中查找数据最为常用和有效的索引，大多数存储引擎都支持这种索引。使用 B-Tree 这个术语，是因为 MySQL 在<code>CREATE TABLE</code>或其它语句中使用了这个关键字，但实际上不同的存储引擎可能使用不同的数据结构，比如 InnoDB 就是使用的 B+Tree。</p>
<p>B+Tree 中的 B 是指<code>balance</code>，意为平衡。需要注意的是，B+树索引并不能找到一个给定键值的具体行，它找到的只是被查找数据行所在的页，接着数据库会把页读入到内存，再在内存中进行查找，最后得到要查找的数据。</p>
<h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><p>二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。其查询时间复杂度是 $$O(log(N))$$。</p>
<p>当然为了维持 $$O(log(N))$$ 的查询复杂度，你就需要保持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是 $$O(log(N))$$。</p>
<p>随着数据库中数据的增加，索引本身大小随之增加，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘 I&#x2F;O 消耗，相对于内存存取，I&#x2F;O 存取的消耗要高几个数量级。可以想象一下一棵几百万节点的二叉树的深度是多少？如果将这么大深度的一颗二叉树放磁盘上，每读取一个节点，需要一次磁盘的 I&#x2F;O 读取，整个查找的耗时显然是不能够接受的。那么如何减少查找过程中的 I&#x2F;O 存取次数？</p>
<p>一种行之有效的解决方法是减少树的深度，将<strong>二叉树变为 N 叉树</strong>（多路搜索树），而 <strong>B+ 树就是一种多路搜索树</strong>。</p>
<h4 id="B-树"><a href="#B-树" class="headerlink" title="B+ 树"></a>B+ 树</h4><p>B+ 树索引适用于<strong>全键值查找</strong>、<strong>键值范围查找</strong>和<strong>键前缀查找</strong>，其中键前缀查找只适用于最左前缀查找。</p>
<p>理解 B+Tree 时，只需要理解其最重要的两个特征即可：</p>
<ul>
<li>第一，所有的关键字（可以理解为数据）都存储在叶子节点，非叶子节点并不存储真正的数据，所有记录节点都是按键值大小顺序存放在同一层叶子节点上。</li>
<li>其次，所有的叶子节点由指针连接。如下图为简化了的 B+Tree。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200304235424.jpg" alt="img"></p>
<h4 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h4><p>根据叶子节点的内容，索引类型分为主键索引和非主键索引。</p>
<ul>
<li>主键索引又被称为<strong>“聚簇索引（clustered index）”，其叶子节点存的是整行数据</strong>。<ul>
<li>聚簇表示数据行和相邻的键值紧凑地存储在一起，因为数据紧凑，所以访问快。</li>
<li>因为无法同时把数据行存放在两个不同的地方，所以<strong>一个表只能有一个聚簇索引</strong>。</li>
<li>InnoDB 的聚簇索引实际是在同一个结构中保存了 B 树的索引和数据行。</li>
</ul>
</li>
<li>非主键索引又被称为<strong>“二级索引（secondary index）”，其叶子节点存的是主键的值</strong>。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。可以有多个，小于 249 个。</li>
</ul>
<p><strong>聚簇索引和非聚簇索引的查询有什么区别</strong></p>
<ul>
<li>如果语句是 <code>select * from T where ID=500</code>，即聚簇索引查询方式，则只需要搜索主键（ID）索引树；</li>
<li>如果语句是 <code>select * from T where k=5</code>，即非聚簇索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为<strong>回表</strong>。</li>
</ul>
<p>也就是说，<strong>基于非聚簇索引的查询需要多扫描一棵索引树</strong>。因此，我们在应用中应该尽量使用主键查询。</p>
<p><strong>显然，主键长度越小，非聚簇索引的叶子节点就越小，非聚簇索引占用的空间也就越小。</strong></p>
<p>在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：</p>
<ul>
<li>如果有主键，默认会使用主键作为聚簇索引的索引键（key）；</li>
<li>如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；</li>
<li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）；</li>
</ul>
<p>自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： <code>NOT NULL PRIMARY KEY AUTO_INCREMENT</code>。从性能和存储空间方面考量，自增主键往往是更合理的选择。有没有什么场景适合用业务字段直接做主键的呢？还是有的。比如，有些业务的场景需求是这样的：</p>
<ul>
<li>只有一个索引；</li>
<li>该索引必须是唯一索引。</li>
</ul>
<p>由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。</p>
<p>这时候我们就要优先考虑上一段提到的“尽量使用主键查询”原则，直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。</p>
<h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</p>
<p>全文索引一般使用倒排索引实现，它记录着关键词到其所在文档的映射。</p>
<p>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</p>
<p>全文索引主要用来查找文本中的关键字，而不是直接与索引中的值相比较。</p>
<p>全文索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的 WHERE 语句的参数匹配。全文索引配合 <code>match against</code> 操作使用，而不是一般的 WHERE 语句加 LIKE。它可以在 <code>CREATE TABLE</code>，<code>ALTER TABLE</code> ，<code>CREATE INDEX</code> 使用，不过目前只有 <code>char</code>、<code>varchar</code>，<code>text</code> 列上可以创建全文索引。值得一提的是，在数据量较大时候，先将数据放入一个没有全局索引的表中，然后再用 <code>CREATE INDEX</code> 创建全文索引，要比先为一张表建立全文索引然后再将数据写入的速度快很多。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">table</span>` (</span><br><span class="line">    `content` text <span class="type">CHARACTER</span> <span class="keyword">NULL</span>,</span><br><span class="line">    ...</span><br><span class="line">    FULLTEXT (content)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="空间数据索引"><a href="#空间数据索引" class="headerlink" title="空间数据索引"></a>空间数据索引</h3><p>MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p>
<p>必须使用 GIS 相关的函数来维护数据。</p>
<h2 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h2><p>主流的关系型数据库一般都支持以下索引类型：</p>
<h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><p>主键索引：一种特殊的唯一索引，不允许有空值。一个表只能有一个主键（在 InnoDB 中本质上即聚簇索引），一般是在建表的时候同时创建主键索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">	`id` <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    # ...</span><br><span class="line">	<span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p><strong>“唯一索引”确保索引中的值是唯一的，不允许有重复值，如果是组合索引，则列值的组合必须唯一</strong>。</p>
<p>在 MySQL 中，可以使用 <code>CREATE UNIQUE INDEX</code> 语句来创建唯一索引。</p>
<p>直接创建唯一索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX `uniq_name` <span class="keyword">ON</span> `<span class="keyword">user</span>`(`name`);</span><br></pre></td></tr></table></figure>

<p>创建表时，添加唯一索引示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">	`id` <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">	`name` <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">	<span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">	<span class="keyword">UNIQUE</span> KEY `uniq_name`(`name`)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>修改表时，添加唯一索引示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>`</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> `uniq_name`(`name`);</span><br></pre></td></tr></table></figure>

<h3 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h3><p>普通索引是最基本的索引，没有任何限制。</p>
<p>直接创建索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX `idx_name` <span class="keyword">ON</span> `<span class="keyword">user</span>`(`name`);</span><br></pre></td></tr></table></figure>

<p>创建表时，添加索引示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">	`id` <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">	`name` <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">	<span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">	KEY `idx_name`(`name`)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>修改表时，添加索引示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>`</span><br><span class="line"><span class="keyword">ADD</span> INDEX `idx_name`(`name`);</span><br></pre></td></tr></table></figure>

<h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>有时候需要索引很长的字符列，这使得存储索引占用大量空间，且导致查询变慢。这种情况下，可以使用前缀索引。</p>
<p><strong>“前缀索引”是指索引开始的部分字符</strong>。对于 <code>BLOB</code>&#x2F;<code>TEXT</code> 这种文本类型的列，必须使用前缀索引，因为数据库往往不允许索引这些列的完整长度。</p>
<p>✔️️️️ 前缀索引的<strong>优点</strong>是：</p>
<ul>
<li>可以<strong>大大节约索引空间</strong>，从而<strong>提高索引效率</strong>。</li>
</ul>
<p>❌ 前缀索引的<strong>缺点</strong>是：</p>
<ul>
<li><strong>会降低索引的区分度</strong>。</li>
<li>此外，**<code>order by</code> 无法使用前缀索引，无法把前缀索引用作覆盖索引**。</li>
</ul>
<p><strong>使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。</strong></p>
<p>直接创建前缀索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX `idx_name` <span class="keyword">ON</span> `<span class="keyword">user</span>`(`name`(<span class="number">10</span>));</span><br></pre></td></tr></table></figure>

<p>创建表时，添加前缀索引示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">	`id` <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">	`name` <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">	<span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">	KEY `idx_name`(`name`(<span class="number">10</span>))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>修改表时，添加前缀索引示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>`</span><br><span class="line"><span class="keyword">ADD</span> INDEX `idx_name`(`name`(<span class="number">10</span>));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>那么，如何确定前缀索引合适的长度呢？</p>
</blockquote>
<p>可以使用下面这个语句，算出这个列上有多少个不同的值：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> email) <span class="keyword">as</span> L <span class="keyword">from</span> SUser;</span><br></pre></td></tr></table></figure>

<p>然后，依次选取不同长度的前缀来看这个值，比如我们要看一下 4~7 个字节的前缀索引，可以用这个语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">  <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">4</span>)）<span class="keyword">as</span> L4,</span><br><span class="line">  <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">5</span>)）<span class="keyword">as</span> L5,</span><br><span class="line">  <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">6</span>)）<span class="keyword">as</span> L6,</span><br><span class="line">  <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">7</span>)）<span class="keyword">as</span> L7,</span><br><span class="line"><span class="keyword">from</span> SUser;</span><br></pre></td></tr></table></figure>

<p>当然，<strong>使用前缀索引很可能会损失区分度</strong>，所以你需要预先设定一个可以接受的损失比例，比如 5%。然后，在返回的 L4~L7 中，找出不小于 L * 95% 的值，假设这里 L6、L7 都满足，你就可以选择前缀长度为 6。</p>
<h2 id="索引优化策略"><a href="#索引优化策略" class="headerlink" title="索引优化策略"></a>索引优化策略</h2><h3 id="索引基本原则"><a href="#索引基本原则" class="headerlink" title="索引基本原则"></a>索引基本原则</h3><ul>
<li><strong>索引不是越多越好，不要为所有列都创建索引</strong>。要考虑到索引的维护代价、空间占用和查询时回表的代价。索引一定是按需创建的，并且要尽可能确保足够轻量。一旦创建了多字段的联合索引，我们要考虑尽可能利用索引本身完成数据查询，减少回表的成本。</li>
<li>要<strong>尽量避免冗余和重复索引</strong>。</li>
<li>要<strong>考虑删除未使用的索引</strong>。</li>
<li><strong>尽量的扩展索引，不要新建索引</strong>。</li>
</ul>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p><strong>覆盖索引是指：索引上的信息足够满足查询请求，不需要回表查询数据</strong>。</p>
<p>【示例】范围查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> T (</span><br><span class="line">ID <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">k <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">s <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">index k(k))</span><br><span class="line">engine<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> T <span class="keyword">values</span>(<span class="number">100</span>,<span class="number">1</span>, <span class="string">&#x27;aa&#x27;</span>),(<span class="number">200</span>,<span class="number">2</span>,<span class="string">&#x27;bb&#x27;</span>),(<span class="number">300</span>,<span class="number">3</span>,<span class="string">&#x27;cc&#x27;</span>),(<span class="number">500</span>,<span class="number">5</span>,<span class="string">&#x27;ee&#x27;</span>),(<span class="number">600</span>,<span class="number">6</span>,<span class="string">&#x27;ff&#x27;</span>),(<span class="number">700</span>,<span class="number">7</span>,<span class="string">&#x27;gg&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> k <span class="keyword">between</span> <span class="number">3</span> <span class="keyword">and</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>需要执行几次树的搜索操作，会扫描多少行？</p>
<ol>
<li>在 k 索引树上找到 k&#x3D;3 的记录，取得 ID &#x3D; 300；</li>
<li>再到 ID 索引树查到 ID&#x3D;300 对应的 R3；</li>
<li>在 k 索引树取下一个值 k&#x3D;5，取得 ID&#x3D;500；</li>
<li>再回到 ID 索引树查到 ID&#x3D;500 对应的 R4；</li>
<li>在 k 索引树取下一个值 k&#x3D;6，不满足条件，循环结束。</li>
</ol>
<p>在这个过程中，<strong>回到聚簇索引树搜索的过程，称为“回表”</strong>。可以看到，这个查询过程读了 k 索引树的 3 条记录（步骤 1、3 和 5），回表了两次（步骤 2 和 4）。</p>
<p>如果执行的语句是 <code>select ID from T where k between 3 and 5</code>，这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。索引包含所有需要查询的字段的值，称为覆盖索引。</p>
<p><strong>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段</strong>。</p>
<h3 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h3><p>不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。<strong>这里的最左，可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符</strong>。</p>
<p>如果是联合索引，那么 key 也由多个列组成，同时，索引只能用于查找 key 是否<strong>存在（相等）</strong>，遇到范围查询 (<code>&gt;</code>、<code>&lt;</code>、<code>BETWEEN</code>、<code>LIKE</code>) 就<strong>不能进一步匹配</strong>了，后续退化为线性查找。因此，<strong>列的排列顺序决定了可命中索引的列数</strong>。</p>
<p><strong>应该将选择性高的列或基数大的列优先排在多列索引最前列</strong>。但有时，也需要考虑 <code>WHERE</code> 子句中的排序、分组和范围条件等因素，这些因素也会对查询性能造成较大影响。</p>
<p><strong>“索引的选择性”是指不重复的索引值和记录总数的比值</strong>，最大值为 1，此时每个记录都有唯一的索引与其对应。索引的选择性越高，查询效率越高。如果存在多条命中前缀索引的情况，就需要依次扫描，直到最终找到正确记录。</p>
<p>例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> staff_id)<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> staff_id_selectivity,</span><br><span class="line"><span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> customer_id)<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> customer_id_selectivity,</span><br><span class="line"><span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> payment;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   staff_id_selectivity: 0.0001</span><br><span class="line">customer_id_selectivity: 0.0373</span><br><span class="line">               COUNT(*): 16049</span><br></pre></td></tr></table></figure>

<h3 id="使用索引来排序"><a href="#使用索引来排序" class="headerlink" title="使用索引来排序"></a>使用索引来排序</h3><p>Mysql 有两种方式可以生成排序结果：通过排序操作；或者按索引顺序扫描。</p>
<p><strong>索引最好既满足排序，又用于查找行</strong>。这样，就可以通过命中覆盖索引直接将结果查出来，也就不再需要排序了。</p>
<p>这样整个查询语句的执行流程就变成了：</p>
<ol>
<li>从索引 (city,name,age) 找到第一个满足 city&#x3D;’杭州’条件的记录，取出其中的 city、name 和 age 这三个字段的值，作为结果集的一部分直接返回；</li>
<li>从索引 (city,name,age) 取下一个记录，同样取出这三个字段的值，作为结果集的一部分直接返回；</li>
<li>重复执行步骤 2，直到查到第 1000 条记录，或者是不满足 city&#x3D;’杭州’条件时循环结束。</li>
</ol>
<h3 id="和-in-可以乱序"><a href="#和-in-可以乱序" class="headerlink" title="&#x3D; 和 in 可以乱序"></a>&#x3D; 和 in 可以乱序</h3><p><strong>不需要考虑 <code>=</code>、<code>IN</code> 等的顺序</strong>，Mysql 会自动优化这些条件的顺序，以匹配尽可能多的索引列。</p>
<p>【示例】如有索引 (a, b, c, d)，查询条件 <code>c &gt; 3 and b = 2 and a = 1 and d &lt; 4</code> 与 <code>a = 1 and c &gt; 3 and b = 2 and d &lt; 4</code> 等顺序都是可以的，MySQL 会自动优化为 a &#x3D; 1 and b &#x3D; 2 and c &gt; 3 and d &lt; 4，依次命中 a、b、c、d。</p>
<h2 id="索引失效的场景"><a href="#索引失效的场景" class="headerlink" title="索引失效的场景"></a>索引失效的场景</h2><p>创建了索引，并非一定有效。比如不满足前缀索引、最左前缀匹配原则、查询条件涉及函数计算等情况都无法使用索引。此外，即使 SQL 本身符合索引的使用条件，MySQL 也会通过评估各种查询方式的代价，来决定是否走索引，以及走哪个索引。</p>
<h3 id="对索引使用左模糊匹配"><a href="#对索引使用左模糊匹配" class="headerlink" title="对索引使用左模糊匹配"></a>对索引使用左模糊匹配</h3><p>使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code> 这两种方式都会造成索引失效。这是因为：<strong>B+ 树索引是按照“索引值”有序存储的，只能根据前缀进行比较。</strong></p>
<h3 id="对索引使用函数或表达式"><a href="#对索引使用函数或表达式" class="headerlink" title="对索引使用函数或表达式"></a>对索引使用函数或表达式</h3><p><strong>查询语句中，如果对索引字段使用“函数”或“表达式”，会导致索引失效</strong>。</p>
<p>因为索引树存储的是索引字段的原始值，因此无法索引经过函数计算或表达式计算后的值。</p>
<p>❌ 错误示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> actor <span class="keyword">WHERE</span> actor_id <span class="operator">+</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">WHERE</span> TO_DAYS(<span class="built_in">current_date</span>) <span class="operator">-</span> TO_DAYS(date_col) <span class="operator">&lt;=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h3 id="对索引隐式类型转换"><a href="#对索引隐式类型转换" class="headerlink" title="对索引隐式类型转换"></a>对索引隐式类型转换</h3><p>查询语句中，如果对索引字段进行隐式类型转换，会导致索引失效。由于隐式类型转换是通过 <code>CAST</code> 函数实现的，等同于对索引列使用了函数，所以会导致索引失效。</p>
<h3 id="联合索引不遵循最左匹配原则"><a href="#联合索引不遵循最左匹配原则" class="headerlink" title="联合索引不遵循最左匹配原则"></a>联合索引不遵循最左匹配原则</h3><p>联合索引如果不遵循最左匹配原则，就会导致索引失效。原因是，在联合索引的情况下，数据是按照索引第一列排序，第一列数据相同时才会按照第二列排序。</p>
<h3 id="索引列判空"><a href="#索引列判空" class="headerlink" title="索引列判空"></a>索引列判空</h3><p><strong>索引列与 <code>NULL</code> 或者 <code>NOT NULL</code> 进行判断的时候也会失效</strong>。这是因为索引并不存储空值，所以最好在设计数据表的时候就将字段设置为 <code>NOT NULL</code> 约束，比如你可以将 INT 类型的字段，默认值设置为 0。将字符类型的默认值设置为空字符串 (’’)。</p>
<h3 id="WHERE-子句中的-OR-前后条件存在非索引列"><a href="#WHERE-子句中的-OR-前后条件存在非索引列" class="headerlink" title="WHERE 子句中的 OR 前后条件存在非索引列"></a>WHERE 子句中的 OR 前后条件存在非索引列</h3><p>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</p>
<p>比如下面的 SQL 语句，comment_id 是主键，而 comment_text 没有进行索引，因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列进行了索引是没有意义的，只要有条件列没有进行索引，就会进行全表扫描，因此索引的条件列也会失效：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> comment_id, user_id, comment_text <span class="keyword">FROM</span> product_comment <span class="keyword">WHERE</span> comment_id = <span class="number">900001</span> <span class="keyword">OR</span> comment_text = <span class="string">&#x27;462eed7ac6e791292a79&#x27;</span></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-----------------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span><br><span class="line">| id | select_type | table           | partitions | <span class="class"><span class="keyword">type</span> | possible_keys | key  | key_len | ref  | rows   | filtered | <span class="type">Extra</span>       |</span></span><br><span class="line">+----+-------------+-----------------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span><br><span class="line">|  <span class="number">1</span> | <span class="type">SIMPLE</span>      | product_comment | <span class="type">NULL</span>       | <span class="type">ALL</span>  | <span class="type">PRIMARY</span>       | <span class="type">NULL</span> | <span class="type">NULL</span>    | <span class="type">NULL</span> | <span class="number">996663</span> |    <span class="number">10.00</span> | <span class="type">Using</span> <span class="keyword">where</span> |</span><br><span class="line">+----+-------------+-----------------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span><br></pre></td></tr></table></figure>

<p>如果我们把 comment_text 创建了索引会是怎样的呢？</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-----------------+------------+-------------+----------------------+----------------------+---------+------+------+----------+------------------------------------------------+</span><br><span class="line">| id | select_type | table           | partitions | <span class="class"><span class="keyword">type</span>        | possible_keys        | key                  | key_len | ref  | rows | filtered | <span class="type">Extra</span>                                          |</span></span><br><span class="line">+----+-------------+-----------------+------------+-------------+----------------------+----------------------+---------+------+------+----------+------------------------------------------------+</span><br><span class="line">|  <span class="number">1</span> | <span class="type">SIMPLE</span>      | product_comment | <span class="type">NULL</span>       | index_merge | <span class="type">PRIMARY</span>,comment_text | <span class="type">PRIMARY</span>,comment_text | <span class="number">4</span>,<span class="number">767</span>   | <span class="type">NULL</span> |    <span class="number">2</span> |   <span class="number">100.00</span> | <span class="type">Using</span> union(<span class="type">PRIMARY</span>,comment_text); <span class="type">Using</span> <span class="keyword">where</span> |</span><br><span class="line">+----+-------------+-----------------+------------+-------------+----------------------+----------------------+---------+------+------+----------+------------------------------------------------+</span><br></pre></td></tr></table></figure>

<p>你能看到这里使用到了 index merge，简单来说 index merge 就是对 comment_id 和 comment_text 分别进行了扫描，然后将这两个结果集进行了合并。这样做的好处就是避免了全表扫描。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/23008813/">《高性能 MySQL》</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/139">MySQL 实战 45 讲</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5b55b842f265da0f9e589e79">数据库两大神器【索引和锁】</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">MySQL 索引背后的数据结构及算法原理</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/8262aa/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/8262aa/" class="post-title-link" itemprop="url">Mysql 架构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-07-16 11:14:07" itemprop="dateCreated datePublished" datetime="2020-07-16T11:14:07+08:00">2020-07-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">关系型数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/" itemprop="url" rel="index"><span itemprop="name">Mysql</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Mysql-架构"><a href="#Mysql-架构" class="headerlink" title="Mysql 架构"></a>Mysql 架构</h1><p>大体来说，MySQL 可以分为 Server 层和存储引擎层两部分。</p>
<p><strong>Server 层包括连接器、查询缓存、解析器、优化器、执行器等</strong>，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p>
<p><strong>存储引擎层负责数据的存储和提取</strong>。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202311111138178.png"></p>
<h2 id="Mysql-查询流程"><a href="#Mysql-查询流程" class="headerlink" title="Mysql 查询流程"></a>Mysql 查询流程</h2><p>SQL 语句在 MySQL 中是如何执行的？</p>
<p>MySQL 整个查询执行过程，总的来说分为 6 个步骤：</p>
<ol>
<li><strong>连接器</strong> - 客户端和 MySQL 服务器建立连接；连接器负责跟客户端建立连接、获取权限、维持和管理连接。</li>
<li><strong>查询缓存</strong> - MySQL 服务器首先检查查询缓存，如果命中缓存，则立刻返回结果。否则进入下一阶段。</li>
<li><strong>分析器</strong> - MySQL 服务器进行 SQL 解析：语法分析、词法分析。</li>
<li><strong>优化器</strong> - MySQL 服务器用优化器生成对应的执行计划。</li>
<li><strong>执行器</strong> - MySQL 服务器根据执行计划，调用存储引擎的 API 来执行查询。</li>
<li><strong>返回结果</strong> - MySQL 服务器将结果返回给客户端，同时缓存查询结果。</li>
</ol>
<h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>使用 MySQL 第一步自然是要连接数据库。<strong>连接器负责跟客户端建立连接、获取权限、维持和管理连接</strong>。</p>
<p>MySQL 客户端&#x2F;服务端通信是<strong>半双工模式</strong>：即任一时刻，要么是服务端向客户端发送数据，要么是客户端向服务器发送数据。客户端用一个单独的数据包将查询请求发送给服务器，所以当查询语句很长的时候，需要设置 <code>max_allowed_packet</code> 参数。但是需要注意的是，如果查询实在是太大，服务端会拒绝接收更多数据并抛出异常。</p>
<p>MySQL 客户端连接命令形式为：<code>mysql -h&lt;主机&gt; -P&lt;端口&gt; -u&lt;用户名&gt; -p&lt;密码&gt;</code>。如果没有显式指定密码，会要求输入密码才能访问。</p>
<p>连接完成后，如果没有后续的动作，这个连接就处于<strong>空闲状态</strong>。<strong>可以执行 <code>show processlist</code> 命令查看当前有多少个客户端连接</strong>。<strong>客户端如果空闲太久，连接器就会自动将它断开</strong>。客户端连接维持时间是由参数 <code>wait_timeout</code> 控制的，默认值是 8 小时。如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： <code>Lost connection to MySQL server during query</code>。这时候如果你要继续，就需要重连，然后再执行请求了。</p>
<p>建立连接的过程通常是比较复杂的，建议在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。为了在程序中提高数据库连接的服用了，一般会使用数据库连接池来维护管理。</p>
<p>但是全部使用长连接后，你可能会发现，有些时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。</p>
<p>怎么解决这个问题呢？你可以考虑以下两种方案。</p>
<ul>
<li><strong>定期断开长连接</strong>。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</li>
<li>如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 <code>mysql_reset_connection</code> 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</li>
</ul>
<h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><blockquote>
<p><strong>不建议使用数据库缓存，因为往往弊大于利</strong>。</p>
</blockquote>
<p>解析一个查询语句前，如果查询缓存是打开的，那么 MySQL 会检查这个查询语句是否命中查询缓存中的数据。如果当前查询恰好命中查询缓存，在检查一次用户权限后直接返回缓存中的结果。这种情况下，查询不会被解析，也不会生成执行计划，更不会执行。</p>
<p>MySQL 将缓存存放在一个引用表（不要理解成<code>table</code>，可以认为是类似于<code>HashMap</code>的数据结构），通过一个哈希值索引，这个哈希值通过查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息计算得来。所以两个查询在任何字符上的不同（例如：空格、注释），都会导致缓存不会命中。</p>
<p><strong>如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、mysql 库中的系统表，其查询结果都不会被缓存</strong>。比如函数<code>NOW()</code>或者<code>CURRENT_DATE()</code>会因为不同的查询时间，返回不同的查询结果，再比如包含<code>CURRENT_USER</code>或者<code>CONNECION_ID()</code>的查询语句会因为不同的用户而返回不同的结果，将这样的查询结果缓存起来没有任何的意义。</p>
<p><strong>不建议使用数据库缓存，因为往往弊大于利</strong>。查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</p>
<p>好在 MySQL 也提供了这种“按需使用”的方式。你可以将参数 <code>query_cache_type</code> 设置成 <code>DEMAND</code>，这样对于默认的 SQL 语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用 <code>SQL_CACHE</code> 显式指定，像下面这个语句一样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> SQL_CACHE <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：MySQL 8.0 版本直接将查询缓存的整块功能删掉了。</p>
</blockquote>
<h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><p>如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL 需要知道你要做什么，因此需要对 SQL 语句做解析。MySQL 通过关键字对 SQL 语句进行解析，并生成一颗对应的语法解析树。这个过程中，分析器主要通过语法规则来验证和解析。比如 SQL 中是否使用了错误的关键字或者关键字的顺序是否正确等等。预处理则会根据 MySQL 规则进一步检查解析树是否合法。比如检查要查询的数据表和数据列是否存在等等。</p>
<ul>
<li>分析器先会先做“<strong>词法分析</strong>”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。MySQL 从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。</li>
<li>接下来，要做“<strong>语法分析</strong>”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒，比如下面这个语句 select 少打了开头的字母“s”。</li>
</ul>
<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>经过了分析器，MySQL 就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。</p>
<p>经过前面的步骤生成的语法树被认为是合法的了，并且由优化器将其转化成执行计划。多数情况下，一条查询可以有很多种执行方式，最后都返回相应的结果。优化器的作用就是找到这其中最好的执行计划。</p>
<p>MySQL 使用基于成本的优化器，它尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最小的一个。在 MySQL 可以通过查询当前会话的 <code>last_query_cost</code> 的值来得到其计算当前查询的成本。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t_message limit <span class="number">10</span>;</span><br><span class="line">...省略结果集</span><br><span class="line"></span><br><span class="line">mysql&gt; show status like <span class="string">&#x27;last_query_cost&#x27;</span>;</span><br><span class="line">+-----------------+-------------+</span><br><span class="line">|<span class="params"> Variable_name   </span>| <span class="title class_">Value</span>       |<span class="params"></span></span><br><span class="line"><span class="params">+-----------------+-------------+</span></span><br><span class="line"><span class="params"></span>| <span class="title class_">Last</span>_query_cost |<span class="params"> 6391.799000 </span>|</span><br><span class="line">+-----------------+-------------+</span><br></pre></td></tr></table></figure>

<p>示例中的结果表示优化器认为大概需要做 6391 个数据页的随机查找才能完成上面的查询。这个结果是根据一些列的统计信息计算得来的，这些统计信息包括：每张表或者索引的页面个数、索引的基数、索引和数据行的长度、索引的分布情况等等。</p>
<p>有非常多的原因会导致 MySQL 选择错误的执行计划，比如统计信息不准确、不会考虑不受其控制的操作成本（用户自定义函数、存储过程）、MySQL 认为的最优跟我们想的不一样（我们希望执行时间尽可能短，但 MySQL 值选择它认为成本小的，但成本小并不意味着执行时间短）等等。</p>
<p>MySQL 的查询优化器是一个非常复杂的部件，它使用了非常多的优化策略来生成一个最优的执行计划：</p>
<ul>
<li>重新定义表的关联顺序（多张表关联查询时，并不一定按照 SQL 中指定的顺序进行，但有一些技巧可以指定关联顺序）</li>
<li>优化<code>MIN()</code>和<code>MAX()</code>函数（找某列的最小值，如果该列有索引，只需要查找 B+Tree 索引最左端，反之则可以找到最大值，具体原理见下文）</li>
<li>提前终止查询（比如：使用 Limit 时，查找到满足数量的结果集后会立即终止查询）</li>
<li>优化排序（在老版本 MySQL 会使用两次传输排序，即先读取行指针和需要排序的字段在内存中对其排序，然后再根据排序结果去读取数据行，而新版本采用的是单次传输排序，也就是一次读取所有的数据行，然后根据给定的列排序。对于 I&#x2F;O 密集型应用，效率会高很多）</li>
</ul>
<p>随着 MySQL 的不断发展，优化器使用的优化策略也在不断的进化，这里仅仅介绍几个非常常用且容易理解的优化策略，其他的优化策略，大家自行查阅吧。</p>
<h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>在完成解析和优化阶段以后，MySQL 会生成对应的执行计划，查询执行引擎根据执行计划给出的指令逐步执行得出结果。整个执行过程的大部分操作均是通过调用存储引擎实现的接口来完成，这些接口被称为 <code>handler API</code>。查询过程中的每一张表由一个 <code>handler</code> 实例表示。实际上，MySQL 在查询优化阶段就为每一张表创建了一个 <code>handler</code> 实例，优化器可以根据这些实例的接口来获取表的相关信息，包括表的所有列名、索引统计信息等。存储引擎接口提供了非常丰富的功能，但其底层仅有几十个接口，这些接口像搭积木一样完成了一次查询的大部分操作。</p>
<h3 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h3><p>查询过程的最后一个阶段就是将结果返回给客户端。即使查询不到数据，MySQL 仍然会返回这个查询的相关信息，比如该查询影响到的行数以及执行时间等等。</p>
<p>如果查询缓存被打开且这个查询可以被缓存，MySQL 也会将结果存放到缓存中。</p>
<p>结果集返回客户端是一个增量且逐步返回的过程。有可能 MySQL 在生成第一条结果时，就开始向客户端逐步返回结果集了。这样服务端就无须存储太多结果而消耗过多内存，也可以让客户端第一时间获得返回结果。需要注意的是，结果集中的每一行都会以一个满足 ① 中所描述的通信协议的数据包发送，再通过 TCP 协议进行传输，在传输过程中，可能对 MySQL 的数据包进行缓存然后批量发送。</p>
<h2 id="Mysql-更新流程"><a href="#Mysql-更新流程" class="headerlink" title="Mysql 更新流程"></a>Mysql 更新流程</h2><p>MySQL 更新过程和 MySQL 查询过程类似，也会将流程走一遍。不一样的是：<strong>更新流程还涉及两个重要的日志模块，：redo log（重做日志）和 binlog（归档日志）</strong>。</p>
<h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。为了解决这个问题，MySQL 采用了 WAL 技术（全程是 Write-Ahead Logging），它的关键点就是先写日志，再写磁盘。</p>
<p>具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log 里，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。</p>
<p>InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202311111210060.png"></p>
<p>write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p>
<p>write pos 和 checkpoint 之间的是还空着的部分，可以用来记录新的操作。如果 write pos 追上 checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。</p>
<p>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为<strong>crash-safe</strong>。</p>
<h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><p>redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog（归档日志）。</p>
<p>redo log 和 binlog 的差异：</p>
<ol>
<li>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</li>
<li>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID&#x3D;2 这一行的 c 字段加 1 ”。</li>
<li>redo log 是循环写的，空间固定会用完；binlog 是追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li>
</ol>
<p>再来看一下：update 语句时的内部流程</p>
<ol>
<li>执行器先找引擎取 ID&#x3D;2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID&#x3D;2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li>
<li>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li>
<li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。</li>
<li>执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</li>
<li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220720210120.png"></p>
<h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p>为什么日志需要“两阶段提交”</p>
<p>由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么就是先写完 redo log 再写 binlog，或者采用反过来的顺序。</p>
<ol>
<li><strong>先写 redo log 后写 binlog</strong>。假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。</li>
</ol>
<ul>
<li>但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。</li>
<li>然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。</li>
</ul>
<ol start="2">
<li><strong>先写 binlog 后写 redo log</strong>。如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。</li>
</ol>
<p>可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/23008813/">《高性能 MySQL》</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/139">MySQL 实战 45 讲</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/edd121/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/edd121/" class="post-title-link" itemprop="url">ForkJoin框架</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-07-14 15:27:46" itemprop="dateCreated datePublished" datetime="2020-07-14T15:27:46+08:00">2020-07-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JavaSE/%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">并发</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java-Fork-Join-框架"><a href="#Java-Fork-Join-框架" class="headerlink" title="Java Fork Join 框架"></a>Java Fork Join 框架</h1><p><strong>对于简单的并行任务，你可以通过“线程池 +Future”的方案来解决；如果任务之间有聚合关系，无论是 AND 聚合还是 OR 聚合，都可以通过 CompletableFuture 来解决；而批量的并行任务，则可以通过 CompletionService 来解决。</strong></p>
<h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><h3 id="runAsync-和-supplyAsync-方法"><a href="#runAsync-和-supplyAsync-方法" class="headerlink" title="runAsync 和 supplyAsync 方法"></a>runAsync 和 supplyAsync 方法</h3><p>CompletableFuture 提供了四个静态方法来创建一个异步操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable, Executor executor)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier, Executor executor)</span></span><br></pre></td></tr></table></figure>

<p>没有指定 Executor 的方法会使用 ForkJoinPool.commonPool() 作为它的线程池执行异步代码。如果指定线程池，则使用指定的线程池运行。以下所有的方法都类同。</p>
<ul>
<li>runAsync 方法不支持返回值。</li>
<li>supplyAsync 可以支持返回值。</li>
</ul>
<h2 id="CompletionStage"><a href="#CompletionStage" class="headerlink" title="CompletionStage"></a>CompletionStage</h2><p>CompletionStage 接口可以清晰地描述任务之间的时序关系，如<strong>串行关系、并行关系、汇聚关系</strong>等。</p>
<h3 id="串行关系"><a href="#串行关系" class="headerlink" title="串行关系"></a>串行关系</h3><p>CompletionStage 接口里面描述串行关系，主要是 thenApply、thenAccept、thenRun 和 thenCompose 这四个系列的接口。</p>
<p>thenApply 系列函数里参数 fn 的类型是接口 <code>Function&lt;T, R&gt;</code>，这个接口里与 CompletionStage 相关的方法是 <code>R apply(T t)</code>，这个方法既能接收参数也支持返回值，所以 thenApply 系列方法返回的是<code>CompletionStage</code>。</p>
<p>而 thenAccept 系列方法里参数 consumer 的类型是接口 <code>Consumer&lt;T&gt;</code>，这个接口里与 CompletionStage 相关的方法是 <code>void accept(T t)</code>，这个方法虽然支持参数，但却不支持回值，所以 thenAccept 系列方法返回的是<code>CompletionStage&lt;Void&gt;</code>。</p>
<p>thenRun 系列方法里 action 的参数是 Runnable，所以 action 既不能接收参数也不支持返回值，所以 thenRun 系列方法返回的也是<code>CompletionStage&lt;Void&gt;</code>。</p>
<p>这些方法里面 Async 代表的是异步执行 fn、consumer 或者 action。其中，需要你注意的是 thenCompose 系列方法，这个系列的方法会新创建出一个子流程，最终结果和 thenApply 系列是相同的。</p>
<h3 id="描述-AND-汇聚关系"><a href="#描述-AND-汇聚关系" class="headerlink" title="描述 AND 汇聚关系"></a>描述 AND 汇聚关系</h3><p>CompletionStage 接口里面描述 AND 汇聚关系，主要是 thenCombine、thenAcceptBoth 和 runAfterBoth 系列的接口，这些接口的区别也是源自 fn、consumer、action 这三个核心参数不同。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CompletionStage&lt;<span class="attribute">R</span>&gt; <span class="built_in">thenCombine</span>(other, fn);</span><br><span class="line">CompletionStage&lt;<span class="attribute">R</span>&gt; <span class="built_in">thenCombineAsync</span>(other, fn);</span><br><span class="line">CompletionStage&lt;Void&gt; <span class="built_in">thenAcceptBoth</span>(other, consumer);</span><br><span class="line">CompletionStage&lt;Void&gt; <span class="built_in">thenAcceptBothAsync</span>(other, consumer);</span><br><span class="line">CompletionStage&lt;Void&gt; <span class="built_in">runAfterBoth</span>(other, action);</span><br><span class="line">CompletionStage&lt;Void&gt; <span class="built_in">runAfterBothAsync</span>(other, action);</span><br></pre></td></tr></table></figure>

<h3 id="描述-OR-汇聚关系"><a href="#描述-OR-汇聚关系" class="headerlink" title="描述 OR 汇聚关系"></a>描述 OR 汇聚关系</h3><p>CompletionStage 接口里面描述 OR 汇聚关系，主要是 applyToEither、acceptEither 和 runAfterEither 系列的接口，这些接口的区别也是源自 fn、consumer、action 这三个核心参数不同。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CompletionStage <span class="built_in">applyToEither</span>(other, fn);</span><br><span class="line">CompletionStage <span class="built_in">applyToEitherAsync</span>(other, fn);</span><br><span class="line">CompletionStage <span class="built_in">acceptEither</span>(other, consumer);</span><br><span class="line">CompletionStage <span class="built_in">acceptEitherAsync</span>(other, consumer);</span><br><span class="line">CompletionStage <span class="built_in">runAfterEither</span>(other, action);</span><br><span class="line">CompletionStage <span class="built_in">runAfterEitherAsync</span>(other, action);</span><br></pre></td></tr></table></figure>

<p>下面的示例代码展示了如何使用 applyToEither() 方法来描述一个 OR 汇聚关系。</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;<span class="built_in">String</span>&gt; f1 =</span><br><span class="line">  CompletableFuture.supplyAsync<span class="function"><span class="params">(()-&gt;&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    int t = getRandom(<span class="number">5</span>, <span class="number">10</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">    sleep(t, TimeUnit.SECONDS);</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">return</span> <span class="built_in">String</span>.valueOf(t);</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">CompletableFuture</span>&lt;<span class="title">String</span>&gt; <span class="title">f2</span> =</span></span><br><span class="line"><span class="function">  <span class="title">CompletableFuture</span>.<span class="title">supplyAsync</span><span class="params">(()-&gt;&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    int t = getRandom(<span class="number">5</span>, <span class="number">10</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">    sleep(t, TimeUnit.SECONDS);</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">return</span> <span class="built_in">String</span>.valueOf(t);</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">CompletableFuture</span>&lt;<span class="title">String</span>&gt; <span class="title">f3</span> =</span></span><br><span class="line"><span class="function">  <span class="title">f1</span>.<span class="title">applyToEither</span><span class="params">(f2,s -&gt; s)</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(f3.join())</span>;</span></span><br></pre></td></tr></table></figure>

<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>虽然上面我们提到的 fn、consumer、action 它们的核心方法都<strong>不允许抛出可检查异常，但是却无法限制它们抛出运行时异常</strong>，例如下面的代码，执行 <code>7/0</code> 就会出现除零错误这个运行时异常。非异步编程里面，我们可以使用 try{}catch{} 来捕获并处理异常，那在异步编程里面，异常该如何处理呢？</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt;</span><br><span class="line">  f0 = CompletableFuture.</span><br><span class="line">    .supplyAsync<span class="function"><span class="params">(()-&gt;(<span class="number">7</span>/<span class="number">0</span>))</span></span></span><br><span class="line"><span class="function">    .<span class="title">thenApply</span><span class="params">(r-&gt;r*<span class="number">10</span>)</span>;</span></span><br><span class="line"><span class="function"><span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(f0.join())</span>;</span></span><br></pre></td></tr></table></figure>

<p>CompletionStage 接口给我们提供的方案非常简单，比 try{}catch{}还要简单，下面是相关的方法，使用这些方法进行异常处理和串行操作是一样的，都支持链式编程方式。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CompletionStage <span class="built_in">exceptionally</span>(fn);</span><br><span class="line">CompletionStage&lt;<span class="attribute">R</span>&gt; <span class="built_in">whenComplete</span>(consumer);</span><br><span class="line">CompletionStage&lt;<span class="attribute">R</span>&gt; <span class="built_in">whenCompleteAsync</span>(consumer);</span><br><span class="line">CompletionStage&lt;<span class="attribute">R</span>&gt; <span class="built_in">handle</span>(fn);</span><br><span class="line">CompletionStage&lt;<span class="attribute">R</span>&gt; <span class="built_in">handleAsync</span>(fn);</span><br></pre></td></tr></table></figure>

<p>下面的示例代码展示了如何使用 exceptionally() 方法来处理异常，exceptionally() 的使用非常类似于 try{}catch{}中的 catch{}，但是由于支持链式编程方式，所以相对更简单。既然有 try{}catch{}，那就一定还有 try{}finally{}，whenComplete() 和 handle() 系列方法就类似于 try{}finally{}中的 finally{}，无论是否发生异常都会执行 whenComplete() 中的回调函数 consumer 和 handle() 中的回调函数 fn。whenComplete() 和 handle() 的区别在于 whenComplete() 不支持返回结果，而 handle() 是支持返回结果的。</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt;</span><br><span class="line">  f0 = CompletableFuture</span><br><span class="line">    .supplyAsync<span class="function"><span class="params">(()-&gt;<span class="number">7</span>/<span class="number">0</span>)</span>)</span></span><br><span class="line"><span class="function">    .<span class="title">thenApply</span><span class="params">(r-&gt;r*<span class="number">10</span>)</span></span></span><br><span class="line"><span class="function">    .<span class="title">exceptionally</span><span class="params">(e-&gt;<span class="number">0</span>)</span>;</span></span><br><span class="line"><span class="function"><span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(f0.join())</span>;</span></span><br></pre></td></tr></table></figure>

<h2 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork&#x2F;Join"></a>Fork&#x2F;Join</h2><p>Fork&#x2F;Join 是一个并行计算的框架，主要就是用来支持分治任务模型的，这个计算框架里的<strong>Fork 对应的是分治任务模型里的任务分解，Join 对应的是结果合并</strong>。Fork&#x2F;Join 计算框架主要包含两部分，一部分是<strong>分治任务的线程池 ForkJoinPool</strong>，另一部分是<strong>分治任务 ForkJoinTask</strong>。这两部分的关系类似于 ThreadPoolExecutor 和 Runnable 的关系，都可以理解为提交任务到线程池，只不过分治任务有自己独特类型 ForkJoinTask。</p>
<p>ForkJoinTask 是一个抽象类，它的方法有很多，最核心的是 fork() 方法和 join() 方法，其中 fork() 方法会异步地执行一个子任务，而 join() 方法则会阻塞当前线程来等待子任务的执行结果。ForkJoinTask 有两个子类——RecursiveAction 和 RecursiveTask，通过名字你就应该能知道，它们都是用递归的方式来处理分治任务的。这两个子类都定义了抽象方法 compute()，不过区别是 RecursiveAction 定义的 compute() 没有返回值，而 RecursiveTask 定义的 compute() 方法是有返回值的。这两个子类也是抽象类，在使用的时候，需要你定义子类去扩展。</p>
<h3 id="ForkJoinPool-工作原理"><a href="#ForkJoinPool-工作原理" class="headerlink" title="ForkJoinPool 工作原理"></a>ForkJoinPool 工作原理</h3><p>Fork&#x2F;Join 并行计算的核心组件是 ForkJoinPool，所以下面我们就来简单介绍一下 ForkJoinPool 的工作原理。</p>
<p>通过专栏前面文章的学习，你应该已经知道 ThreadPoolExecutor 本质上是一个生产者 - 消费者模式的实现，内部有一个任务队列，这个任务队列是生产者和消费者通信的媒介；ThreadPoolExecutor 可以有多个工作线程，但是这些工作线程都共享一个任务队列。</p>
<p>ForkJoinPool 本质上也是一个生产者 - 消费者的实现，但是更加智能，你可以参考下面的 ForkJoinPool 工作原理图来理解其原理。ThreadPoolExecutor 内部只有一个任务队列，而 ForkJoinPool 内部有多个任务队列，当我们通过 ForkJoinPool 的 invoke() 或者 submit() 方法提交任务时，ForkJoinPool 根据一定的路由规则把任务提交到一个任务队列中，如果任务在执行过程中会创建出子任务，那么子任务会提交到工作线程对应的任务队列中。</p>
<p>如果工作线程对应的任务队列空了，是不是就没活儿干了呢？不是的，ForkJoinPool 支持一种叫做“<strong>任务窃取</strong>”的机制，如果工作线程空闲了，那它可以“窃取”其他工作任务队列里的任务，例如下图中，线程 T2 对应的任务队列已经空了，它可以“窃取”线程 T1 对应的任务队列的任务。如此一来，所有的工作线程都不会闲下来了。</p>
<p>ForkJoinPool 中的任务队列采用的是双端队列，工作线程正常获取任务和“窃取任务”分别是从任务队列不同的端消费，这样能避免很多不必要的数据竞争。我们这里介绍的仅仅是简化后的原理，ForkJoinPool 的实现远比我们这里介绍的复杂，如果你感兴趣，建议去看它的源码。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200703141326.png" alt="img"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/10484692/">《Java 并发编程实战》</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/26591326/">《Java 并发编程的艺术》</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100023901">《Java 并发编程实战》</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6bac52527ca4">CompletableFuture 使用详解</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/451b73/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/451b73/" class="post-title-link" itemprop="url">Redis 面试</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-07-13 17:03:42" itemprop="dateCreated datePublished" datetime="2020-07-13T17:03:42+08:00">2020-07-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">KV数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>16k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>14 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Redis-面试"><a href="#Redis-面试" class="headerlink" title="Redis 面试"></a>Redis 面试</h1><h2 id="Redis-简介"><a href="#Redis-简介" class="headerlink" title="Redis 简介"></a>Redis 简介</h2><h3 id="什么是-Redis"><a href="#什么是-Redis" class="headerlink" title="什么是 Redis"></a>什么是 Redis</h3><p>【问题】</p>
<ul>
<li>什么是 Redis？</li>
<li>Redis 有什么功能和特性？</li>
</ul>
<p>【解答】</p>
<p>什么是 Redis：</p>
<p><strong>Redis 是一个开源的“内存”数据库</strong>。由于，Redis 的读写操作都是在内存中完成，因此其<strong>读写速度非常快</strong>。</p>
<ul>
<li><strong>高性能</strong> - 由于，Redis 的读写操作都是在内存中完成，因此性能极高。</li>
<li><strong>高并发</strong> - Redis 单机 QPS 能达到 10w+，将近是 Mysql 的 10 倍。</li>
</ul>
<p>Redis 常被用于<strong>缓存，消息队列、分布式锁等场景</strong>。</p>
<p>Redis 的功能和特性：</p>
<ul>
<li><p><strong>Redis 支持多种数据类型</strong>。如：String(字符串)、Hash(哈希)、 List (列表)、Set(集合)、Zset(有序集合)、Bitmaps（位图）、HyperLogLog（基数统计）、GEO（地理空间）、Stream（流）。</p>
</li>
<li><p><strong>Redis 的读写采用“单线程”模型</strong>，因此，其操作天然就具有<strong>原子性</strong>。</p>
</li>
<li><p>Redis 支持两种持久化策略：RDB 和 AOF。</p>
</li>
<li><p>Redis 有多种高可用方案：<strong>主从复制</strong>模式、<strong>哨兵</strong>模式、<strong>集群</strong>模式。</p>
</li>
<li><p>Redis 支持很多丰富的特性，如：<strong>事务</strong> 、<strong>Lua 脚本</strong>、<strong>发布订阅</strong>、<strong>过期删除</strong>、<strong>内存淘汰</strong>等等。</p>
</li>
</ul>
<p><img src="https://architecturenotes.co/content/images/size/w2400/2022/08/Redis-v2-01-1.jpg"></p>
<p>图来自 <a target="_blank" rel="noopener" href="https://architecturenotes.co/redis/">https://architecturenotes.co/redis/</a></p>
<h3 id="Redis-有哪些应用场景"><a href="#Redis-有哪些应用场景" class="headerlink" title="Redis 有哪些应用场景"></a>Redis 有哪些应用场景</h3><p>【问题】</p>
<ul>
<li>Redis 有哪些应用场景？</li>
</ul>
<p>【解答】</p>
<ul>
<li><strong>缓存</strong> - 将热点数据放到内存中，设置内存的最大使用量以及过期淘汰策略来保证缓存的命中率。</li>
<li><strong>计数器</strong> - Redis 这种内存数据库能支持计数器频繁的读写操作。</li>
<li><strong>应用限流</strong> - 限制一个网站访问流量。</li>
<li><strong>消息队列</strong> - 使用 List 数据类型，它是双向链表。</li>
<li><strong>查找表</strong> - 使用 HASH 数据类型。</li>
<li><strong>聚合运算</strong> - 使用 SET 类型，例如求两个用户的共同好友。</li>
<li><strong>排行榜</strong> - 使用 ZSET 数据类型。</li>
<li><strong>分布式 Session</strong> - 多个应用服务器的 Session 都存储到 Redis 中来保证 Session 的一致性。</li>
<li><strong>分布式锁</strong> - 除了可以使用 SETNX 实现分布式锁之外，还可以使用官方提供的 RedLock 分布式锁实现。</li>
</ul>
<h3 id="Redis-vs-Memcached"><a href="#Redis-vs-Memcached" class="headerlink" title="Redis vs. Memcached"></a>Redis vs. Memcached</h3><p>【问题】</p>
<ul>
<li>Redis 和 Memcached 有什么相同点？</li>
<li>Redis 和 Memcached 有什么差异？</li>
<li>分布式缓存技术选型，选 Redis 还是 Memcached，为什么？</li>
</ul>
<p>【解答】</p>
<p>Redis 与 Memcached 的<strong>共性</strong>：</p>
<ol>
<li>都是内存数据库，因此性能都很高</li>
<li>都有过期策略。</li>
</ol>
<p>因为以上两点，所以常被作为缓存使用。</p>
<p>Redis 与 Memcached 的<strong>差异</strong>：</p>
<table>
<thead>
<tr>
<th></th>
<th>Redis</th>
<th>Memcached</th>
</tr>
</thead>
<tbody><tr>
<td>数据类型</td>
<td>支持多种数据类型：String、Hash、List、Set、ZSet 等</td>
<td>只支持 String 类型</td>
</tr>
<tr>
<td>持久化</td>
<td>支持两种持久化策略：RDB 和 AOF</td>
<td>不支持持久化，一旦重启或宕机就会丢失数据</td>
</tr>
<tr>
<td>分布式</td>
<td>支持分布式</td>
<td>本身不支持分布式，只能通过在客户端使用像一致性哈希这样的分布式算法来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点</td>
</tr>
<tr>
<td>线程模型</td>
<td>读写采用单线程+IO 多路复用。因此存储小数据时比 Memcached 性能更高</td>
<td>采用多线程+IO 多路复用。在 100k 以上的数据中，Memcached 性能要高于 Redis</td>
</tr>
<tr>
<td>其他功能</td>
<td>支持发布订阅模型、Lua 脚本、事务等功能</td>
<td>不支持</td>
</tr>
</tbody></table>
<p>通过以上分析，可以看出，Redis 在很多方面都占有优势。因此，绝大多数情况下，优先选择 Redis 作为分布式缓存。</p>
<blockquote>
<p>参考：<a href="www.imooc.com/article/23549">《脚踏两只船的困惑 - Memcached 与 Redis》</a></p>
</blockquote>
<h3 id="Redis-为什么快"><a href="#Redis-为什么快" class="headerlink" title="Redis 为什么快"></a>Redis 为什么快</h3><p>【问题】</p>
<ul>
<li>Redis 有多快？</li>
<li>Redis 为什么这么快？</li>
</ul>
<p>【解答】</p>
<p>根据 <a target="_blank" rel="noopener" href="https://redis.io/docs/management/optimization/benchmarks/">Redis 官方 Benchmark</a> 文档的描述，Redis 单机 QPS 能达到 10w+。</p>
<p><img src="https://redis.io/docs/management/optimization/benchmarks/Connections_chart.png" alt="Redis 官方 Benchmark QPS 图"></p>
<p>Redis 是单线程模型（Redis 6.0 已经支持多线程模型），为什么还能有这么高的并发？</p>
<ul>
<li><strong>Redis 读写基于内存</strong></li>
<li><strong>IO 多路复用</strong> + <strong>读写单线程模型</strong><ul>
<li>IO 多路复用是利用 select、poll、epoll 可以同时监察多个流的 I&#x2F;O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I&#x2F;O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。</li>
<li>单线程模型避免了由于并发而产生的线程切换、锁竞争等开销。</li>
<li>由于，Redis 读写基于内存，性能很高，所以 CPU 并不是制约 Redis 性能表现的瓶颈所在。更多情况下是受到内存大小和网络 I&#x2F;O 的限制，所以 Redis 核心网络模型使用单线程并没有什么问题。</li>
</ul>
</li>
<li><strong>高效的数据结构</strong></li>
</ul>
<p><img src="https://pbs.twimg.com/media/FoYNzdcacAAMjy5?format=jpg&name=4096x4096"></p>
<p>图来自 <a target="_blank" rel="noopener" href="https://blog.bytebytego.com/p/why-is-redis-so-fast">Why is redis so fast?</a></p>
<h2 id="Redis-数据类型"><a href="#Redis-数据类型" class="headerlink" title="Redis 数据类型"></a>Redis 数据类型</h2><h3 id="Redis-支持哪些数据类型"><a href="#Redis-支持哪些数据类型" class="headerlink" title="Redis 支持哪些数据类型"></a>Redis 支持哪些数据类型</h3><p>【问题】</p>
<ul>
<li>Redis 支持哪些数据类型？</li>
</ul>
<p>【解答】</p>
<ul>
<li>Redis 支持五种基本数据类型：String（字符串），Hash（哈希），List（列表），Set（集合）、Zset（有序集合）。</li>
<li>随着 Redis 版本升级，又陆续支持以下数据类型： BitMap（2.2 版新增）、HyperLogLog（2.8 版新增）、GEO（3.2 版新增）、Stream（5.0 版新增）。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202309232155082.png"></p>
<h3 id="Redis-各数据类型的应用场景"><a href="#Redis-各数据类型的应用场景" class="headerlink" title="Redis 各数据类型的应用场景"></a>Redis 各数据类型的应用场景</h3><p>【问题】</p>
<p>Redis 各数据类型有哪些应用场景？</p>
<p>【解答】</p>
<ul>
<li><p><strong>String（字符串）</strong> - 缓存对象、分布式 Session、分布式锁、计数器、限流器、分布式 ID 等。</p>
</li>
<li><p><strong>Hash（哈希）</strong> - 缓存对象、购物车等。</p>
</li>
<li><p><strong>List（列表）</strong> - 消息队列</p>
</li>
<li><p><strong>Set（集合）</strong> - 聚合计算（并集、交集、差集），如点赞、共同关注、抽奖活动等。</p>
</li>
<li><p><strong>Zset（有序集合）</strong> - 排序场景，如排行榜、电话和姓名排序等。</p>
</li>
<li><p><strong>BitMap</strong>（2.2 版新增） - 二值状态统计的场景，比如签到、判断用户登陆状态、连续签到用户总数等；</p>
</li>
<li><p><strong>HyperLogLog</strong>（2.8 版新增） - 海量数据基数统计的场景，比如百万级网页 UV 计数等；</p>
</li>
<li><p><strong>GEO</strong>（3.2 版新增） - 存储地理位置信息的场景，比如滴滴叫车；</p>
</li>
<li><p><strong>Stream</strong>（5.0 版新增） - 消息队列，相比于基于 List 类型实现的消息队列，有这两个特有的特性：自动生成全局唯一消息 ID，支持以消费组形式消费数据。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202309232144470.jpg"></p>
<h3 id="Redis-基本数据类型的底层实现"><a href="#Redis-基本数据类型的底层实现" class="headerlink" title="Redis 基本数据类型的底层实现"></a>Redis 基本数据类型的底层实现</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202309241112034.png"></p>
<ul>
<li><strong>String 类型</strong> - String 类型的底层数据结构是 SDS。SDS 是 Redis 针对字符串类型的优化，具有以下特性：<ul>
<li>常数复杂度获取字符串长度</li>
<li>杜绝缓冲区溢出</li>
<li>减少修改字符串长度时所需的内存重分配次数</li>
</ul>
</li>
<li><strong>List 类型</strong> - 列表对象的编码可以是 <code>ziplist</code> 或者 <code>linkedlist</code> 。当列表对象可以同时满足以下两个条件时， 列表对象使用 <code>ziplist</code> 编码；否则，使用 <code>linkedlist</code> 编码。<ul>
<li>列表对象保存的所有字符串元素的长度都小于 <code>64</code> 字节；</li>
<li>列表对象保存的元素数量小于 <code>512</code> 个；</li>
</ul>
</li>
<li><strong>Hash 类型</strong> - 哈希对象的编码可以是 <code>ziplist</code> 或者 <code>hashtable</code> 。当哈希对象同时满足以下两个条件时， 使用 <code>ziplist</code> 编码；否则，使用 <code>hashtable</code> 编码。<ul>
<li>哈希对象保存的所有键值对的键和值的字符串长度都小于 <code>64</code> 字节；</li>
<li>哈希对象保存的键值对数量小于 <code>512</code> 个；</li>
</ul>
</li>
<li><strong>Set 类型</strong> - 集合对象的编码可以是 <code>intset</code> 或者 <code>hashtable</code> 。当集合对象可以同时满足以下两个条件时，集合对象使用 <code>intset</code> 编码；否则，使用 <code>hashtable</code> 编码。<ul>
<li>集合对象保存的所有元素都是整数值；</li>
<li>集合对象保存的元素数量不超过 <code>512</code> 个；</li>
</ul>
</li>
<li><strong>Zset 类型</strong> - 有序集合的编码可以是 <code>ziplist</code> 或者 <code>skiplist</code> 。当有序集合对象可以同时满足以下两个条件时，有序集合对象使用 <code>ziplist</code> 编码；否则，使用 <code>skiplist</code> 编码。<ul>
<li>有序集合保存的元素数量小于 <code>128</code> 个；</li>
<li>有序集合保存的所有元素成员的长度都小于 <code>64</code> 字节；</li>
</ul>
</li>
</ul>
<h2 id="Redis-过期删除和内存淘汰"><a href="#Redis-过期删除和内存淘汰" class="headerlink" title="Redis 过期删除和内存淘汰"></a>Redis 过期删除和内存淘汰</h2><h3 id="Redis-过期删除策略"><a href="#Redis-过期删除策略" class="headerlink" title="Redis 过期删除策略"></a>Redis 过期删除策略</h3><p>【问题】</p>
<ul>
<li>Redis 的过期删除策略是什么？</li>
</ul>
<p>【解答】</p>
<p>Redis 采用的过期策略是：<strong>定期删除+惰性删除</strong>。</p>
<ul>
<li><strong>定时删除</strong> - 在设置 key 的过期时间的同时，创建一个定时器，让定时器在 key 的过期时间来临时，立即执行 key 的删除操作。<ul>
<li>优点 - 保证过期 key 被尽可能快的删除，释放内存。</li>
<li>缺点 - <strong>如果过期 key 较多，可能会占用相当一部分的 CPU，从而影响服务器的吞吐量和响应时延</strong>。</li>
</ul>
</li>
<li><strong>惰性删除</strong> - 放任 key 过期不管，但是每次访问 key 时，都检查 key 是否过期，如果过期的话，就删除该 key ；如果没有过期，就返回该 key。<ul>
<li>优点 - 占用 CPU 最少。程序只会在读写键时，对当前键进行过期检查，因此不会有额外的 CPU 开销。</li>
<li>缺点 - <strong>过期的 key 可能因为没有被访问，而一直无法释放，造成内存的浪费，有内存泄漏的风险</strong>。</li>
</ul>
</li>
<li><strong>定期删除</strong> - 每隔一段时间，程序就对数据库进行一次检查，删除里面的过期 key 。至于要删除多少过期 key ，以及要检查多少个数据库，则由算法决定。定期删除是前两种策略的一种折中方案。定期删除策略的难点是删除操作执行的时长和频率。<ul>
<li>执行太频或执行时间过长，就会出现和定时删除相同的问题；</li>
<li>执行太少或执行时间过短，就会出现和惰性删除相同的问题；</li>
</ul>
</li>
</ul>
<h3 id="持久化时，对过期键会如何处理"><a href="#持久化时，对过期键会如何处理" class="headerlink" title="持久化时，对过期键会如何处理"></a>持久化时，对过期键会如何处理</h3><p>RDB 持久化</p>
<ul>
<li><strong>RDB 文件生成阶段</strong> - 从内存状态持久化成 RDB（文件）的时候，会对 key 进行过期检查，<strong>过期的键“不会”被保存到新的 RDB 文件中</strong>，因此 Redis 中的过期键不会对生成新 RDB 文件产生任何影响。</li>
<li><strong>RDB 加载阶段</strong> - RDB 加载阶段时，要看服务器是主服务器还是从服务器，分别对应以下两种情况：<ul>
<li><strong>如果 Redis 是“主服务器”运行模式的话，在载入 RDB 文件时，程序会对文件中保存的键进行检查，过期键“不会”被载入到数据库中</strong>。所以过期键不会对载入 RDB 文件的主服务器造成影响；</li>
<li><strong>如果 Redis 是“从服务器”运行模式的话，在载入 RDB 文件时，不论键是否过期都会被载入到数据库中</strong>。但由于主从服务器在进行数据同步时，从服务器的数据会被清空。所以一般来说，过期键对载入 RDB 文件的从服务器也不会造成影响。</li>
</ul>
</li>
</ul>
<p>AOF 持久化</p>
<ul>
<li><strong>AOF 文件写入阶段</strong> - 当 Redis 以 AOF 模式持久化时，<strong>如果数据库某个过期键还没被删除，那么 AOF 文件会保留此过期键，当此过期键被删除后，Redis 会向 AOF 文件追加一条 DEL 命令来显式地删除该键值</strong>。</li>
<li><strong>AOF 重写阶段</strong> - 执行 AOF 重写时，会对 Redis 中的键值对进行检查，<strong>已过期的键不会被保存到重写后的 AOF 文件中</strong>，因此不会对 AOF 重写造成任何影响。</li>
</ul>
<h3 id="主从复制时，对过期键会如何处理"><a href="#主从复制时，对过期键会如何处理" class="headerlink" title="主从复制时，对过期键会如何处理"></a>主从复制时，对过期键会如何处理</h3><p>当 Redis 运行在主从模式下时，<strong>从库不会进行过期扫描，从库对过期的处理是被动的</strong>。也就是即使从库中的 key 过期了，如果有客户端访问从库时，依然可以得到 key 对应的值，像未过期的键值对一样返回。</p>
<p>从库的过期键处理依靠主服务器控制，<strong>主库在 key 到期时，会在 AOF 文件里增加一条 del 指令，同步到所有的从库</strong>，从库通过执行这条 del 指令来删除过期的 key。</p>
<h3 id="Redis-内存淘汰策略"><a href="#Redis-内存淘汰策略" class="headerlink" title="Redis 内存淘汰策略"></a>Redis 内存淘汰策略</h3><p>【问题】</p>
<ul>
<li>Redis 内存不足时，怎么办？</li>
<li>Redis 有哪些内存淘汰策略？</li>
<li>如何选择内存淘汰策略？</li>
</ul>
<p>【解答】</p>
<p>（1）Redis 内存淘汰要点</p>
<ul>
<li><strong>失效时间</strong> - 作为一种定期清理无效数据的重要机制，在 Redis 提供的诸多命令中，<code>EXPIRE</code>、<code>EXPIREAT</code>、<code>PEXPIRE</code>、<code>PEXPIREAT</code> 以及 <code>SETEX</code> 和 <code>PSETEX</code> 均可以用来设置一条键值对的失效时间。而一条键值对一旦被关联了失效时间就会在到期后自动删除（或者说变得无法访问更为准确）。</li>
<li><strong>最大缓存</strong> - Redis 允许通过 <code>maxmemory</code> 参数来设置内存最大值。当内存达设定的阀值，就会触发<strong>内存淘汰</strong>。</li>
<li><strong>内存淘汰</strong> - 内存淘汰是为了更好的利用内存——清理部分缓存，以此换取内存的利用率，即尽量保证 Redis 缓存中存储的是热点数据。</li>
</ul>
<p>（2）Redis 内存淘汰策略</p>
<ul>
<li><p><strong>不淘汰</strong></p>
<ul>
<li><strong><code>noeviction</code></strong> - 当内存使用达到阈值的时候，所有引起申请内存的命令会报错。这是 Redis 默认的策略。</li>
</ul>
</li>
<li><p><strong>在过期键中进行淘汰</strong></p>
<ul>
<li><p><strong><code>volatile-random</code></strong> - 在设置了过期时间的键空间中，随机移除某个 key。</p>
</li>
<li><p><strong><code>volatile-ttl</code></strong> - 在设置了过期时间的键空间中，具有更早过期时间的 key 优先移除。</p>
</li>
<li><p><strong><code>volatile-lru</code></strong> - 在设置了过期时间的键空间中，优先移除最近未使用的 key。</p>
</li>
<li><p><strong><code>volatile-lfu</code></strong> （Redis 4.0 新增）- 淘汰所有设置了过期时间的键值中，最少使用的键值。</p>
</li>
</ul>
</li>
<li><p><strong>在所有键中进行淘汰</strong></p>
<ul>
<li><strong><code>allkeys-lru</code></strong> - 在主键空间中，优先移除最近未使用的 key。</li>
<li><strong><code>allkeys-random</code></strong> - 在主键空间中，随机移除某个 key。</li>
<li><strong><code>allkeys-lfu</code></strong> (Redis 4.0 新增) - 淘汰整个键值中最少使用的键值。</li>
</ul>
</li>
</ul>
<p>（3）如何选择内存淘汰策略</p>
<ul>
<li>如果数据呈现幂等分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用 <code>allkeys-lru</code> 或 <code>allkeys-lfu</code>。</li>
<li>如果数据呈现平均分布，也就是所有的数据访问频率都相同，则使用 <code>allkeys-random</code>。</li>
<li>若 Redis 既用于缓存，也用于持久化存储时，适用 <code>volatile-lru</code> 、<code>volatile-lfu</code>、<code>volatile-random</code>。但是，这种情况下，也可以部署两个 Redis 集群来达到同样目的。</li>
<li>为 key 设置过期时间实际上会消耗更多的内存。因此，如果条件允许，建议使用 <code>allkeys-lru</code> 或 <code>allkeys-lfu</code>，从而更高效的使用内存。</li>
</ul>
<h2 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h2><h3 id="Redis-如何保证数据不丢失"><a href="#Redis-如何保证数据不丢失" class="headerlink" title="Redis 如何保证数据不丢失"></a>Redis 如何保证数据不丢失</h3><p>【问题】</p>
<ul>
<li>Redis 如何保证数据不丢失？</li>
<li>Redis 有几种持久化方式？</li>
</ul>
<p>【解答】</p>
<p>为了追求性能，Redis 的读写都是在内存中完成的。一旦重启，内存中的数据就会清空，为了保证数据不丢失，Redis 支持持久化机制。</p>
<p>Redis 有三种持久化方式</p>
<ul>
<li>RDB 快照</li>
<li>AOF 日志</li>
<li>混合持久化</li>
</ul>
<h3 id="AOF-的实现原理"><a href="#AOF-的实现原理" class="headerlink" title="AOF 的实现原理"></a>AOF 的实现原理</h3><p>【问题】</p>
<ul>
<li>AOF 的实现原理是什么？</li>
<li>为什么先执行命令，再把数据写入日志呢？</li>
</ul>
<p>【解答】</p>
<p><strong>Redis 命令请求会先保存到 AOF 缓冲区，再定期写入并同步到 AOF 文件</strong>。</p>
<p>AOF 的实现可以分为命令追加（append）、文件写入、文件同步（sync）三个步骤。</p>
<ul>
<li><strong>命令追加</strong> - 当 Redis 服务器开启 AOF 功能时，服务器在执行完一个写命令后，会以 Redis 命令协议格式将被执行的写命令追加到 AOF 缓冲区的末尾。</li>
<li><strong>文件写入</strong>和<strong>文件同步</strong><ul>
<li>Redis 的服务器进程就是一个事件循环，这个循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复。而时间事件则负责执行想 <code>serverCron</code> 这样的定时运行的函数。</li>
<li>因为服务器在处理文件事件时可能会执行写命令，这些写命令会被追加到 AOF 缓冲区，服务器每次结束事件循环前，都会根据 <code>appendfsync</code> 选项来判断 AOF 缓冲区内容是否需要写入和同步到 AOF 文件中。</li>
</ul>
</li>
</ul>
<p>先执行命令，再把数据写入 AOF 日志有两个好处：</p>
<ul>
<li><strong>避免额外的检查开销</strong></li>
<li><strong>不会阻塞当前写操作命令的执行</strong></li>
</ul>
<p>当然，这样做也会有弊端：</p>
<ul>
<li><strong>数据可能会丢失：</strong></li>
<li><strong>可能阻塞其他操作：</strong></li>
</ul>
<h3 id="AOF-的回写策略有几种"><a href="#AOF-的回写策略有几种" class="headerlink" title="AOF 的回写策略有几种"></a>AOF 的回写策略有几种</h3><p><strong>Redis 命令请求会先保存到 AOF 缓冲区，再定期写入并同步到 AOF 文件</strong>。</p>
<p><code>appendfsync</code> 不同选项决定了不同的持久化行为：</p>
<ul>
<li><strong><code>always</code></strong> - 将 AOF 缓冲区中所有内容写入并同步到 AOF 文件。这种方式是最数据最安全的，但也是性能最差的。</li>
<li><strong><code>no</code></strong> - 将 AOF 缓冲区所有内容写入到 AOF 文件，但并不对 AOF 文件进行同步，何时同步由操作系统决定。这种方式是数据最不安全的，一旦出现故障，未来得及同步的所有数据都会丢失。</li>
<li><strong><code>everysec</code></strong> - <code>appendfsync</code> 默认选项。将 AOF 缓冲区所有内容写入到 AOF 文件，如果上次同步 AOF 文件的时间距离现在超过一秒钟，那么再次对 AOF 文件进行同步，这个同步操作是有一个线程专门负责执行的。这张方式是前面两种的这种方案——性能足够好，且即使出现故障，仅丢失一秒钟内的数据。</li>
</ul>
<p><code>appendfsync</code> 选项的不同值对 AOF 持久化功能的安全性、以及 Redis 服务器的性能有很大的影响。</p>
<h3 id="AOF-重写机制"><a href="#AOF-重写机制" class="headerlink" title="AOF 重写机制"></a>AOF 重写机制</h3><p>【问题】</p>
<ul>
<li>AOF 日志过大时，怎么办？</li>
<li>AOF 重写流程是怎样的？</li>
<li>AOF 重写时，可以处理请求吗？</li>
</ul>
<p>【解答】</p>
<p>当 AOF 日志过大时，恢复过程就会很久。为了避免此问题，Redis 提供了 AOF 重写机制，即 AOF 日志大小超过所设阈值后，启动 AOF 重写，压缩 AOF 文件。</p>
<p>AOF 重写机制是，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到新的 AOF 日志中，等到全部记录完成后，就使用新的 AOF 日志替换现有的 AOF 日志。</p>
<p>作为一种辅助性功能，显然 Redis 并不想在 AOF 重写时阻塞 Redis 服务接收其他命令。因此，Redis 决定通过 <code>BGREWRITEAOF</code> 命令创建一个子进程，然后由子进程负责对 AOF 文件进行重写，这与 <code>BGSAVE</code> 原理类似。</p>
<ul>
<li>在执行 <code>BGREWRITEAOF</code> 命令时，Redis 服务器会维护一个 AOF 重写缓冲区。当 AOF 重写子进程开始工作后，Redis 每执行完一个写命令，会同时将这个命令发送给 AOF 缓冲区和 AOF 重写缓冲区。</li>
<li>由于彼此不是在同一个进程中工作，AOF 重写不影响 AOF 写入和同步。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新旧两个 AOF 文件所保存的数据库状态一致。</li>
<li>最后，服务器用新的 AOF 文件替换就的 AOF 文件，以此来完成 AOF 重写操作。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202309171957918.png" alt="BGREWRITEAOF 流程"></p>
<h3 id="RDB-的实现原理"><a href="#RDB-的实现原理" class="headerlink" title="RDB 的实现原理"></a>RDB 的实现原理</h3><p>【问题】</p>
<ul>
<li>RDB 的实现原理是什么？</li>
<li>生成 RDB 快照时，Redis 可以响应请求吗？</li>
</ul>
<p>【解答】</p>
<p><a target="_blank" rel="noopener" href="https://redis.io/commands/bgsave"><strong><code>BGSAVE</code></strong></a> 命令会<strong>“派生”</strong>（fork）一个子进程，由子进程负责创建 RDB 文件，服务器进程继续处理命令请求，所以<strong>该命令“不会阻塞”服务器</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202309172009198.png" alt="BGSAVE 流程"></p>
<h3 id="为什么会有混合持久化？"><a href="#为什么会有混合持久化？" class="headerlink" title="为什么会有混合持久化？"></a>为什么会有混合持久化？</h3><p>RDB 优点是数据恢复速度快，但是快照的频率不好把握。频率太低，丢失的数据就会比较多，频率太高，就会影响性能。</p>
<p>AOF 优点是丢失数据少，但是数据恢复不快。</p>
<p>为了集成了两者的优点， Redis 4.0 提出了<strong>混合使用 AOF 日志和内存快照</strong>，也叫混合持久化，既保证了 Redis 重启速度，又降低数据丢失风险。</p>
<p>混合持久化工作在 <strong>AOF 日志重写过程</strong>，当开启了混合持久化时，在 AOF 重写日志时，fork 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。</p>
<p>也就是说，使用了混合持久化，AOF 文件的<strong>前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据</strong>。</p>
<p>这样的好处在于，重启 Redis 加载数据的时候，由于前半部分是 RDB 内容，这样<strong>加载的时候速度会很快</strong>。</p>
<p>加载完 RDB 的内容后，才会加载后半部分的 AOF 内容，这里的内容是 Redis 后台子进程重写 AOF 期间，主线程处理的操作命令，可以使得<strong>数据更少的丢失</strong>。</p>
<p><strong>混合持久化优点：</strong></p>
<ul>
<li>混合持久化结合了 RDB 和 AOF 持久化的优点，开头为 RDB 的格式，使得 Redis 可以更快的启动，同时结合 AOF 的优点，有减低了大量数据丢失的风险。</li>
</ul>
<p><strong>混合持久化缺点：</strong></p>
<ul>
<li>AOF 文件中添加了 RDB 格式的内容，使得 AOF 文件的可读性变得很差；</li>
<li>兼容性差，如果开启混合持久化，那么此混合持久化 AOF 文件，就不能用在 Redis 4.0 之前版本了。</li>
</ul>
<h2 id="Redis-高可用"><a href="#Redis-高可用" class="headerlink" title="Redis 高可用"></a>Redis 高可用</h2><p>【问题】</p>
<p>Redis 如何保证高可用？</p>
<h3 id="Redis-主从复制"><a href="#Redis-主从复制" class="headerlink" title="Redis 主从复制"></a>Redis 主从复制</h3><p>【问题】</p>
<ul>
<li>Redis 复制的工作原理？Redis 旧版复制和新版复制有何不同？</li>
<li>Redis 主从节点间如何复制数据？</li>
<li>Redis 的数据一致性是强一致性吗？</li>
</ul>
<p>【解答】</p>
<p>（1）旧版复制基于 <code>SYNC</code> 命令实现。分为同步（sync）和命令传播（command propagate）两个操作。这种方式存在缺陷：不能高效处理断线重连后的复制情况。</p>
<p>（2）新版复制基于 <code>PSYNC</code> 命令实现。同步操作分为了两块：</p>
<ul>
<li><strong><code>完整重同步（full resychronization）</code></strong> 用于初次复制；</li>
<li><strong><code>部分重同步（partial resychronization）</code></strong> 用于断线后重复制。<ul>
<li>主从服务器的<strong>复制偏移量（replication offset）</strong></li>
<li>主服务器的<strong>复制积压缓冲区（replication backlog）</strong></li>
<li><strong>服务器的运行 ID</strong></li>
</ul>
</li>
</ul>
<p>（3）Redis 集群主从节点复制的工作流程：</p>
<ul>
<li>步骤 1. 设置主从服务器</li>
<li>步骤 2. 主从服务器建立 TCP 连接。</li>
<li>步骤 3. 发送 PING 检查通信状态。</li>
<li>步骤 4. 身份验证。</li>
<li>步骤 5. 发送端口信息。</li>
<li>步骤 6. 同步。</li>
<li>步骤 7. 命令传播。</li>
</ul>
<p>（4）由于主从复制是<strong>异步</strong>的，具体来说，在主从服务器命令传播阶段，主服务器收到新的写命令后，会发送给从服务器。但是，主服务器并不会等到从服务器实际执行完命令后，再把结果返回给客户端，而是主服务器自己在本地执行完命令后，就会向客户端返回结果了。如果从服务器还没有执行主服务器同步过来的命令，主从服务器间的数据就不一致了。所以，无法实现强一致性保证（主从数据时时刻刻保持一致），数据不一致是难以避免的。</p>
<h3 id="Redis-哨兵"><a href="#Redis-哨兵" class="headerlink" title="Redis 哨兵"></a>Redis 哨兵</h3><p>【问题】</p>
<ul>
<li>Redis 哨兵的功能？</li>
<li>Redis 哨兵的原理？</li>
<li>Redis 哨兵如何选举 Leader？</li>
<li>Redis 如何实现故障转移？</li>
</ul>
<p>【解答】</p>
<p>（1）Redis 主从复制模式无法自动故障转移，也就是说，一旦主服务器宕机，需要手动恢复。为了解决此问题，Redis 增加了哨兵模式（Sentinel）。</p>
<p>（2）由一个或多个 Sentinel 实例组成的 Sentinel 系统可以监视任意多个主服务器，以及这些主服务器的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200131135847.png" alt="img"></p>
<h3 id="Redis-集群"><a href="#Redis-集群" class="headerlink" title="Redis 集群"></a>Redis 集群</h3><p>当 Redis 数据量超出单机的极限，就需要通过分区技术来分而治之。</p>
<p>Redis 采用的分区策略是：使用虚拟哈希槽来映射节点和数据。在 Redis Cluster 中，为整个集群分配 16384 个哈希槽。每个节点都会被分配一定的哈希槽，这个过程可以是自动分配，也可以是手动分配。任何一个槽没有被分配，那么集群处于下线状态。</p>
<p>当客户端向服务端发起读写请求时，先要根据 key 计算其所属的哈希槽（计算公式：CRC16(KEY) mod 16384），然后获取该哈希槽所属的节点。这样，就完成了寻址过程。</p>
<h2 id="Redis-脑裂"><a href="#Redis-脑裂" class="headerlink" title="Redis 脑裂"></a>Redis 脑裂</h2><h3 id="什么是脑裂"><a href="#什么是脑裂" class="headerlink" title="什么是脑裂"></a>什么是脑裂</h3><p>分布式系统的脑裂问题（Split-Brain Problem）是一个严重的一致性问题，通常发生在分布式系统中的节点之间失去通信或部分通信时。这个问题的名称源自脑裂的比喻，就像一个分布式系统被分成多个部分的”脑”，每个部分独立运行，而没有协调一致的方式。</p>
<p>脑裂问题通常发生在以下情况下：</p>
<ol>
<li><strong>网络分区</strong>：当分布式系统中的网络发生问题，导致节点之间无法互相通信或只能部分通信时。这可能是由于网络故障、硬件故障、防火墙配置问题等原因引起的。</li>
<li><strong>节点故障</strong>：当分布式系统的某个节点崩溃或出现故障，但其他节点无法确定该节点的状态，可能导致脑裂问题。</li>
</ol>
<p>脑裂问题的典型情况是，在网络分区或节点故障后，分布式系统的一部分节点认为另一部分节点已经不可用，因此开始采取某种措施，比如选举新的领袖或切换到备份模式。然而，在某些情况下，网络分区可能会解除，或者节点故障可能会自行修复，导致系统中存在多个独立运行的子系统，每个子系统都认为自己是正确的。</p>
<p>这种情况下，脑裂问题可能导致以下问题：</p>
<ol>
<li><strong>数据不一致性</strong>：不同子系统可能具有不同的数据状态，这可能会导致数据不一致性和冲突。</li>
<li><strong>资源冲突</strong>：如果不同的子系统尝试访问相同的资源，可能会发生资源冲突和竞争条件。</li>
<li><strong>性能问题</strong>：系统中的资源可能被多次分配，从而浪费了资源并降低了性能。</li>
</ol>
<p>为了解决脑裂问题，分布式系统通常需要采用一些机制，如投票算法、选举协议、心跳检测等，以确保在出现网络分区或节点故障时，系统能够正确地识别和处理问题，并维护一致性。这些机制可以帮助系统中的节点协同工作，避免脑裂问题的发生。然而，脑裂问题是分布式系统设计和管理中的复杂挑战之一，需要细致的规划和测试来确保系统的可靠性和稳定性。</p>
<h3 id="Redis-中的脑裂问题是如何产生的"><a href="#Redis-中的脑裂问题是如何产生的" class="headerlink" title="Redis 中的脑裂问题是如何产生的"></a>Redis 中的脑裂问题是如何产生的</h3><p>在 Redis 主从架构中，部署方式一般是“一主多从”，主节点提供写操作，从节点提供读操作。 如果主节点的网络突然发生了问题，它与所有的从节点都失联了，但是此时的主节点和客户端的网络是正常的，这个客户端并不知道 Redis 内部已经出现了问题，还在照样的向这个失联的主节点写数据（过程 A），此时这些数据被旧主节点缓存到了缓冲区里，因为主从节点之间的网络问题，这些数据都是无法同步给从节点的。</p>
<p>这时，哨兵也发现主节点失联了，它就认为主节点挂了（但实际上主节点正常运行，只是网络出问题了），于是哨兵就会在“从节点”中选举出一个 leader 作为主节点，这时集群就有两个主节点了 —— <strong>脑裂出现了</strong>。</p>
<p>然后，网络突然好了，哨兵因为之前已经选举出一个新主节点了，它就会把旧主节点降级为从节点（A），然后从节点（A）会向新主节点请求数据同步，<strong>因为第一次同步是全量同步的方式，此时的从节点（A）会清空掉自己本地的数据，然后再做全量同步。所以，之前客户端在过程 A 写入的数据就会丢失了，也就是集群产生脑裂数据丢失的问题</strong>。</p>
<p>总结一句话就是：由于网络问题，集群节点之间失去联系。主从数据不同步；重新平衡选举，产生两个主服务。等网络恢复，旧主节点会降级为从节点，再与新主节点进行同步复制的时候，由于从节点会清空自己的缓冲区，所以导致之前客户端写入的数据丢失了。</p>
<h3 id="如何解决-Redis-中的脑裂问题"><a href="#如何解决-Redis-中的脑裂问题" class="headerlink" title="如何解决 Redis 中的脑裂问题"></a>如何解决 Redis 中的脑裂问题</h3><p>当主节点发现从节点下线或者通信超时的总数量小于阈值时，那么禁止主节点进行写数据，直接把错误返回给客户端。</p>
<p>在 Redis 的配置文件中有两个参数我们可以设置：</p>
<ul>
<li><code>min-slaves-to-write x</code>，主节点必须要有至少 x 个从节点连接，如果小于这个数，主节点会禁止写数据。</li>
<li><code>min-slaves-max-lag x</code>，主从数据复制和同步的延迟不能超过 x 秒，如果超过，主节点会禁止写数据。</li>
</ul>
<p>我们可以把 min-slaves-to-write 和 min-slaves-max-lag 这两个配置项搭配起来使用，分别给它们设置一定的阈值，假设为 N 和 T。</p>
<p>这两个配置项组合后的要求是，主库连接的从库中至少有 N 个从库，和主库进行数据复制时的 ACK 消息延迟不能超过 T 秒，否则，主库就不会再接收客户端的写请求了。</p>
<p>即使原主库是假故障，它在假故障期间也无法响应哨兵心跳，也不能和从库进行同步，自然也就无法和从库进行 ACK 确认了。这样一来，min-slaves-to-write 和 min-slaves-max-lag 的组合要求就无法得到满足，<strong>原主库就会被限制接收客户端写请求，客户端也就不能在原主库中写入新数据了</strong>。</p>
<p><strong>等到新主库上线时，就只有新主库能接收和处理客户端请求，此时，新写的数据会被直接写到新主库中。而原主库会被哨兵降为从库，即使它的数据被清空了，也不会有新数据丢失。</strong></p>
<p>再来举个例子。</p>
<p>假设我们将 min-slaves-to-write 设置为 1，把 min-slaves-max-lag 设置为 12s，把哨兵的 down-after-milliseconds 设置为 10s，主库因为某些原因卡住了 15s，导致哨兵判断主库客观下线，开始进行主从切换。</p>
<p>同时，因为原主库卡住了 15s，没有一个从库能和原主库在 12s 内进行数据复制，原主库也无法接收客户端请求了。</p>
<p>这样一来，主从切换完成后，也只有新主库能接收请求，不会发生脑裂，也就不会发生数据丢失的问题了。</p>
<h2 id="Redis-线程模型"><a href="#Redis-线程模型" class="headerlink" title="Redis 线程模型"></a>Redis 线程模型</h2><h3 id="Redis-真的只有单线程吗？"><a href="#Redis-真的只有单线程吗？" class="headerlink" title="Redis 真的只有单线程吗？"></a>Redis 真的只有单线程吗？</h3><p>Redis 并非真的只有单线程。</p>
<ul>
<li>Redis 的主要工作包括接收客户端请求、解析请求和进行数据读写等操作，是由单线程来执行的，这也是常说 Redis 是单线程程序的原因。</li>
<li>Redis 还启动了 3 个线程来执行<strong>文件关闭</strong>、<strong>AOF 同步写</strong>和<strong>惰性删除</strong>等操作。</li>
</ul>
<h3 id="Redis-单线程模式是怎样的？"><a href="#Redis-单线程模式是怎样的？" class="headerlink" title="Redis 单线程模式是怎样的？"></a>Redis 单线程模式是怎样的？</h3><p>Redis 单线程模式指的是其核心网络模型为单线程模式。这个模式为 IO 多路复用+单线程读写请求，其中，IO 多路复用使得 Redis 可以同时处理多个客户端连接。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202309241133046.png"></p>
<h3 id="Redis-采用单线程为什么还这么快？"><a href="#Redis-采用单线程为什么还这么快？" class="headerlink" title="Redis 采用单线程为什么还这么快？"></a>Redis 采用单线程为什么还这么快？</h3><blockquote>
<p>参考：[Redis 为什么快](#Redis 为什么快)</p>
</blockquote>
<h3 id="Redis-6-0-之后为什么引入了多线程？"><a href="#Redis-6-0-之后为什么引入了多线程？" class="headerlink" title="Redis 6.0 之后为什么引入了多线程？"></a>Redis 6.0 之后为什么引入了多线程？</h3><p>随着网络硬件的性能提升，Redis 的性能瓶颈有时会出现在网络 IO 的处理上，也就是说，<strong>单个主线程处理网络请求的速度跟不上底层网络硬件的速度。</strong></p>
<p>为了提高网络 I&#x2F;O 的并行度，Redis 6.0 对于网络 I&#x2F;O 采用多线程来处理。但是，对于命令的执行，Redis 仍然使用单线程来处理。</p>
<p>Redis 官方表示，<strong>Redis 6.0 版本引入的多线程 I&#x2F;O 特性对性能提升至少是一倍以上</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202309241148273.png"></p>
<h2 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h2><p>【问题】</p>
<ul>
<li>Redis 的并发竞争问题是什么？如何解决这个问题？</li>
<li>Redis 支持事务吗？</li>
<li>Redis 事务是严格意义的事务吗？Redis 为什么不支持回滚。</li>
<li>Redis 事务如何工作？</li>
<li>了解 Redis 事务中的 CAS 行为吗？</li>
</ul>
<p>【解答】</p>
<p><strong>Redis 提供的不是严格的事务，Redis 只保证串行执行命令，并且能保证全部执行，但是执行命令失败时并不会回滚，而是会继续执行下去</strong>。</p>
<p>Redis 不支持回滚的理由：</p>
<ul>
<li>Redis 命令只会因为错误的语法而失败，或是命令用在了错误类型的键上面。</li>
<li>因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。</li>
</ul>
<p><code>MULTI</code> 、 <code>EXEC</code> 、 <code>DISCARD</code> 和 <code>WATCH</code> 是 Redis 事务相关的命令。</p>
<p>Redis 有天然解决这个并发竞争问题的类 CAS 乐观锁方案：每次要<strong>写之前，先判断</strong>一下当前这个 value 的时间戳是否比缓存里的 value 的时间戳要新。如果是的话，那么可以写，否则，就不能用旧的数据覆盖新的数据。</p>
<h2 id="Redis-管道"><a href="#Redis-管道" class="headerlink" title="Redis 管道"></a>Redis 管道</h2><p>【问题】</p>
<ul>
<li>除了事务，还有其他批量执行 Redis 命令的方式吗？</li>
</ul>
<p>【解答】</p>
<p>Redis 是一种基于 C&#x2F;S 模型以及请求&#x2F;响应协议的 TCP 服务。Redis 支持管道技术。管道技术允许请求以异步方式发送，即旧请求的应答还未返回的情况下，允许发送新请求。这种方式可以大大提高传输效率。使用管道发送命令时，Redis Server 会将部分请求放到缓存队列中（占用内存），执行完毕后一次性发送结果。如果需要发送大量的命令，会占用大量的内存，因此应该按照合理数量分批次的处理。</p>
<h2 id="Redis-应用"><a href="#Redis-应用" class="headerlink" title="Redis 应用"></a>Redis 应用</h2><h3 id="缓存设计"><a href="#缓存设计" class="headerlink" title="缓存设计"></a>缓存设计</h3><p>【问题】</p>
<p>如何避免缓存雪崩、缓存击穿、缓存穿透？</p>
<p>有哪些更新缓存策略？采用那种策略比较好？</p>
<p>如何保证缓存一致性？</p>
<p>有哪些常见的内存淘汰算法</p>
<p>LRU 算法的原理是什么</p>
<p>LFU 算法的原理是什么</p>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><h3 id="大-Key-处理"><a href="#大-Key-处理" class="headerlink" title="大 Key 处理"></a>大 Key 处理</h3><h4 id="什么是大-Key"><a href="#什么是大-Key" class="headerlink" title="什么是大 Key"></a>什么是大 Key</h4><p>大 key 并不是指 key 的值很大，而是 key 对应的 value 很大。</p>
<p>一般而言，下面这两种情况被称为大 key：</p>
<ul>
<li>String 类型的值大于 10 KB；</li>
<li>Hash、List、Set、ZSet 类型的元素的个数超过 5000 个；</li>
</ul>
<h4 id="大-Key-的影响"><a href="#大-Key-的影响" class="headerlink" title="大 Key 的影响"></a>大 Key 的影响</h4><p>大 key 会带来以下四种影响：</p>
<ul>
<li><strong>客户端超时阻塞</strong>。由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。</li>
<li><strong>引发网络阻塞</strong>。每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。</li>
<li><strong>阻塞工作线程</strong>。如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。</li>
<li><strong>内存分布不均</strong>。集群模型在 slot 分片均匀情况下，会出现数据和查询倾斜情况，部分有大 key 的 Redis 节点占用内存多，QPS 也会比较大。</li>
</ul>
<h4 id="如何找到大-Key"><a href="#如何找到大-Key" class="headerlink" title="如何找到大 Key"></a>如何找到大 Key</h4><p><strong><em>1、redis-cli –bigkeys 查找大 key</em></strong></p>
<p>可以通过 redis-cli –bigkeys 命令查找大 key：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p6379 -a &quot;password&quot; -- bigkeys</span><br></pre></td></tr></table></figure>

<p>使用的时候注意事项：</p>
<ul>
<li>最好选择在从节点上执行该命令。因为主节点上执行时，会阻塞主节点；</li>
<li>如果没有从节点，那么可以选择在 Redis 实例业务压力的低峰阶段进行扫描查询，以免影响到实例的正常运行；或者可以使用 -i 参数控制扫描间隔，避免长时间扫描降低 Redis 实例的性能。</li>
</ul>
<p>该方式的不足之处：</p>
<ul>
<li>这个方法只能返回每种类型中最大的那个 bigkey，无法得到大小排在前 N 位的 bigkey；</li>
<li>对于集合类型来说，这个方法只统计集合元素个数的多少，而不是实际占用的内存量。但是，一个集合中的元素个数多，并不一定占用的内存就多。因为，有可能每个元素占用的内存很小，这样的话，即使元素个数有很多，总内存开销也不大；</li>
</ul>
<p><strong><em>2、使用 SCAN 命令查找大 key</em></strong></p>
<p>使用 SCAN 命令对数据库扫描，然后用 TYPE 命令获取返回的每一个 key 的类型。</p>
<p>对于 String 类型，可以直接使用 STRLEN 命令获取字符串的长度，也就是占用的内存空间字节数。</p>
<p>对于集合类型来说，有两种方法可以获得它占用的内存大小：</p>
<ul>
<li>如果能够预先从业务层知道集合元素的平均大小，那么，可以使用下面的命令获取集合元素的个数，然后乘以集合元素的平均大小，这样就能获得集合占用的内存大小了。List 类型：<code>LLEN</code> 命令；Hash 类型：<code>HLEN</code> 命令；Set 类型：<code>SCARD</code> 命令；Sorted Set 类型：<code>ZCARD</code> 命令；</li>
<li>如果不能提前知道写入集合的元素大小，可以使用 <code>MEMORY USAGE</code> 命令（需要 Redis 4.0 及以上版本），查询一个键值对占用的内存空间。</li>
</ul>
<p><strong><em>3、使用 RdbTools 工具查找大 key</em></strong></p>
<p>使用 RdbTools 第三方开源工具，可以用来解析 Redis 快照（RDB）文件，找到其中的大 key。</p>
<p>比如，下面这条命令，将大于 10 kb 的 key 输出到一个表格文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rdb dump.rdb -c memory --bytes 10240 -f redis.csv</span><br></pre></td></tr></table></figure>

<h4 id="如何删除大-Key"><a href="#如何删除大-Key" class="headerlink" title="如何删除大 Key"></a>如何删除大 Key</h4><p>如果大 Key 过大，删除时间过长，会阻塞 Redis 主线程，导致主线程无法及时响应其他请求。因此，删除大 Key 时需要考虑分批、异步处理。</p>
<p><strong><em>1、分批次删除</em></strong></p>
<p>对于<strong>删除大 Hash</strong>，使用 <code>hscan</code> 命令，每次获取 100 个字段，再用 <code>hdel</code> 命令，每次删除 1 个字段。</p>
<p>Python 代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">del_large_hash</span>():</span><br><span class="line">  r = redis.StrictRedis(host=<span class="string">&#x27;redis-host1&#x27;</span>, port=<span class="number">6379</span>)</span><br><span class="line">    large_hash_key =<span class="string">&quot;xxx&quot;</span> <span class="comment">#要删除的大hash键名</span></span><br><span class="line">    cursor = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> cursor != <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 使用 hscan 命令，每次获取 100 个字段</span></span><br><span class="line">        cursor, data = r.hscan(large_hash_key, cursor=cursor, count=<span class="number">100</span>)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> data.items():</span><br><span class="line">                <span class="comment"># 再用 hdel 命令，每次删除1个字段</span></span><br><span class="line">                r.hdel(large_hash_key, item[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<p>对于<strong>删除大 List</strong>，通过 <code>ltrim</code> 命令，每次删除少量元素。</p>
<p>Python 代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">del_large_list</span>():</span><br><span class="line">  r = redis.StrictRedis(host=<span class="string">&#x27;redis-host1&#x27;</span>, port=<span class="number">6379</span>)</span><br><span class="line">  large_list_key = <span class="string">&#x27;xxx&#x27;</span>  <span class="comment">#要删除的大list的键名</span></span><br><span class="line">  <span class="keyword">while</span> r.llen(large_list_key)&gt;<span class="number">0</span>:</span><br><span class="line">      <span class="comment">#每次只删除最右100个元素</span></span><br><span class="line">      r.ltrim(large_list_key, <span class="number">0</span>, -<span class="number">101</span>)</span><br></pre></td></tr></table></figure>

<p>对于<strong>删除大 Set</strong>，使用 <code>sscan</code> 命令，每次扫描集合中 100 个元素，再用 <code>srem</code> 命令每次删除一个键。</p>
<p>Python 代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">del_large_set</span>():</span><br><span class="line">  r = redis.StrictRedis(host=<span class="string">&#x27;redis-host1&#x27;</span>, port=<span class="number">6379</span>)</span><br><span class="line">  large_set_key = <span class="string">&#x27;xxx&#x27;</span>   <span class="comment"># 要删除的大set的键名</span></span><br><span class="line">  cursor = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">  <span class="keyword">while</span> cursor != <span class="number">0</span>:</span><br><span class="line">    <span class="comment"># 使用 sscan 命令，每次扫描集合中 100 个元素</span></span><br><span class="line">    cursor, data = r.sscan(large_set_key, cursor=cursor, count=<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> data:</span><br><span class="line">      <span class="comment"># 再用 srem 命令每次删除一个键</span></span><br><span class="line">      r.srem(large_size_key, item)</span><br></pre></td></tr></table></figure>

<p>对于<strong>删除大 ZSet</strong>，使用 <code>zremrangebyrank</code> 命令，每次删除 top 100 个元素。</p>
<p>Python 代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">del_large_sortedset</span>():</span><br><span class="line">  r = redis.StrictRedis(host=<span class="string">&#x27;large_sortedset_key&#x27;</span>, port=<span class="number">6379</span>)</span><br><span class="line">  large_sortedset_key=<span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">  <span class="keyword">while</span> r.zcard(large_sortedset_key)&gt;<span class="number">0</span>:</span><br><span class="line">    <span class="comment"># 使用 zremrangebyrank 命令，每次删除 top 100个元素</span></span><br><span class="line">    r.zremrangebyrank(large_sortedset_key,<span class="number">0</span>,<span class="number">99</span>)</span><br></pre></td></tr></table></figure>

<p><strong><em>2、异步删除</em></strong></p>
<p>从 Redis 4.0 版本开始，可以采用<strong>异步删除</strong>法，<strong>用 unlink 命令代替 del 来删除</strong>。</p>
<p>这样 Redis 会将这个 key 放入到一个异步线程中进行删除，这样不会阻塞主线程。</p>
<p>除了主动调用 unlink 命令实现异步删除之外，我们还可以通过配置参数，达到某些条件的时候自动进行异步删除。</p>
<p>主要有 4 种场景，默认都是关闭的：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lazyfree-lazy-eviction no</span><br><span class="line">lazyfree-lazy-expire no</span><br><span class="line">lazyfree-lazy-server-del</span><br><span class="line">noslave-lazy-flush no</span><br></pre></td></tr></table></figure>

<p>它们代表的含义如下：</p>
<ul>
<li>lazyfree-lazy-eviction：表示当 Redis 运行内存超过 maxmeory 时，是否开启 lazy free 机制删除；</li>
<li>lazyfree-lazy-expire：表示设置了过期时间的键值，当过期之后是否开启 lazy free 机制删除；</li>
<li>lazyfree-lazy-server-del：有些指令在处理已存在的键时，会带有一个隐式的 del 键的操作，比如 rename 命令，当目标键已存在，Redis 会先删除目标键，如果这些目标键是一个 big key，就会造成阻塞删除的问题，此配置表示在这种场景中是否开启 lazy free 机制删除；</li>
<li>slave-lazy-flush：针对 slave (从节点) 进行全量数据同步，slave 在加载 master 的 RDB 文件前，会运行 flushall 来清理自己的数据，它表示此时是否开启 lazy free 机制删除。</li>
</ul>
<p>建议开启其中的 lazyfree-lazy-eviction、lazyfree-lazy-expire、lazyfree-lazy-server-del 等配置，这样就可以有效的提高主线程的执行效率。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5ad6e4066fb9a028d82c4b66">面试中关于 Redis 的问题看这篇就够了</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/doocs/advanced-java#%E7%BC%93%E5%AD%98">advanced-java</a></li>
<li><a target="_blank" rel="noopener" href="https://xiaolincoding.com/redis/base/redis_interview.html">Redis 常见面试题</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/5fe0f3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/5fe0f3/" class="post-title-link" itemprop="url">Mysql 存储引擎</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-07-13 10:08:37" itemprop="dateCreated datePublished" datetime="2020-07-13T10:08:37+08:00">2020-07-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库``</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">关系型数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/" itemprop="url" rel="index"><span itemprop="name">Mysql</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Mysql-存储引擎"><a href="#Mysql-存储引擎" class="headerlink" title="Mysql 存储引擎"></a>Mysql 存储引擎</h1><p>在文件系统中，Mysql 将每个数据库（也可以成为 schema）保存为数据目录下的一个子目录。创建表示，Mysql 会在数据库子目录下创建一个和表同名的 <code>.frm</code> 文件保存表的定义。因为 Mysql 使用文件系统的目录和文件来保存数据库和表的定义，大小写敏感性和具体平台密切相关。Windows 中大小写不敏感；类 Unix 中大小写敏感。<strong>不同的存储引擎保存数据和索引的方式是不同的，但表的定义则是在 Mysql 服务层统一处理的。</strong></p>
<p>MySQL 的存储引擎采用了插件的形式，每个存储引擎都面向一种特定的数据库应用环境。同时开源的 MySQL 还允许开发人员设置自己的存储引擎，下面是一些常见的存储引擎：</p>
<ul>
<li>InnoDB 存储引擎：它是 MySQL 5.5 版本之后默认的存储引擎，最大的特点是支持事务、行级锁定、外键约束等。</li>
<li>MyISAM 存储引擎：在 MySQL 5.5 版本之前是默认的存储引擎，不支持事务，也不支持外键，最大的特点是速度快，占用资源少。</li>
<li>Memory 存储引擎：使用系统内存作为存储介质，以便得到更快的响应速度。不过如果 mysqld 进程崩溃，则会导致所有的数据丢失，因此我们只有当数据是临时的情况下才使用 Memory 存储引擎。</li>
<li>NDB 存储引擎：也叫做 NDB Cluster 存储引擎，主要用于 MySQL Cluster 分布式集群环境，类似于 Oracle 的 RAC 集群。</li>
<li>Archive 存储引擎：它有很好的压缩机制，用于文件归档，在请求写入时会进行压缩，所以也经常用来做仓库。</li>
</ul>
<h2 id="存储引擎相关操作"><a href="#存储引擎相关操作" class="headerlink" title="存储引擎相关操作"></a>存储引擎相关操作</h2><h3 id="查看存储引擎命令"><a href="#查看存储引擎命令" class="headerlink" title="查看存储引擎命令"></a>查看存储引擎命令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 查看支持的存储引擎</span><br><span class="line"><span class="keyword">SHOW</span> ENGINES;</span><br><span class="line"></span><br><span class="line"># 查看默认的存储引擎</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;storage_engine&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 查看某表所使用的存储引擎</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `table_name`;</span><br><span class="line"></span><br><span class="line"># 查看某数据库中的某表所使用的存储引擎</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLE</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;table_name&#x27;</span>;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLE</span> STATUS <span class="keyword">FROM</span> `database_name` <span class="keyword">WHERE</span> `name` <span class="operator">=</span> &quot;table_name&quot;;</span><br></pre></td></tr></table></figure>

<h3 id="设置存储引擎命令"><a href="#设置存储引擎命令" class="headerlink" title="设置存储引擎命令"></a>设置存储引擎命令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 建表时指定存储引擎，如果不显示指定，默认是 INNODB</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (i <span class="type">INT</span>) ENGINE <span class="operator">=</span> INNODB;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t2 (i <span class="type">INT</span>) ENGINE <span class="operator">=</span> CSV;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t3 (i <span class="type">INT</span>) ENGINE <span class="operator">=</span> MEMORY;</span><br><span class="line"></span><br><span class="line"># 修改存储引擎</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t ENGINE <span class="operator">=</span> InnoDB;</span><br><span class="line"></span><br><span class="line"># 修改默认存储引擎，也可以在配置文件 my.cnf 中修改默认引擎</span><br><span class="line"><span class="keyword">SET</span> default_storage_engine<span class="operator">=</span>NDBCLUSTER;</span><br></pre></td></tr></table></figure>

<p>默认情况下，每当 <code>CREATE TABLE</code> 或 <code>ALTER TABLE</code> 不能使用默认存储引擎时，都会生成一个警告。为了防止在所需的引擎不可用时出现令人困惑的意外行为，可以启用 <code>NO_ENGINE_SUBSTITUTION SQL</code> 模式。如果所需的引擎不可用，则此设置将产生错误而不是警告，并且不会创建或更改表</p>
<h2 id="Mysql-存储引擎简介"><a href="#Mysql-存储引擎简介" class="headerlink" title="Mysql 存储引擎简介"></a>Mysql 存储引擎简介</h2><h3 id="Mysql-内置的存储引擎"><a href="#Mysql-内置的存储引擎" class="headerlink" title="Mysql 内置的存储引擎"></a>Mysql 内置的存储引擎</h3><ul>
<li><strong>InnoDB</strong> - InnoDB 是 MySQL 5.5 版本以后的默认存储引擎。并且提供了行级锁和外键的约束。性能不错且支持自动崩溃恢复。</li>
<li><strong>MyISAM</strong> - MyISAM 是 MySQL 5.5 版本以后的默认存储引擎。特性丰富但不支持事务，也不支持行级锁和外键，也没有崩溃恢复功能。</li>
<li><strong>CSV</strong> - 可以将 CSV 文件作为 Mysql 的表来处理，但这种表不支持索引。</li>
<li><strong>Memory</strong> - 数据存储在内存，以便得到更快的响应速度。不过如果 mysqld 进程崩溃，则会导致所有的数据丢失。</li>
<li><strong>NDB</strong> - 也叫做 NDB Cluster 存储引擎，主要用于 MySQL Cluster 分布式集群环境，类似于 Oracle 的 RAC 集群。</li>
<li><strong>Archieve</strong> - Archieve 存储引擎非常适合用于归档数据。<ul>
<li>Archieve 存储引擎只支持 <code>INSERT</code> 和 <code>SELECT</code> 操作。</li>
<li>Archieve 存储引擎采用 zlib 算法压缩数据，压缩比可达到 1: 10。</li>
</ul>
</li>
</ul>
<h3 id="如何选择合适的存储引擎"><a href="#如何选择合适的存储引擎" class="headerlink" title="如何选择合适的存储引擎"></a>如何选择合适的存储引擎</h3><p>大多数情况下，InnoDB 都是正确的选择，除非需要用到 InnoDB 不具备的特性。</p>
<p>如果应用需要选择 InnoDB 以外的存储引擎，可以考虑以下因素：</p>
<ul>
<li>事务：如果业务场景是 OLTP，则 InnoDB 是首选存储引擎。如果不需要支持事务，且主要是 SELECT 和 INSERT 操作，MyISAM 是不错的选择。所以，如果 Mysql 部署方式为主备模式，并进行读写分离。那么可以这么做：主节点只支持写操作，默认引擎为 InnoDB；备节点只支持读操作，默认引擎为 MyISAM。</li>
<li>并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。所以，InnoDB 并发性能更高。</li>
<li>外键：InnoDB 支持外键。</li>
<li>备份：InnoDB 支持在线热备份。</li>
<li>崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</li>
<li>其它特性：MyISAM 支持压缩表和空间数据索引。</li>
</ul>
<h2 id="InnoDB-简介"><a href="#InnoDB-简介" class="headerlink" title="InnoDB 简介"></a>InnoDB 简介</h2><p>InnoDB 是 MySQL 5.5 版本以后的默认存储引擎。只有在需要 InnoDB 不支持的特性时，才考虑使用其它存储引擎。</p>
<p>InnoDB 也使用 B+Tree 作为索引结构，但具体实现方式却与 MyISAM 截然不同。MyISAM 索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而<strong>在 InnoDB 中，表数据文件本身就是按 B+Tree 组织的一个索引结构</strong>，这棵树的叶节点 data 域保存了完整的数据记录。这个<strong>索引的 key 是数据表的主键</strong>，因此<strong>InnoDB 表数据文件本身就是主索引</strong>。</p>
<p>InnoDB 采用 MVCC 来支持高并发，并且实现了四个标准的隔离级别。其默认级别是可重复读（REPEATABLE READ），并且通过间隙锁（next-key locking）防止幻读。</p>
<p>InnoDB 是基于聚簇索引建立的，与其他存储引擎有很大不同。在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</p>
<p>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。</p>
<p>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</p>
<p>InnoDB 物理文件结构为：</p>
<ul>
<li><p><code>.frm</code> 文件：与表相关的元数据信息都存放在 frm 文件，包括表结构的定义信息等。</p>
</li>
<li><p><code>.ibd</code> 文件或 <code>.ibdata</code> 文件： 这两种文件都是存放 InnoDB 数据的文件，之所以有两种文件形式存放 InnoDB 的数据，是因为 InnoDB 的数据存储方式能够通过配置来决定是使用<strong>共享表空间</strong>存放存储数据，还是用<strong>独享表空间</strong>存放存储数据。</p>
<p>独享表空间存储方式使用<code>.ibd</code>文件，并且每个表一个<code>.ibd</code>文件 共享表空间存储方式使用<code>.ibdata</code>文件，所有表共同使用一个<code>.ibdata</code>文件（或多个，可自己配置）</p>
</li>
</ul>
<h2 id="InnoDB-存储架构"><a href="#InnoDB-存储架构" class="headerlink" title="InnoDB 存储架构"></a>InnoDB 存储架构</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202311070640589.png"></p>
<p>InnoDB 存储架构分为内存结构和磁盘结构。</p>
<p>InnoDB 内存结构的核心组件有：</p>
<ul>
<li>Buffer Pool</li>
<li>Change Buffer</li>
<li>Adaptive Hash Index</li>
<li>Log Buffer</li>
</ul>
<p>InnoDB 磁盘结构的核心组件有：</p>
<ul>
<li>Tablespace</li>
<li>Doublewrite Buffer</li>
<li>redo log</li>
<li>undo log</li>
</ul>
<h2 id="InnoDB-表空间"><a href="#InnoDB-表空间" class="headerlink" title="InnoDB 表空间"></a>InnoDB 表空间</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202311070708733.png"></p>
<h3 id="行（row）"><a href="#行（row）" class="headerlink" title="行（row）"></a>行（row）</h3><p>数据库表中的记录都是按行（row）进行存放的，每行记录根据不同的行格式，有不同的存储结构。</p>
<p>后面我们详细介绍 InnoDB 存储引擎的行格式，也是本文重点介绍的内容。</p>
<h3 id="页（page）"><a href="#页（page）" class="headerlink" title="页（page）"></a>页（page）</h3><p>记录是按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I&#x2F;O 操作）只能处理一行数据，效率会非常低。</p>
<p>因此，<strong>InnoDB 的数据是按「页」为单位来读写的</strong>，也就是说，当需要读一条记录的时候，并不是将这个行记录从磁盘读出来，而是以页为单位，将其整体读入内存。</p>
<p><strong>默认每个页的大小为 16KB</strong>，也就是最多能保证 16KB 的连续存储空间。</p>
<p>页是 InnoDB 存储引擎磁盘管理的最小单元，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。</p>
<p>页的类型有很多，常见的有数据页、undo 日志页、溢出页等等。数据表中的行记录是用「数据页」来管理的，数据页的结构这里我就不讲细说了，之前文章有说过，感兴趣的可以去看这篇文章：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/index/page.html">换一个角度看 B+ 树(opens new window)</a></p>
<p>总之知道表中的记录存储在「数据页」里面就行。</p>
<h3 id="区（extent）"><a href="#区（extent）" class="headerlink" title="区（extent）"></a>区（extent）</h3><p>我们知道 InnoDB 存储引擎是用 B+ 树来组织数据的。</p>
<p>B+ 树中每一层都是通过双向链表连接起来的，如果是以页为单位来分配存储空间，那么链表中相邻的两个页之间的物理位置并不是连续的，可能离得非常远，那么磁盘查询时就会有大量的随机 I&#x2F;O，随机 I&#x2F;O 是非常慢的。</p>
<p>解决这个问题也很简单，就是让链表中相邻的页的物理位置也相邻，这样就可以使用顺序 I&#x2F;O 了，那么在范围查询（扫描叶子节点）的时候性能就会很高。</p>
<p>那具体怎么解决呢？</p>
<p><strong>在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I&#x2F;O 了</strong>。</p>
<h3 id="段（segment）"><a href="#段（segment）" class="headerlink" title="段（segment）"></a>段（segment）</h3><p>表空间是由各个段（segment）组成的，段是由多个区（extent）组成的。段一般分为数据段、索引段和回滚段等。</p>
<ul>
<li>索引段：存放 B + 树的非叶子节点的区的集合；</li>
<li>数据段：存放 B + 树的叶子节点的区的集合；</li>
<li>回滚段：存放的是回滚数据的区的集合。</li>
</ul>
<p>好了，终于说完表空间的结构了。接下来，就具体讲一下 InnoDB 的行格式了。</p>
<p>之所以要绕一大圈才讲行记录的格式，主要是想让大家知道行记录是存储在哪个文件，以及行记录在这个表空间文件中的哪个区域，有一个从上往下切入的视角，这样理解起来不会觉得很抽象。</p>
<h2 id="InnoDB-内存结构"><a href="#InnoDB-内存结构" class="headerlink" title="InnoDB 内存结构"></a>InnoDB 内存结构</h2><h3 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202311070641009.png"></p>
<p>Buffer Pool 用于加速数据的访问和修改，通过将热点数据缓存在内存的方法，最大限度地减少磁盘 IO，加速热点数据的读和写。</p>
<p>Buffer Pool 中数据<strong>以页为存储单位</strong>，其实现数据结构是<strong>以页为单位的单链表</strong>。</p>
<p>由于内存的空间限制，Buffer Pool 仅能容纳最热点的数据。Buffer Pool 使用最近最少使用算法（Least Recent Used，LRU）算法淘汰非热点数据页。</p>
<p>依据时间局部性原理与空间局部性原理，Buffer Pool 在存储当前活动数据页的时候，会以预读 Read-ahead 的方式缓存目标数据页临近的数据页。</p>
<p>预读机制带来预读失败的问题，InnoDB <strong>采用分代机制解决预读失败问题</strong>：将 Buffer Pool 分为 New SubList 和 Old SubList 两部分，将最新读取的数据页置于 Old SubList 头部，Old SubList 中的数据再次被访问到才会置于 New SubList 头部；预读失败的冷数据将更快地从 Old SubList 中淘汰，而不会影响到 New SubList 中原有的热数据。</p>
<p>预读失败问题可以引申到缓冲池污染问题，InnoDB <strong>采用时间窗口（Time Window）机制解决缓冲池污染问题</strong>：对于 Old SubList 中的数据页，必须在 Old SubList 中停留到达指定时间之后再次被访问到，才能转移到 New SubList 中，默认窗口大小是 1s。</p>
<p>对于 Buffer Pool 中数据的查询，InnoDB 直接读取返回；对于 Buffer Pool 中数据的修改，InnoDB 直接在 Buffer Pool 中修改，并将修改写入 redo Log 中，当数据页被 LRU 算法淘汰时写入磁盘，若持久化前系统崩溃，则在重启后使用 redo Log 进行恢复。</p>
<h3 id="Change-Buffer"><a href="#Change-Buffer" class="headerlink" title="Change Buffer"></a>Change Buffer</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202311070641668.png"></p>
<p>Change Buffer 用于加速非热点数据中二级索引的写入操作。由于二级索引数据的不连续性，导致修改二级索引时需要进行频繁的磁盘 IO 消耗大量性能，Change Buffer 缓冲对二级索引的修改操作，同时将写操作录入 redo log 中，在缓冲到一定量或系统较空闲时进行 <code>ibuf merge</code> 操作将修改写入磁盘中。Change Buffer 在系统表空间中有相应的持久化区域。</p>
<p>Change Buffer 大小默认占 Buffer Pool 的 25%，在引擎启动时便初始化完成。其物理结构为一棵名为 <code>ibuf</code> 的 B Tree。Change Buffer 的使用条件为：</p>
<ul>
<li>InnoDB 开启 <code>innodb_change_buffering</code>，且该表当前没有 <code>flush</code> 操作。</li>
<li>仅对二级索引树的叶子节点进行修改，且该索引页不在 Buffer Pool 中。</li>
<li>对于 Unique 二级索引，仅删除操作可以缓冲。</li>
</ul>
<p>其 <code>ibuf merge</code> 时机为：</p>
<ul>
<li>用户使用该二级索引进行查询时。</li>
<li>缓存插入操作时，预估到 page 空间不足可能导致索引页分裂时。</li>
<li>本次缓存操作将导致 ibuf btree 页分裂，且分类后 Change Buffer 大小将超出限制时。</li>
<li>master 线程发起 <code>merge</code> 命令时。</li>
<li>用户对该表进行 <code>flush</code> 操作时。</li>
</ul>
<h3 id="Adaptive-Hash-Index"><a href="#Adaptive-Hash-Index" class="headerlink" title="Adaptive Hash Index"></a>Adaptive Hash Index</h3><p>自适应哈希索引（Adaptive Hash Index）用于实现对于热数据页的一次查询。使用聚簇索引进行数据页定位的时候需要根据索引树的高度从根节点走到叶子节点，通常需要 3 到 4 次查询才能定位数据。InnoDB 根据对索引使用情况的分析和索引字段的分析，通过自调优 Self-tuning 的方式为索引页建立或者删除哈希索引。</p>
<p>AHI 所作用的目标是频繁查询的数据页和索引页，而由于数据页是聚簇索引的一部分，因此 AHI 是建立在索引之上的索引，<strong>对于二级索引，若命中 AHI，则将直接从 AHI 获取二级索引页的记录指针，再根据主键沿着聚簇索引查找数据；若聚簇索引查询同样命中 AHI，则直接返回目标数据页的记录指针，此时就可以根据记录指针直接定位数据页</strong>。</p>
<p>AHI 的大小为 Buffer Pool 的 1&#x2F;64，再 MySql 5.7 之后支持分区，以减少对于全局 AHI 锁的竞争，默认分区数为 8。</p>
<h3 id="Log-Buffer"><a href="#Log-Buffer" class="headerlink" title="Log Buffer"></a>Log Buffer</h3><p>Log Buffer 是用于缓冲待写入磁盘日志文件的数据。InnoDB 的所有修改操作都会被写入 redo log、undo log 等日志文件，如果每次都直接写入磁盘，会引发大量 IO。Log Buffer 正是针对此进行了优化：先将修改操作缓冲于此内存区域，然后定期批量 刷新到磁盘。</p>
<p>日志缓冲区大小可以由配置 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_log_buffer_size"><code>innodb_log_buffer_size</code></a> 控制，默认大小为 16MB。</p>
<h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><p>MyISAM 是 MySQL 5.5 版本以前的默认存储引擎。</p>
<p>MyISAM 设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用 MyISAM。</p>
<p>MyISAM 引擎使用 B+Tree 作为索引结构，<strong>叶节点的 data 域存放的是数据记录的地址</strong>。</p>
<p>MyISAM 提供了大量的特性，包括：全文索引、压缩表、空间函数等。但是，MyISAM 不支持事务和行级锁。并且 MyISAM 不支持崩溃后的安全恢复。</p>
<p>MyISAM 物理文件结构为：</p>
<ul>
<li><code>.frm</code>文件：与表相关的元数据信息都存放在 frm 文件，包括表结构的定义信息等。</li>
<li><code>.MYD</code> (<code>MYData</code>) 文件：MyISAM 存储引擎专用，用于存储 MyISAM 表的数据。</li>
<li><code>.MYI</code> (<code>MYIndex</code>)文件：MyISAM 存储引擎专用，用于存储 MyISAM 表的索引相关信息。</li>
</ul>
<h2 id="InnoDB-vs-MyISAM"><a href="#InnoDB-vs-MyISAM" class="headerlink" title="InnoDB vs. MyISAM"></a>InnoDB vs. MyISAM</h2><p>InnoDB 和 MyISAM 的对比：</p>
<table>
<thead>
<tr>
<th>对比项</th>
<th>MyISAM</th>
<th>InnoDB</th>
</tr>
</thead>
<tbody><tr>
<td>主外键</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>事务</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>锁</td>
<td>支持表级锁</td>
<td>支持表级锁、行级锁</td>
</tr>
<tr>
<td>索引</td>
<td>采用非聚簇索引</td>
<td>主键采用聚簇索引，以提高 IO 效率</td>
</tr>
<tr>
<td>表空间</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>关注点</td>
<td>性能</td>
<td>事务</td>
</tr>
<tr>
<td>计数器</td>
<td>维护了计数器，<code>SELECT COUNT(*)</code> 效率为 <code>O(1)</code></td>
<td>没有维护计数器，需要全表扫描</td>
</tr>
</tbody></table>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/23008813/">《高性能 MySQL》</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/139">MySQL 实战 45 讲</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/e25d81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/e25d81/" class="post-title-link" itemprop="url">Java IO 工具类</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-30 21:34:59" itemprop="dateCreated datePublished" datetime="2020-06-30T21:34:59+08:00">2020-06-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JavaSE/IO/" itemprop="url" rel="index"><span itemprop="name">IO</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java-IO-工具类"><a href="#Java-IO-工具类" class="headerlink" title="Java IO 工具类"></a>Java IO 工具类</h1><blockquote>
<p><strong><em>关键词：<code>File</code>、<code>RandomAccessFile</code>、<code>System</code>、<code>Scanner</code></em></strong></p>
<p>本文介绍 Java IO 的一些常见工具类的用法和特性。</p>
</blockquote>
<h2 id="File"><a href="#File" class="headerlink" title="File"></a>File</h2><p><code>File</code> 类是 <code>java.io</code> 包中唯一对文件本身进行操作的类。它可以对文件、目录进行增删查操作。</p>
<h3 id="createNewFille"><a href="#createNewFille" class="headerlink" title="createNewFille"></a>createNewFille</h3><p><strong>可以使用 <code>createNewFille()</code> 方法创建一个新文件</strong>。</p>
<p>注：</p>
<p>Windows 中使用反斜杠表示目录的分隔符 <code>\</code>。~~~~~~~~</p>
<p>Linux 中使用正斜杠表示目录的分隔符 <code>/</code>。</p>
<p>最好的做法是使用 <code>File.separator</code> 静态常量，可以根据所在操作系统选取对应的分隔符。</p>
<p>【示例】创建文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filename);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> f.createNewFile();</span><br></pre></td></tr></table></figure>

<h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><p><strong>可以使用 <code>mkdir()</code> 来创建文件夹</strong>，但是如果要创建的目录的父路径不存在，则无法创建成功。</p>
<p>如果要解决这个问题，可以使用 <code>mkdirs()</code>，当父路径不存在时，会连同上级目录都一并创建。</p>
<p>【示例】创建目录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filename);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> f.mkdir();</span><br></pre></td></tr></table></figure>

<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p><strong>可以使用 <code>delete()</code> 来删除文件或目录</strong>。</p>
<p>需要注意的是，如果删除的是目录，且目录不为空，直接用 <code>delete()</code> 删除会失败。</p>
<p>【示例】删除文件或目录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filename);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> f.delete();</span><br></pre></td></tr></table></figure>

<h3 id="list-和-listFiles"><a href="#list-和-listFiles" class="headerlink" title="list 和 listFiles"></a>list 和 listFiles</h3><p><code>File</code> 中给出了两种列出文件夹内容的方法：</p>
<ul>
<li><strong><code>list()</code>: 列出全部名称，返回一个字符串数组</strong>。</li>
<li><strong><code>listFiles()</code>: 列出完整的路径，返回一个 <code>File</code> 对象数组</strong>。</li>
</ul>
<p><code>list()</code> 示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filename);</span><br><span class="line">String str[] = f.list();</span><br></pre></td></tr></table></figure>

<p><code>listFiles()</code> 示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filename);</span><br><span class="line">File files[] = f.listFiles();</span><br></pre></td></tr></table></figure>

<h2 id="RandomAccessFile"><a href="#RandomAccessFile" class="headerlink" title="RandomAccessFile"></a>RandomAccessFile</h2><blockquote>
<p>注：<code>RandomAccessFile</code> 类虽然可以实现对文件内容的读写操作，但是比较复杂。所以一般操作文件内容往往会使用字节流或字符流方式。</p>
</blockquote>
<p><code>RandomAccessFile</code> 类是随机读取类，它是一个完全独立的类。</p>
<p>它适用于由大小已知的记录组成的文件，所以我们可以使用 <code>seek()</code> 将记录从一处转移到另一处，然后读取或者修改记录。</p>
<p>文件中记录的大小不一定都相同，只要能够确定哪些记录有多大以及它们在文件中的位置即可。</p>
<h3 id="RandomAccessFile-写操作"><a href="#RandomAccessFile-写操作" class="headerlink" title="RandomAccessFile 写操作"></a>RandomAccessFile 写操作</h3><p>当用 <code>rw</code> 方式声明 <code>RandomAccessFile</code> 对象时，如果要写入的文件不存在，系统将自行创建。</p>
<p><code>r</code> 为只读；<code>w</code> 为只写；<code>rw</code> 为读写。</p>
<p>【示例】文件随机读写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomAccessFileDemo01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:&quot;</span> + File.separator + <span class="string">&quot;test.txt&quot;</span>); <span class="comment">// 指定要操作的文件</span></span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">rdf</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 声明RandomAccessFile类的对象</span></span><br><span class="line">        rdf = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(f, <span class="string">&quot;rw&quot;</span>);<span class="comment">// 读写模式，如果文件不存在，会自动创建</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        name = <span class="string">&quot;zhangsan&quot;</span>; <span class="comment">// 字符串长度为8</span></span><br><span class="line">        age = <span class="number">30</span>; <span class="comment">// 数字的长度为4</span></span><br><span class="line">        rdf.writeBytes(name); <span class="comment">// 将姓名写入文件之中</span></span><br><span class="line">        rdf.writeInt(age); <span class="comment">// 将年龄写入文件之中</span></span><br><span class="line">        name = <span class="string">&quot;lisi    &quot;</span>; <span class="comment">// 字符串长度为8</span></span><br><span class="line">        age = <span class="number">31</span>; <span class="comment">// 数字的长度为4</span></span><br><span class="line">        rdf.writeBytes(name); <span class="comment">// 将姓名写入文件之中</span></span><br><span class="line">        rdf.writeInt(age); <span class="comment">// 将年龄写入文件之中</span></span><br><span class="line">        name = <span class="string">&quot;wangwu  &quot;</span>; <span class="comment">// 字符串长度为8</span></span><br><span class="line">        age = <span class="number">32</span>; <span class="comment">// 数字的长度为4</span></span><br><span class="line">        rdf.writeBytes(name); <span class="comment">// 将姓名写入文件之中</span></span><br><span class="line">        rdf.writeInt(age); <span class="comment">// 将年龄写入文件之中</span></span><br><span class="line">        rdf.close(); <span class="comment">// 关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RandomAccessFile-读操作"><a href="#RandomAccessFile-读操作" class="headerlink" title="RandomAccessFile 读操作"></a>RandomAccessFile 读操作</h3><p>读取是直接使用 <code>r</code> 的模式即可，以只读的方式打开文件。</p>
<p>读取时所有的字符串只能按照 byte 数组方式读取出来，而且长度必须和写入时的固定大小相匹配。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomAccessFileDemo02</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:&quot;</span> + File.separator + <span class="string">&quot;test.txt&quot;</span>);    <span class="comment">// 指定要操作的文件</span></span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">rdf</span> <span class="operator">=</span> <span class="literal">null</span>;        <span class="comment">// 声明RandomAccessFile类的对象</span></span><br><span class="line">        rdf = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(f, <span class="string">&quot;r&quot;</span>);<span class="comment">// 以只读的方式打开文件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">byte</span> b[] = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>];    <span class="comment">// 开辟byte数组</span></span><br><span class="line">        <span class="comment">// 读取第二个人的信息，意味着要空出第一个人的信息</span></span><br><span class="line">        rdf.skipBytes(<span class="number">12</span>);        <span class="comment">// 跳过第一个人的信息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">            b[i] = rdf.readByte();    <span class="comment">// 读取一个字节</span></span><br><span class="line">        &#125;</span><br><span class="line">        name = <span class="keyword">new</span> <span class="title class_">String</span>(b);    <span class="comment">// 将读取出来的byte数组变为字符串</span></span><br><span class="line">        age = rdf.readInt();    <span class="comment">// 读取数字</span></span><br><span class="line">        System.out.println(<span class="string">&quot;第二个人的信息 --&gt; 姓名：&quot;</span> + name + <span class="string">&quot;；年龄：&quot;</span> + age);</span><br><span class="line">        <span class="comment">// 读取第一个人的信息</span></span><br><span class="line">        rdf.seek(<span class="number">0</span>);    <span class="comment">// 指针回到文件的开头</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">            b[i] = rdf.readByte();    <span class="comment">// 读取一个字节</span></span><br><span class="line">        &#125;</span><br><span class="line">        name = <span class="keyword">new</span> <span class="title class_">String</span>(b);    <span class="comment">// 将读取出来的byte数组变为字符串</span></span><br><span class="line">        age = rdf.readInt();    <span class="comment">// 读取数字</span></span><br><span class="line">        System.out.println(<span class="string">&quot;第一个人的信息 --&gt; 姓名：&quot;</span> + name + <span class="string">&quot;；年龄：&quot;</span> + age);</span><br><span class="line">        rdf.skipBytes(<span class="number">12</span>);    <span class="comment">// 空出第二个人的信息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">            b[i] = rdf.readByte();    <span class="comment">// 读取一个字节</span></span><br><span class="line">        &#125;</span><br><span class="line">        name = <span class="keyword">new</span> <span class="title class_">String</span>(b);    <span class="comment">// 将读取出来的byte数组变为字符串</span></span><br><span class="line">        age = rdf.readInt();    <span class="comment">// 读取数字</span></span><br><span class="line">        System.out.println(<span class="string">&quot;第三个人的信息 --&gt; 姓名：&quot;</span> + name + <span class="string">&quot;；年龄：&quot;</span> + age);</span><br><span class="line">        rdf.close();                <span class="comment">// 关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="System"><a href="#System" class="headerlink" title="System"></a>System</h2><p><code>System</code> 类中提供了大量的静态方法，可以获取系统相关的信息或系统级操作，其中提供了三个常用于 IO 的静态成员：</p>
<ul>
<li><code>System.out</code> - 一个 PrintStream 流。System.out 一般会把你写到其中的数据输出到控制台上。System.out 通常仅用在类似命令行工具的控制台程序上。System.out 也经常用于打印程序的调试信息(尽管它可能并不是获取程序调试信息的最佳方式)。</li>
<li><code>System.err</code> - 一个 PrintStream 流。System.err 与 System.out 的运行方式类似，但它更多的是用于打印错误文本。一些类似 Eclipse 的程序，为了让错误信息更加显眼，会将错误信息以红色文本的形式通过 System.err 输出到控制台上。</li>
<li><code>System.in</code> - 一个典型的连接控制台程序和键盘输入的 InputStream 流。通常当数据通过命令行参数或者配置文件传递给命令行 Java 程序的时候，System.in 并不是很常用。图形界面程序通过界面传递参数给程序，这是一块单独的 Java IO 输入机制。</li>
</ul>
<p>【示例】重定向 <code>System.out</code> 输出流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemOutDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;d:\\test.txt&quot;</span>);</span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(out);</span><br><span class="line">        System.setOut(ps);</span><br><span class="line">        System.out.println(<span class="string">&quot;人生若只如初见，何事秋风悲画扇&quot;</span>);</span><br><span class="line">        ps.close();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【示例】重定向 <code>System.err</code> 输出流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemErrDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();        <span class="comment">// 实例化</span></span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(bos);        <span class="comment">// 实例化</span></span><br><span class="line">        System.setErr(ps);    <span class="comment">// 输出重定向</span></span><br><span class="line">        System.err.print(<span class="string">&quot;此处有误&quot;</span>);</span><br><span class="line">        System.out.println(bos);    <span class="comment">// 输出内存中的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【示例】<code>System.in</code> 接受控制台输入信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemInDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> System.in;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入内容：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((temp = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">char</span>) temp;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            buf.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;输入的内容为：&quot;</span> + buf);</span><br><span class="line">        input.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a>Scanner</h2><p><strong><code>Scanner</code> 可以获取用户的输入，并对数据进行校验</strong>。</p>
<p>【示例】校验输入数据是否格式正确</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScannerDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);    <span class="comment">// 从键盘接收数据</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">0.0f</span>;</span><br><span class="line">        System.out.print(<span class="string">&quot;输入整数：&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (scan.hasNextInt()) &#123;    <span class="comment">// 判断输入的是否是整数</span></span><br><span class="line">            i = scan.nextInt();    <span class="comment">// 接收整数</span></span><br><span class="line">            System.out.println(<span class="string">&quot;整数数据：&quot;</span> + i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;输入的不是整数！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;输入小数：&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (scan.hasNextFloat()) &#123;    <span class="comment">// 判断输入的是否是小数</span></span><br><span class="line">            f = scan.nextFloat();    <span class="comment">// 接收小数</span></span><br><span class="line">            System.out.println(<span class="string">&quot;小数数据：&quot;</span> + f);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;输入的不是小数！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        System.out.print(<span class="string">&quot;输入日期（yyyy-MM-dd）：&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (scan.hasNext(<span class="string">&quot;^\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;$&quot;</span>)) &#123;    <span class="comment">// 判断</span></span><br><span class="line">            str = scan.next(<span class="string">&quot;^\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;$&quot;</span>);    <span class="comment">// 接收</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                date = <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>).parse(str);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;输入的日期格式错误！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入整数：20</span><br><span class="line">整数数据：20</span><br><span class="line">输入小数：3.2</span><br><span class="line">小数数据：3.2</span><br><span class="line">输入日期（yyyy-MM-dd）：1988<span class="string">-13</span><span class="string">-1</span></span><br><span class="line">输入的日期格式错误！</span><br><span class="line">null</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/2130190/">《Java 编程思想（Thinking in java）》</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/26880667/">《Java 核心技术 卷 I 基础知识》</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/api/java/lang/System.html">System 官方 API 手册</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/db5b69/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/db5b69/" class="post-title-link" itemprop="url">Java 内存管理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-28 16:19:00" itemprop="dateCreated datePublished" datetime="2020-06-28T16:19:00+08:00">2020-06-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JavaSE/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>15k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>13 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java-内存管理"><a href="#Java-内存管理" class="headerlink" title="Java 内存管理"></a>Java 内存管理</h1><h2 id="内存简介"><a href="#内存简介" class="headerlink" title="内存简介"></a>内存简介</h2><h3 id="物理内存和虚拟内存"><a href="#物理内存和虚拟内存" class="headerlink" title="物理内存和虚拟内存"></a>物理内存和虚拟内存</h3><p>所谓物理内存就是通常所说的 RAM（随机存储器）。</p>
<p>虚拟内存使得多个进程在同时运行时可以共享物理内存，这里的共享只是空间上共享，在逻辑上彼此仍然是隔离的。</p>
<h3 id="内核空间和用户空间"><a href="#内核空间和用户空间" class="headerlink" title="内核空间和用户空间"></a>内核空间和用户空间</h3><p>一个计算通常有固定大小的内存空间，但是程序并不能使用全部的空间。因为这些空间被划分为内核空间和用户空间，而程序只能使用用户空间的内存。</p>
<h3 id="使用内存的-Java-组件"><a href="#使用内存的-Java-组件" class="headerlink" title="使用内存的 Java 组件"></a>使用内存的 Java 组件</h3><p>Java 启动后，作为一个进程运行在操作系统中。</p>
<p>有哪些 Java 组件需要占用内存呢？</p>
<ul>
<li>堆内存：Java 堆、类和类加载器</li>
<li>栈内存：线程</li>
<li>本地内存：NIO、JNI</li>
</ul>
<h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>JVM 在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/jvm/jvm-memory-runtime-data-area.png" alt="img"></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p><strong><code>程序计数器（Program Counter Register）</code></strong> 是一块较小的内存空间，它可以看做是<strong>当前线程所执行的字节码的行号指示器</strong>。例如，分支、循环、跳转、异常、线程恢复等都依赖于计数器。</p>
<p>当执行的线程数量超过 CPU 数量时，线程之间会根据时间片轮询争夺 CPU 资源。如果一个线程的时间片用完了，或者是其它原因导致这个线程的 CPU 资源被提前抢夺，那么这个退出的线程就需要单独的一个程序计数器，来记录下一条运行的指令，从而在线程切换后能恢复到正确的执行位置。各条线程间的计数器互不影响，独立存储，我们称这类内存区域为 “线程私有” 的内存。</p>
<ul>
<li>如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；</li>
<li>如果正在执行的是 Native 方法，这个计数器值则为空（Undefined）。</li>
</ul>
<blockquote>
<p>🔔 注意：此内存区域是唯一一个在 JVM 中没有规定任何 <code>OutOfMemoryError</code> 情况的区域。</p>
</blockquote>
<h3 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h3><p><strong><code>Java 虚拟机栈（Java Virtual Machine Stacks）</code></strong> 也<strong>是线程私有的，它的生命周期与线程相同</strong>。</p>
<p>每个 Java 方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储 <strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>常量池引用</strong> 等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/jvm/jvm-stack.png!w640" alt="img"></p>
<ul>
<li><strong>局部变量表</strong> - 32 位变量槽，存放了编译期可知的各种基本数据类型、对象引用、<code>ReturnAddress</code> 类型。</li>
<li><strong>操作数栈</strong> - 基于栈的执行引擎，虚拟机把操作数栈作为它的工作区，大多数指令都要从这里弹出数据、执行运算，然后把结果压回操作数栈。</li>
<li><strong>动态链接</strong> - 每个栈帧都包含一个指向运行时常量池（方法区的一部分）中该栈帧所属方法的引用。持有这个引用是为了支持方法调用过程中的动态连接。Class 文件的常量池中有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为静态解析。另一部分将在每一次的运行期间转化为直接应用，这部分称为动态链接。</li>
<li><strong>方法出口</strong> - 返回方法被调用的位置，恢复上层方法的局部变量和操作数栈，如果无返回值，则把它压入调用者的操作数栈。</li>
</ul>
<blockquote>
<p>🔔 注意：</p>
<p>该区域可能抛出以下异常：</p>
<ul>
<li>如果线程请求的栈深度超过最大值，就会抛出 <code>StackOverflowError</code> 异常；</li>
<li>如果虚拟机栈进行动态扩展时，无法申请到足够内存，就会抛出 <code>OutOfMemoryError</code> 异常。</li>
</ul>
<p>💡 提示：</p>
<p>可以通过 <code>-Xss</code> 这个虚拟机参数来指定一个程序的 Java 虚拟机栈内存大小：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xss=512M HackTheJava</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p><strong><code>本地方法栈（Native Method Stack）</code></strong> 与虚拟机栈的作用相似。</p>
<p>二者的区别在于：<strong>虚拟机栈为 Java 方法服务；本地方法栈为 Native 方法服务</strong>。本地方法并不是用 Java 实现的，而是由 C 语言实现的。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/jvm/jvm-native-method-stack.gif!w640" alt="img"></p>
<blockquote>
<p>🔔 注意：本地方法栈也会抛出 <code>StackOverflowError</code> 异常和 <code>OutOfMemoryError</code> 异常。</p>
</blockquote>
<h3 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h3><p><strong><code>Java 堆（Java Heap）</code> 的作用就是存放对象实例，几乎所有的对象实例都是在这里分配内存</strong>。</p>
<p>Java 堆是垃圾收集的主要区域（因此也被叫做”GC 堆”）。现代的垃圾收集器基本都是采用<strong>分代收集算法</strong>，该算法的思想是针对不同的对象采取不同的垃圾回收算法。</p>
<p>因此虚拟机把 Java 堆分成以下三块：</p>
<ul>
<li><strong><code>新生代（Young Generation）</code></strong><ul>
<li><code>Eden</code> - Eden 和 Survivor 的比例为 8:1</li>
<li><code>From Survivor</code></li>
<li><code>To Survivor</code></li>
</ul>
</li>
<li><strong><code>老年代（Old Generation）</code></strong></li>
<li><strong><code>永久代（Permanent Generation）</code></strong></li>
</ul>
<p>当一个对象被创建时，它首先进入新生代，之后有可能被转移到老年代中。新生代存放着大量的生命很短的对象，因此新生代在三个区域中垃圾回收的频率最高。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/jvm/jvm-heap.gif!w640" alt="img"></p>
<blockquote>
<p>🔔 注意：Java 堆不需要连续内存，并且可以动态扩展其内存，扩展失败会抛出 <code>OutOfMemoryError</code> 异常。</p>
<p>💡 提示：可以通过 <code>-Xms</code> 和 <code>-Xmx</code> 两个虚拟机参数来指定一个程序的 Java 堆内存大小，第一个参数设置初始值，第二个参数设置最大值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xms=1M -Xmx=2M HackTheJava</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区（Method Area）也被称为永久代。<strong>方法区用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</strong>。</p>
<p>对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。</p>
<blockquote>
<p>🔔 注意：和 Java 堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 <code>OutOfMemoryError</code> 异常。</p>
<p>💡 提示：</p>
<ul>
<li>JDK 1.7 之前，HotSpot 虚拟机把它当成永久代来进行垃圾回收。可通过参数 <code>-XX:PermSize</code> 和 <code>-XX:MaxPermSize</code> 设置。</li>
<li>JDK 1.8 之后，取消了永久代，用 **<code>metaspace（元数据）</code>**区替代。可通过参数 <code>-XX:MaxMetaspaceSize</code> 设置。</li>
</ul>
</blockquote>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p><strong><code>运行时常量池（Runtime Constant Pool）</code> 是方法区的一部分</strong>，Class 文件中除了有类的版本、字段、方法、接口等描述信息，还有一项信息是常量池（Constant Pool Table），<strong>用于存放编译器生成的各种字面量和符号引用</strong>，这部分内容会在类加载后被放入这个区域。</p>
<ul>
<li><strong>字面量</strong> - 文本字符串、声明为 <code>final</code> 的常量值等。</li>
<li><strong>符号引用</strong> - 类和接口的完全限定名（Fully Qualified Name）、字段的名称和描述符（Descriptor）、方法的名称和描述符。</li>
</ul>
<p>除了在编译期生成的常量，还允许动态生成，例如 <code>String</code> 类的 <code>intern()</code>。这部分常量也会被放入运行时常量池。</p>
<blockquote>
<p>🔔 注意：当常量池无法再申请到内存时会抛出 <code>OutOfMemoryError</code> 异常。</p>
</blockquote>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是 JVM 规范中定义的内存区域。</p>
<p>在 JDK 1.4 中新加入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里的 <code>DirectByteBuffer</code> 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。</p>
<blockquote>
<p>🔔 注意：直接内存这部分也被频繁的使用，且也可能导致 <code>OutOfMemoryError</code> 异常。</p>
<p>💡 提示：直接内存容量可通过 <code>-XX:MaxDirectMemorySize</code> 指定，如果不指定，则默认与 Java 堆最大值（<code>-Xmx</code> 指定）一样。</p>
</blockquote>
<h3 id="Java-内存区域对比"><a href="#Java-内存区域对比" class="headerlink" title="Java 内存区域对比"></a>Java 内存区域对比</h3><table>
<thead>
<tr>
<th>内存区域</th>
<th>内存作用范围</th>
<th>异常</th>
</tr>
</thead>
<tbody><tr>
<td>程序计数器</td>
<td>线程私有</td>
<td>无</td>
</tr>
<tr>
<td>Java 虚拟机栈</td>
<td>线程私有</td>
<td><code>StackOverflowError</code> 和 <code>OutOfMemoryError</code></td>
</tr>
<tr>
<td>本地方法栈</td>
<td>线程私有</td>
<td><code>StackOverflowError</code> 和 <code>OutOfMemoryError</code></td>
</tr>
<tr>
<td>Java 堆</td>
<td>线程共享</td>
<td><code>OutOfMemoryError</code></td>
</tr>
<tr>
<td>方法区</td>
<td>线程共享</td>
<td><code>OutOfMemoryError</code></td>
</tr>
<tr>
<td>运行时常量池</td>
<td>线程共享</td>
<td><code>OutOfMemoryError</code></td>
</tr>
<tr>
<td>直接内存</td>
<td>非运行时数据区</td>
<td><code>OutOfMemoryError</code></td>
</tr>
</tbody></table>
<h2 id="JVM-运行原理"><a href="#JVM-运行原理" class="headerlink" title="JVM 运行原理"></a>JVM 运行原理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JVMCase</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 常量</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">MAN_SEX_TYPE</span> <span class="operator">=</span> <span class="string">&quot;man&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 静态变量</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">WOMAN_SEX_TYPE</span> <span class="operator">=</span> <span class="string">&quot;woman&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">		stu.setName(<span class="string">&quot;nick&quot;</span>);</span><br><span class="line">		stu.setSexType(MAN_SEX_TYPE);</span><br><span class="line">		stu.setAge(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">		<span class="type">JVMCase</span> <span class="variable">jvmcase</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JVMCase</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 调用静态方法</span></span><br><span class="line">		print(stu);</span><br><span class="line">		<span class="comment">// 调用非静态方法</span></span><br><span class="line">		jvmcase.sayHello(stu);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 常规静态方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(Student stu)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;name: &quot;</span> + stu.getName() + <span class="string">&quot;; sex:&quot;</span> + stu.getSexType() + <span class="string">&quot;; age:&quot;</span> + stu.getAge());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 非静态方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(Student stu)</span> &#123;</span><br><span class="line">		System.out.println(stu.getName() + <span class="string">&quot;say: hello&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	String sexType;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getSexType</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> sexType;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSexType</span><span class="params">(String sexType)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.sexType = sexType;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行以上代码时，JVM 处理过程如下：</p>
<p>（1）JVM 向操作系统申请内存，JVM 第一步就是通过配置参数或者默认配置参数向操作系统申请内存空间，根据内存大小找到具体的内存分配表，然后把内存段的起始地址和终止地址分配给 JVM，接下来 JVM 就进行内部分配。</p>
<p>（2）JVM 获得内存空间后，会根据配置参数分配堆、栈以及方法区的内存大小。</p>
<p>（3）class 文件加载、验证、准备以及解析，其中准备阶段会为类的静态变量分配内存，初始化为系统的初始值（这部分我在第 21 讲还会详细介绍）。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200630094250.png" alt="img"></p>
<p>（4）完成上一个步骤后，将会进行最后一个初始化阶段。在这个阶段中，JVM 首先会执行构造器 <code>&lt;clinit&gt;</code> 方法，编译器会在 <code>.java</code> 文件被编译成 <code>.class</code> 文件时，收集所有类的初始化代码，包括静态变量赋值语句、静态代码块、静态方法，收集在一起成为 <code>&lt;clinit&gt;()</code> 方法。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200630094329.png" alt="img"></p>
<p>（5）执行方法。启动 main 线程，执行 main 方法，开始执行第一行代码。此时堆内存中会创建一个 student 对象，对象引用 student 就存放在栈中。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200630094651.png" alt="img"></p>
<p>（6）此时再次创建一个 JVMCase 对象，调用 sayHello 非静态方法，sayHello 方法属于对象 JVMCase，此时 sayHello 方法入栈，并通过栈中的 student 引用调用堆中的 Student 对象；之后，调用静态方法 print，print 静态方法属于 JVMCase 类，是从静态方法中获取，之后放入到栈中，也是通过 student 引用调用堆中的 student 对象。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200630094714.png" alt="img"></p>
<h2 id="OutOfMemoryError"><a href="#OutOfMemoryError" class="headerlink" title="OutOfMemoryError"></a>OutOfMemoryError</h2><h3 id="什么是-OutOfMemoryError"><a href="#什么是-OutOfMemoryError" class="headerlink" title="什么是 OutOfMemoryError"></a>什么是 OutOfMemoryError</h3><p><code>OutOfMemoryError</code> 简称为 OOM。Java 中对 OOM 的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。通俗的解释是：JVM 内存不足了。</p>
<p>在 JVM 规范中，<strong>除了程序计数器区域外，其他运行时区域都可能发生 <code>OutOfMemoryError</code> 异常（简称 OOM）</strong>。</p>
<p>下面逐一介绍 OOM 发生场景。</p>
<h3 id="堆空间溢出"><a href="#堆空间溢出" class="headerlink" title="堆空间溢出"></a>堆空间溢出</h3><p><code>java.lang.OutOfMemoryError: Java heap space</code> 这个错误意味着：<strong>堆空间溢出</strong>。</p>
<p>更细致的说法是：Java 堆内存已经达到 <code>-Xmx</code> 设置的最大值。Java 堆用于存储对象实例，只要不断地创建对象，并且保证 GC Roots 到对象之间有可达路径来避免垃圾收集器回收这些对象，那么当堆空间到达最大容量限制后就会产生 OOM。</p>
<p>堆空间溢出有可能是**<code>内存泄漏（Memory Leak）</code>** 或 <strong><code>内存溢出（Memory Overflow）</code></strong> 。需要使用 jstack 和 jmap 生成 threaddump 和 heapdump，然后用内存分析工具（如：MAT）进行分析。</p>
<h4 id="Java-heap-space-分析步骤"><a href="#Java-heap-space-分析步骤" class="headerlink" title="Java heap space 分析步骤"></a>Java heap space 分析步骤</h4><ol>
<li>使用 <code>jmap</code> 或 <code>-XX:+HeapDumpOnOutOfMemoryError</code> 获取堆快照。</li>
<li>使用内存分析工具（visualvm、mat、jProfile 等）对堆快照文件进行分析。</li>
<li>根据分析图，重点是确认内存中的对象是否是必要的，分清究竟是是内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）。</li>
</ol>
<h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p><strong>内存泄漏是指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况</strong>。</p>
<p>内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。内存泄漏随着被执行的次数不断增加，最终会导致内存溢出。</p>
<p>内存泄漏常见场景：</p>
<ul>
<li>静态容器<ul>
<li>声明为静态（<code>static</code>）的 <code>HashMap</code>、<code>Vector</code> 等集合</li>
<li>通俗来讲 A 中有 B，当前只把 B 设置为空，A 没有设置为空，回收时 B 无法回收。因为被 A 引用。</li>
</ul>
</li>
<li>监听器<ul>
<li>监听器被注册后释放对象时没有删除监听器</li>
</ul>
</li>
<li>物理连接<ul>
<li>各种连接池建立了连接，必须通过 <code>close()</code> 关闭链接</li>
</ul>
</li>
<li>内部类和外部模块等的引用<ul>
<li>发现它的方式同内存溢出，可再加个实时观察</li>
<li><code>jstat -gcutil 7362 2500 70</code></li>
</ul>
</li>
</ul>
<p>重点关注：</p>
<ul>
<li><code>FGC</code> — 从应用程序启动到采样时发生 Full GC 的次数。</li>
<li><code>FGCT</code> — 从应用程序启动到采样时 Full GC 所用的时间（单位秒）。</li>
<li><code>FGC</code> 次数越多，<code>FGCT</code> 所需时间越多，越有可能存在内存泄漏。</li>
</ul>
<p>如果是内存泄漏，可以进一步查看泄漏对象到 GC Roots 的对象引用链。这样就能找到泄漏对象是怎样与 GC Roots 关联并导致 GC 无法回收它们的。掌握了这些原因，就可以较准确的定位出引起内存泄漏的代码。</p>
<p>导致内存泄漏的常见原因是使用容器，且不断向容器中添加元素，但没有清理，导致容器内存不断膨胀。</p>
<p>【示例】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内存泄漏示例</span></span><br><span class="line"><span class="comment"> * 错误现象：java.lang.OutOfMemoryError: Java heap space</span></span><br><span class="line"><span class="comment"> * VM Args：-verbose:gc -Xms10M -Xmx10M -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapOutOfMemoryDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;OomObject&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">OomObject</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OomObject</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h4><p>如果不存在内存泄漏，即内存中的对象确实都必须存活着，则应当检查虚拟机的堆参数（<code>-Xmx</code> 和 <code>-Xms</code>），与机器物理内存进行对比，看看是否可以调大。并从代码上检查是否存在某些对象生命周期过长、持有时间过长的情况，尝试减少程序运行期的内存消耗。</p>
<p>【示例】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆溢出示例</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 错误现象：java.lang.OutOfMemoryError: Java heap space</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * VM Args：-verbose:gc -Xms10M -Xmx10M</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href=&quot;mailto:forbreak@163.com&quot;&gt;Zhang Peng&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019-06-25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapOutOfMemoryDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Double[] array = <span class="keyword">new</span> <span class="title class_">Double</span>[<span class="number">999999999</span>];</span><br><span class="line">        System.out.println(<span class="string">&quot;array length = [&quot;</span> + array.length + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行 <code>java -verbose:gc -Xms10M -Xmx10M -XX:+HeapDumpOnOutOfMemoryError io.github.dunwu.javacore.jvm.memory.HeapMemoryLeakMemoryErrorDemo</code></p>
<p>上面的例子是一个极端的例子，试图创建一个维度很大的数组，堆内存无法分配这么大的内存，从而报错：<code>Java heap space</code>。</p>
<p>但如果在现实中，代码并没有问题，仅仅是因为堆内存不足，可以通过 <code>-Xms</code> 和 <code>-Xmx</code> 适当调整堆内存大小。</p>
<h3 id="GC-开销超过限制"><a href="#GC-开销超过限制" class="headerlink" title="GC 开销超过限制"></a>GC 开销超过限制</h3><p><code>java.lang.OutOfMemoryError: GC overhead limit exceeded</code> 这个错误，官方给出的定义是：<strong>超过 <code>98%</code> 的时间用来做 GC 并且回收了不到 <code>2%</code> 的堆内存时会抛出此异常</strong>。这意味着，发生在 GC 占用大量时间为释放很小空间的时候发生的，是一种保护机制。导致异常的原因：一般是因为堆太小，没有足够的内存。</p>
<p>【示例】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * GC overhead limit exceeded 示例</span></span><br><span class="line"><span class="comment"> * 错误现象：java.lang.OutOfMemoryError: GC overhead limit exceeded</span></span><br><span class="line"><span class="comment"> * 发生在GC占用大量时间为释放很小空间的时候发生的，是一种保护机制。导致异常的原因：一般是因为堆太小，没有足够的内存。</span></span><br><span class="line"><span class="comment"> * 官方对此的定义：超过98%的时间用来做GC并且回收了不到2%的堆内存时会抛出此异常。</span></span><br><span class="line"><span class="comment"> * VM Args: -Xms10M -Xmx10M</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GcOverheadLimitExceededDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Double&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            list.add(d++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【处理】</p>
<p>与 <strong>Java heap space</strong> 错误处理方法类似，先判断是否存在内存泄漏。如果有，则修正代码；如果没有，则通过 <code>-Xms</code> 和 <code>-Xmx</code> 适当调整堆内存大小。</p>
<h3 id="永久代空间不足"><a href="#永久代空间不足" class="headerlink" title="永久代空间不足"></a>永久代空间不足</h3><p>【错误】</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java<span class="selector-class">.lang</span><span class="selector-class">.OutOfMemoryError</span>: PermGen space</span><br></pre></td></tr></table></figure>

<p>【原因】</p>
<p>Perm （永久代）空间主要用于存放 <code>Class</code> 和 Meta 信息，包括类的名称和字段，带有方法字节码的方法，常量池信息，与类关联的对象数组和类型数组以及即时编译器优化。GC 在主程序运行期间不会对永久代空间进行清理，默认是 64M 大小。</p>
<p>根据上面的定义，可以得出 <strong>PermGen 大小要求取决于加载的类的数量以及此类声明的大小</strong>。因此，可以说造成该错误的主要原因是永久代中装入了太多的类或太大的类。</p>
<p>在 JDK8 之前的版本中，可以通过 <code>-XX:PermSize</code> 和 <code>-XX:MaxPermSize</code> 设置永久代空间大小，从而限制方法区大小，并间接限制其中常量池的容量。</p>
<h4 id="初始化时永久代空间不足"><a href="#初始化时永久代空间不足" class="headerlink" title="初始化时永久代空间不足"></a>初始化时永久代空间不足</h4><p>【示例】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 永久代内存空间不足示例</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 错误现象：</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;java.lang.OutOfMemoryError: PermGen space (JDK8 以前版本)&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;java.lang.OutOfMemoryError: Metaspace (JDK8 及以后版本)&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * VM Args:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;-Xmx100M -XX:MaxPermSize=16M (JDK8 以前版本)&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;-Xmx100M -XX:MaxMetaspaceSize=16M (JDK8 及以后版本)&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PermOutOfMemoryErrorDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100_000_000</span>; i++) &#123;</span><br><span class="line">            generate(<span class="string">&quot;eu.plumbr.demo.Generated&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class <span class="title function_">generate</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="keyword">return</span> pool.makeClass(name).toClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，源代码遍历循环并在运行时生成类。javassist 库正在处理类生成的复杂性。</p>
<h4 id="重部署时永久代空间不足"><a href="#重部署时永久代空间不足" class="headerlink" title="重部署时永久代空间不足"></a>重部署时永久代空间不足</h4><p>对于更复杂，更实际的示例，让我们逐步介绍一下在应用程序重新部署期间发生的 Permgen 空间错误。重新部署应用程序时，你希望垃圾回收会摆脱引用所有先前加载的类的加载器，并被加载新类的类加载器取代。</p>
<p>不幸的是，许多第三方库以及对线程，JDBC 驱动程序或文件系统句柄等资源的不良处理使得无法卸载以前使用的类加载器。反过来，这意味着在每次重新部署期间，所有先前版本的类仍将驻留在 PermGen 中，从而在每次重新部署期间生成数十兆的垃圾。</p>
<p>让我们想象一个使用 JDBC 驱动程序连接到关系数据库的示例应用程序。启动应用程序时，初始化代码将加载 JDBC 驱动程序以连接到数据库。对应于规范，JDBC 驱动程序向 java.sql.DriverManager 进行注册。该注册包括将对驱动程序实例的引用存储在 DriverManager 的静态字段中。</p>
<p>现在，当从应用程序服务器取消部署应用程序时，java.sql.DriverManager 仍将保留该引用。我们最终获得了对驱动程序类的实时引用，而驱动程序类又保留了用于加载应用程序的 java.lang.Classloader 实例的引用。反过来，这意味着垃圾回收算法无法回收空间。</p>
<p>而且该 java.lang.ClassLoader 实例仍引用应用程序的所有类，通常在 PermGen 中占据数十兆字节。这意味着只需少量重新部署即可填充通常大小的 PermGen。</p>
<h4 id="PermGen-space-解决方案"><a href="#PermGen-space-解决方案" class="headerlink" title="PermGen space 解决方案"></a>PermGen space 解决方案</h4><p>（1）解决初始化时的 <code>OutOfMemoryError</code></p>
<p>在应用程序启动期间触发由于 PermGen 耗尽导致的 <code>OutOfMemoryError</code> 时，解决方案很简单。该应用程序仅需要更多空间才能将所有类加载到 PermGen 区域，因此我们只需要增加其大小即可。为此，更改你的应用程序启动配置并添加（或增加，如果存在）<code>-XX:MaxPermSize</code> 参数，类似于以下示例：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:<span class="attribute">MaxPermSize</span>=512m com.yourcompany.YourClass</span><br></pre></td></tr></table></figure>

<p>上面的配置将告诉 JVM，PermGen 可以增长到 512MB。</p>
<p>清理应用程序中 <code>WEB-INF/lib</code> 下的 jar，用不上的 jar 删除掉，多个应用公共的 jar 移动到 Tomcat 的 lib 目录，减少重复加载。</p>
<p>🔔 注意：<code>-XX:PermSize</code> 一般设为 64M</p>
<p>（2）解决重新部署时的 <code>OutOfMemoryError</code></p>
<p>重新部署应用程序后立即发生 OutOfMemoryError 时，应用程序会遭受类加载器泄漏的困扰。在这种情况下，解决问题的最简单，继续进行堆转储分析–使用类似于以下命令的重新部署后进行堆转储：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -<span class="keyword">dump</span>:format=b,<span class="keyword">file</span>=<span class="keyword">dump</span>.hprof &lt;process-id&gt;</span><br></pre></td></tr></table></figure>

<p>然后使用你最喜欢的堆转储分析器打开转储（Eclipse MAT 是一个很好的工具）。在分析器中可以查找重复的类，尤其是那些正在加载应用程序类的类。从那里，你需要进行所有类加载器的查找，以找到当前活动的类加载器。</p>
<p>对于非活动类加载器，你需要通过从非活动类加载器收集到 GC 根的最短路径来确定阻止它们被垃圾收集的引用。有了此信息，你将找到根本原因。如果根本原因是在第三方库中，则可以进入 Google&#x2F;StackOverflow 查看是否是已知问题以获取补丁&#x2F;解决方法。</p>
<p>（3）解决运行时 <code>OutOfMemoryError</code></p>
<p>第一步是检查是否允许 GC 从 PermGen 卸载类。在这方面，标准的 JVM 相当保守-类是天生的。因此，一旦加载，即使没有代码在使用它们，类也会保留在内存中。当应用程序动态创建许多类并且长时间不需要生成的类时，这可能会成为问题。在这种情况下，允许 JVM 卸载类定义可能会有所帮助。这可以通过在启动脚本中仅添加一个配置参数来实现：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:+CMSClassUnloadingEnabled</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，此选项设置为 false，因此要启用此功能，你需要在 Java 选项中显式设置。如果启用 CMSClassUnloadingEnabled，GC 也会扫描 PermGen 并删除不再使用的类。请记住，只有同时使用 UseConcMarkSweepGC 时此选项才起作用。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:+UseConcMarkSweepGC</span></span><br></pre></td></tr></table></figure>

<p>在确保可以卸载类并且问题仍然存在之后，你应该继续进行堆转储分析–使用类似于以下命令的方法进行堆转储：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -<span class="keyword">dump</span>:<span class="keyword">file</span>=<span class="keyword">dump</span>.hprof,format=b &lt;process-id&gt;</span><br></pre></td></tr></table></figure>

<p>然后，使用你最喜欢的堆转储分析器（例如 Eclipse MAT）打开转储，然后根据已加载的类数查找最昂贵的类加载器。从此类加载器中，你可以继续提取已加载的类，并按实例对此类进行排序，以使可疑对象排在首位。</p>
<p>然后，对于每个可疑者，就需要你手动将根本原因追溯到生成此类的应用程序代码。</p>
<h3 id="元数据区空间不足"><a href="#元数据区空间不足" class="headerlink" title="元数据区空间不足"></a>元数据区空间不足</h3><p>【错误】</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Exception</span> <span class="keyword">in</span> thread <span class="string">&quot;main&quot;</span> java.lang.<span class="built_in">OutOfMemoryError</span>: Metaspace</span><br></pre></td></tr></table></figure>

<p>【原因】</p>
<p>Java8 以后，JVM 内存空间发生了很大的变化。取消了永久代，转而变为元数据区。</p>
<p><strong>元数据区的内存不足，即方法区和运行时常量池的空间不足</strong>。</p>
<p>方法区用于存放 Class 的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。</p>
<p>一个类要被垃圾收集器回收，判定条件是比较苛刻的。在经常动态生成大量 Class 的应用中，需要特别注意类的回收状况。这类常见除了 CGLib 字节码增强和动态语言以外，常见的还有：大量 JSP 或动态产生 JSP 文件的应用（JSP 第一次运行时需要编译为 Java 类）、基于 OSGi 的应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）等。</p>
<p>【示例】方法区出现 <code>OutOfMemoryError</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodAreaOutOfMemoryDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">            enhancer.setSuperclass(Bean.class);</span><br><span class="line">            enhancer.setUseCache(<span class="literal">false</span>);</span><br><span class="line">            enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                    <span class="keyword">return</span> proxy.invokeSuper(obj, args);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            enhancer.create();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【解决】</p>
<p>当由于元空间而面临 <code>OutOfMemoryError</code> 时，第一个解决方案应该是显而易见的。如果应用程序耗尽了内存中的 Metaspace 区域，则应增加 Metaspace 的大小。更改应用程序启动配置并增加以下内容：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:<span class="attribute">MaxMetaspaceSize</span>=512m</span><br></pre></td></tr></table></figure>

<p>上面的配置示例告诉 JVM，允许 Metaspace 增长到 512 MB。</p>
<p>另一种解决方案甚至更简单。你可以通过删除此参数来完全解除对 Metaspace 大小的限制，JVM 默认对 Metaspace 的大小没有限制。但是请注意以下事实：这样做可能会导致大量交换或达到本机物理内存而分配失败。</p>
<h3 id="无法新建本地线程"><a href="#无法新建本地线程" class="headerlink" title="无法新建本地线程"></a>无法新建本地线程</h3><p><code>java.lang.OutOfMemoryError: Unable to create new native thread</code> 这个错误意味着：<strong>Java 应用程序已达到其可以启动线程数的限制</strong>。</p>
<p>【原因】</p>
<p>当发起一个线程的创建时，虚拟机会在 JVM 内存创建一个 <code>Thread</code> 对象同时创建一个操作系统线程，而这个系统线程的内存用的不是 JVM 内存，而是系统中剩下的内存。</p>
<p>那么，究竟能创建多少线程呢？这里有一个公式：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">线程数 = <span class="comment">(MaxProcessMemory - JVMMemory - ReservedOsMemory)</span> / <span class="comment">(ThreadStackSize)</span></span><br></pre></td></tr></table></figure>

<p>【参数】</p>
<ul>
<li><code>MaxProcessMemory</code> - 一个进程的最大内存</li>
<li><code>JVMMemory</code> - JVM 内存</li>
<li><code>ReservedOsMemory</code> - 保留的操作系统内存</li>
<li><code>ThreadStackSize</code> - 线程栈的大小</li>
</ul>
<p>**给 JVM 分配的内存越多，那么能用来创建系统线程的内存就会越少，越容易发生 <code>unable to create new native thread</code>**。所以，JVM 内存不是分配的越大越好。</p>
<p>但是，通常导致 <code>java.lang.OutOfMemoryError</code> 的情况：无法创建新的本机线程需要经历以下阶段：</p>
<ol>
<li>JVM 内部运行的应用程序请求新的 Java 线程</li>
<li>JVM 本机代码代理为操作系统创建新本机线程的请求</li>
<li>操作系统尝试创建一个新的本机线程，该线程需要将内存分配给该线程</li>
<li>操作系统将拒绝本机内存分配，原因是 32 位 Java 进程大小已耗尽其内存地址空间（例如，已达到（2-4）GB 进程大小限制）或操作系统的虚拟内存已完全耗尽</li>
<li>引发 <code>java.lang.OutOfMemoryError: Unable to create new native thread</code> 错误。</li>
</ol>
<p>【示例】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnableCreateNativeThreadErrorDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.MINUTES.sleep(<span class="number">5</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【处理】</p>
<p>可以通过增加操作系统级别的限制来绕过无法创建新的本机线程问题。例如，如果限制了 JVM 可在用户空间中产生的进程数，则应检查出并可能增加该限制：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@dev ~]# ulimit -a</span><br><span class="line">core file size          (blocks, -c) 0</span><br><span class="line">--- cut for brevity ---</span><br><span class="line">max user processes              (-u) 1800</span><br></pre></td></tr></table></figure>

<p>通常，<code>OutOfMemoryError</code> 对新的本机线程的限制表示编程错误。当应用程序产生数千个线程时，很可能出了一些问题—很少有应用程序可以从如此大量的线程中受益。</p>
<p>解决问题的一种方法是开始进行线程转储以了解情况。</p>
<h3 id="直接内存溢出"><a href="#直接内存溢出" class="headerlink" title="直接内存溢出"></a>直接内存溢出</h3><p>由直接内存导致的内存溢出，一个明显的特征是在 Head Dump 文件中不会看见明显的异常，如果发现 OOM 之后 Dump 文件很小，而程序中又直接或间接使用了 NIO，就可以考虑检查一下是不是这方面的原因。</p>
<p>【示例】直接内存 <code>OutOfMemoryError</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本机直接内存溢出示例</span></span><br><span class="line"><span class="comment"> * 错误现象：java.lang.OutOfMemoryError</span></span><br><span class="line"><span class="comment"> * VM Args：-Xmx20M -XX:MaxDirectMemorySize=10M</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectOutOfMemoryDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">unsafeField</span> <span class="operator">=</span> Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</span><br><span class="line">        unsafeField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) unsafeField.get(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            unsafe.allocateMemory(_1MB);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="StackOverflowError"><a href="#StackOverflowError" class="headerlink" title="StackOverflowError"></a>StackOverflowError</h2><p>对于 HotSpot 虚拟机来说，栈容量只由 <code>-Xss</code> 参数来决定如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出 <code>StackOverflowError</code> 异常。</p>
<p>从实战来说，栈溢出的常见原因：</p>
<ul>
<li><strong>递归函数调用层数太深</strong></li>
<li><strong>大量循环或死循环</strong></li>
</ul>
<p>【示例】递归函数调用层数太深导致 <code>StackOverflowError</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackOverflowDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">stackLength</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recursion</span><span class="params">()</span> &#123;</span><br><span class="line">        stackLength++;</span><br><span class="line">        recursion();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StackOverflowDemo</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StackOverflowDemo</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            obj.recursion();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈深度：&quot;</span> + obj.stackLength);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/34907497/">《深入理解 Java 虚拟机》</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100028001">《Java 性能调优实战》</a></li>
<li><a target="_blank" rel="noopener" href="https://www.douban.com/doulist/2545443/">从表到里学习 JVM 实现</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/28935cbfbae0">作为测试你应该知道的 JAVA OOM 及定位分析</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_29912455/article/details/51125748">异常、堆内存溢出、OOM 的几种情况</a></li>
<li><a target="_blank" rel="noopener" href="https://tianmingxing.com/2019/11/17/%E4%BB%8B%E7%BB%8DJVM%E4%B8%ADOOM%E7%9A%848%E7%A7%8D%E7%B1%BB%E5%9E%8B/">介绍 JVM 中 OOM 的 8 种类型</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/22/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><span class="page-number current">23</span><a class="page-number" href="/page/24/">24</a><span class="space">&hellip;</span><a class="page-number" href="/page/47/">47</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/24/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2015 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">李狗蛋</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">3.5m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">53:28</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/yiyirushi/" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.1/dist/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  




<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>

</body>
</html>
