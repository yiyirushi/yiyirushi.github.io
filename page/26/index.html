<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/uploads/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/uploads/favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.ligoudan.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="天气不错哇，你看这大冰雹下得">
<meta property="og:type" content="website">
<meta property="og:title" content="LIGOUDAN">
<meta property="og:url" content="https://www.ligoudan.cn/page/26/index.html">
<meta property="og:site_name" content="LIGOUDAN">
<meta property="og:description" content="天气不错哇，你看这大冰雹下得">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="李狗蛋">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://www.ligoudan.cn/page/26/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/26/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>LIGOUDAN</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">LIGOUDAN</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">好好学习，天天向上</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">326</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">137</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">462</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="李狗蛋"
      src="/uploads/ligoudan.png">
  <p class="site-author-name" itemprop="name">李狗蛋</p>
  <div class="site-description" itemprop="description">天气不错哇，你看这大冰雹下得</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">462</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">137</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">326</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/yiyirushi" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yiyirushi" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yuanhaohoo@163.com" title="E-Mail → mailto:yuanhaohoo@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/002159/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/002159/" class="post-title-link" itemprop="url">Elastic 技术栈之 Kibana</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-16 07:10:44" itemprop="dateCreated datePublished" datetime="2020-06-16T07:10:44+08:00">2020-06-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">搜索引擎数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/Elastic/" itemprop="url" rel="index"><span itemprop="name">Elastic</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Elastic-技术栈之-Kibana"><a href="#Elastic-技术栈之-Kibana" class="headerlink" title="Elastic 技术栈之 Kibana"></a>Elastic 技术栈之 Kibana</h1><h2 id="Discover"><a href="#Discover" class="headerlink" title="Discover"></a>Discover</h2><p>单击侧面导航栏中的 <code>Discover</code> ，可以显示 <code>Kibana</code> 的数据查询功能功能。</p>
<p><img src="https://www.elastic.co/guide/en/kibana/current/images/tutorial-discover.png" alt="img"></p>
<p>在搜索栏中，您可以输入 Elasticsearch 查询条件来搜索您的数据。您可以在 <code>Discover</code> 页面中浏览结果并在 <code>Visualize</code> 页面中创建已保存搜索条件的可视化。</p>
<p>当前索引模式显示在查询栏下方。索引模式确定提交查询时搜索哪些索引。要搜索一组不同的索引，请从下拉菜单中选择不同的模式。要添加索引模式（index pattern），请转至 <code>Management/Kibana/Index Patterns</code> 并单击 <code>Add New</code>。</p>
<p>您可以使用字段名称和您感兴趣的值构建搜索。对于数字字段，可以使用比较运算符，如大于（&gt;），小于（&lt;）或等于（&#x3D;）。您可以将元素与逻辑运算符 <code>AND</code>，<code>OR</code> 和 <code>NOT</code> 链接，全部使用大写。</p>
<p>默认情况下，每个匹配文档都显示所有字段。要选择要显示的文档字段，请将鼠标悬停在“可用字段”列表上，然后单击要包含的每个字段旁边的添加按钮。例如，如果只添加 account_number，则显示将更改为包含五个帐号的简单列表：</p>
<p><img src="https://www.elastic.co/guide/en/kibana/6.1/images/tutorial-discover-3.png" alt="img"></p>
<h3 id="查询语义"><a href="#查询语义" class="headerlink" title="查询语义"></a>查询语义</h3><p>kibana 的搜索栏遵循 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-query-string-query.html#query-string-syntax">query-string-syntax</a> 文档中所说明的查询语义。</p>
<p>这里说明一些最基本的查询语义。</p>
<p>查询字符串会被解析为一系列的术语和运算符。一个术语可以是一个单词（如：quick、brown）或用双引号包围的短语（如”quick brown”）。</p>
<p>查询操作允许您自定义搜索 - 下面介绍了可用的选项。</p>
<h4 id="字段名称"><a href="#字段名称" class="headerlink" title="字段名称"></a>字段名称</h4><p>正如查询字符串查询中所述，将在搜索条件中搜索 default_field，但可以在查询语法中指定其他字段：</p>
<p>例如：</p>
<ul>
<li>查询 <code>status</code> 字段中包含 <code>active</code> 关键字</li>
</ul>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">status:</span>active</span><br></pre></td></tr></table></figure>

<ul>
<li><code>title</code> 字段包含 <code>quick</code> 或 <code>brown</code> 关键字。如果您省略 <code>OR</code> 运算符，则将使用默认运算符</li>
</ul>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">title:</span>(quick <span class="keyword">OR</span> brown)</span><br><span class="line"><span class="symbol">title:</span>(quick brown)</span><br></pre></td></tr></table></figure>

<ul>
<li>author 字段查找精确的短语 “john smith”，即精确查找。</li>
</ul>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">author:</span><span class="string">&quot;John Smith&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>任意字段 <code>book.title</code>，<code>book.content</code> 或 <code>book.date</code> 都包含 <code>quick</code> 或 <code>brown</code>（注意我们需要如何使用 <code>\*</code> 表示通配符）</li>
</ul>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">book.\*:(quick brown)</span><br></pre></td></tr></table></figure>

<ul>
<li>title 字段包含任意非 null 值</li>
</ul>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">_exists_</span>:title</span><br></pre></td></tr></table></figure>

<h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><p>ELK 提供了 ? 和 * 两个通配符。</p>
<ul>
<li><code>?</code> 表示任意单个字符；</li>
<li><code>*</code> 表示任意零个或多个字符。</li>
</ul>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">qu</span>?ck <span class="keyword">bro</span>*</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：通配符查询会使用大量的内存并且执行性能较为糟糕，所以请慎用。</strong> &gt; <strong>提示</strong>：纯通配符 <code>*</code> 被写入 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-exists-query.html">exsits</a> 查询，从而提高了查询效率。因此，通配符 <code>field：*</code> 将匹配包含空值的文档，如：<code>&#123;“field”：“”&#125;</code>，但是如果字段丢失或显示将值置为 null 则不匹配，如：<code>“field”：null&#125;</code> &gt; <strong>提示</strong>：在一个单词的开头（例如：<code>*ing</code>）使用通配符这种方式的查询量特别大，因为索引中的所有术语都需要检查，以防万一匹配。通过将 <code>allow_leading_wildcard</code> 设置为 <code>false</code>，可以禁用。</p>
</blockquote>
<h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>可以通过 <code>/</code> 将正则表达式包裹在查询字符串中进行查询</p>
<p>例：</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">na</span><span class="symbol">me:</span>/joh?<span class="built_in">n</span>(<span class="comment">ath[oa]n</span>)/</span><br></pre></td></tr></table></figure>

<p>支持的正则表达式语义可以参考：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html#regexp-syntax">Regular expression syntax</a></p>
<h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h4><p>我们可以使用 <code>~</code> 运算符来进行模糊查询。</p>
<p>例：</p>
<p>假设我们实际想查询</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">quick brown forks</span></span><br></pre></td></tr></table></figure>

<p>但是，由于拼写错误，我们的查询关键字变成如下情况，依然可以查到想要的结果。</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quikc<span class="string">\~</span> brwn<span class="string">\~</span> foks<span class="string">\~</span></span><br></pre></td></tr></table></figure>

<p>这种模糊查询使用 Damerau-Levenshtein 距离来查找所有匹配最多两个更改的项。所谓的更改是指单个字符的插入，删除或替换，或者两个相邻字符的换位。</p>
<p>默认编辑距离为 <code>2</code>，但编辑距离为 <code>1</code> 应足以捕捉所有人类拼写错误的 80％。它可以被指定为：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">quikc</span>\~<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="近似检索"><a href="#近似检索" class="headerlink" title="近似检索"></a>近似检索</h4><p>尽管短语查询（例如，<code>john smith</code>）期望所有的词条都是完全相同的顺序，但是近似查询允许指定的单词进一步分开或以不同的顺序排列。与模糊查询可以为单词中的字符指定最大编辑距离一样，近似搜索也允许我们指定短语中单词的最大编辑距离：</p>
<p>例</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;fox quick&quot;</span><span class="string">\~5</span></span><br></pre></td></tr></table></figure>

<p>字段中的文本越接近查询字符串中指定的原始顺序，该文档就越被认为是相关的。当与上面的示例查询相比时，短语 <code>&quot;quick fox&quot;</code> 将被认为比 <code>&quot;quick brown fox&quot;</code> 更近似查询条件。</p>
<h4 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h4><p>可以为日期，数字或字符串字段指定范围。闭区间范围用方括号 <code>[min TO max]</code> 和开区间范围用花括号 <code>&#123;min TO max&#125;</code> 来指定。</p>
<p>我们不妨来看一些示例。</p>
<ul>
<li>2012 年的所有日子</li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">date</span>:[<span class="number">2012</span>-<span class="number">01</span>-<span class="number">01</span> TO <span class="number">2012</span>-<span class="number">12</span>-<span class="number">31</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>数字 1 到 5</li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">count</span>:[<span class="number">1</span> TO <span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>alpha</code> 和 <code>omega</code> 之间的标签，不包括 <code>alpha</code> 和 <code>omega</code></li>
</ul>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">tags:</span>&#123;alpha TO omega&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>10 以上的数字</li>
</ul>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">count</span>:[<span class="number">10</span> <span class="keyword">TO</span> *]</span><br></pre></td></tr></table></figure>

<ul>
<li>2012 年以前的所有日期</li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">date</span>:&#123;* TO <span class="number">2012</span>-<span class="number">01</span>-<span class="number">01</span>&#125;</span><br></pre></td></tr></table></figure>

<p>此外，开区间和闭区间也可以组合使用</p>
<ul>
<li>数组 1 到 5，但不包括 5</li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">count</span>:[<span class="number">1</span> TO <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>

<p>一边无界的范围也可以使用以下语法：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">age</span>:&gt;<span class="number">10</span></span><br><span class="line"><span class="attribute">age</span>:&gt;=<span class="number">10</span></span><br><span class="line"><span class="attribute">age</span>:&lt;<span class="number">10</span></span><br><span class="line"><span class="attribute">age</span>:&lt;=<span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>当然，你也可以使用 AND 运算符来得到连个查询结果的交集</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">age</span>:(&gt;=<span class="number">10</span> AND &lt;<span class="number">20</span>)</span><br><span class="line"><span class="attribute">age</span>:(+&gt;=<span class="number">10</span> +&lt;<span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<h4 id="Boosting"><a href="#Boosting" class="headerlink" title="Boosting"></a>Boosting</h4><p>使用操作符 <code>^</code> 使一个术语比另一个术语更相关。例如，如果我们想查找所有有关狐狸的文档，但我们对狐狸特别感兴趣：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">quick</span>^<span class="number">2</span> fox</span><br></pre></td></tr></table></figure>

<p>默认提升值是 1，但可以是任何正浮点数。 0 到 1 之间的提升减少了相关性。</p>
<p>增强也可以应用于短语或组：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;john smith&quot;</span>^<span class="number">2</span>   <span class="comment">(foo bar)</span>^<span class="number">4</span></span><br></pre></td></tr></table></figure>

<h4 id="布尔操作"><a href="#布尔操作" class="headerlink" title="布尔操作"></a>布尔操作</h4><p>默认情况下，只要一个词匹配，所有词都是可选的。搜索 <code>foo bar baz</code> 将查找包含 <code>foo</code> 或 <code>bar</code> 或 <code>baz</code> 中的一个或多个的任何文档。我们已经讨论了上面的<code>default_operator</code>，它允许你强制要求所有的项，但也有布尔运算符可以在查询字符串本身中使用，以提供更多的控制。</p>
<p>首选的操作符是 <code>+</code>（此术语必须存在）和 <code>-</code> （此术语不得存在）。所有其他条款是可选的。例如，这个查询：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quick <span class="keyword">brown </span>+fox -news</span><br></pre></td></tr></table></figure>

<p>这条查询意味着：</p>
<ul>
<li>fox 必须存在</li>
<li>news 必须不存在</li>
<li>quick 和 brown 是可有可无的</li>
</ul>
<p>熟悉的运算符 <code>AND</code>，<code>OR</code> 和 <code>NOT</code>（也写成 <code>&amp;&amp;</code>，<code>||</code> 和 <code>!</code>）也被支持。然而，这些操作符有一定的优先级：<code>NOT</code> 优先于 <code>AND</code>，<code>AND</code> 优先于 <code>OR</code>。虽然 <code>+</code> 和 <code>-</code> 仅影响运算符右侧的术语，但 <code>AND</code> 和 <code>OR</code> 会影响左侧和右侧的术语。</p>
<h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><p>多个术语或子句可以用圆括号组合在一起，形成子查询</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(quick <span class="keyword">OR </span><span class="keyword">brown) </span><span class="keyword">AND </span>fox</span><br></pre></td></tr></table></figure>

<p>可以使用组来定位特定的字段，或者增强子查询的结果：</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stat<span class="symbol">us:</span>(active <span class="built_in">OR</span> pending) tit<span class="symbol">le:</span>(full <span class="built_in">text</span> <span class="built_in">search</span>)^<span class="number">2</span></span><br></pre></td></tr></table></figure>

<h4 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h4><p>如果你需要使用任何在你的查询本身中作为操作符的字符（而不是作为操作符），那么你应该用一个反斜杠来转义它们。例如，要搜索（1 + 1）&#x3D; 2，您需要将查询写为 <code>\(1\+1\)\=2</code></p>
<p>保留字符是：<code>+ - = &amp;&amp; || &gt; &lt; ! ( ) &#123; &#125; [ ] ^ &quot; ~ * ? : \ /</code></p>
<p>无法正确地转义这些特殊字符可能会导致语法错误，从而阻止您的查询运行。</p>
<h4 id="空查询"><a href="#空查询" class="headerlink" title="空查询"></a>空查询</h4><p>如果查询字符串为空或仅包含空格，则查询将生成一个空的结果集。</p>
<h2 id="Visualize"><a href="#Visualize" class="headerlink" title="Visualize"></a>Visualize</h2><p>要想使用可视化的方式展示您的数据，请单击侧面导航栏中的 <code>Visualize</code>。</p>
<p>Visualize 工具使您能够以多种方式（如饼图、柱状图、曲线图、分布图等）查看数据。要开始使用，请点击蓝色的 <code>Create a visualization</code> 或 <code>+</code> 按钮。</p>
<p><img src="https://www.elastic.co/guide/en/kibana/6.1/images/tutorial-visualize-landing.png" alt="https://www.elastic.co/guide/en/kibana/6.1/images/tutorial-visualize-landing.png"></p>
<p>有许多可视化类型可供选择。</p>
<p><img src="https://www.elastic.co/guide/en/kibana/6.1/images/tutorial-visualize-wizard-step-1.png" alt="https://www.elastic.co/guide/en/kibana/6.1/images/tutorial-visualize-wizard-step-1.png"></p>
<p>下面，我们来看创建几个图标示例：</p>
<h3 id="Pie"><a href="#Pie" class="headerlink" title="Pie"></a>Pie</h3><p>您可以从保存的搜索中构建可视化文件，也可以输入新的搜索条件。要输入新的搜索条件，首先需要选择一个索引模式来指定要搜索的索引。</p>
<p>默认搜索匹配所有文档。最初，一个“切片”包含整个饼图：</p>
<p><img src="https://www.elastic.co/guide/en/kibana/6.1/images/tutorial-visualize-pie-1.png" alt="https://www.elastic.co/guide/en/kibana/6.1/images/tutorial-visualize-pie-1.png"></p>
<p>要指定在图表中展示哪些数据，请使用 Elasticsearch 存储桶聚合。分组汇总只是将与您的搜索条件相匹配的文档分类到不同的分类中，也称为分组。</p>
<p>为每个范围定义一个存储桶：</p>
<ol>
<li>单击 <code>Split Slices</code>。</li>
<li>在 <code>Aggregation</code> 列表中选择 <code>Terms</code>。_注意：这里的 Terms 是 Elk 采集数据时定义好的字段或标签_。</li>
<li>在 <code>Field</code> 列表中选择 <code>level.keyword</code>。</li>
<li>点击 <img src="https://www.elastic.co/guide/en/kibana/6.1/images/apply-changes-button.png" alt="images/apply-changes-button.png"> 按钮来更新图表。</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/3101171-7fb2042dc6d59520.png" alt="image.png"></p>
<p>完成后，如果想要保存这个图表，可以点击页面最上方一栏中的 <code>Save</code> 按钮。</p>
<h3 id="Vertical-Bar"><a href="#Vertical-Bar" class="headerlink" title="Vertical Bar"></a>Vertical Bar</h3><p>我们在展示一下如何创建柱状图。</p>
<ol>
<li>点击蓝色的 <code>Create a visualization</code> 或 <code>+</code> 按钮。选择 <code>Vertical Bar</code></li>
<li>选择索引模式。由于您尚未定义任何 bucket ，因此您会看到一个大栏，显示与默认通配符查询匹配的文档总数。</li>
<li>指定 Y 轴所代表的字段</li>
<li>指定 X 轴所代表的字段</li>
<li>点击 <img src="https://www.elastic.co/guide/en/kibana/6.1/images/apply-changes-button.png" alt="images/apply-changes-button.png"> 按钮来更新图表。</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/3101171-5aa7627284c19a56.png" alt="image.png"></p>
<p>完成后，如果想要保存这个图表，可以点击页面最上方一栏中的 <code>Save</code> 按钮。</p>
<h2 id="Dashboard"><a href="#Dashboard" class="headerlink" title="Dashboard"></a>Dashboard</h2><p><code>Dashboard</code> 可以整合和共享 <code>Visualize</code> 集合。</p>
<ol>
<li>点击侧面导航栏中的 Dashboard。</li>
<li>点击添加显示保存的可视化列表。</li>
<li>点击之前保存的 <code>Visualize</code>，然后点击列表底部的小向上箭头关闭可视化列表。</li>
<li>将鼠标悬停在可视化对象上会显示允许您编辑，移动，删除和调整可视化对象大小的容器控件。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/92df30/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/92df30/" class="post-title-link" itemprop="url">Logstash 运维</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-16 07:10:44" itemprop="dateCreated datePublished" datetime="2020-06-16T07:10:44+08:00">2020-06-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">搜索引擎数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/Elastic/" itemprop="url" rel="index"><span itemprop="name">Elastic</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>10k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Logstash-运维"><a href="#Logstash-运维" class="headerlink" title="Logstash 运维"></a>Logstash 运维</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/elastic/logstash">Logstash</a> 是开源的服务器端数据处理管道，能够同时从多个来源采集数据，转换数据，然后将数据发送到您最喜欢的“存储库”中。</p>
</blockquote>
<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><h3 id="1-1-安装步骤"><a href="#1-1-安装步骤" class="headerlink" title="1.1. 安装步骤"></a>1.1. 安装步骤</h3><p>安装步骤如下：</p>
<p>（1）在 <a target="_blank" rel="noopener" href="https://www.elastic.co/downloads/logstash">logstash 官方下载地址</a>下载所需版本包并解压到本地。</p>
<p>（2）添加一个 <code>logstash.conf</code> 文件，指定要使用的插件以及每个插件的设置。举个简单的例子：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">input</span> &#123; <span class="keyword">stdin</span> &#123; &#125; &#125;</span><br><span class="line"><span class="keyword">output</span> &#123;</span><br><span class="line">  <span class="keyword">elasticsearch</span> &#123; hosts <span class="operator">=&gt;</span> [<span class="string">&quot;localhost:9200&quot;</span>] &#125;</span><br><span class="line">  <span class="keyword">stdout</span> &#123; codec <span class="operator">=&gt;</span> rubydebug &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）运行 <code>bin/logstash -f logstash.conf</code> （Windows 上运行<code>bin/logstash.bat -f logstash.conf</code>）</p>
<h2 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h2><h3 id="2-1-设置文件"><a href="#2-1-设置文件" class="headerlink" title="2.1. 设置文件"></a>2.1. 设置文件</h3><ul>
<li>**<code>logstash.yml</code>**：logstash 的默认启动配置文件</li>
<li>**<code>jvm.options</code>**：logstash 的 JVM 配置文件。</li>
<li><strong><code>startup.options</code></strong> (Linux)：包含系统安装脚本在 <code>/usr/share/logstash/bin</code> 中使用的选项为您的系统构建适当的启动脚本。安装 Logstash 软件包时，系统安装脚本将在安装过程结束时执行，并使用 <code>startup.options</code> 中指定的设置来设置用户，组，服务名称和服务描述等选项。</li>
</ul>
<h3 id="2-2-logstash-yml-设置项"><a href="#2-2-logstash-yml-设置项" class="headerlink" title="2.2. logstash.yml 设置项"></a>2.2. logstash.yml 设置项</h3><p>节选部分设置项，更多项请参考：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/logstash-settings-file.html">https://www.elastic.co/guide/en/logstash/current/logstash-settings-file.html</a></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td><code>node.name</code></td>
<td>节点名</td>
<td>机器的主机名</td>
</tr>
<tr>
<td><code>path.data</code></td>
<td>Logstash 及其插件用于任何持久性需求的目录。</td>
<td><code>LOGSTASH_HOME/data</code></td>
</tr>
<tr>
<td><code>pipeline.workers</code></td>
<td>同时执行管道的过滤器和输出阶段的工作任务数量。如果发现事件正在备份，或 CPU 未饱和，请考虑增加此数字以更好地利用机器处理能力。</td>
<td>Number of the host’s CPU cores</td>
</tr>
<tr>
<td><code>pipeline.batch.size</code></td>
<td>尝试执行过滤器和输出之前，单个工作线程从输入收集的最大事件数量。较大的批量处理大小一般来说效率更高，但是以增加的内存开销为代价。您可能必须通过设置 <code>LS_HEAP_SIZE</code> 变量来有效使用该选项来增加 JVM 堆大小。</td>
<td><code>125</code></td>
</tr>
<tr>
<td><code>pipeline.batch.delay</code></td>
<td>创建管道事件批处理时，在将一个尺寸过小的批次发送给管道工作任务之前，等待每个事件需要多长时间（毫秒）。</td>
<td><code>5</code></td>
</tr>
<tr>
<td><code>pipeline.unsafe_shutdown</code></td>
<td>如果设置为 true，则即使在内存中仍存在 inflight 事件时，也会强制 Logstash 在关闭期间退出。默认情况下，Logstash 将拒绝退出，直到所有接收到的事件都被推送到输出。启用此选项可能会导致关机期间数据丢失。</td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>path.config</code></td>
<td>主管道的 Logstash 配置路径。如果您指定一个目录或通配符，配置文件将按字母顺序从目录中读取。</td>
<td>Platform-specific. See [<a target="_blank" rel="noopener" href="https://github.com/elastic/logstash/blob/6.1/docs/static/settings-file.asciidoc#dir-layout">dir-layout]</a>.</td>
</tr>
<tr>
<td><code>config.string</code></td>
<td>包含用于主管道的管道配置的字符串。使用与配置文件相同的语法。</td>
<td>None</td>
</tr>
<tr>
<td><code>config.test_and_exit</code></td>
<td>设置为 true 时，检查配置是否有效，然后退出。请注意，使用此设置不会检查 grok 模式的正确性。 Logstash 可以从目录中读取多个配置文件。如果将此设置与 log.level：debug 结合使用，则 Logstash 将记录组合的配置文件，并注掉其源文件的配置块。</td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>config.reload.automatic</code></td>
<td>设置为 true 时，定期检查配置是否已更改，并在配置更改时重新加载配置。这也可以通过 SIGHUP 信号手动触发。</td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>config.reload.interval</code></td>
<td>Logstash 检查配置文件更改的时间间隔。</td>
<td><code>3s</code></td>
</tr>
<tr>
<td><code>config.debug</code></td>
<td>设置为 true 时，将完全编译的配置显示为调试日志消息。您还必须设置<code>log.level：debug</code>。警告：日志消息将包括任何传递给插件配置作为明文的“密码”选项，并可能导致明文密码出现在您的日志！</td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>config.support_escapes</code></td>
<td>当设置为 true 时，带引号的字符串将处理转义字符。</td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>modules</code></td>
<td>配置时，模块必须处于上表所述的嵌套 YAML 结构中。</td>
<td>None</td>
</tr>
<tr>
<td><code>http.host</code></td>
<td>绑定地址</td>
<td><code>&quot;127.0.0.1&quot;</code></td>
</tr>
<tr>
<td><code>http.port</code></td>
<td>绑定端口</td>
<td><code>9600</code></td>
</tr>
<tr>
<td><code>log.level</code></td>
<td>日志级别。有效选项：fatal &gt; error &gt; warn &gt; info &gt; debug &gt; trace</td>
<td><code>info</code></td>
</tr>
<tr>
<td><code>log.format</code></td>
<td>日志格式。json （JSON 格式）或 plain （原对象）</td>
<td><code>plain</code></td>
</tr>
<tr>
<td><code>path.logs</code></td>
<td>Logstash 自身日志的存储路径</td>
<td><code>LOGSTASH_HOME/logs</code></td>
</tr>
<tr>
<td><code>path.plugins</code></td>
<td>在哪里可以找到自定义的插件。您可以多次指定此设置以包含多个路径。</td>
<td></td>
</tr>
</tbody></table>
<h2 id="3-启动"><a href="#3-启动" class="headerlink" title="3. 启动"></a>3. 启动</h2><h3 id="3-1-命令行"><a href="#3-1-命令行" class="headerlink" title="3.1. 命令行"></a>3.1. 命令行</h3><p>通过命令行启动 logstash 的方式如下：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">bin</span>/logstash<span class="meta"> [options]</span></span><br></pre></td></tr></table></figure>

<p>其中 <code>options</code> 是您可以指定用于控制 Logstash 执行的命令行标志。</p>
<p>在命令行上设置的任何标志都会覆盖 Logstash 设置文件（<code>logstash.yml</code>）中的相应设置，但设置文件本身不会更改。</p>
<blockquote>
<p><strong>注</strong></p>
<p>虽然可以通过指定命令行参数的方式，来控制 logstash 的运行方式，但显然这么做很麻烦。</p>
<p>建议通过指定配置文件的方式，来控制 logstash 运行，启动命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/logstash -f logstash.conf</span><br></pre></td></tr></table></figure>

<p>若想了解更多的命令行参数细节，请参考：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/running-logstash-command-line.html">https://www.elastic.co/guide/en/logstash/current/running-logstash-command-line.html</a></p>
</blockquote>
<h3 id="3-2-配置文件"><a href="#3-2-配置文件" class="headerlink" title="3.2. 配置文件"></a>3.2. 配置文件</h3><p>上节，我们了解到，logstash 可以执行 <code>bin/logstash -f logstash.conf</code> ，按照配置文件中的参数去覆盖默认设置文件（<code>logstash.yml</code>）中的设置。</p>
<p>这节，我们就来学习一下这个配置文件如何配置参数。</p>
<h4 id="3-2-1-配置文件结构"><a href="#3-2-1-配置文件结构" class="headerlink" title="3.2.1. 配置文件结构"></a>3.2.1. 配置文件结构</h4><p>在工作原理一节中，我们已经知道了 Logstash 主要有三个工作阶段 input 、filter、output。而 logstash 配置文件文件结构也与之相对应：</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml">input </span><span class="template-variable">&#123;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">filter </span><span class="template-variable">&#123;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">output </span><span class="template-variable">&#123;&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>每个部分都包含一个或多个插件的配置选项。如果指定了多个过滤器，则会按照它们在配置文件中的显示顺序应用它们。</p>
</blockquote>
<h4 id="3-2-2-插件配置"><a href="#3-2-2-插件配置" class="headerlink" title="3.2.2. 插件配置"></a>3.2.2. 插件配置</h4><p>插件的配置由插件名称和插件的一个设置块组成。</p>
<p>下面的例子中配置了两个输入文件配置：</p>
<figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">input</span> &#123;</span><br><span class="line">  file &#123;</span><br><span class="line">    <span class="attr">path</span> =&gt; <span class="string">&quot;/var/log/messages&quot;</span></span><br><span class="line">    <span class="attr">type</span> =&gt; <span class="string">&quot;syslog&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">file</span> &#123;</span><br><span class="line">    <span class="attr">path</span> =&gt; <span class="string">&quot;/var/log/apache/access.log&quot;</span></span><br><span class="line">    <span class="attr">type</span> =&gt; <span class="string">&quot;apache&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您可以配置的设置因插件类型而异。你可以参考： <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/input-plugins.html">Input Plugins</a>, <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/output-plugins.html">Output Plugins</a>, <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/filter-plugins.html">Filter Plugins</a>, 和 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/codec-plugins.html">Codec Plugins</a> 。</p>
<h4 id="3-2-3-值类型"><a href="#3-2-3-值类型" class="headerlink" title="3.2.3. 值类型"></a>3.2.3. 值类型</h4><p>一个插件可以要求设置的值是一个特定的类型，比如布尔值，列表或哈希值。以下值类型受支持。</p>
<ul>
<li>Array</li>
</ul>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">users =&gt; [ &#123;id =&gt; <span class="number">1</span>, name =&gt; bob&#125;, &#123;id =&gt; <span class="number">2</span>, name =&gt; jane&#125; ]</span><br></pre></td></tr></table></figure>

<ul>
<li>Lists</li>
</ul>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">path</span> =&gt; [ <span class="string">&quot;/var/log/messages&quot;</span>, <span class="string">&quot;/var/log/*.log&quot;</span> ]</span><br><span class="line"><span class="attr">uris</span> =&gt; [ <span class="string">&quot;http://elastic.co&quot;</span>, <span class="string">&quot;http://example.net&quot;</span> ]</span><br></pre></td></tr></table></figure>

<ul>
<li>Boolean</li>
</ul>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ssl_enable</span> =&gt; <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Bytes</li>
</ul>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">my_bytes</span> =&gt; <span class="string">&quot;1113&quot;</span>   <span class="comment"># 1113 bytes</span></span><br><span class="line"><span class="attr">my_bytes</span> =&gt; <span class="string">&quot;10MiB&quot;</span>  <span class="comment"># 10485760 bytes</span></span><br><span class="line"><span class="attr">my_bytes</span> =&gt; <span class="string">&quot;100kib&quot;</span> <span class="comment"># 102400 bytes</span></span><br><span class="line"><span class="attr">my_bytes</span> =&gt; <span class="string">&quot;180 mb&quot;</span> <span class="comment"># 180000000 bytes</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Codec</li>
</ul>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">codec</span> <span class="operator">=</span>&gt; <span class="string">&quot;json&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Hash</li>
</ul>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">match</span> <span class="operator">=</span>&gt; &#123;</span><br><span class="line">  <span class="string">&quot;field1&quot;</span> <span class="operator">=</span>&gt; <span class="string">&quot;value1&quot;</span></span><br><span class="line">  <span class="string">&quot;field2&quot;</span> <span class="operator">=</span>&gt; <span class="string">&quot;value2&quot;</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Number</li>
</ul>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">port</span> <span class="operator">=</span>&gt; <span class="number">33</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Password</li>
</ul>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">my_password</span> =&gt; <span class="string">&quot;password&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>URI</li>
</ul>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">my_uri</span> =&gt; <span class="string">&quot;http://foo:bar@example.net&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Path</li>
</ul>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">my_path</span> =&gt; <span class="string">&quot;/tmp/logstash&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>String</p>
</li>
<li><p>转义字符</p>
</li>
</ul>
<h2 id="4-插件"><a href="#4-插件" class="headerlink" title="4. 插件"></a>4. 插件</h2><h3 id="4-1-input"><a href="#4-1-input" class="headerlink" title="4.1. input"></a>4.1. input</h3><blockquote>
<p>Logstash 支持各种输入选择 ，可以在同一时间从众多常用来源捕捉事件。能够以连续的流式传输方式，轻松地从您的日志、指标、Web 应用、数据存储以及各种 AWS 服务采集数据。</p>
</blockquote>
<h4 id="4-1-1-常用-input-插件"><a href="#4-1-1-常用-input-插件" class="headerlink" title="4.1.1. 常用 input 插件"></a>4.1.1. 常用 input 插件</h4><ul>
<li><strong>file</strong>：从文件系统上的文件读取，就像 UNIX 命令 <code>tail -0F</code> 一样</li>
<li><strong>syslog：</strong>在众所周知的端口 514 上侦听系统日志消息，并根据 RFC3164 格式进行解析</li>
<li><strong>redis：</strong>从 redis 服务器读取，使用 redis 通道和 redis 列表。 Redis 经常用作集中式 Logstash 安装中的“代理”，它将来自远程 Logstash“托运人”的 Logstash 事件排队。</li>
<li><strong>beats：</strong>处理由 Filebeat 发送的事件。</li>
</ul>
<p>更多详情请见：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/input-plugins.html">Input Plugins</a></p>
<h3 id="4-2-filter"><a href="#4-2-filter" class="headerlink" title="4.2. filter"></a>4.2. filter</h3><blockquote>
<p>过滤器是 Logstash 管道中的中间处理设备。如果符合特定条件，您可以将条件过滤器组合在一起，对事件执行操作。</p>
</blockquote>
<h4 id="4-2-1-常用-filter-插件"><a href="#4-2-1-常用-filter-插件" class="headerlink" title="4.2.1. 常用 filter 插件"></a>4.2.1. 常用 filter 插件</h4><ul>
<li><p><strong>grok：</strong>解析和结构任意文本。 Grok 目前是 Logstash 中将非结构化日志数据解析为结构化和可查询的最佳方法。</p>
</li>
<li><p><strong>mutate：</strong>对事件字段执行一般转换。您可以重命名，删除，替换和修改事件中的字段。</p>
</li>
<li><p><strong>drop：</strong>完全放弃一个事件，例如调试事件。</p>
</li>
<li><p><strong>clone：</strong>制作一个事件的副本，可能会添加或删除字段。</p>
</li>
<li><p><strong>geoip：</strong>添加有关 IP 地址的地理位置的信息（也可以在 Kibana 中显示惊人的图表！）</p>
</li>
</ul>
<p>更多详情请见：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/filter-plugins.html">Filter Plugins</a></p>
<h3 id="4-3-output"><a href="#4-3-output" class="headerlink" title="4.3. output"></a>4.3. output</h3><blockquote>
<p>输出是 Logstash 管道的最后阶段。一个事件可以通过多个输出，但是一旦所有输出处理完成，事件就完成了执行。</p>
</blockquote>
<h4 id="4-3-1-常用-output-插件"><a href="#4-3-1-常用-output-插件" class="headerlink" title="4.3.1. 常用 output 插件"></a>4.3.1. 常用 output 插件</h4><ul>
<li><strong>elasticsearch：</strong>将事件数据发送给 Elasticsearch（推荐模式）。</li>
<li><strong>file：</strong>将事件数据写入文件或磁盘。</li>
<li><strong>graphite：</strong>将事件数据发送给 graphite（一个流行的开源工具，存储和绘制指标。 <a target="_blank" rel="noopener" href="http://graphite.readthedocs.io/en/latest/%EF%BC%89%E3%80%82">http://graphite.readthedocs.io/en/latest/）。</a></li>
<li><strong>statsd：</strong>将事件数据发送到 statsd （这是一种侦听统计数据的服务，如计数器和定时器，通过 UDP 发送并将聚合发送到一个或多个可插入的后端服务）。</li>
</ul>
<p>更多详情请见：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/output-plugins.html">Output Plugins</a></p>
<h3 id="4-4-codec"><a href="#4-4-codec" class="headerlink" title="4.4. codec"></a>4.4. codec</h3><p>用于格式化对应的内容。</p>
<h4 id="4-4-1-常用-codec-插件"><a href="#4-4-1-常用-codec-插件" class="headerlink" title="4.4.1. 常用 codec 插件"></a>4.4.1. 常用 codec 插件</h4><ul>
<li><strong>json：</strong>以 JSON 格式对数据进行编码或解码。</li>
<li><strong>multiline：</strong>将多行文本事件（如 java 异常和堆栈跟踪消息）合并为单个事件。</li>
</ul>
<p>更多插件请见：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/codec-plugins.html">Codec Plugins</a></p>
<h2 id="5-实战"><a href="#5-实战" class="headerlink" title="5. 实战"></a>5. 实战</h2><p>前面的内容都是对 Logstash 的介绍和原理说明。接下来，我们来实战一些常见的应用场景。</p>
<h3 id="5-1-传输控制台数据"><a href="#5-1-传输控制台数据" class="headerlink" title="5.1. 传输控制台数据"></a>5.1. 传输控制台数据</h3><blockquote>
<p>stdin input 插件从标准输入读取事件。这是最简单的 input 插件，一般用于测试场景。</p>
</blockquote>
<p><strong>应用</strong></p>
<p>（1）创建 <code>logstash-input-stdin.conf</code> ：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">input</span> &#123; <span class="keyword">stdin</span> &#123; &#125; &#125;</span><br><span class="line"><span class="keyword">output</span> &#123;</span><br><span class="line">  <span class="keyword">elasticsearch</span> &#123; hosts <span class="operator">=&gt;</span> [<span class="string">&quot;localhost:9200&quot;</span>] &#125;</span><br><span class="line">  <span class="keyword">stdout</span> &#123; codec <span class="operator">=&gt;</span> rubydebug &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多配置项可以参考：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/plugins-inputs-stdin.html">https://www.elastic.co/guide/en/logstash/current/plugins-inputs-stdin.html</a></p>
<p>（2）执行 logstash，使用 <code>-f</code> 来指定你的配置文件：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/logstash -f logstash-<span class="built_in">input</span>-<span class="built_in">stdin</span>.conf</span><br></pre></td></tr></table></figure>

<h3 id="5-2-传输-logback-日志"><a href="#5-2-传输-logback-日志" class="headerlink" title="5.2. 传输 logback 日志"></a>5.2. 传输 logback 日志</h3><blockquote>
<p>elk 默认使用的 Java 日志工具是 log4j2 ，并不支持 logback 和 log4j。</p>
<p>想使用 logback + logstash ，可以使用 <a target="_blank" rel="noopener" href="https://github.com/logstash/logstash-logback-encoder">logstash-logback-encoder</a> 。<a target="_blank" rel="noopener" href="https://github.com/logstash/logstash-logback-encoder">logstash-logback-encoder</a> 提供了 UDP &#x2F; TCP &#x2F; 异步方式来传输日志数据到 logstash。</p>
<p>如果你使用的是 log4j ，也不是不可以用这种方式，只要引入桥接 jar 包即可。如果你对 log4j 、logback ，或是桥接 jar 包不太了解，可以参考我的这篇博文：<a target="_blank" rel="noopener" href="https://github.com/dunwu/JavaStack/blob/master/docs/javalib/java-log.md">细说 Java 主流日志工具库</a> 。</p>
</blockquote>
<h4 id="5-2-1-TCP-应用"><a href="#5-2-1-TCP-应用" class="headerlink" title="5.2.1. TCP 应用"></a>5.2.1. TCP 应用</h4><p>logstash 配置：</p>
<p>（1）创建 <code>logstash-input-tcp.conf</code> ：</p>
<figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">input</span> &#123;</span><br><span class="line">  <span class="comment"># stdin &#123; &#125;</span></span><br><span class="line">  tcp &#123;</span><br><span class="line">    <span class="comment"># host:port就是上面appender中的 destination，</span></span><br><span class="line"> <span class="comment"># 这里其实把logstash作为服务，开启9250端口接收logback发出的消息</span></span><br><span class="line">    <span class="attr">host</span> =&gt; <span class="string">&quot;127.0.0.1&quot;</span> <span class="attr">port</span> =&gt; <span class="number">9250</span> <span class="attr">mode</span> =&gt; <span class="string">&quot;server&quot;</span> <span class="attr">tags</span> =&gt; [<span class="string">&quot;tags&quot;</span>] <span class="attr">codec</span> =&gt; json_lines</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">output</span> &#123;</span><br><span class="line">  elasticsearch &#123; <span class="attr">hosts</span> =&gt; [<span class="string">&quot;localhost:9200&quot;</span>] &#125;</span><br><span class="line">  <span class="keyword">stdout</span> &#123; <span class="attr">codec</span> =&gt; rubydebug &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多配置项可以参考：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/plugins-inputs-tcp.html">https://www.elastic.co/guide/en/logstash/current/plugins-inputs-tcp.html</a></p>
<p>（2）执行 logstash，使用 <code>-f</code> 来指定你的配置文件：<code>bin/logstash -f logstash-input-udp.conf</code></p>
<p>java 应用配置：</p>
<p>（1）在 Java 应用的 pom.xml 中引入 jar 包：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.logstash.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logstash-logback-encoder<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- logback 依赖包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-access<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）接着，在 logback.xml 中添加 appender</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;ELK-TCP&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.logstash.logback.appender.LogstashTcpSocketAppender&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> destination 是 logstash 服务的 host:port，</span></span><br><span class="line"><span class="comment"> 相当于和 logstash 建立了管道，将日志数据定向传输到 logstash</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">destination</span>&gt;</span>192.168.28.32:9251<span class="tag">&lt;/<span class="name">destination</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.logstash.logback.encoder.LogstashEncoder&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;io.github.dunwu.spring&quot;</span> <span class="attr">level</span>=<span class="string">&quot;TRACE&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ELK-TCP&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>大功告成，此后，<code>io.github.dunwu.spring</code> 包中的 TRACE 及以上级别的日志信息都会被定向输出到 logstash 服务。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3101171-cd876d79a14955b0.png" alt="img"></p>
<p>接下来，就是 logback 的具体使用 ，如果对此不了解，不妨参考一下我的这篇博文：<a target="_blank" rel="noopener" href="https://github.com/dunwu/JavaStack/blob/master/docs/javalib/java-log.md">细说 Java 主流日志工具库</a> 。</p>
<p><strong>实例：</strong><a target="_blank" rel="noopener" href="https://github.com/dunwu/JavaStack/blob/master/codes/javatool/src/main/resources/logback.xml">我的 logback.xml</a></p>
<h4 id="5-2-2-UDP-应用"><a href="#5-2-2-UDP-应用" class="headerlink" title="5.2.2. UDP 应用"></a>5.2.2. UDP 应用</h4><p>UDP 和 TCP 的使用方式大同小异。</p>
<p>logstash 配置：</p>
<p>（1）创建 <code>logstash-input-udp.conf</code> ：</p>
<figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">input</span> &#123;</span><br><span class="line">udp &#123;</span><br><span class="line">  <span class="attr">port</span> =&gt; <span class="number">9250</span></span><br><span class="line">  <span class="attr">codec</span> =&gt; json</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">output</span> &#123;</span><br><span class="line"> elasticsearch &#123; <span class="attr">hosts</span> =&gt; [<span class="string">&quot;localhost:9200&quot;</span>] &#125;</span><br><span class="line"> <span class="keyword">stdout</span> &#123; <span class="attr">codec</span> =&gt; rubydebug &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多配置项可以参考：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/plugins-inputs-udp.html">https://www.elastic.co/guide/en/logstash/current/plugins-inputs-udp.html</a></p>
<p>（2）执行 logstash，使用 <code>-f</code> 来指定你的配置文件：<code>bin/logstash -f logstash-input-udp.conf</code></p>
<p>java 应用配置：</p>
<p>（1）在 Java 应用的 pom.xml 中引入 jar 包：</p>
<p>与 <strong>TCP 应用</strong> 一节中的引入依赖包完全相同。</p>
<p>（2）接着，在 logback.xml 中添加 appender</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;ELK-UDP&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.logstash.logback.appender.LogstashSocketAppender&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">host</span>&gt;</span>192.168.28.32<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span>&gt;</span>9250<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;io.github.dunwu.spring&quot;</span> <span class="attr">level</span>=<span class="string">&quot;TRACE&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ELK-UDP&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（3）接下来，就是 logback 的具体使用 ，如果对此不了解，不妨参考一下我的这篇博文：<a target="_blank" rel="noopener" href="https://github.com/dunwu/JavaStack/blob/master/docs/javalib/java-log.md">细说 Java 主流日志工具库</a> 。</p>
<p><strong>实例：</strong><a target="_blank" rel="noopener" href="https://github.com/dunwu/JavaStack/blob/master/codes/javatool/src/main/resources/logback.xml">我的 logback.xml</a></p>
<h3 id="5-3-传输文件"><a href="#5-3-传输文件" class="headerlink" title="5.3. 传输文件"></a>5.3. 传输文件</h3><blockquote>
<p>在 Java Web 领域，需要用到一些重要的工具，例如 Tomcat 、Nginx 、Mysql 等。这些不属于业务应用，但是它们的日志数据对于定位问题、分析统计同样很重要。这时无法使用 logback 方式将它们的日志传输到 logstash。</p>
<p>如何采集这些日志文件呢？别急，你可以使用 logstash 的 file input 插件。</p>
<p>需要注意的是，传输文件这种方式，必须在日志所在的机器上部署 logstash 。</p>
</blockquote>
<p><strong>应用</strong></p>
<p>logstash 配置</p>
<p>（1）创建 <code>logstash-input-file.conf</code> ：</p>
<figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">input</span> &#123;</span><br><span class="line"> file &#123;</span><br><span class="line">  <span class="attr">path</span> =&gt; [<span class="string">&quot;/var/log/nginx/access.log&quot;</span>]</span><br><span class="line">  <span class="attr">type</span> =&gt; <span class="string">&quot;nginx-access-log&quot;</span></span><br><span class="line">  <span class="attr">start_position</span> =&gt; <span class="string">&quot;beginning&quot;</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">output</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> [<span class="built_in">type</span>] == <span class="string">&quot;nginx-access-log&quot;</span> &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">   <span class="attr">hosts</span> =&gt; [<span class="string">&quot;localhost:9200&quot;</span>]</span><br><span class="line">   <span class="attr">index</span> =&gt; <span class="string">&quot;nginx-access-log&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）执行 logstash，使用 <code>-f</code> 来指定你的配置文件：<code>bin/logstash -f logstash-input-file.conf</code></p>
<p>更多配置项可以参考：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/plugins-inputs-file.html">https://www.elastic.co/guide/en/logstash/current/plugins-inputs-file.html</a></p>
<h2 id="6-小技巧"><a href="#6-小技巧" class="headerlink" title="6. 小技巧"></a>6. 小技巧</h2><h3 id="6-1-启动、终止应用"><a href="#6-1-启动、终止应用" class="headerlink" title="6.1. 启动、终止应用"></a>6.1. 启动、终止应用</h3><p>如果你的 logstash 每次都是通过指定配置文件方式启动。不妨建立一个启动脚本。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd xxx 进入 logstash 安装目录下的 bin 目录</span></span><br><span class="line"><span class="attribute">logstash</span> -f logstash.conf</span><br></pre></td></tr></table></figure>

<p>如果你的 logstash 运行在 linux 系统下，不妨使用 nohup 来启动一个守护进程。这样做的好处在于，即使关闭终端，应用仍会运行。</p>
<p>创建 startup.sh：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">nohup</span> ./logstash -f logstash.conf &gt;&gt; nohup.out <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</span><br></pre></td></tr></table></figure>

<p>终止应用没有什么好方法，你只能使用 ps -ef | grep logstash ，查出进程，将其 kill 。不过，我们可以写一个脚本来干这件事：</p>
<p>创建 shutdown.sh：</p>
<p>脚本不多解释，请自行领会作用。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">PID</span>=`ps -ef | grep logstash | awk &#x27;&#123; print $<span class="number">2</span>&#125;&#x27; | head -n <span class="number">1</span>`</span><br><span class="line"><span class="attribute">kill</span> -<span class="number">9</span> <span class="variable">$&#123;PID&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="7-参考资料"><a href="#7-参考资料" class="headerlink" title="7. 参考资料"></a>7. 参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/cn/products/logstash">Logstash 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/elastic/logstash">Logstash Github</a></li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/index.html">Logstash 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/logstash/logstash-logback-encoder">logstash-logback-encoder</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/chenryn/logstash-best-practice-cn">ELK Stack 权威指南</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/judasn/Linux-Tutorial/blob/master/ELK-Install-And-Settings.md">ELK（Elasticsearch、Logstash、Kibana）安装和配置</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/fc47af/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/fc47af/" class="post-title-link" itemprop="url">Kibana 运维</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-16 07:10:44" itemprop="dateCreated datePublished" datetime="2020-06-16T07:10:44+08:00">2020-06-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">搜索引擎数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/Elastic/" itemprop="url" rel="index"><span itemprop="name">Elastic</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Kibana-运维"><a href="#Kibana-运维" class="headerlink" title="Kibana 运维"></a>Kibana 运维</h1><blockquote>
<p>通过 Kibana，您可以对自己的 Elasticsearch 进行可视化，还可以在 Elastic Stack 中进行导航，这样您便可以进行各种操作了，从跟踪查询负载，到理解请求如何流经您的整个应用，都能轻松完成。</p>
</blockquote>
<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><h3 id="1-1-环境要求"><a href="#1-1-环境要求" class="headerlink" title="1.1. 环境要求"></a>1.1. 环境要求</h3><blockquote>
<p>版本：Elastic Stack 7.4</p>
</blockquote>
<h3 id="1-2-安装步骤"><a href="#1-2-安装步骤" class="headerlink" title="1.2. 安装步骤"></a>1.2. 安装步骤</h3><p>安装步骤如下：</p>
<ol>
<li>在 <a target="_blank" rel="noopener" href="https://www.elastic.co/downloads/kibana">kibana 官方下载地址</a>下载所需版本包并解压到本地。</li>
<li>修改 <code>config/kibana.yml</code> 配置文件，设置 <code>elasticsearch.url</code> 指向 Elasticsearch 实例。</li>
<li>运行 <code>bin/kibana</code> （Windows 上运行 <code>bin\kibana.bat</code>）</li>
<li>在浏览器上访问 <a target="_blank" rel="noopener" href="http://localhost:5601/">http://localhost:5601</a></li>
</ol>
<h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h2><h3 id="2-1-检索"><a href="#2-1-检索" class="headerlink" title="2.1. 检索"></a>2.1. 检索</h3><p>单击侧面导航栏中的 <code>检索（Discover）</code> ，可以显示 <code>Kibana</code> 的数据查询功能功能。</p>
<p><img src="https://www.elastic.co/guide/en/kibana/current/images/tutorial-discover.png" alt="img"></p>
<p>在搜索栏中，您可以输入 Elasticsearch 查询条件来搜索您的数据。您可以在 <code>Discover</code> 页面中浏览结果并在 <code>Visualize</code> 页面中创建已保存搜索条件的可视化。</p>
<p>当前索引模式显示在查询栏下方。索引模式确定提交查询时搜索哪些索引。要搜索一组不同的索引，请从下拉菜单中选择不同的模式。要添加索引模式（index pattern），请转至 <code>Management/Kibana/Index Patterns</code> 并单击 <code>Add New</code>。</p>
<p>您可以使用字段名称和您感兴趣的值构建搜索。对于数字字段，可以使用比较运算符，如大于（&gt;），小于（&lt;）或等于（&#x3D;）。您可以将元素与逻辑运算符 <code>AND</code>，<code>OR</code> 和 <code>NOT</code> 链接，全部使用大写。</p>
<p>默认情况下，每个匹配文档都显示所有字段。要选择要显示的文档字段，请将鼠标悬停在“可用字段”列表上，然后单击要包含的每个字段旁边的添加按钮。例如，如果只添加 account_number，则显示将更改为包含五个帐号的简单列表：</p>
<p><img src="https://www.elastic.co/guide/en/kibana/6.1/images/tutorial-discover-3.png" alt="img"></p>
<p>kibana 的搜索栏遵循 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-query-string-query.html#query-string-syntax">query-string-syntax</a> 文档中所说明的查询语义。</p>
<p>这里说明一些最基本的查询语义。</p>
<p>查询字符串会被解析为一系列的术语和运算符。一个术语可以是一个单词（如：quick、brown）或用双引号包围的短语（如”quick brown”）。</p>
<p>查询操作允许您自定义搜索 - 下面介绍了可用的选项。</p>
<h4 id="2-1-1-字段名称"><a href="#2-1-1-字段名称" class="headerlink" title="2.1.1. 字段名称"></a>2.1.1. 字段名称</h4><p>正如查询字符串查询中所述，将在搜索条件中搜索 default_field，但可以在查询语法中指定其他字段：</p>
<p>例如：</p>
<ul>
<li>查询 <code>status</code> 字段中包含 <code>active</code> 关键字</li>
</ul>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">status:</span>active</span><br></pre></td></tr></table></figure>

<ul>
<li><code>title</code> 字段包含 <code>quick</code> 或 <code>brown</code> 关键字。如果您省略 <code>OR</code> 运算符，则将使用默认运算符</li>
</ul>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">title:</span>(quick <span class="keyword">OR</span> brown)</span><br><span class="line"><span class="symbol">title:</span>(quick brown)</span><br></pre></td></tr></table></figure>

<ul>
<li>author 字段查找精确的短语 “john smith”，即精确查找。</li>
</ul>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">author:</span><span class="string">&quot;John Smith&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>任意字段 <code>book.title</code>，<code>book.content</code> 或 <code>book.date</code> 都包含 <code>quick</code> 或 <code>brown</code>（注意我们需要如何使用 <code>\*</code> 表示通配符）</li>
</ul>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">book.\*:(quick brown)</span><br></pre></td></tr></table></figure>

<ul>
<li>title 字段包含任意非 null 值</li>
</ul>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">_exists_</span>:title</span><br></pre></td></tr></table></figure>

<h4 id="2-1-2-通配符"><a href="#2-1-2-通配符" class="headerlink" title="2.1.2. 通配符"></a>2.1.2. 通配符</h4><p>ELK 提供了 ? 和 * 两个通配符。</p>
<ul>
<li><code>?</code> 表示任意单个字符；</li>
<li><code>*</code> 表示任意零个或多个字符。</li>
</ul>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">qu</span>?ck <span class="keyword">bro</span>*</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：通配符查询会使用大量的内存并且执行性能较为糟糕，所以请慎用。</strong> &gt; <strong>提示</strong>：纯通配符 * 被写入 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-exists-query.html">exsits</a> 查询，从而提高了查询效率。因此，通配符 <code>field：*</code> 将匹配包含空值的文档，如：<code>&#123;“field”：“”&#125;</code>，但是如果字段丢失或显示将值置为 null 则不匹配，如：<code>“field”：null&#125;</code> &gt; <strong>提示</strong>：在一个单词的开头（例如：<code>*ing</code>）使用通配符这种方式的查询量特别大，因为索引中的所有术语都需要检查，以防万一匹配。通过将 <code>allow_leading_wildcard</code> 设置为 <code>false</code>，可以禁用。</p>
</blockquote>
<h4 id="2-1-3-正则表达式"><a href="#2-1-3-正则表达式" class="headerlink" title="2.1.3. 正则表达式"></a>2.1.3. 正则表达式</h4><p>可以通过 <code>/</code> 将正则表达式包裹在查询字符串中进行查询</p>
<p>例：</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">na</span><span class="symbol">me:</span>/joh?<span class="built_in">n</span>(<span class="comment">ath[oa]n</span>)/</span><br></pre></td></tr></table></figure>

<p>支持的正则表达式语义可以参考：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html#regexp-syntax">Regular expression syntax</a></p>
<h4 id="2-1-4-模糊查询"><a href="#2-1-4-模糊查询" class="headerlink" title="2.1.4. 模糊查询"></a>2.1.4. 模糊查询</h4><p>我们可以使用 <code>~</code> 运算符来进行模糊查询。</p>
<p>例：</p>
<p>假设我们实际想查询</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">quick brown forks</span></span><br></pre></td></tr></table></figure>

<p>但是，由于拼写错误，我们的查询关键字变成如下情况，依然可以查到想要的结果。</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quikc<span class="string">\~</span> brwn<span class="string">\~</span> foks<span class="string">\~</span></span><br></pre></td></tr></table></figure>

<p>这种模糊查询使用 Damerau-Levenshtein 距离来查找所有匹配最多两个更改的项。所谓的更改是指单个字符的插入，删除或替换，或者两个相邻字符的换位。</p>
<p>默认编辑距离为 <code>2</code>，但编辑距离为 <code>1</code> 应足以捕捉所有人类拼写错误的 80％。它可以被指定为：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">quikc</span>\~<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="2-1-5-近似检索"><a href="#2-1-5-近似检索" class="headerlink" title="2.1.5. 近似检索"></a>2.1.5. 近似检索</h4><p>尽管短语查询（例如，<code>john smith</code>）期望所有的词条都是完全相同的顺序，但是近似查询允许指定的单词进一步分开或以不同的顺序排列。与模糊查询可以为单词中的字符指定最大编辑距离一样，近似搜索也允许我们指定短语中单词的最大编辑距离：</p>
<p>例</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;fox quick&quot;</span><span class="string">\~5</span></span><br></pre></td></tr></table></figure>

<p>字段中的文本越接近查询字符串中指定的原始顺序，该文档就越被认为是相关的。当与上面的示例查询相比时，短语 <code>&quot;quick fox&quot;</code> 将被认为比 <code>&quot;quick brown fox&quot;</code> 更近似查询条件。</p>
<h4 id="2-1-6-范围"><a href="#2-1-6-范围" class="headerlink" title="2.1.6. 范围"></a>2.1.6. 范围</h4><p>可以为日期，数字或字符串字段指定范围。闭区间范围用方括号 <code>[min TO max]</code> 和开区间范围用花括号 <code>&#123;min TO max&#125;</code> 来指定。</p>
<p>我们不妨来看一些示例。</p>
<ul>
<li>2012 年的所有日子</li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">date</span>:[<span class="number">2012</span>-<span class="number">01</span>-<span class="number">01</span> TO <span class="number">2012</span>-<span class="number">12</span>-<span class="number">31</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>数字 1 到 5</li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">count</span>:[<span class="number">1</span> TO <span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>alpha</code> 和 <code>omega</code> 之间的标签，不包括 <code>alpha</code> 和 <code>omega</code></li>
</ul>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">tags:</span>&#123;alpha TO omega&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>10 以上的数字</li>
</ul>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">count</span>:[<span class="number">10</span> <span class="keyword">TO</span> *]</span><br></pre></td></tr></table></figure>

<ul>
<li>2012 年以前的所有日期</li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">date</span>:&#123;* TO <span class="number">2012</span>-<span class="number">01</span>-<span class="number">01</span>&#125;</span><br></pre></td></tr></table></figure>

<p>此外，开区间和闭区间也可以组合使用</p>
<ul>
<li>数组 1 到 5，但不包括 5</li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">count</span>:[<span class="number">1</span> TO <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>

<p>一边无界的范围也可以使用以下语法：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">age</span>:&gt;<span class="number">10</span></span><br><span class="line"><span class="attribute">age</span>:&gt;=<span class="number">10</span></span><br><span class="line"><span class="attribute">age</span>:&lt;<span class="number">10</span></span><br><span class="line"><span class="attribute">age</span>:&lt;=<span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>当然，你也可以使用 AND 运算符来得到连个查询结果的交集</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">age</span>:(&gt;=<span class="number">10</span> AND &lt;<span class="number">20</span>)</span><br><span class="line"><span class="attribute">age</span>:(+&gt;=<span class="number">10</span> +&lt;<span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<h4 id="2-1-7-Boosting"><a href="#2-1-7-Boosting" class="headerlink" title="2.1.7. Boosting"></a>2.1.7. Boosting</h4><p>使用操作符 <code>^</code> 使一个术语比另一个术语更相关。例如，如果我们想查找所有有关狐狸的文档，但我们对狐狸特别感兴趣：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">quick</span>^<span class="number">2</span> fox</span><br></pre></td></tr></table></figure>

<p>默认提升值是 1，但可以是任何正浮点数。 0 到 1 之间的提升减少了相关性。</p>
<p>增强也可以应用于短语或组：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;john smith&quot;</span>^<span class="number">2</span>   <span class="comment">(foo bar)</span>^<span class="number">4</span></span><br></pre></td></tr></table></figure>

<h4 id="2-1-8-布尔操作"><a href="#2-1-8-布尔操作" class="headerlink" title="2.1.8. 布尔操作"></a>2.1.8. 布尔操作</h4><p>默认情况下，只要一个词匹配，所有词都是可选的。搜索 <code>foo bar baz</code> 将查找包含 <code>foo</code> 或 <code>bar</code> 或 <code>baz</code> 中的一个或多个的任何文档。我们已经讨论了上面的<code>default_operator</code>，它允许你强制要求所有的项，但也有布尔运算符可以在查询字符串本身中使用，以提供更多的控制。</p>
<p>首选的操作符是 <code>+</code>（此术语必须存在）和 <code>-</code> （此术语不得存在）。所有其他条款是可选的。例如，这个查询：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quick <span class="keyword">brown </span>+fox -news</span><br></pre></td></tr></table></figure>

<p>这条查询意味着：</p>
<ul>
<li>fox 必须存在</li>
<li>news 必须不存在</li>
<li>quick 和 brown 是可有可无的</li>
</ul>
<p>熟悉的运算符 <code>AND</code>，<code>OR</code> 和 <code>NOT</code>（也写成 <code>&amp;&amp;</code>，<code>||</code> 和 <code>!</code>）也被支持。然而，这些操作符有一定的优先级：<code>NOT</code> 优先于 <code>AND</code>，<code>AND</code> 优先于 <code>OR</code>。虽然 <code>+</code> 和 <code>-</code> 仅影响运算符右侧的术语，但 <code>AND</code> 和 <code>OR</code> 会影响左侧和右侧的术语。</p>
<h4 id="2-1-9-分组"><a href="#2-1-9-分组" class="headerlink" title="2.1.9. 分组"></a>2.1.9. 分组</h4><p>多个术语或子句可以用圆括号组合在一起，形成子查询</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(quick <span class="keyword">OR </span><span class="keyword">brown) </span><span class="keyword">AND </span>fox</span><br></pre></td></tr></table></figure>

<p>可以使用组来定位特定的字段，或者增强子查询的结果：</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stat<span class="symbol">us:</span>(active <span class="built_in">OR</span> pending) tit<span class="symbol">le:</span>(full <span class="built_in">text</span> <span class="built_in">search</span>)^<span class="number">2</span></span><br></pre></td></tr></table></figure>

<h4 id="2-1-10-保留字"><a href="#2-1-10-保留字" class="headerlink" title="2.1.10. 保留字"></a>2.1.10. 保留字</h4><p>如果你需要使用任何在你的查询本身中作为操作符的字符（而不是作为操作符），那么你应该用一个反斜杠来转义它们。例如，要搜索（1 + 1）&#x3D; 2，您需要将查询写为 <code>\(1\+1\)\=2</code></p>
<p>保留字符是：<code>+ - = &amp;&amp; || &gt; &lt; ! ( ) &#123; &#125; [ ] ^ &quot; ~ * ? : \ /</code></p>
<p>无法正确地转义这些特殊字符可能会导致语法错误，从而阻止您的查询运行。</p>
<h4 id="2-1-11-空查询"><a href="#2-1-11-空查询" class="headerlink" title="2.1.11. 空查询"></a>2.1.11. 空查询</h4><p>如果查询字符串为空或仅包含空格，则查询将生成一个空的结果集。</p>
<h3 id="2-2-可视化"><a href="#2-2-可视化" class="headerlink" title="2.2. 可视化"></a>2.2. 可视化</h3><p>要想使用可视化的方式展示您的数据，请单击侧面导航栏中的 <code>可视化（Visualize）</code>。</p>
<p>Visualize 工具使您能够以多种方式（如饼图、柱状图、曲线图、分布图等）查看数据。要开始使用，请点击蓝色的 <code>Create a visualization</code> 或 <code>+</code> 按钮。</p>
<p><img src="https://www.elastic.co/guide/en/kibana/6.1/images/tutorial-visualize-landing.png" alt="https://www.elastic.co/guide/en/kibana/6.1/images/tutorial-visualize-landing.png"></p>
<p>有许多可视化类型可供选择。</p>
<p><img src="https://www.elastic.co/guide/en/kibana/6.1/images/tutorial-visualize-wizard-step-1.png" alt="https://www.elastic.co/guide/en/kibana/6.1/images/tutorial-visualize-wizard-step-1.png"></p>
<p>下面，我们来看创建几个图标示例：</p>
<h4 id="2-2-1-Pie"><a href="#2-2-1-Pie" class="headerlink" title="2.2.1. Pie"></a>2.2.1. Pie</h4><p>您可以从保存的搜索中构建可视化文件，也可以输入新的搜索条件。要输入新的搜索条件，首先需要选择一个索引模式来指定要搜索的索引。</p>
<p>默认搜索匹配所有文档。最初，一个“切片”包含整个饼图：</p>
<p><img src="https://www.elastic.co/guide/en/kibana/6.1/images/tutorial-visualize-pie-1.png" alt="https://www.elastic.co/guide/en/kibana/6.1/images/tutorial-visualize-pie-1.png"></p>
<p>要指定在图表中展示哪些数据，请使用 Elasticsearch 存储桶聚合。分组汇总只是将与您的搜索条件相匹配的文档分类到不同的分类中，也称为分组。</p>
<p>为每个范围定义一个存储桶：</p>
<ol>
<li>单击 <code>Split Slices</code>。</li>
<li>在 <code>Aggregation</code> 列表中选择 <code>Terms</code>。_注意：这里的 Terms 是 Elk 采集数据时定义好的字段或标签_。</li>
<li>在 <code>Field</code> 列表中选择 <code>level.keyword</code>。</li>
<li>点击 <img src="https://www.elastic.co/guide/en/kibana/6.1/images/apply-changes-button.png" alt="images/apply-changes-button.png"> 按钮来更新图表。</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/3101171-7fb2042dc6d59520.png" alt="image.png"></p>
<p>完成后，如果想要保存这个图表，可以点击页面最上方一栏中的 <code>Save</code> 按钮。</p>
<h4 id="2-2-2-Vertical-Bar"><a href="#2-2-2-Vertical-Bar" class="headerlink" title="2.2.2. Vertical Bar"></a>2.2.2. Vertical Bar</h4><p>我们在展示一下如何创建柱状图。</p>
<ol>
<li>点击蓝色的 <code>Create a visualization</code> 或 <code>+</code> 按钮。选择 <code>Vertical Bar</code></li>
<li>选择索引模式。由于您尚未定义任何 bucket ，因此您会看到一个大栏，显示与默认通配符查询匹配的文档总数。</li>
<li>指定 Y 轴所代表的字段</li>
<li>指定 X 轴所代表的字段</li>
<li>点击 <img src="https://www.elastic.co/guide/en/kibana/6.1/images/apply-changes-button.png" alt="images/apply-changes-button.png"> 按钮来更新图表。</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/3101171-5aa7627284c19a56.png" alt="image.png"></p>
<p>完成后，如果想要保存这个图表，可以点击页面最上方一栏中的 <code>Save</code> 按钮。</p>
<h3 id="2-3-报表"><a href="#2-3-报表" class="headerlink" title="2.3. 报表"></a>2.3. 报表</h3><p><code>报表（Dashboard）</code> 可以整合和共享 <code>Visualize</code> 集合。</p>
<ol>
<li>点击侧面导航栏中的 Dashboard。</li>
<li>点击添加显示保存的可视化列表。</li>
<li>点击之前保存的 <code>Visualize</code>，然后点击列表底部的小向上箭头关闭可视化列表。</li>
<li>将鼠标悬停在可视化对象上会显示允许您编辑，移动，删除和调整可视化对象大小的容器控件。</li>
</ol>
<h2 id="3-FAQ"><a href="#3-FAQ" class="headerlink" title="3. FAQ"></a>3. FAQ</h2><h3 id="3-1-Kibana-No-Default-Index-Pattern-Warning"><a href="#3-1-Kibana-No-Default-Index-Pattern-Warning" class="headerlink" title="3.1. Kibana No Default Index Pattern Warning"></a>3.1. Kibana No Default Index Pattern Warning</h3><p><strong>问题：</strong>安装 ELK 后，访问 kibana 页面时，提示以下错误信息：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Warning No default <span class="keyword">index</span> pattern. You must <span class="keyword">select</span> <span class="keyword">or</span> <span class="keyword">create</span> one <span class="keyword">to</span> <span class="keyword">continue</span>.</span><br><span class="line">...</span><br><span class="line">Unable <span class="keyword">to</span> <span class="keyword">fetch</span> <span class="keyword">mapping</span>. <span class="keyword">Do</span> you have indices matching the pattern?</span><br></pre></td></tr></table></figure>

<p>这就说明 logstash 没有把日志写入到 elasticsearch。</p>
<p><strong>解决方法：</strong></p>
<p>检查 logstash 与 elasticsearch 之间的通讯是否有问题，一般问题就出在这。</p>
<h2 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4. 参考资料"></a>4. 参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/cn/products/kibana">Kibana 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/elastic/kibana">Kibana Github</a></li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/kibana/current/index.html">Kibana 官方文档</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/55ce99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/55ce99/" class="post-title-link" itemprop="url">Elastic 技术栈之 Logstash</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-16 07:10:44" itemprop="dateCreated datePublished" datetime="2020-06-16T07:10:44+08:00">2020-06-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">搜索引擎数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/Elastic/" itemprop="url" rel="index"><span itemprop="name">Elastic</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Elastic-技术栈之-Logstash"><a href="#Elastic-技术栈之-Logstash" class="headerlink" title="Elastic 技术栈之 Logstash"></a>Elastic 技术栈之 Logstash</h1><blockquote>
<p>本文是 Elastic 技术栈（ELK）的 Logstash 应用。</p>
<p>如果不了解 Elastic 的安装、配置、部署，可以参考：<a target="_blank" rel="noopener" href="https://github.com/dunwu/JavaStack/blob/master/docs/javatool/elastic/elastic-quickstart.md">Elastic 技术栈之快速入门</a></p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Logstash 可以传输和处理你的日志、事务或其他数据。</p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>Logstash 是 Elasticsearch 的最佳数据管道。</p>
<p>Logstash 是插件式管理模式，在输入、过滤、输出以及编码过程中都可以使用插件进行定制。Logstash 社区有超过 200 种可用插件。</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>Logstash 有两个必要元素：<code>input</code> 和 <code>output</code> ，一个可选元素：<code>filter</code>。</p>
<p>这三个元素，分别代表 Logstash 事件处理的三个阶段：输入 &gt; 过滤器 &gt; 输出。</p>
<p><img src="https://www.elastic.co/guide/en/logstash/current/static/images/basic_logstash_pipeline.png" alt="img"></p>
<ul>
<li>input 负责从数据源采集数据。</li>
<li>filter 将数据修改为你指定的格式或内容。</li>
<li>output 将数据传输到目的地。</li>
</ul>
<p>在实际应用场景中，通常输入、输出、过滤器不止一个。Logstash 的这三个元素都使用插件式管理方式，用户可以根据应用需要，灵活的选用各阶段需要的插件，并组合使用。</p>
<p>后面将对插件展开讲解，暂且不表。</p>
<h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><h3 id="设置文件"><a href="#设置文件" class="headerlink" title="设置文件"></a>设置文件</h3><ul>
<li>**<code>logstash.yml</code>**：logstash 的默认启动配置文件</li>
<li>**<code>jvm.options</code>**：logstash 的 JVM 配置文件。</li>
<li><strong><code>startup.options</code></strong> (Linux)：包含系统安装脚本在 <code>/usr/share/logstash/bin</code> 中使用的选项为您的系统构建适当的启动脚本。安装 Logstash 软件包时，系统安装脚本将在安装过程结束时执行，并使用 <code>startup.options</code> 中指定的设置来设置用户，组，服务名称和服务描述等选项。</li>
</ul>
<h3 id="logstash-yml-设置项"><a href="#logstash-yml-设置项" class="headerlink" title="logstash.yml 设置项"></a>logstash.yml 设置项</h3><p>节选部分设置项，更多项请参考：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/logstash-settings-file.html">https://www.elastic.co/guide/en/logstash/current/logstash-settings-file.html</a></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td><code>node.name</code></td>
<td>节点名</td>
<td>机器的主机名</td>
</tr>
<tr>
<td><code>path.data</code></td>
<td>Logstash 及其插件用于任何持久性需求的目录。</td>
<td><code>LOGSTASH_HOME/data</code></td>
</tr>
<tr>
<td><code>pipeline.workers</code></td>
<td>同时执行管道的过滤器和输出阶段的工作任务数量。如果发现事件正在备份，或 CPU 未饱和，请考虑增加此数字以更好地利用机器处理能力。</td>
<td>Number of the host’s CPU cores</td>
</tr>
<tr>
<td><code>pipeline.batch.size</code></td>
<td>尝试执行过滤器和输出之前，单个工作线程从输入收集的最大事件数量。较大的批量处理大小一般来说效率更高，但是以增加的内存开销为代价。您可能必须通过设置 <code>LS_HEAP_SIZE</code> 变量来有效使用该选项来增加 JVM 堆大小。</td>
<td><code>125</code></td>
</tr>
<tr>
<td><code>pipeline.batch.delay</code></td>
<td>创建管道事件批处理时，在将一个尺寸过小的批次发送给管道工作任务之前，等待每个事件需要多长时间（毫秒）。</td>
<td><code>5</code></td>
</tr>
<tr>
<td><code>pipeline.unsafe_shutdown</code></td>
<td>如果设置为 true，则即使在内存中仍存在 inflight 事件时，也会强制 Logstash 在关闭期间退出。默认情况下，Logstash 将拒绝退出，直到所有接收到的事件都被推送到输出。启用此选项可能会导致关机期间数据丢失。</td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>path.config</code></td>
<td>主管道的 Logstash 配置路径。如果您指定一个目录或通配符，配置文件将按字母顺序从目录中读取。</td>
<td>Platform-specific. See [<a target="_blank" rel="noopener" href="https://github.com/elastic/logstash/blob/6.1/docs/static/settings-file.asciidoc#dir-layout">dir-layout]</a>.</td>
</tr>
<tr>
<td><code>config.string</code></td>
<td>包含用于主管道的管道配置的字符串。使用与配置文件相同的语法。</td>
<td>None</td>
</tr>
<tr>
<td><code>config.test_and_exit</code></td>
<td>设置为 true 时，检查配置是否有效，然后退出。请注意，使用此设置不会检查 grok 模式的正确性。 Logstash 可以从目录中读取多个配置文件。如果将此设置与 log.level：debug 结合使用，则 Logstash 将记录组合的配置文件，并注掉其源文件的配置块。</td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>config.reload.automatic</code></td>
<td>设置为 true 时，定期检查配置是否已更改，并在配置更改时重新加载配置。这也可以通过 SIGHUP 信号手动触发。</td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>config.reload.interval</code></td>
<td>Logstash 检查配置文件更改的时间间隔。</td>
<td><code>3s</code></td>
</tr>
<tr>
<td><code>config.debug</code></td>
<td>设置为 true 时，将完全编译的配置显示为调试日志消息。您还必须设置<code>log.level：debug</code>。警告：日志消息将包括任何传递给插件配置作为明文的“密码”选项，并可能导致明文密码出现在您的日志！</td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>config.support_escapes</code></td>
<td>当设置为 true 时，带引号的字符串将处理转义字符。</td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>modules</code></td>
<td>配置时，模块必须处于上表所述的嵌套 YAML 结构中。</td>
<td>None</td>
</tr>
<tr>
<td><code>http.host</code></td>
<td>绑定地址</td>
<td><code>&quot;127.0.0.1&quot;</code></td>
</tr>
<tr>
<td><code>http.port</code></td>
<td>绑定端口</td>
<td><code>9600</code></td>
</tr>
<tr>
<td><code>log.level</code></td>
<td>日志级别。有效选项：fatal &gt; error &gt; warn &gt; info &gt; debug &gt; trace</td>
<td><code>info</code></td>
</tr>
<tr>
<td><code>log.format</code></td>
<td>日志格式。json （JSON 格式）或 plain （原对象）</td>
<td><code>plain</code></td>
</tr>
<tr>
<td><code>path.logs</code></td>
<td>Logstash 自身日志的存储路径</td>
<td><code>LOGSTASH_HOME/logs</code></td>
</tr>
<tr>
<td><code>path.plugins</code></td>
<td>在哪里可以找到自定义的插件。您可以多次指定此设置以包含多个路径。</td>
<td></td>
</tr>
</tbody></table>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><p>通过命令行启动 logstash 的方式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/logstash [options]</span><br></pre></td></tr></table></figure>

<p>其中 <code>options</code> 是您可以指定用于控制 Logstash 执行的命令行标志。</p>
<p>在命令行上设置的任何标志都会覆盖 Logstash 设置文件（<code>logstash.yml</code>）中的相应设置，但设置文件本身不会更改。</p>
<blockquote>
<p><strong>注</strong></p>
<p>虽然可以通过指定命令行参数的方式，来控制 logstash 的运行方式，但显然这么做很麻烦。</p>
<p>建议通过指定配置文件的方式，来控制 logstash 运行，启动命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/logstash -f logstash.conf</span><br></pre></td></tr></table></figure>

<p>若想了解更多的命令行参数细节，请参考：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/running-logstash-command-line.html">https://www.elastic.co/guide/en/logstash/current/running-logstash-command-line.html</a></p>
</blockquote>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>上节，我们了解到，logstash 可以执行 <code>bin/logstash -f logstash.conf</code> ，按照配置文件中的参数去覆盖默认设置文件（<code>logstash.yml</code>）中的设置。</p>
<p>这节，我们就来学习一下这个配置文件如何配置参数。</p>
<h4 id="配置文件结构"><a href="#配置文件结构" class="headerlink" title="配置文件结构"></a>配置文件结构</h4><p>在工作原理一节中，我们已经知道了 Logstash 主要有三个工作阶段 input 、filter、output。而 logstash 配置文件文件结构也与之相对应：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">input &#123;&#125;</span><br><span class="line"></span><br><span class="line">filter &#123;&#125;</span><br><span class="line"></span><br><span class="line">output &#123;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>每个部分都包含一个或多个插件的配置选项。如果指定了多个过滤器，则会按照它们在配置文件中的显示顺序应用它们。</p>
</blockquote>
<h4 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h4><p>插件的配置由插件名称和插件的一个设置块组成。</p>
<p>下面的例子中配置了两个输入文件配置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  file &#123;</span><br><span class="line">    <span class="function"><span class="params">path</span> =&gt;</span> <span class="string">&quot;/var/log/messages&quot;</span></span><br><span class="line">    type =&gt; <span class="string">&quot;syslog&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  file &#123;</span><br><span class="line">    <span class="function"><span class="params">path</span> =&gt;</span> <span class="string">&quot;/var/log/apache/access.log&quot;</span></span><br><span class="line">    type =&gt; <span class="string">&quot;apache&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您可以配置的设置因插件类型而异。你可以参考： <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/input-plugins.html">Input Plugins</a>, <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/output-plugins.html">Output Plugins</a>, <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/filter-plugins.html">Filter Plugins</a>, 和 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/codec-plugins.html">Codec Plugins</a> 。</p>
<h4 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h4><p>一个插件可以要求设置的值是一个特定的类型，比如布尔值，列表或哈希值。以下值类型受支持。</p>
<ul>
<li>Array</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">users =&gt; [ &#123;<span class="function"><span class="params">id</span> =&gt;</span> <span class="number">1</span>, <span class="function"><span class="params">name</span> =&gt;</span> bob&#125;, &#123;<span class="function"><span class="params">id</span> =&gt;</span> <span class="number">2</span>, <span class="function"><span class="params">name</span> =&gt;</span> jane&#125; ]</span><br></pre></td></tr></table></figure>

<ul>
<li>Lists</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path =&gt; [<span class="string">&#x27;/var/log/messages&#x27;</span>, <span class="string">&#x27;/var/log/*.log&#x27;</span>]</span><br><span class="line">uris =&gt; [<span class="string">&#x27;http://elastic.co&#x27;</span>, <span class="string">&#x27;http://example.net&#x27;</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>Boolean</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssl_enable =&gt; <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Bytes</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my_bytes =&gt; <span class="string">&quot;1113&quot;</span>   # <span class="number">1113</span> bytes</span><br><span class="line">my_bytes =&gt; <span class="string">&quot;10MiB&quot;</span>  # <span class="number">10485760</span> bytes</span><br><span class="line">my_bytes =&gt; <span class="string">&quot;100kib&quot;</span> # <span class="number">102400</span> bytes</span><br><span class="line">my_bytes =&gt; <span class="string">&quot;180 mb&quot;</span> # <span class="number">180000000</span> bytes</span><br></pre></td></tr></table></figure>

<ul>
<li>Codec</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">codec =&gt; <span class="string">&#x27;json&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Hash</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">match =&gt; &#123;</span><br><span class="line">  <span class="string">&quot;field1&quot;</span> =&gt; <span class="string">&quot;value1&quot;</span></span><br><span class="line">  <span class="string">&quot;field2&quot;</span> =&gt; <span class="string">&quot;value2&quot;</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Number</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">port =&gt; <span class="number">33</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Password</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_password =&gt; <span class="string">&#x27;password&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>URI</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_uri =&gt; <span class="string">&#x27;http://foo:bar@example.net&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Path</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_path =&gt; <span class="string">&#x27;/tmp/logstash&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>String</p>
</li>
<li><p>转义字符</p>
</li>
</ul>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="input"><a href="#input" class="headerlink" title="input"></a>input</h3><blockquote>
<p>Logstash 支持各种输入选择 ，可以在同一时间从众多常用来源捕捉事件。能够以连续的流式传输方式，轻松地从您的日志、指标、Web 应用、数据存储以及各种 AWS 服务采集数据。</p>
</blockquote>
<h4 id="常用-input-插件"><a href="#常用-input-插件" class="headerlink" title="常用 input 插件"></a>常用 input 插件</h4><ul>
<li><strong>file</strong>：从文件系统上的文件读取，就像 UNIX 命令 <code>tail -0F</code> 一样</li>
<li><strong>syslog：</strong>在众所周知的端口 514 上侦听系统日志消息，并根据 RFC3164 格式进行解析</li>
<li><strong>redis：</strong>从 redis 服务器读取，使用 redis 通道和 redis 列表。 Redis 经常用作集中式 Logstash 安装中的“代理”，它将来自远程 Logstash“托运人”的 Logstash 事件排队。</li>
<li><strong>beats：</strong>处理由 Filebeat 发送的事件。</li>
</ul>
<p>更多详情请见：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/input-plugins.html">Input Plugins</a></p>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><blockquote>
<p>过滤器是 Logstash 管道中的中间处理设备。如果符合特定条件，您可以将条件过滤器组合在一起，对事件执行操作。</p>
</blockquote>
<h4 id="常用-filter-插件"><a href="#常用-filter-插件" class="headerlink" title="常用 filter 插件"></a>常用 filter 插件</h4><ul>
<li><strong>grok：</strong>解析和结构任意文本。 Grok 目前是 Logstash 中将非结构化日志数据解析为结构化和可查询的最佳方法。</li>
<li><strong>mutate：</strong>对事件字段执行一般转换。您可以重命名，删除，替换和修改事件中的字段。</li>
<li><strong>drop：</strong>完全放弃一个事件，例如调试事件。</li>
<li><strong>clone：</strong>制作一个事件的副本，可能会添加或删除字段。</li>
<li><strong>geoip：</strong>添加有关 IP 地址的地理位置的信息（也可以在 Kibana 中显示惊人的图表！）</li>
</ul>
<p>更多详情请见：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/filter-plugins.html">Filter Plugins</a></p>
<h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><blockquote>
<p>输出是 Logstash 管道的最后阶段。一个事件可以通过多个输出，但是一旦所有输出处理完成，事件就完成了执行。</p>
</blockquote>
<h4 id="常用-output-插件"><a href="#常用-output-插件" class="headerlink" title="常用 output 插件"></a>常用 output 插件</h4><ul>
<li><strong>elasticsearch：</strong>将事件数据发送给 Elasticsearch（推荐模式）。</li>
<li><strong>file：</strong>将事件数据写入文件或磁盘。</li>
<li><strong>graphite：</strong>将事件数据发送给 graphite（一个流行的开源工具，存储和绘制指标。 <a target="_blank" rel="noopener" href="http://graphite.readthedocs.io/en/latest/%EF%BC%89%E3%80%82">http://graphite.readthedocs.io/en/latest/）。</a></li>
<li><strong>statsd：</strong>将事件数据发送到 statsd （这是一种侦听统计数据的服务，如计数器和定时器，通过 UDP 发送并将聚合发送到一个或多个可插入的后端服务）。</li>
</ul>
<p>更多详情请见：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/output-plugins.html">Output Plugins</a></p>
<h3 id="codec"><a href="#codec" class="headerlink" title="codec"></a>codec</h3><p>用于格式化对应的内容。</p>
<h4 id="常用-codec-插件"><a href="#常用-codec-插件" class="headerlink" title="常用 codec 插件"></a>常用 codec 插件</h4><ul>
<li><strong>json：</strong>以 JSON 格式对数据进行编码或解码。</li>
<li><strong>multiline：</strong>将多行文本事件（如 java 异常和堆栈跟踪消息）合并为单个事件。</li>
</ul>
<p>更多插件请见：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/codec-plugins.html">Codec Plugins</a></p>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>前面的内容都是对 Logstash 的介绍和原理说明。接下来，我们来实战一些常见的应用场景。</p>
<h3 id="传输控制台数据"><a href="#传输控制台数据" class="headerlink" title="传输控制台数据"></a>传输控制台数据</h3><blockquote>
<p>stdin input 插件从标准输入读取事件。这是最简单的 input 插件，一般用于测试场景。</p>
</blockquote>
<p><strong>应用</strong></p>
<p>（1）创建 <code>logstash-input-stdin.conf</code> ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">input &#123; stdin &#123; &#125; &#125;</span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123; <span class="function"><span class="params">hosts</span> =&gt;</span> [<span class="string">&quot;localhost:9200&quot;</span>] &#125;</span><br><span class="line">  stdout &#123; <span class="function"><span class="params">codec</span> =&gt;</span> rubydebug &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多配置项可以参考：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/plugins-inputs-stdin.html">https://www.elastic.co/guide/en/logstash/current/plugins-inputs-stdin.html</a></p>
<p>（2）执行 logstash，使用 <code>-f</code> 来指定你的配置文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/logstash -f logstash-input-stdin.conf</span><br></pre></td></tr></table></figure>

<h3 id="传输-logback-日志"><a href="#传输-logback-日志" class="headerlink" title="传输 logback 日志"></a>传输 logback 日志</h3><blockquote>
<p>elk 默认使用的 Java 日志工具是 log4j2 ，并不支持 logback 和 log4j。</p>
<p>想使用 logback + logstash ，可以使用 <a target="_blank" rel="noopener" href="https://github.com/logstash/logstash-logback-encoder">logstash-logback-encoder</a> 。<a target="_blank" rel="noopener" href="https://github.com/logstash/logstash-logback-encoder">logstash-logback-encoder</a> 提供了 UDP &#x2F; TCP &#x2F; 异步方式来传输日志数据到 logstash。</p>
<p>如果你使用的是 log4j ，也不是不可以用这种方式，只要引入桥接 jar 包即可。如果你对 log4j 、logback ，或是桥接 jar 包不太了解，可以参考我的这篇博文：<a target="_blank" rel="noopener" href="https://github.com/dunwu/JavaStack/blob/master/docs/javalib/java-log.md">细说 Java 主流日志工具库</a> 。</p>
</blockquote>
<h4 id="TCP-应用"><a href="#TCP-应用" class="headerlink" title="TCP 应用"></a>TCP 应用</h4><p>logstash 配置</p>
<p>（1）创建 <code>logstash-input-tcp.conf</code> ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">tcp &#123;</span><br><span class="line">  <span class="function"><span class="params">port</span> =&gt;</span> <span class="number">9251</span></span><br><span class="line">  codec =&gt; json_lines</span><br><span class="line">  mode =&gt; server</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line"> elasticsearch &#123; <span class="function"><span class="params">hosts</span> =&gt;</span> [<span class="string">&quot;localhost:9200&quot;</span>] &#125;</span><br><span class="line"> stdout &#123; <span class="function"><span class="params">codec</span> =&gt;</span> rubydebug &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多配置项可以参考：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/plugins-inputs-tcp.html">https://www.elastic.co/guide/en/logstash/current/plugins-inputs-tcp.html</a></p>
<p>（2）执行 logstash，使用 <code>-f</code> 来指定你的配置文件：<code>bin/logstash -f logstash-input-udp.conf</code></p>
<p>java 应用配置</p>
<p>（1）在 Java 应用的 pom.xml 中引入 jar 包：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.logstash.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logstash-logback-encoder<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- logback 依赖包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-access<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）接着，在 logback.xml 中添加 appender</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;ELK-TCP&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.logstash.logback.appender.LogstashTcpSocketAppender&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> destination 是 logstash 服务的 host:port，</span></span><br><span class="line"><span class="comment"> 相当于和 logstash 建立了管道，将日志数据定向传输到 logstash</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">destination</span>&gt;</span>192.168.28.32:9251<span class="tag">&lt;/<span class="name">destination</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.logstash.logback.encoder.LogstashEncoder&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;io.github.dunwu.spring&quot;</span> <span class="attr">level</span>=<span class="string">&quot;TRACE&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ELK-TCP&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（3）接下来，就是 logback 的具体使用 ，如果对此不了解，不妨参考一下我的这篇博文：<a target="_blank" rel="noopener" href="https://github.com/dunwu/JavaStack/blob/master/docs/javalib/java-log.md">细说 Java 主流日志工具库</a> 。</p>
<p><strong>实例：</strong><a target="_blank" rel="noopener" href="https://github.com/dunwu/JavaStack/blob/master/codes/javatool/src/main/resources/logback.xml">我的 logback.xml</a></p>
<h4 id="UDP-应用"><a href="#UDP-应用" class="headerlink" title="UDP 应用"></a>UDP 应用</h4><p>UDP 和 TCP 的使用方式大同小异。</p>
<p>logstash 配置</p>
<p>（1）创建 <code>logstash-input-udp.conf</code> ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">udp &#123;</span><br><span class="line">  <span class="function"><span class="params">port</span> =&gt;</span> <span class="number">9250</span></span><br><span class="line">  codec =&gt; json</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line"> elasticsearch &#123; <span class="function"><span class="params">hosts</span> =&gt;</span> [<span class="string">&quot;localhost:9200&quot;</span>] &#125;</span><br><span class="line"> stdout &#123; <span class="function"><span class="params">codec</span> =&gt;</span> rubydebug &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多配置项可以参考：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/plugins-inputs-udp.html">https://www.elastic.co/guide/en/logstash/current/plugins-inputs-udp.html</a></p>
<p>（2）执行 logstash，使用 <code>-f</code> 来指定你的配置文件：<code>bin/logstash -f logstash-input-udp.conf</code></p>
<p>java 应用配置</p>
<p>（1）在 Java 应用的 pom.xml 中引入 jar 包：</p>
<p>与 <strong>TCP 应用</strong> 一节中的引入依赖包完全相同。</p>
<p>（2）接着，在 logback.xml 中添加 appender</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;ELK-UDP&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.logstash.logback.appender.LogstashSocketAppender&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">host</span>&gt;</span>192.168.28.32<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span>&gt;</span>9250<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;io.github.dunwu.spring&quot;</span> <span class="attr">level</span>=<span class="string">&quot;TRACE&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ELK-UDP&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（3）接下来，就是 logback 的具体使用 ，如果对此不了解，不妨参考一下我的这篇博文：<a target="_blank" rel="noopener" href="https://github.com/dunwu/JavaStack/blob/master/docs/javalib/java-log.md">细说 Java 主流日志工具库</a> 。</p>
<p><strong>实例：</strong><a target="_blank" rel="noopener" href="https://github.com/dunwu/JavaStack/blob/master/codes/javatool/src/main/resources/logback.xml">我的 logback.xml</a></p>
<h3 id="传输文件"><a href="#传输文件" class="headerlink" title="传输文件"></a>传输文件</h3><blockquote>
<p>在 Java Web 领域，需要用到一些重要的工具，例如 Tomcat 、Nginx 、Mysql 等。这些不属于业务应用，但是它们的日志数据对于定位问题、分析统计同样很重要。这时无法使用 logback 方式将它们的日志传输到 logstash。</p>
<p>如何采集这些日志文件呢？别急，你可以使用 logstash 的 file input 插件。</p>
<p>需要注意的是，传输文件这种方式，必须在日志所在的机器上部署 logstash 。</p>
</blockquote>
<p><strong>应用</strong></p>
<p>logstash 配置</p>
<p>（1）创建 <code>logstash-input-file.conf</code> ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line"> file &#123;</span><br><span class="line">  <span class="function"><span class="params">path</span> =&gt;</span> [<span class="string">&quot;/var/log/nginx/access.log&quot;</span>]</span><br><span class="line">  type =&gt; <span class="string">&quot;nginx-access-log&quot;</span></span><br><span class="line">  start_position =&gt; <span class="string">&quot;beginning&quot;</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line"> <span class="keyword">if</span> [type] == <span class="string">&quot;nginx-access-log&quot;</span> &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">   <span class="function"><span class="params">hosts</span> =&gt;</span> [<span class="string">&quot;localhost:9200&quot;</span>]</span><br><span class="line">   index =&gt; <span class="string">&quot;nginx-access-log&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）执行 logstash，使用 <code>-f</code> 来指定你的配置文件：<code>bin/logstash -f logstash-input-file.conf</code></p>
<p>更多配置项可以参考：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/plugins-inputs-file.html">https://www.elastic.co/guide/en/logstash/current/plugins-inputs-file.html</a></p>
<h2 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h2><h3 id="启动、终止应用"><a href="#启动、终止应用" class="headerlink" title="启动、终止应用"></a>启动、终止应用</h3><p>如果你的 logstash 每次都是通过指定配置文件方式启动。不妨建立一个启动脚本。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cd</span> xxx 进入 logstash 安装目录下的 bin 目录</span></span><br><span class="line">logstash -f logstash.conf</span><br></pre></td></tr></table></figure>

<p>如果你的 logstash 运行在 linux 系统下，不妨使用 nohup 来启动一个守护进程。这样做的好处在于，即使关闭终端，应用仍会运行。</p>
<p><strong>创建 startup.sh</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./logstash -f logstash.conf &gt;&gt; nohup.out 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<p>终止应用没有什么好方法，你只能使用 ps -ef | grep logstash ，查出进程，将其 kill 。不过，我们可以写一个脚本来干这件事：</p>
<p><strong>创建 shutdown.sh</strong></p>
<p>脚本不多解释，请自行领会作用。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PID=`ps -ef | grep logstash | awk &#x27;&#123; print $2&#125;&#x27; | head -n 1`</span><br><span class="line">kill -9 $&#123;PID&#125;</span><br></pre></td></tr></table></figure>

<h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/index.html">Logstash 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/logstash/logstash-logback-encoder">logstash-logback-encoder</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/chenryn/logstash-best-practice-cn">ELK Stack 权威指南</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/judasn/Linux-Tutorial/blob/master/ELK-Install-And-Settings.md">ELK（Elasticsearch、Logstash、Kibana）安装和配置</a></li>
</ul>
<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/dunwu/JavaStack/blob/master/docs/javatool/elastic/README.md">Elastic 技术栈</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/dunwu/JavaStack">JavaStack</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/ab9f64/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/ab9f64/" class="post-title-link" itemprop="url">RPC 基础篇</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-10 16:00:00" itemprop="dateCreated datePublished" datetime="2020-06-10T16:00:00+08:00">2020-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:53" itemprop="dateModified" datetime="2024-12-12T10:02:53+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/" itemprop="url" rel="index"><span itemprop="name">分布式通信</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/RPC/" itemprop="url" rel="index"><span itemprop="name">RPC</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/RPC/RPC%E7%BB%BC%E5%90%88/" itemprop="url" rel="index"><span itemprop="name">RPC综合</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="RPC-基础篇"><a href="#RPC-基础篇" class="headerlink" title="RPC 基础篇"></a>RPC 基础篇</h1><h2 id="RPC-简介"><a href="#RPC-简介" class="headerlink" title="RPC 简介"></a>RPC 简介</h2><h3 id="什么是-RPC"><a href="#什么是-RPC" class="headerlink" title="什么是 RPC"></a>什么是 RPC</h3><p>RPC 的全称是 <strong>Remote Procedure Call</strong>，即<strong>远程过程调用</strong>。</p>
<p>RPC 的主要作用是：</p>
<ul>
<li><strong>屏蔽远程调用跟本地调用的差异</strong>，让用户像调用本地一样去调用远程方法。</li>
<li><strong>隐藏底层网络通信的复杂性</strong>，让用户更聚焦于业务逻辑。</li>
</ul>
<h3 id="RPC-的架构定位"><a href="#RPC-的架构定位" class="headerlink" title="RPC 的架构定位"></a>RPC 的架构定位</h3><p>RPC 是微服务架构的基石，它提供了一种应用间通信的方式。<img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220619101023.png"></p>
<h2 id="RPC-核心原理"><a href="#RPC-核心原理" class="headerlink" title="RPC 核心原理"></a>RPC 核心原理</h2><p>RPC 是一种应用间通信的方式，它的通信流程中需要注意以下环节：</p>
<ul>
<li><strong>传输方式</strong>：RPC 是一个远程调用，因此必然需要通过网络传输数据，且 RPC 常用于业务系统之间的数据交互，需要保证其可靠性，所以 RPC 一般默认采用 TCP 来传输。</li>
<li><strong>序列化</strong>：在网络中传输的数据只能是二进制数据，而 RPC 请求时，发送的都是对象。因此，请求方需要将请求参数转为二进制数据，即序列化。</li>
<li><strong>反序列化</strong>：RPC 响应方接受到请求，要将二进制数据转换为请求参数，需要<strong>反序列化</strong>。</li>
<li><strong>协议</strong>：请求方和响应方要互相识别彼此的信息，需要约定好彼此数据的格式，即协议。大多数的协议至少分成两部分，分别是数据头和消息体。数据头一般用于身份识别，包括协议标识、数据大小、请求类型、序列化类型等信息；消息体主要是请求的业务参数信息和扩展属性等。</li>
<li><strong>动态代理</strong>：为了屏蔽底层通信细节，使用户聚焦自身业务，因此 RPC 框架一般引入了动态代理，通过依赖注入等技术，拦截方法调用，完成远程调用的通信逻辑。</li>
</ul>
<p>下图诠释了以上环节是如何串联起来的：</p>
<img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220625094814.png" style="zoom:67%;" />

<h2 id="RPC-协议"><a href="#RPC-协议" class="headerlink" title="RPC 协议"></a>RPC 协议</h2><h3 id="协议的作用"><a href="#协议的作用" class="headerlink" title="协议的作用"></a>协议的作用</h3><p>只有二进制才能在网络中传输，所以 RPC 请求在发送到网络中之前，他需要把方法调用的请求参数转成二进制；转成二进制后，写入本地 Socket 中，然后被网卡发送到网络设备中。</p>
<p>在传输过程中，RPC 并不会把请求参数的所有二进制数据整体一下子发送到对端机器上，中间可能会拆分成好几个数据包，也可能会合并其他请求的数据包（合并的前提是同一个 TCP 连接上的数据），至于怎么拆分合并，这其中的细节会涉及到系统参数配置和 TCP 窗口大小。对于服务提供方应用来说，他会从 TCP 通道里面收到很多的二进制数据，那这时候怎么识别出哪些二进制是第一个请求的呢？</p>
<p>这就好比让你读一篇没有标点符号的文章，你要怎么识别出每一句话到哪里结束呢？很简单啊，我们加上标点，完成断句就好了。</p>
<p>为了避免语义不一致的事情发生，我们就需要在发送请求的时候设定一个边界，然后在收到请求的时候按照这个设定的边界进行数据分割。这个边界语义的表达，就是我们所说的协议。</p>
<h3 id="为何需要设计-RPC-协议"><a href="#为何需要设计-RPC-协议" class="headerlink" title="为何需要设计 RPC 协议"></a>为何需要设计 RPC 协议</h3><p>既然有了现成的 HTTP 协议，还有必要设计 RPC 协议吗？</p>
<p>有必要。因为 HTTP 这些通信标准协议，数据包中的实际请求数据相对于数据包本身要小很多，有很多无用的内容；并且 HTTP 属于无状态协议，无法将请求和响应关联，每次请求要重新建立连接。这对于高性能的 RPC 来说，HTTP 协议难以满足需求，所以有必要设计一个<strong>紧凑的私有协议</strong>。</p>
<h3 id="如何？"><a href="#如何？" class="headerlink" title="如何？"></a>如何？</h3><p>首先，必须先明确消息的边界，即确定消息的长度。因此，至少要分为：消息长度+消息内容两部分。</p>
<p>接下来，我们会发现，在使用过程中，仅消息长度，不足以明确通信中的很多细节：如序列化方式是怎样的？是否消息压缩？压缩格式是怎样的？如果协议发生变化，需要明确协议版本等等。</p>
<p>综上，一个 RPC 协议大概会由下图中的这些参数组成：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220619102052.png"></p>
<h3 id="可扩展的协议"><a href="#可扩展的协议" class="headerlink" title="可扩展的协议"></a>可扩展的协议</h3><p>前面所述的协议属于定长协议头，那也就是说往后就不能再往协议头里加新参数了，如果加参<br>数就会导致线上兼容问题。</p>
<p>为了保证能平滑地升级改造前后的协议，我们有必要设计一种支持可扩展的协议。其关键在于让协议头支持可扩展，扩展后协议头的长度就不能定长了。那要实现读取不定长的协议头里面的内容，在这之前肯定需要一个固定的地方读取长度，所以我们需要一个固定的写入协议头的长度。整体协议就变成了三部分内容：固定部分、协议头内容、协议体内容。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220619102833.png"></p>
<h2 id="RPC-序列化"><a href="#RPC-序列化" class="headerlink" title="RPC 序列化"></a>RPC 序列化</h2><blockquote>
<p>有兴趣深入了解 JDK 序列化方式，可以参考：<a target="_blank" rel="noopener" href="https://dunwu.github.io/waterdrop/pages/2b2f0f/">Java 序列化</a></p>
</blockquote>
<p>由于，网络传输的数据必须是二进制数据，而调用方请求的出参、入参都是对象。因此，必须将对象转换可传输的二进制，并且要求转换算法是可逆的。</p>
<ul>
<li><strong>序列化（serialize）</strong>：序列化是将对象转换为二进制数据。</li>
<li><strong>反序列化（deserialize）</strong>：反序列化是将二进制数据转换为对象。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220619110947.png"></p>
<p>序列化就是将对象转换成二进制数据的过程，而反序列就是反过来将二进制转换为对象的过程。</p>
<h3 id="序列化技术"><a href="#序列化技术" class="headerlink" title="序列化技术"></a>序列化技术</h3><p>Java 领域，常见的序列化技术如下</p>
<ul>
<li>JDK 序列化：JDK 内置的二进制序列化方式</li>
<li>其他二进制序列化<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/thrift">Thrift</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/protocolbuffers/protobuf">Protobuf</a></li>
<li><a target="_blank" rel="noopener" href="http://hessian.caucho.com/doc/hessian-overview.xtp">Hessian</a></li>
</ul>
</li>
<li>JSON 序列化<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/FasterXML/jackson">Jackson</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/google/gson">Gson</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/alibaba/fastjson">Fastjson</a></li>
</ul>
</li>
</ul>
<h3 id="序列化技术选型"><a href="#序列化技术选型" class="headerlink" title="序列化技术选型"></a>序列化技术选型</h3><p>市面上有如此多的序列化技术，那么我们在应用时如何选择呢?</p>
<p>序列化技术选型，需要考量的维度，根据重要性从高到低，依次有：</p>
<ul>
<li><strong>安全性</strong>：是否存在漏洞。如果存在漏洞，就有被攻击的可能性。</li>
<li><strong>兼容性</strong>：版本升级后的兼容性是否很好，是否支持更多的对象类型，是否是跨平台、跨语言的。服务调用的稳定性与可靠性，要比服务的性能更加重要。</li>
<li><strong>性能</strong><ul>
<li><strong>时间开销</strong>：序列化、反序列化的耗时性能自然越小越好。</li>
<li><strong>空间开销</strong>：序列化后的数据越小越好，这样网络传输效率就高。</li>
</ul>
</li>
<li><strong>易用性</strong>：类库是否轻量化，API 是否简单易懂。</li>
</ul>
<p>鉴于以上的考量，序列化技术的选型建议如下：</p>
<ul>
<li>JDK 序列化：性能较差，且有很多使用限制，不建议使用。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/thrift">Thrift</a>、<a target="_blank" rel="noopener" href="https://github.com/protocolbuffers/protobuf">Protobuf</a>：适用于<strong>对性能敏感，对开发体验要求不高</strong>。</li>
<li><a target="_blank" rel="noopener" href="http://hessian.caucho.com/doc/hessian-overview.xtp">Hessian</a>：适用于<strong>对开发体验敏感，性能有要求</strong>。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/FasterXML/jackson">Jackson</a>、<a target="_blank" rel="noopener" href="https://github.com/google/gson">Gson</a>、<a target="_blank" rel="noopener" href="https://github.com/alibaba/fastjson">Fastjson</a>：适用于对序列化后的数据要求有<strong>良好的可读性</strong>（转为 json 、xml 形式）。</li>
</ul>
<h3 id="序列化问题"><a href="#序列化问题" class="headerlink" title="序列化问题"></a>序列化问题</h3><p>由于 RPC 每次通信，都要经过序列化、反序列化的过程，所以序列化方式，会直接影响 RPC 通信的性能。除了选择合适的序列化技术，如何合理使用序列化也非常重要。</p>
<p>RPC 序列化常见的使用不当的情况如下：</p>
<ul>
<li><p><strong>对象过于复杂、庞大</strong> - 对象过于复杂、庞大，会降低序列化、反序列化的效率，并增加传输开销，从而导致响应时延增大。</p>
<ul>
<li>过于复杂：存在多层的嵌套，比如 A 对象关联 B 对象，B 对象又聚合 C 对象，C 对象又关联聚合很多其他对象</li>
<li>过于庞大：比如一个大 List 或者大 Map</li>
</ul>
</li>
<li><p><strong>对象有复杂的继承关系</strong> - 对象关系越复杂，就越浪费性能，同时又很容易出现序列化上的问题。大多数序列化框架在进行序列化时，如果发现类有继承关系，会不停地寻找父类，遍历属性。</p>
</li>
<li><p><strong>使用序列化框架不支持的类作为入参类</strong> - 比如 Hessian 框架，他天然是不支持 LinkHashMap、LinkedHashSet 等，而且大多数情况下最好不要使用第三方集合类，如 Guava 中的集合类，很多开源的序列化框架都是优先支持编程语言原生的对象。因此如果入参是集合类，应尽量选用原生的、最为常用的集合类，如 HashMap、ArrayList。</p>
</li>
</ul>
<h3 id="序列化要点"><a href="#序列化要点" class="headerlink" title="序列化要点"></a>序列化要点</h3><p>前面已经列举了常见的序列化问题，既然明确了问题，就要针对性预防。RPC 序列化时要注意以下几点：</p>
<ol>
<li>对象要尽量简单，没有太多的依赖关系，属性不要太多，尽量高内聚；</li>
<li>入参对象与返回值对象体积不要太大，更不要传太大的集合；</li>
<li>尽量使用简单的、常用的、开发语言原生的对象，尤其是集合类；</li>
<li>对象不要有复杂的继承关系，最好不要有父子类的情况。</li>
</ol>
<h2 id="RPC-通信"><a href="#RPC-通信" class="headerlink" title="RPC 通信"></a>RPC 通信</h2><p>一次 RPC 调用，本质就是服务消费者与服务提供者间的一次网络信息交换的过程。可见，通信时 RPC 实现的核心。</p>
<p>常见的网络 IO 模型有：同步阻塞（BIO）、同步非阻塞（NIO）、异步非阻塞（AIO）。</p>
<h3 id="IO-多路复用"><a href="#IO-多路复用" class="headerlink" title="IO 多路复用"></a>IO 多路复用</h3><p>IO 多路复用（Reactor 模式）在高并发场景下使用最为广泛，很多知名软件都应用了这一技术，如：Netty、Redis、Nginx 等。</p>
<p>IO 多路复用分为 select，poll 和 epoll。</p>
<p>什么是 IO 多路复用？字面上的理解，多路就是指多个通道，也就是多个网络连接的 IO，而复用就是指多个通道复用在一个复用器上。</p>
<h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><p>系统内核处理 IO 操作分为两个阶段——等待数据和拷贝数据。等待数据，就是系统内核在等待网卡接收到数据后，把数据写到内核中；而拷贝数据，就是系统内核在获取到数据后，将数据拷贝到用户进程的空间中。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200717154300" alt="img"></p>
<p>应用进程的每一次写操作，都会把数据写到用户空间的缓冲区中，再由 CPU 将数据拷贝到系统内核的缓冲区中，之后再由 DMA 将这份数据拷贝到网卡中，最后由网卡发送出去。这里我们可以看到，一次写操作数据要拷贝两次才能通过网卡发送出去，而用户进程的读操作则是将整个流程反过来，数据同样会拷贝两次才能让应用程序读取到数据。</p>
<p>应用进程的一次完整的读写操作，都需要在用户空间与内核空间中来回拷贝，并且每一次拷贝，都需要 CPU 进行一次上下文切换（由用户进程切换到系统内核，或由系统内核切换到用户进程），这样很浪费 CPU 和性能。</p>
<p>所谓的零拷贝，就是取消用户空间与内核空间之间的数据拷贝操作，应用进程每一次的读写操作，可以通过一种方式，直接将数据写入内核或从内核中读取数据，再通过 DMA 将内核中的数据拷贝到网卡，或将网卡中的数据 copy 到内核。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200717154716.jfif" alt="img"></p>
<p>Netty 的零拷贝偏向于用户空间中对数据操作的优化，这对处理 TCP 传输中的拆包粘包问题有着重要的意义，对应用程序处理请求数据与返回数据也有重要的意义。</p>
<p>Netty 框架中很多内部的 ChannelHandler 实现类，都是通过 CompositeByteBuf、slice、wrap 操作来处理 TCP 传输中的拆包与粘包问题的。</p>
<p>Netty 的 ByteBuffer 可以采用 Direct Buffers，使用堆外直接内存进行 Socketd 的读写<br>操作，最终的效果与我刚才讲解的虚拟内存所实现的效果是一样的。</p>
<p>Netty 还提供 FileRegion 中包装 NIO 的 FileChannel.transferTo() 方法实现了零拷<br>贝，这与 Linux 中的 sendfile 方式在原理上也是一样的。</p>
<h2 id="RPC-动态代理"><a href="#RPC-动态代理" class="headerlink" title="RPC 动态代理"></a>RPC 动态代理</h2><p>RPC 的远程过程调用是通过反射+动态代理实现的。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/1553614585028.png" alt="img"></p>
<p>RPC 框架会自动为要调用的接口生成一个代理类。当在项目中注入接口的时候，运行过程中实际绑定的就是这个接口生成的代理类。在接口方法被调用时，会被代理类拦截，这样，就可以在生成的代理类中，加入远程调用逻辑。</p>
<p>除了 JDK 默认的 <code>InvocationHandler</code> 能完成代理功能，还有很多其他的第三方框架也可以，比如像 Javassist、Byte Buddy 这样的框架。</p>
<blockquote>
<p>反射+动态代理更多详情可以参考：<a target="_blank" rel="noopener" href="https://dunwu.github.io/waterdrop/pages/0d066a/">深入理解 Java 反射和动态代理</a></p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100046201">RPC 实战与核心原理</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/c5a5b6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/c5a5b6/" class="post-title-link" itemprop="url">JVM 垃圾收集</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-07 09:21:16" itemprop="dateCreated datePublished" datetime="2020-06-07T09:21:16+08:00">2020-06-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JavaSE/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>13k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>12 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="JVM-垃圾收集"><a href="#JVM-垃圾收集" class="headerlink" title="JVM 垃圾收集"></a>JVM 垃圾收集</h1><blockquote>
<p>程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后也会消失，因此不需要对这三个区域进行垃圾回收。<strong>垃圾回收主要是针对 Java 堆和方法区进行</strong>。</p>
</blockquote>
<h2 id="对象活着吗"><a href="#对象活着吗" class="headerlink" title="对象活着吗"></a>对象活着吗</h2><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。</p>
<p>两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCountingGC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ReferenceCountingGC</span> <span class="variable">objectA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGC</span>();</span><br><span class="line">        <span class="type">ReferenceCountingGC</span> <span class="variable">objectB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGC</span>();</span><br><span class="line">        objectA.instance = objectB;</span><br><span class="line">        objectB.instance = objectA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为循环引用的存在，所以 <strong>Java 虚拟机不适用引用计数算法</strong>。</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>通过 <strong>GC Roots</strong> 作为起始点进行搜索，JVM 将能够到达到的对象视为<strong>存活</strong>，不可达的对象视为<strong>死亡</strong>。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/jvm/jvm-gc-root.png" />
<p>可达性分析算法</p>
</div>

<p><strong>可作为 GC Roots 的对象</strong>包括下面几种：</p>
<ul>
<li>虚拟机栈中引用的对象</li>
<li>本地方法栈中引用的对象（Native 方法）</li>
<li>方法区中，类静态属性引用的对象</li>
<li>方法区中，常量引用的对象</li>
</ul>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>无论是通过引用计算算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否可被回收都与引用有关。</p>
<p>Java 具有四种强度不同的引用类型。</p>
<h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p><strong>被强引用（Strong Reference）关联的对象不会被垃圾收集器回收。</strong></p>
<p>强引用：使用 <code>new</code> 一个新对象的方式来创建强引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>

<h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p><strong>被软引用（Soft Reference）关联的对象，只有在内存不够的情况下才会被回收。</strong></p>
<p>软引用：使用 <code>SoftReference</code> 类来创建软引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>; <span class="comment">// 使对象只被软引用关联</span></span><br></pre></td></tr></table></figure>

<h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p><strong>被弱引用（Weak Reference）关联的对象一定会被垃圾收集器回收，也就是说它只能存活到下一次垃圾收集发生之前。</strong></p>
<p>使用 <code>WeakReference</code> 类来实现弱引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p><code>WeakHashMap</code> 的 <code>Entry</code> 继承自 <code>WeakReference</code>，主要用来实现缓存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;Object&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt;</span><br></pre></td></tr></table></figure>

<p>Tomcat 中的 <code>ConcurrentCache</code> 就使用了 <code>WeakHashMap</code> 来实现缓存功能。<code>ConcurrentCache</code> 采取的是分代缓存，经常使用的对象放入 eden 中，而不常用的对象放入 longterm。eden 使用 <code>ConcurrentHashMap</code> 实现，longterm 使用 <code>WeakHashMap</code>，保证了不常使用的对象容易被回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ConcurrentCache</span>&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, V&gt; eden;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, V&gt; longterm;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcurrentCache</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">        <span class="built_in">this</span>.eden = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(size);</span><br><span class="line">        <span class="built_in">this</span>.longterm = <span class="keyword">new</span> <span class="title class_">WeakHashMap</span>&lt;&gt;(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K k)</span> &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> <span class="built_in">this</span>.eden.get(k);</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="literal">null</span>) &#123;</span><br><span class="line">            v = <span class="built_in">this</span>.longterm.get(k);</span><br><span class="line">            <span class="keyword">if</span> (v != <span class="literal">null</span>)</span><br><span class="line">                <span class="built_in">this</span>.eden.put(k, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K k, V v)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.eden.size() &gt;= size) &#123;</span><br><span class="line">            <span class="built_in">this</span>.longterm.putAll(<span class="built_in">this</span>.eden);</span><br><span class="line">            <span class="built_in">this</span>.eden.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.eden.put(k, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p>又称为幽灵引用或者幻影引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象实例。</p>
<p><strong>为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</strong></p>
<p>使用 <code>PhantomReference</code> 来实现虚引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<h3 id="方法区的回收"><a href="#方法区的回收" class="headerlink" title="方法区的回收"></a>方法区的回收</h3><p>因为方法区主要存放永久代对象，而永久代对象的回收率比年轻代差很多，因此在方法区上进行回收性价比不高。</p>
<p>主要是对常量池的回收和对类的卸载。</p>
<p>类的卸载条件很多，需要满足以下三个条件，并且满足了也不一定会被卸载：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>
<li>加载该类的 <code>ClassLoader</code> 已经被回收。</li>
<li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。</li>
</ul>
<p>可以通过 <code>-Xnoclassgc</code> 参数来控制是否对类进行卸载。</p>
<p>在大量使用反射、动态代理、CGLib 等字节码框架、动态生成 JSP 以及 OSGi 这类频繁自定义 <code>ClassLoader</code> 的场景都需要虚拟机具备类卸载功能，以保证不会出现内存溢出。</p>
<h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h3><p><code>finalize()</code> 类似 C++ 的析构函数，用来做关闭外部资源等工作。但是 try-finally 等方式可以做的更好，并且该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此**最好不要使用 <code>finalize()</code>**。</p>
<p>当一个对象可被回收时，如果需要执行该对象的 <code>finalize()</code> 方法，那么就有可能通过在该方法中让对象重新被引用，从而实现自救。</p>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="垃圾收集性能"><a href="#垃圾收集性能" class="headerlink" title="垃圾收集性能"></a>垃圾收集性能</h3><p>垃圾收集器的性能指标主要有两点：</p>
<ul>
<li><strong>停顿时间</strong> - 停顿时间是因为 GC 而导致程序不能工作的时间长度。</li>
<li><strong>吞吐量</strong> - 吞吐量关注在特定的时间周期内一个应用的工作量的最大值。对关注吞吐量的应用来说长暂停时间是可以接受的。由于高吞吐量的应用关注的基准在更长周期时间上，所以快速响应时间不在考虑之内。</li>
</ul>
<h3 id="标记-清除（Mark-Sweep）"><a href="#标记-清除（Mark-Sweep）" class="headerlink" title="标记 - 清除（Mark-Sweep）"></a>标记 - 清除（Mark-Sweep）</h3><div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/jvm/jvm-gc-mark-sweep.jpg" />
</div>

<p>将需要回收的对象进行标记，然后清理掉被标记的对象。</p>
<p>不足：</p>
<ul>
<li>标记和清除过程效率都不高；</li>
<li>会产生大量不连续的内存碎片，导致无法给大对象分配内存。</li>
</ul>
<h3 id="标记-整理（Mark-Compact）"><a href="#标记-整理（Mark-Compact）" class="headerlink" title="标记 - 整理（Mark-Compact）"></a>标记 - 整理（Mark-Compact）</h3><div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/jvm/jvm-gc-mark-compact.jpg" />
</div>

<p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<p>这种做法能够解决内存碎片化的问题，但代价是压缩算法的性能开销。</p>
<h3 id="复制（Copying）"><a href="#复制（Copying）" class="headerlink" title="复制（Copying）"></a>复制（Copying）</h3><div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/jvm/jvm-gc-copying.jpg" />
</div>

<p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。</p>
<p>主要不足是只使用了内存的一半。</p>
<p>现在的商业虚拟机都<strong>采用这种收集算法来回收年轻代</strong>，但是并不是将内存划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survior 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1（可以通过参数 <code>-XX:SurvivorRatio</code> 来调整比例），保证了内存的利用率达到 90 %。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。</p>
<h3 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h3><p>现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。</p>
<p>一般将 Java 堆分为年轻代和老年代。</p>
<ul>
<li>年轻代使用：<strong>复制</strong> 算法</li>
<li>老年代使用：<strong>标记 - 清理</strong> 或者 <strong>标记 - 整理</strong> 算法</li>
</ul>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/jvm/jvm-hotspot-heap-structure.png" />
</div>

<h4 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h4><p>新生代是大部分对象创建和销毁的区域，在通常的 Java 应用中，绝大部分对象生命周期都是很短暂的。其内部又分为 <code>Eden</code> 区域，作为对象初始分配的区域；两个 <code>Survivor</code>，有时候也叫 <code>from</code>、<code>to</code> 区域，被用来放置从 Minor GC 中保留下来的对象。</p>
<p>JVM 会随意选取一个 <code>Survivor</code> 区域作为 <code>to</code>，然后会在 GC 过程中进行区域间拷贝，也就是将 Eden 中存活下来的对象和 <code>from</code> 区域的对象，拷贝到这个<code>to</code>区域。这种设计主要是为了防止内存的碎片化，并进一步清理无用对象。</p>
<p>Java 虚拟机会记录 <code>Survivor</code> 区中的对象一共被来回复制了几次。如果一个对象被复制的次数为 15（对应虚拟机参数 <code>-XX:+MaxTenuringThreshold</code>），那么该对象将被晋升（promote）至老年代。另外，如果单个 <code>Survivor</code> 区已经被占用了 50%（对应虚拟机参数 <code>-XX:TargetSurvivorRatio</code>），那么较高复制次数的对象也会被晋升至老年代。</p>
<h4 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h4><p>放置长生命周期的对象，通常都是从 <code>Survivor</code> 区域拷贝过来的对象。当然，也有特殊情况，如果对象较大，JVM 会试图直接分配在 <code>Eden</code> 其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM 就会直接分配到老年代。</p>
<h4 id="永久代"><a href="#永久代" class="headerlink" title="永久代"></a>永久代</h4><p>这部分就是早期 Hotspot JVM 的方法区实现方式了，储存 Java 类元数据、常量池、Intern 字符串缓存。在 JDK 8 之后就不存在永久代这块儿了。</p>
<h4 id="JVM-参数"><a href="#JVM-参数" class="headerlink" title="JVM 参数"></a>JVM 参数</h4><p>这里顺便提一下，JVM 允许对堆空间大小、各代空间大小进行设置，以调整 JVM GC。</p>
<table>
<thead>
<tr>
<th>配置</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>-Xss</code></td>
<td>虚拟机栈大小。</td>
</tr>
<tr>
<td><code>-Xms</code></td>
<td>堆空间初始值。</td>
</tr>
<tr>
<td><code>-Xmx</code></td>
<td>堆空间最大值。</td>
</tr>
<tr>
<td><code>-Xmn</code></td>
<td>新生代空间大小。</td>
</tr>
<tr>
<td><code>-XX:NewSize</code></td>
<td>新生代空间初始值。</td>
</tr>
<tr>
<td><code>-XX:MaxNewSize</code></td>
<td>新生代空间最大值。</td>
</tr>
<tr>
<td><code>-XX:NewRatio</code></td>
<td>新生代与年老代的比例。默认为 2，意味着老年代是新生代的 2 倍。</td>
</tr>
<tr>
<td><code>-XX:SurvivorRatio</code></td>
<td>新生代中调整 eden 区与 survivor 区的比例，默认为 8。即 <code>eden</code> 区为 80% 的大小，两个 <code>survivor</code> 分别为 10% 的大小。</td>
</tr>
<tr>
<td><code>-XX:PermSize</code></td>
<td>永久代空间的初始值。</td>
</tr>
<tr>
<td><code>-XX:MaxPermSize</code></td>
<td>永久代空间的最大值。</td>
</tr>
</tbody></table>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/jvm/jvm-gc-overview.jpg" />
</div>

<p>以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。</p>
<p>注：G1 垃圾收集器既可以回收年轻代内存，也可以回收老年代内存。而其他垃圾收集器只能针对特定代的内存进行回收。</p>
<h3 id="串行收集器"><a href="#串行收集器" class="headerlink" title="串行收集器"></a>串行收集器</h3><p>串行收集器（Serial）是最基本、发展历史最悠久的收集器。</p>
<p>串行收集器是 <strong><code>client</code> 模式下的默认收集器配置</strong>。因为在客户端模式下，分配给虚拟机管理的内存一般来说不会很大。Serial 收集器收集几十兆甚至一两百兆的年轻代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。</p>
<p><strong>串行收集器采用单线程 stop-the-world 的方式进行收集</strong>。当内存不足时，串行 GC 设置停顿标识，待所有线程都进入安全点（Safepoint）时，应用线程暂停，串行 GC 开始工作，<strong>采用单线程方式回收空间并整理内存</strong>。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/jvm/jvm-gc-serial.jpg" />
<p>Serial / Serial Old 收集器运行示意图</p>
</div>

<p>单线程意味着复杂度更低、占用内存更少，垃圾回收效率高；但同时也意味着不能有效利用多核优势。事实上，串行收集器特别适合堆内存不高、单核甚至双核 CPU 的场合。</p>
<h4 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h4><blockquote>
<p>开启选项：<code>-XX:+UseSerialGC</code></p>
<p>打开此开关后，使用 <strong>Serial</strong> + <strong>Serial Old</strong> 收集器组合来进行内存回收。</p>
</blockquote>
<h4 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h4><p>Serial Old 是 Serial 收集器的老年代版本，也是给 Client 模式下的虚拟机使用。如果用在 Server 模式下，它有两大用途：</p>
<ul>
<li>在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。</li>
<li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</li>
</ul>
<h3 id="并行收集器"><a href="#并行收集器" class="headerlink" title="并行收集器"></a>并行收集器</h3><blockquote>
<p>开启选项：<code>-XX:+UseParallelGC</code></p>
<p>打开此开关后，使用 <strong>Parallel Scavenge</strong> + <strong>Serial Old</strong> 收集器组合来进行内存回收。</p>
<p>开启选项：<code>-XX:+UseParallelOldGC</code></p>
<p>打开此开关后，使用 <strong>Parallel Scavenge</strong> + <strong>Parallel Old</strong> 收集器组合来进行内存回收。</p>
</blockquote>
<p>其他收集器都是以关注停顿时间为目标，而<strong>并行收集器是以关注吞吐量（Throughput）为目标的垃圾收集器</strong>。</p>
<ul>
<li>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验；</li>
<li>而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</li>
</ul>
<figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">吞吐量 </span>=<span class="string"> 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)</span></span><br></pre></td></tr></table></figure>

<p><strong>并行收集器是 server 模式下的默认收集器。</strong></p>
<p>并行收集器与串行收集器工作模式相似，都是 stop-the-world 方式，只是暂停时并行地进行垃圾收集。<strong>并行收集器年轻代采用复制算法，老年代采用标记-整理</strong>，在回收的同时还会对内存进行压缩。并行收集器适合对吞吐量要求远远高于延迟要求的场景，并且在满足最差延时的情况下，并行收集器将提供最佳的吞吐量。</p>
<p><strong>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 收集器 + Parallel Old 收集器。</strong></p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/jvm/jvm-gc-parallel.jpg" />
<p>Parallel / Parallel Old 收集器运行示意图</p>
</div>

<h4 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h4><p>Parallel Scavenge 收集器提供了两个参数用于精确控制吞吐量，分别是：</p>
<ul>
<li><code>-XX:MaxGCPauseMillis</code> - 控制最大垃圾收集停顿时间，收集器将尽可能保证内存回收时间不超过设定值。</li>
<li><code>-XX:GCTimeRatio</code> - 直接设置吞吐量大小的（值为大于 0 且小于 100 的整数）。</li>
</ul>
<p>缩短停顿时间是以牺牲吞吐量和年轻代空间来换取的：年轻代空间变小，垃圾回收变得频繁，导致吞吐量下降。</p>
<p>Parallel Scavenge 收集器还提供了一个参数 <code>-XX:+UseAdaptiveSizePolicy</code>，这是一个开关参数，打开参数后，就不需要手工指定年轻代的大小（<code>-Xmn</code>）、Eden 和 Survivor 区的比例（<code>-XX:SurvivorRatio</code>）、晋升老年代对象年龄（<code>-XX:PretenureSizeThreshold</code>）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种方式称为 GC 自适应的调节策略（GC Ergonomics）。</p>
<h4 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h4><p>是 Parallel Scavenge 收集器的老年代版本，使用<strong>多线程和 “标记-整理” 算法</strong>。</p>
<h3 id="并发标记清除收集器"><a href="#并发标记清除收集器" class="headerlink" title="并发标记清除收集器"></a>并发标记清除收集器</h3><blockquote>
<p>开启选项：<code>-XX:+UseConcMarkSweepGC</code></p>
<p>打开此开关后，使用 <strong>CMS</strong> + <strong>ParNew</strong> + <strong>Serial Old</strong> 收集器组合来进行内存回收。</p>
</blockquote>
<p>并发标记清除收集器是以获取最短停顿时间为目标。</p>
<p>开启后，年轻代使用 ParNew 收集器；老年代使用 CMS 收集器，如果 CMS 产生的碎片过多，导致无法存放浮动垃圾，JVM 会出现 <code>Concurrent Mode Failure</code> ，此时使用 Serial Old 收集器来替代 CMS 收集器清理碎片。</p>
<h4 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h4><p><strong>CMS 收集器是一种以获取最短停顿时间为目标的收集器。</strong></p>
<p>CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。</p>
<h5 id="CMS-回收机制"><a href="#CMS-回收机制" class="headerlink" title="CMS 回收机制"></a>CMS 回收机制</h5><p>CMS 收集器运行步骤如下：</p>
<ol>
<li><strong>初始标记</strong>：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。</li>
<li><strong>并发标记</strong>：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。</li>
<li><strong>重新标记</strong>：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li>
<li><strong>并发清除</strong>：回收在标记阶段被鉴定为不可达的对象。不需要停顿。</li>
</ol>
<p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/jvm/jvm-gc-cms.jpg" />
<p>CMS 收集器运行示意图</p>
</div>

<h5 id="CMS-回收年轻代详细步骤"><a href="#CMS-回收年轻代详细步骤" class="headerlink" title="CMS 回收年轻代详细步骤"></a>CMS 回收年轻代详细步骤</h5><p><strong>（1）堆空间被分割为三块空间</strong></p>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide1.png" alt="img"><br>年轻代分割成一个 Eden 区和两个 Survivor 区。年老代一个连续的空间。就地完成对象收集。除非有 FullGC 否则不会压缩。</p>
<p><strong>（2）CMS 年轻代垃圾收集如何工作</strong></p>
<p>年轻代被标为浅绿色，年老代被标记为蓝色。如果你的应用已经运行了一段时间，CMS 的堆看起来应该是这个样子。对象分散在年老代区域里。</p>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide2.png" alt="img"></p>
<p>使用 CMS，年老代对象就地释放。它们不会被来回移动。这个空间不会被压缩除非发生 FullGC。</p>
<p><strong>（3）年轻代收集</strong></p>
<p>从 Eden 和 Survivor 区复制活跃对象到另一个 Survivor 区。所有达到他们的年龄阈值的对象会晋升到年老代。</p>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide3.png" alt="img"><br><strong>（4）年轻代回收之后</strong></p>
<p>一次年轻代垃圾收集之后，Eden 区和其中一个 Survivor 区被清空。</p>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide4.png" alt="img"><br>最近晋升的对象以深蓝色显示在上图中，绿色的对象是年轻代幸免的还没有晋升到老年代对象。</p>
<h5 id="CMS-回收年老代详细步骤"><a href="#CMS-回收年老代详细步骤" class="headerlink" title="CMS 回收年老代详细步骤"></a>CMS 回收年老代详细步骤</h5><p><strong>（1）CMS 的年老代收集</strong></p>
<p>发生两次 stop the world 事件：初始标记和重新标记。当年老代达到特定的占用比例时，CMS 开始执行。</p>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide5.png" alt="img"></p>
<ul>
<li>初始标记是一个短暂暂停的、可达对象被标记的阶段。</li>
<li>并发标记寻找活跃对象在应用连续执行时。</li>
<li>最后，在重新标记阶段，寻找在之前并发标记阶段中丢失的对象。</li>
</ul>
<p><strong>（2）年老代收集-并发清除</strong></p>
<p>在之前阶段没有被标记的对象会被就地释放。不进行压缩操作。</p>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide6.png" alt="img"><br><strong>注意：</strong>未被标记的对象等于死亡对象</p>
<p><strong>（3）年老代收集-清除之后</strong></p>
<p>清除阶段之后，你可以看到大量内存被释放。你还可以注意到没有进行压缩操作。</p>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide7.png" alt="img"><br>最后，CMS 收集器会再次进入重新设置阶段，等待下一次垃圾收集时机的到来。</p>
<h5 id="CMS-特点"><a href="#CMS-特点" class="headerlink" title="CMS 特点"></a>CMS 特点</h5><p>CMS 收集器具有以下缺点：</p>
<ul>
<li>并发收集 - 并发指的是用户线程和 GC 线程同时运行。</li>
<li>吞吐量低 - 低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</li>
<li>无法处理浮动垃圾 - 可能出现 <code>Concurrent Mode Failure</code>。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。<ul>
<li>可以使用 <code>-XX:CMSInitiatingOccupancyFraction</code> 来改变触发 CMS 收集器工作的内存占用百分，如果这个值设置的太大，导致预留的内存不够存放浮动垃圾，就会出现 <code>Concurrent Mode Failure</code>，这时虚拟机将临时启用 Serial Old 收集器来替代 CMS 收集器。</li>
</ul>
</li>
<li>标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。<ul>
<li>可以使用 <code>-XX:+UseCMSCompactAtFullCollection</code> ，用于在 CMS 收集器要进行 Full GC 时开启内存碎片的合并整理，内存整理的过程是无法并发的，空间碎片问题没有了，但是停顿时间不得不变长了。</li>
<li>可以使用 <code>-XX:CMSFullGCsBeforeCompaction</code> ，用于设置执行多少次不压缩的 Full GC 后，来一次带压缩的（默认为 0，表示每次进入 Full GC 时都要进行碎片整理）。</li>
</ul>
</li>
</ul>
<h4 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h4><blockquote>
<p>开启选项：<code>-XX:+UseParNewGC</code></p>
</blockquote>
<p>ParNew 收集器其实是 Serial 收集器的多线程版本。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/jvm/jvm-gc-par-new.jpg" />
<p>ParNew 收集器运行示意图</p>
</div>

<p>是 Server 模式下的虚拟机首选年轻代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。</p>
<p>ParNew 收集器也是使用 <code>-XX:+UseConcMarkSweepGC</code> 后的默认年轻代收集器。</p>
<p>ParNew 收集器默认开启的线程数量与 CPU 数量相同，可以使用 -<code>XX:ParallelGCThreads</code> 参数来设置线程数。</p>
<h3 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h3><blockquote>
<p>开启选项：<code>-XX:+UseG1GC</code></p>
</blockquote>
<p>前面提到的垃圾收集器一般策略是关注吞吐量或停顿时间。而 <strong>G1 是一种兼顾吞吐量和停顿时间的 GC 收集器</strong>。G1 是 Oracle JDK9 以后的默认 GC 收集器。G1 可以直观的设定停顿时间的目标，相比于 CMS GC，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多。</p>
<p>G1 最大的特点是引入分区的思路，弱化了分代的概念，合理利用垃圾收集各个周期的资源，解决了其他收集器甚至 CMS 的众多缺陷。</p>
<h4 id="分代和分区"><a href="#分代和分区" class="headerlink" title="分代和分区"></a>分代和分区</h4><p>旧的垃圾收集器一般采取分代收集，Java 堆被分为年轻代、老年代和永久代。收集的范围都是整个年轻代或者整个老年代。</p>
<p>G1 取消了永久代，并把年轻代和老年代划分成多个大小相等的独立区域（Region），年轻代和老年代不再物理隔离。G1 可以直接对年轻代和老年代一起回收。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/jvm/jvm-gc-g1-heap-allocation.png" />
</div>

<p>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p>
<p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p>
<h4 id="G1-回收机制"><a href="#G1-回收机制" class="headerlink" title="G1 回收机制"></a>G1 回收机制</h4><div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/jvm/jvm-gc-g1.jpg" />
<p>G1 收集器运行示意图</p>
</div>

<p>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：</p>
<ol>
<li><strong>初始标记</strong></li>
<li><strong>并发标记</strong></li>
<li><strong>最终标记</strong> - 为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。</li>
<li><strong>筛选回收</strong> - 首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li>
</ol>
<p>具备如下特点：</p>
<ul>
<li>空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</li>
<li>可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</li>
</ul>
<h4 id="G1-回收年轻代详细步骤"><a href="#G1-回收年轻代详细步骤" class="headerlink" title="G1 回收年轻代详细步骤"></a>G1 回收年轻代详细步骤</h4><p><strong>（1）G1 初始堆空间</strong></p>
<p>堆空间是一个被分成许多固定大小区域的内存块。</p>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide8.png" alt="img"><br>Java 虚拟机启动时选定区域大小。Java 虚拟机通常会指定 2000 个左右的大小相等、每个大小范围在 1 到 32M 的区域。</p>
<p><strong>（2）G1 堆空间分配</strong></p>
<p>实际上，这些区域被映射成 Eden、Survivor、年老代空间的逻辑表述形式。</p>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide9.png" alt="img"><br>图片中的颜色表明了哪个区域被关联上什么角色。活跃对象从一个区域疏散（复制、移动）到另一个区域。区域被设计为并行的方式收集，可以暂停或者不暂停所有的其它用户线程。</p>
<p>明显的区域可以被分配成 Eden、Survivor、Old 区域。另外，有第四种类型的区域叫做*极大区域(Humongous regions)*。这些区域被设计成保持标准区域大小的 50%或者更大的对象。它们被保存在一个连续的区域集合里。最后，最后一个类型的区域就是堆空间里没有使用的区域。</p>
<p><strong>注意：</strong>写作此文章时，收集极大对象时还没有被优化。因此，你应该避免创建这个大小的对象。</p>
<p><strong>（3）G1 的年轻代</strong></p>
<p>堆空间被分割成大约 2000 个区域。最小 1M，最大 32M，蓝色区域保持年老代对象，绿色区域保持年轻代对象。</p>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide10.png" alt="img"><br><strong>注意：</strong>区域没有必要像旧的收集器一样是保持连续的。</p>
<p><strong>（4）G1 的年轻代收集</strong></p>
<p>活跃对象会被疏散（复制、移动）到一个或多个 survivor 区域。如果达到晋升总阈值，对象会晋升到年老代区域。</p>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide11.png" alt="img"><br>这是一个 stop the world 暂停。为下一次年轻代垃圾回收计算 Eden 和 Survivor 的大小。保留审计信息有助于计算大小。类似目标暂停时间的事情会被考虑在内。</p>
<p>这个方法使重调区域大小变得很容易，按需把它们调大或调小。</p>
<p><strong>（5）G1 年轻代回收的尾声</strong></p>
<p>活跃对象被疏散到 Survivor 或者年老代区域。</p>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide12.png" alt="img"><br>最近晋升的对象显示为深蓝色。Survivor 区域显示为绿色。</p>
<p>关于 G1 的年轻代回收做以下总结：</p>
<ul>
<li>堆空间是一块单独的内存空间被分割成多个区域。</li>
<li>年轻代内存是由一组非连续的区域组成。这使得需要重调大小变得容易。</li>
<li>年轻代垃圾回收是 stop the world 事件，所有应用线程都会因此操作暂停。</li>
<li>年轻代垃圾收集使用多线程并行回收。</li>
<li>活跃对象被复制到新的 Survivor 区或者年老代区域。</li>
</ul>
<h4 id="G1-回收年老代详细步骤"><a href="#G1-回收年老代详细步骤" class="headerlink" title="G1 回收年老代详细步骤"></a>G1 回收年老代详细步骤</h4><p><strong>（1）初始标记阶段</strong></p>
<p>年轻代垃圾收集肩负着活跃对象初始标记的任务。在日志文件中被标为<em>GC pause (young)(inital-mark)</em></p>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide13.png" alt="img"><br><strong>（2）并发标记阶段</strong></p>
<p>如果发现空区域(“X”标示的)，在重新标记阶段它们会被马上清除掉。当然，决定活性的审计信息也在此时被计算。</p>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide14.png" alt="img"><br><strong>（3）重新标记阶段</strong></p>
<p>空的区域被清除和回收掉。所有区域的活性在此时计算。</p>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide15.png" alt="img"><br><strong>（4）复制&#x2F;清理阶段</strong></p>
<p>G1 选择活性最低的区域，这些区域能够以最快的速度回收。然后这些区域会在年轻代垃圾回收过程中被回收。在日志中被指示为*[GC pause (mixed)]*。所以年轻代和年老代在同一时间被回收。</p>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide16.png" alt="img"><br><strong>（5）复制&#x2F;清理阶段之后</strong></p>
<p>被选择的区域已经被回收和压缩到图中显示的深蓝色区和深绿色区中。</p>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide17.png" alt="img"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th align="center">收集器</th>
<th align="center">串行&#x2F;并行&#x2F;并发</th>
<th align="center">年轻代&#x2F;老年代</th>
<th align="center">收集算法</th>
<th align="center">目标</th>
<th align="center">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>Serial</strong></td>
<td align="center">串行</td>
<td align="center">年轻代</td>
<td align="center">复制</td>
<td align="center">响应速度优先</td>
<td align="center">单 CPU 环境下的 Client 模式</td>
</tr>
<tr>
<td align="center"><strong>Serial Old</strong></td>
<td align="center">串行</td>
<td align="center">老年代</td>
<td align="center">标记-整理</td>
<td align="center">响应速度优先</td>
<td align="center">单 CPU 环境下的 Client 模式、CMS 的后备预案</td>
</tr>
<tr>
<td align="center"><strong>ParNew</strong></td>
<td align="center">串行 + 并行</td>
<td align="center">年轻代</td>
<td align="center">复制算法</td>
<td align="center">响应速度优先</td>
<td align="center">多 CPU 环境时在 Server 模式下与 CMS 配合</td>
</tr>
<tr>
<td align="center"><strong>Parallel Scavenge</strong></td>
<td align="center">串行 + 并行</td>
<td align="center">年轻代</td>
<td align="center">复制算法</td>
<td align="center">吞吐量优先</td>
<td align="center">在后台运算而不需要太多交互的任务</td>
</tr>
<tr>
<td align="center"><strong>Parallel Old</strong></td>
<td align="center">串行 + 并行</td>
<td align="center">老年代</td>
<td align="center">标记-整理</td>
<td align="center">吞吐量优先</td>
<td align="center">在后台运算而不需要太多交互的任务</td>
</tr>
<tr>
<td align="center"><strong>CMS</strong></td>
<td align="center">并行 + 并发</td>
<td align="center">老年代</td>
<td align="center">标记-清除</td>
<td align="center">响应速度优先</td>
<td align="center">集中在互联网站或 B&#x2F;S 系统服务端上的 Java 应用</td>
</tr>
<tr>
<td align="center"><strong>G1</strong></td>
<td align="center">并行 + 并发</td>
<td align="center">年轻代 + 老年代</td>
<td align="center">标记-整理 + 复制算法</td>
<td align="center">响应速度优先</td>
<td align="center">面向服务端应用，将来替换 CMS</td>
</tr>
</tbody></table>
<h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><p>对象的内存分配，也就是在堆上分配。主要分配在年轻代的 Eden 区上，少数情况下也可能直接分配在老年代中。</p>
<h3 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h3><p><strong>当 <code>Eden</code> 区空间不足时，触发 Minor GC</strong>。</p>
<p><strong>Minor GC 发生在年轻代上</strong>，因为年轻代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。</p>
<p>Minor GC 工作流程：</p>
<ol>
<li><p>Java 应用不断创建对象，通常都是分配在 <code>Eden</code> 区域，当其空间不足时（达到设定的阈值），触发 minor GC。仍然被引用的对象（绿色方块）存活下来，被复制到 JVM 选择的 Survivor 区域，而没有被引用的对象（黄色方块）则被回收。</p>
</li>
<li><p>经过一次 Minor GC，Eden 就会空闲下来，直到再次达到 Minor GC 触发条件。这时候，另外一个 Survivor 区域则会成为 <code>To</code> 区域，Eden 区域的存活对象和 <code>From</code> 区域对象，都会被复制到 <code>To</code> 区域，并且存活的年龄计数会被加 1。</p>
</li>
<li><p>类似第二步的过程会发生很多次，直到有对象年龄计数达到阈值，这时候就会发生所谓的晋升（Promotion）过程，如下图所示，超过阈值的对象会被晋升到老年代。这个阈值是可以通过 <code>-XX:MaxTenuringThreshold</code> 参数指定。</p>
</li>
</ol>
<h3 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h3><p><strong>Full GC 发生在老年代上</strong>，老年代对象和年轻代的相反，其存活时间长，因此 Full GC 很少执行，而且执行速度会比 Minor GC 慢很多。</p>
<h4 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h4><p><strong>（一）对象优先在 Eden 分配</strong></p>
<p>大多数情况下，对象在年轻代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC。</p>
<p><strong>（二）大对象直接进入老年代</strong></p>
<p>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。</p>
<p>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。</p>
<p><code>-XX:PretenureSizeThreshold</code>，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制。</p>
<p><strong>（三）长期存活的对象进入老年代</strong></p>
<p>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。</p>
<p><code>-XX:MaxTenuringThreshold</code> 用来定义年龄的阈值。</p>
<p><strong>（四）动态对象年龄判定</strong></p>
<p>虚拟机并不是永远地要求对象的年龄必须达到 <code>MaxTenuringThreshold</code> 才能晋升老年代，如果在 Survivor 区中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 <code>MaxTenuringThreshold</code> 中要求的年龄。</p>
<p><strong>（五）空间分配担保</strong></p>
<p>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于年轻代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的；如果不成立的话虚拟机会查看 <code>HandlePromotionFailure</code> 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC，尽管这次 Minor GC 是有风险的；如果小于，或者 <code>HandlePromotionFailure</code> 设置不允许冒险，那这时也要改为进行一次 Full GC。</p>
<h4 id="Full-GC-的触发条件"><a href="#Full-GC-的触发条件" class="headerlink" title="Full GC 的触发条件"></a>Full GC 的触发条件</h4><p>对于 Minor GC，其触发条件非常简单，当 Eden 区空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：</p>
<p><strong>（1）调用 <code>System.gc()</code></strong></p>
<p>此方法的调用是建议虚拟机进行 Full GC，虽然只是建议而非一定，但很多情况下它会触发 Full GC，从而增加 Full GC 的频率，也即增加了间歇性停顿的次数。因此强烈建议能不使用此方法就不要使用，让虚拟机自己去管理它的内存。可通过 <code>-XX:DisableExplicitGC</code> 来禁止 RMI 调用 <code>System.gc()</code>。</p>
<p><strong>（2）老年代空间不足</strong></p>
<p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等，当执行 Full GC 后空间仍然不足，则抛出 <code>java.lang.OutOfMemoryError: Java heap space</code>。为避免以上原因引起的 Full GC，调优时应尽量做到让对象在 Minor GC 阶段被回收、让对象在年轻代多存活一段时间以及不要创建过大的对象及数组。</p>
<p><strong>（3）方法区空间不足</strong></p>
<p>JVM 规范中运行时数据区域中的<strong>方法区</strong>，在 HotSpot 虚拟机中又被习惯称为<strong>永久代</strong>，永久代中存放的是类的描述信息、常量、静态变量等数据，当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么 JVM 会抛出 <code>java.lang.OutOfMemoryError: PermGen space</code> 错误。为避免永久代占满造成 Full GC 现象，可采用的方法为增大 Perm Gen 空间或转为使用 CMS GC。</p>
<p><strong>（4）Minor GC 的平均晋升空间大小大于老年代可用空间</strong></p>
<p>如果发现统计数据说之前 Minor GC 的平均晋升大小比目前老年代剩余的空间大，则不会触发 Minor GC 而是转为触发 Full GC。</p>
<p><strong>（5）对象大小大于 To 区和老年代的可用内存</strong></p>
<p>由 <code>Eden</code> 区、<code>From</code> 区向 <code>To</code> 区复制时，对象大小大于 To 区可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/34907497/">《深入理解 Java 虚拟机》</a></li>
<li><a target="_blank" rel="noopener" href="https://www.douban.com/doulist/2545443/">从表到里学习 JVM 实现</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/coderlius/article/details/79272773">详解 JVM Garbage First(G1) 垃圾收集器</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhanggang807/article/details/45956325">G1 垃圾收集器入门</a></li>
<li><a target="_blank" rel="noopener" href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html">Getting Started with the G1 Garbage Collector</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/0d066a/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/0d066a/" class="post-title-link" itemprop="url">深入理解 Java 反射和动态代理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-04 13:51:01" itemprop="dateCreated datePublished" datetime="2020-06-04T13:51:01+08:00">2020-06-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JavaSE/%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7/" itemprop="url" rel="index"><span itemprop="name">基础特性</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>21k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>20 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="深入理解-Java-反射和动态代理"><a href="#深入理解-Java-反射和动态代理" class="headerlink" title="深入理解 Java 反射和动态代理"></a>深入理解 Java 反射和动态代理</h1><h2 id="反射简介"><a href="#反射简介" class="headerlink" title="反射简介"></a>反射简介</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/xmind/Java%E5%8F%8D%E5%B0%84.svg" alt="img"></p>
<h3 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h3><p>反射(Reflection)是 Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。</p>
<p><strong>通过反射机制，可以在运行时访问 Java 对象的属性，方法，构造方法等。</strong></p>
<h3 id="反射的应用场景"><a href="#反射的应用场景" class="headerlink" title="反射的应用场景"></a>反射的应用场景</h3><p>反射的主要应用场景有：</p>
<ul>
<li><strong>开发通用框架</strong> - 反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 JavaBean、Filter 等），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。</li>
<li><strong>动态代理</strong> - 在切面编程（AOP）中，需要拦截特定的方法，通常，会选择动态代理方式。这时，就需要反射技术来实现了。</li>
<li><strong>注解</strong> - 注解本身仅仅是起到标记作用，它需要利用反射机制，根据注解标记去调用注解解释器，执行行为。如果没有反射机制，注解并不比注释更有用。</li>
<li><strong>可扩展性功能</strong> - 应用程序可以通过使用完全限定名称创建可扩展性对象实例来使用外部的用户定义类。</li>
</ul>
<h3 id="反射的缺点"><a href="#反射的缺点" class="headerlink" title="反射的缺点"></a>反射的缺点</h3><ul>
<li><strong>性能开销</strong> - 由于反射涉及动态解析的类型，因此无法执行某些 Java 虚拟机优化。因此，反射操作的性能要比非反射操作的性能要差，应该在性能敏感的应用程序中频繁调用的代码段中避免。</li>
<li><strong>破坏封装性</strong> - 反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。</li>
<li><strong>内部曝光</strong> - 由于反射允许代码执行在非反射代码中非法的操作，例如访问私有字段和方法，所以反射的使用可能会导致意想不到的副作用，这可能会导致代码功能失常并可能破坏可移植性。反射代码打破了抽象，因此可能会随着平台的升级而改变行为。</li>
</ul>
<h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/1553611895164.png" alt="img"></p>
<p>类加载的完整过程如下：</p>
<ol>
<li>在编译时，Java 编译器编译好 <code>.java</code> 文件之后，在磁盘中产生 <code>.class</code> 文件。<code>.class</code> 文件是二进制文件，内容是只有 JVM 能够识别的机器码。</li>
<li>JVM 中的类加载器读取字节码文件，取出二进制数据，加载到内存中，解析.class 文件内的信息。类加载器会根据类的全限定名来获取此类的二进制字节流；然后，将字节流所代表的静态存储结构转化为方法区的运行时数据结构；接着，在内存中生成代表这个类的 <code>java.lang.Class</code> 对象。</li>
<li>加载结束后，JVM 开始进行连接阶段（包含验证、准备、初始化）。经过这一系列操作，类的变量会被初始化。</li>
</ol>
<h3 id="Class-对象"><a href="#Class-对象" class="headerlink" title="Class 对象"></a>Class 对象</h3><p>要想使用反射，首先需要获得待操作的类所对应的 Class 对象。<strong>Java 中，无论生成某个类的多少个对象，这些对象都会对应于同一个 Class 对象。这个 Class 对象是由 JVM 生成的，通过它能够获悉整个类的结构</strong>。所以，<code>java.lang.Class</code> 可以视为所有反射 API 的入口点。</p>
<p><strong>反射的本质就是：在运行时，把 Java 类中的各种成分映射成一个个的 Java 对象。</strong></p>
<p>举例来说，假如定义了以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br></pre></td></tr></table></figure>

<p>步骤说明：</p>
<ol>
<li>JVM 加载方法的时候，遇到 <code>new User()</code>，JVM 会根据 <code>User</code> 的全限定名去加载 <code>User.class</code> 。</li>
<li>JVM 会去本地磁盘查找 <code>User.class</code> 文件并加载 JVM 内存中。</li>
<li>JVM 通过调用类加载器自动创建这个类对应的 <code>Class</code> 对象，并且存储在 JVM 的方法区。注意：<strong>一个类有且只有一个 <code>Class</code> 对象</strong>。</li>
</ol>
<h3 id="方法的反射调用"><a href="#方法的反射调用" class="headerlink" title="方法的反射调用"></a>方法的反射调用</h3><p>方法的反射调用，也就是 <code>Method.invoke</code> 方法。</p>
<p><code>Method.invoke</code> 方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Method</span> <span class="keyword">extends</span> <span class="title class_">Executable</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object obj, Object... args)</span> <span class="keyword">throws</span> ... &#123;</span><br><span class="line">    ... <span class="comment">// 权限检查</span></span><br><span class="line">    <span class="type">MethodAccessor</span> <span class="variable">ma</span> <span class="operator">=</span> methodAccessor;</span><br><span class="line">    <span class="keyword">if</span> (ma == <span class="literal">null</span>) &#123;</span><br><span class="line">      ma = acquireMethodAccessor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ma.invoke(obj, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Method.invoke</code> 方法实际上委派给 <code>MethodAccessor</code> 接口来处理。它有两个已有的具体实现：</p>
<ul>
<li><code>NativeMethodAccessorImpl</code>：本地方法来实现反射调用</li>
<li><code>DelegatingMethodAccessorImpl</code>：委派模式来实现反射调用</li>
</ul>
<p>每个 <code>Method</code> 实例的第一次反射调用都会生成一个委派实现（<code>DelegatingMethodAccessorImpl</code>），它所委派的具体实现便是一个本地实现（<code>NativeMethodAccessorImpl</code>）。本地实现非常容易理解。当进入了 Java 虚拟机内部之后，我们便拥有了 <code>Method</code> 实例所指向方法的具体地址。这时候，反射调用无非就是将传入的参数准备好，然后调用进入目标方法。</p>
<p>【示例】通过抛出异常方式 打印 <code>Method.invoke</code> 调用轨迹</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">target</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;#&quot;</span> + i).printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;io.github.dunwu.javacore.reflect.MethodDemo01&quot;</span>);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;target&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line">        method.invoke(<span class="literal">null</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// java.lang.Exception: #0</span></span><br><span class="line"><span class="comment">//     at io.github.dunwu.javacore.reflect.MethodDemo01.target(MethodDemo01.java:12)</span></span><br><span class="line"><span class="comment">//     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span></span><br><span class="line"><span class="comment">//     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span></span><br></pre></td></tr></table></figure>

<p>先调用 <code>DelegatingMethodAccessorImpl</code>；然后调用 <code>NativeMethodAccessorImpl</code>，最后调用实际方法。</p>
<p>为什么反射调用<code>DelegatingMethodAccessorImpl</code> 作为中间层，而不是直接交给本地实现？</p>
<p>其实，Java 的反射调用机制还设立了另一种动态生成字节码的实现（下称动态实现），直接使用 invoke 指令来调用目标方法。之所以采用委派实现，便是为了能够在本地实现以及动态实现中切换。动态实现和本地实现相比，其运行效率要快上 20 倍。这是因为动态实现无需经过 Java 到 C++ 再到 Java 的切换，但由于生成字节码十分耗时，仅调用一次的话，反而是本地实现要快上 3 到 4 倍。</p>
<p>考虑到许多反射调用仅会执行一次，Java 虚拟机设置了一个阈值 15（可以通过 <code>-Dsun.reflect.inflationThreshold</code> 来调整），当某个反射调用的调用次数在 15 之下时，采用本地实现；当达到 15 时，便开始动态生成字节码，并将委派实现的委派对象切换至动态实现，这个过程我们称之为 Inflation。</p>
<p>【示例】执行 java -verbose:class MethodDemo02 启动</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo02</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">target</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;#&quot;</span> + i).printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Class&lt;?&gt; klass = Class.forName(<span class="string">&quot;io.github.dunwu.javacore.reflect.MethodDemo02&quot;</span>);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> klass.getMethod(<span class="string">&quot;target&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            method.invoke(<span class="literal">null</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...省略</span></span><br><span class="line">java.lang.Exception: #<span class="number">14</span></span><br><span class="line">        at io.github.dunwu.javacore.reflect.MethodDemo02.target(MethodDemo02.java:<span class="number">13</span>)</span><br><span class="line">        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">        at java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>)</span><br><span class="line">        at io.github.dunwu.javacore.reflect.MethodDemo02.main(MethodDemo02.java:<span class="number">20</span>)</span><br><span class="line">[Loaded sun.reflect.ClassFileConstants from D:\Tools\Java\jdk1<span class="number">.8</span><span class="number">.0_192</span>\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.AccessorGenerator from D:\Tools\Java\jdk1<span class="number">.8</span><span class="number">.0_192</span>\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.MethodAccessorGenerator from D:\Tools\Java\jdk1<span class="number">.8</span><span class="number">.0_192</span>\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.ByteVectorFactory from D:\Tools\Java\jdk1<span class="number">.8</span><span class="number">.0_192</span>\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.ByteVector from D:\Tools\Java\jdk1<span class="number">.8</span><span class="number">.0_192</span>\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.ByteVectorImpl from D:\Tools\Java\jdk1<span class="number">.8</span><span class="number">.0_192</span>\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.ClassFileAssembler from D:\Tools\Java\jdk1<span class="number">.8</span><span class="number">.0_192</span>\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.UTF8 from D:\Tools\Java\jdk1<span class="number">.8</span><span class="number">.0_192</span>\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.Label from D:\Tools\Java\jdk1<span class="number">.8</span><span class="number">.0_192</span>\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.Label$PatchInfo from D:\Tools\Java\jdk1<span class="number">.8</span><span class="number">.0_192</span>\jre\lib\rt.jar]</span><br><span class="line">[Loaded java.util.ArrayList$Itr from D:\Tools\Java\jdk1<span class="number">.8</span><span class="number">.0_192</span>\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.MethodAccessorGenerator$<span class="number">1</span> from D:\Tools\Java\jdk1<span class="number">.8</span><span class="number">.0_192</span>\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.ClassDefiner from D:\Tools\Java\jdk1<span class="number">.8</span><span class="number">.0_192</span>\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.ClassDefiner$<span class="number">1</span> from D:\Tools\Java\jdk1<span class="number">.8</span><span class="number">.0_192</span>\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.GeneratedMethodAccessor1 from __JVM_DefineClass__]</span><br><span class="line">java.lang.Exception: #<span class="number">15</span></span><br><span class="line">        at io.github.dunwu.javacore.reflect.MethodDemo02.target(MethodDemo02.java:<span class="number">13</span>)</span><br><span class="line">        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">        at java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>)</span><br><span class="line">        at io.github.dunwu.javacore.reflect.MethodDemo02.main(MethodDemo02.java:<span class="number">20</span>)</span><br><span class="line">[Loaded java.util.concurrent.ConcurrentHashMap$ForwardingNode from D:\Tools\Java\jdk1<span class="number">.8</span><span class="number">.0_192</span>\jre\lib\rt.jar]</span><br><span class="line">java.lang.Exception: #<span class="number">16</span></span><br><span class="line">        at io.github.dunwu.javacore.reflect.MethodDemo02.target(MethodDemo02.java:<span class="number">13</span>)</span><br><span class="line">        at sun.reflect.GeneratedMethodAccessor1.invoke(Unknown Source)</span><br><span class="line">        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">        at java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>)</span><br><span class="line">        at io.github.dunwu.javacore.reflect.MethodDemo02.main(MethodDemo02.java:<span class="number">20</span>)</span><br><span class="line"><span class="comment">// ...省略</span></span><br></pre></td></tr></table></figure>

<p>可以看到，从第 16 次开始后，都是使用 <code>DelegatingMethodAccessorImpl</code> ，不再使用本地实现 <code>NativeMethodAccessorImpl</code>。</p>
<h3 id="反射调用的开销"><a href="#反射调用的开销" class="headerlink" title="反射调用的开销"></a>反射调用的开销</h3><p>方法的反射调用会带来不少性能开销，原因主要有三个：</p>
<ul>
<li>变长参数方法导致的 Object 数组</li>
<li>基本类型的自动装箱、拆箱</li>
<li>还有最重要的方法内联</li>
</ul>
<p><code>Class.forName</code> 会调用本地方法，<code>Class.getMethod</code> 则会遍历该类的公有方法。如果没有匹配到，它还将遍历父类的公有方法。可想而知，这两个操作都非常费时。</p>
<blockquote>
<p>注意，以 <code>getMethod</code> 为代表的查找方法操作，会返回查找得到结果的一份拷贝。因此，我们应当避免在热点代码中使用返回 <code>Method</code> 数组的 <code>getMethods</code> 或者 <code>getDeclaredMethods</code> 方法，以减少不必要的堆空间消耗。在实践中，我们往往会在应用程序中缓存 <code>Class.forName</code> 和 <code>Class.getMethod</code> 的结果。</p>
</blockquote>
<p>下面只关注反射调用本身的性能开销。</p>
<p>第一，由于 Method.invoke 是一个变长参数方法，在字节码层面它的最后一个参数会是 Object 数组（感兴趣的同学私下可以用 javap 查看）。Java 编译器会在方法调用处生成一个长度为传入参数数量的 Object 数组，并将传入参数一一存储进该数组中。</p>
<p>第二，由于 Object 数组不能存储基本类型，Java 编译器会对传入的基本类型参数进行自动装箱。</p>
<p>这两个操作除了带来性能开销外，还可能占用堆内存，使得 GC 更加频繁。（如果你感兴趣的话，可以用虚拟机参数 -XX:+PrintGC 试试。）那么，如何消除这部分开销呢？</p>
<h2 id="使用反射"><a href="#使用反射" class="headerlink" title="使用反射"></a>使用反射</h2><h3 id="java-lang-reflect-包"><a href="#java-lang-reflect-包" class="headerlink" title="java.lang.reflect 包"></a>java.lang.reflect 包</h3><p>Java 中的 <code>java.lang.reflect</code> 包提供了反射功能。<code>java.lang.reflect</code> 包中的类都没有 <code>public</code> 构造方法。</p>
<p><code>java.lang.reflect</code> 包的核心接口和类如下：</p>
<ul>
<li><code>Member</code> 接口：反映关于单个成员(字段或方法)或构造函数的标识信息。</li>
<li><code>Field</code> 类：提供一个类的域的信息以及访问类的域的接口。</li>
<li><code>Method</code> 类：提供一个类的方法的信息以及访问类的方法的接口。</li>
<li><code>Constructor</code> 类：提供一个类的构造函数的信息以及访问类的构造函数的接口。</li>
<li><code>Array</code> 类：该类提供动态地生成和访问 JAVA 数组的方法。</li>
<li><code>Modifier</code> 类：提供了 static 方法和常量，对类和成员访问修饰符进行解码。</li>
<li><code>Proxy</code> 类：提供动态地生成代理类和类实例的静态方法。</li>
</ul>
<h3 id="获取-Class-对象"><a href="#获取-Class-对象" class="headerlink" title="获取 Class 对象"></a>获取 Class 对象</h3><p>获取 <code>Class</code> 对象的三种方法：</p>
<p>（1）**<code>Class.forName</code> 静态方法**</p>
<p>【示例】使用 <code>Class.forName</code> 静态方法获取 <code>Class</code> 对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.dunwu.javacore.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectClassDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;io.github.dunwu.javacore.reflect.ReflectClassDemo01&quot;</span>);</span><br><span class="line">        System.out.println(c1.getCanonicalName());</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;[D&quot;</span>);</span><br><span class="line">        System.out.println(c2.getCanonicalName());</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c3</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;[[Ljava.lang.String;&quot;</span>);</span><br><span class="line">        System.out.println(c3.getCanonicalName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="comment">//io.github.dunwu.javacore.reflect.ReflectClassDemo01</span></span><br><span class="line"><span class="comment">//double[]</span></span><br><span class="line"><span class="comment">//java.lang.String[][]</span></span><br></pre></td></tr></table></figure>

<p>使用类的完全限定名来反射对象的类。常见的应用场景为：在 JDBC 开发中常用此方法加载数据库驱动。</p>
<p>（2）<strong>类名 + <code>.class</code></strong></p>
<p>【示例】直接用类名 + <code>.class</code> 获取 <code>Class</code> 对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectClassDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> b;</span><br><span class="line">        <span class="comment">// Class c = b.getClass(); // 编译错误</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="type">boolean</span>.class;</span><br><span class="line">        System.out.println(c1.getCanonicalName());</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> java.io.PrintStream.class;</span><br><span class="line">        System.out.println(c2.getCanonicalName());</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="type">int</span>[][][].class;</span><br><span class="line">        System.out.println(c3.getCanonicalName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="comment">//boolean</span></span><br><span class="line"><span class="comment">//java.io.PrintStream</span></span><br><span class="line"><span class="comment">//int[][][]</span></span><br></pre></td></tr></table></figure>

<p>（3）**<code>Object</code> 的 <code>getClass</code> 方法**</p>
<p><code>Object</code> 类中有 <code>getClass</code> 方法，因为所有类都继承 <code>Object</code> 类。从而调用 <code>Object</code> 类来获取 <code>Class</code> 对象。</p>
<p>【示例】<code>Object</code> 的 <code>getClass</code> 方法获取 <code>Class</code> 对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.dunwu.javacore.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectClassDemo03</span> &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">E</span> &#123;A, B&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;foo&quot;</span>.getClass();</span><br><span class="line">        System.out.println(c.getCanonicalName());</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> ReflectClassDemo03.E.A.getClass();</span><br><span class="line">        System.out.println(c2.getCanonicalName());</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c3</span> <span class="operator">=</span> bytes.getClass();</span><br><span class="line">        System.out.println(c3.getCanonicalName());</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c4</span> <span class="operator">=</span> set.getClass();</span><br><span class="line">        System.out.println(c4.getCanonicalName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="comment">//java.lang.String</span></span><br><span class="line"><span class="comment">//io.github.dunwu.javacore.reflect.ReflectClassDemo.E</span></span><br><span class="line"><span class="comment">//byte[]</span></span><br><span class="line"><span class="comment">//java.util.HashSet</span></span><br></pre></td></tr></table></figure>

<h3 id="判断是否为某个类的实例"><a href="#判断是否为某个类的实例" class="headerlink" title="判断是否为某个类的实例"></a>判断是否为某个类的实例</h3><p>判断是否为某个类的实例有两种方式：</p>
<ol>
<li><strong>用 <code>instanceof</code> 关键字</strong></li>
<li><strong>用 <code>Class</code> 对象的 <code>isInstance</code> 方法</strong>（它是一个 Native 方法）</li>
</ol>
<p>【示例】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstanceofDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">if</span> (arrayList <span class="keyword">instanceof</span> List) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ArrayList is List&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (List.class.isInstance(arrayList)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ArrayList is List&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="comment">//ArrayList is List</span></span><br><span class="line"><span class="comment">//ArrayList is List</span></span><br></pre></td></tr></table></figure>

<h3 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h3><p>通过反射来创建实例对象主要有两种方式：</p>
<ul>
<li>用 <code>Class</code> 对象的 <code>newInstance</code> 方法。</li>
<li>用 <code>Constructor</code> 对象的 <code>newInstance</code> 方法。</li>
</ul>
<p>【示例】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewInstanceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line">        Class&lt;?&gt; c1 = StringBuilder.class;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> (StringBuilder) c1.newInstance();</span><br><span class="line">        sb.append(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取String所对应的Class对象</span></span><br><span class="line">        Class&lt;?&gt; c2 = String.class;</span><br><span class="line">        <span class="comment">//获取String类带一个String参数的构造器</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> c2.getConstructor(String.class);</span><br><span class="line">        <span class="comment">//根据构造器创建实例</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> (String) constructor.newInstance(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        System.out.println(str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="comment">//aaa</span></span><br><span class="line"><span class="comment">//bbb</span></span><br></pre></td></tr></table></figure>

<h3 id="创建数组实例"><a href="#创建数组实例" class="headerlink" title="创建数组实例"></a>创建数组实例</h3><p>数组在 Java 里是比较特殊的一种类型，它可以赋值给一个对象引用。Java 中，<strong>通过 <code>Array.newInstance</code> 创建数组的实例</strong>。</p>
<p>【示例】利用反射创建数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectArrayDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; cls = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">array</span> <span class="operator">=</span> Array.newInstance(cls, <span class="number">25</span>);</span><br><span class="line">        <span class="comment">//往数组里添加内容</span></span><br><span class="line">        Array.set(array, <span class="number">0</span>, <span class="string">&quot;Scala&quot;</span>);</span><br><span class="line">        Array.set(array, <span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        Array.set(array, <span class="number">2</span>, <span class="string">&quot;Groovy&quot;</span>);</span><br><span class="line">        Array.set(array, <span class="number">3</span>, <span class="string">&quot;Scala&quot;</span>);</span><br><span class="line">        Array.set(array, <span class="number">4</span>, <span class="string">&quot;Clojure&quot;</span>);</span><br><span class="line">        <span class="comment">//获取某一项的内容</span></span><br><span class="line">        System.out.println(Array.get(array, <span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="comment">//Scala</span></span><br></pre></td></tr></table></figure>

<p>其中的 Array 类为 <code>java.lang.reflect.Array</code> 类。我们<code>Array.newInstance</code> 的原型是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newInstance</span><span class="params">(Class&lt;?&gt; componentType, <span class="type">int</span> length)</span></span><br><span class="line">    <span class="keyword">throws</span> NegativeArraySizeException &#123;</span><br><span class="line">    <span class="keyword">return</span> newArray(componentType, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h3><p><code>Class</code> 对象提供以下方法获取对象的成员（<code>Field</code>）：</p>
<ul>
<li><code>getFiled</code> - 根据名称获取公有的（public）类成员。</li>
<li><code>getDeclaredField</code> - 根据名称获取已声明的类成员。但不能得到其父类的类成员。</li>
<li><code>getFields</code> - 获取所有公有的（public）类成员。</li>
<li><code>getDeclaredFields</code> - 获取所有已声明的类成员。</li>
</ul>
<p>示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectFieldDemo</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">FieldSpy</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span>[][] b = &#123; &#123;<span class="literal">false</span>, <span class="literal">false</span>&#125;, &#123;<span class="literal">true</span>, <span class="literal">true</span>&#125; &#125;;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> List&lt;Integer&gt; list;</span><br><span class="line">        <span class="keyword">public</span> T val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">f1</span> <span class="operator">=</span> FieldSpy.class.getField(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        System.out.format(<span class="string">&quot;Type: %s%n&quot;</span>, f1.getType());</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">f2</span> <span class="operator">=</span> FieldSpy.class.getField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.format(<span class="string">&quot;Type: %s%n&quot;</span>, f2.getType());</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">f3</span> <span class="operator">=</span> FieldSpy.class.getField(<span class="string">&quot;list&quot;</span>);</span><br><span class="line">        System.out.format(<span class="string">&quot;Type: %s%n&quot;</span>, f3.getType());</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">f4</span> <span class="operator">=</span> FieldSpy.class.getField(<span class="string">&quot;val&quot;</span>);</span><br><span class="line">        System.out.format(<span class="string">&quot;Type: %s%n&quot;</span>, f4.getType());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="comment">//Type: class [[Z</span></span><br><span class="line"><span class="comment">//Type: class java.lang.String</span></span><br><span class="line"><span class="comment">//Type: interface java.util.List</span></span><br><span class="line"><span class="comment">//Type: class java.lang.Object</span></span><br></pre></td></tr></table></figure>

<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p><code>Class</code> 对象提供以下方法获取对象的方法（<code>Method</code>）：</p>
<ul>
<li><code>getMethod</code> - 返回类或接口的特定方法。其中第一个参数为方法名称，后面的参数为方法参数对应 Class 的对象。</li>
<li><code>getDeclaredMethod</code> - 返回类或接口的特定声明方法。其中第一个参数为方法名称，后面的参数为方法参数对应 Class 的对象。</li>
<li><code>getMethods</code> - 返回类或接口的所有 public 方法，包括其父类的 public 方法。</li>
<li><code>getDeclaredMethods</code> - 返回类或接口声明的所有方法，包括 public、protected、默认（包）访问和 private 方法，但不包括继承的方法。</li>
</ul>
<p>获取一个 <code>Method</code> 对象后，可以用 <code>invoke</code> 方法来调用这个方法。</p>
<p><code>invoke</code> 方法的原型为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object obj, Object... args)</span></span><br><span class="line">        <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException,</span><br><span class="line">           InvocationTargetException</span><br></pre></td></tr></table></figure>

<p>【示例】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectMethodDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回所有方法</span></span><br><span class="line">        Method[] methods1 = System.class.getDeclaredMethods();</span><br><span class="line">        System.out.println(<span class="string">&quot;System getDeclaredMethods 清单（数量 = &quot;</span> + methods1.length + <span class="string">&quot;）：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Method m : methods1) &#123;</span><br><span class="line">            System.out.println(m);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回所有 public 方法</span></span><br><span class="line">        Method[] methods2 = System.class.getMethods();</span><br><span class="line">        System.out.println(<span class="string">&quot;System getMethods 清单（数量 = &quot;</span> + methods2.length + <span class="string">&quot;）：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Method m : methods2) &#123;</span><br><span class="line">            System.out.println(m);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用 Method 的 invoke 方法调用 System.currentTimeMillis()</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> System.class.getMethod(<span class="string">&quot;currentTimeMillis&quot;</span>);</span><br><span class="line">        System.out.println(method);</span><br><span class="line">        System.out.println(method.invoke(<span class="literal">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h3><p><code>Class</code> 对象提供以下方法获取对象的构造方法（<code>Constructor</code>）：</p>
<ul>
<li><code>getConstructor</code> - 返回类的特定 public 构造方法。参数为方法参数对应 Class 的对象。</li>
<li><code>getDeclaredConstructor</code> - 返回类的特定构造方法。参数为方法参数对应 Class 的对象。</li>
<li><code>getConstructors</code> - 返回类的所有 public 构造方法。</li>
<li><code>getDeclaredConstructors</code> - 返回类的所有构造方法。</li>
</ul>
<p>获取一个 <code>Constructor</code> 对象后，可以用 <code>newInstance</code> 方法来创建类实例。</p>
<p>【示例】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectMethodConstructorDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;</span><br><span class="line">        Constructor&lt;?&gt;[] constructors1 = String.class.getDeclaredConstructors();</span><br><span class="line">        System.out.println(<span class="string">&quot;String getDeclaredConstructors 清单（数量 = &quot;</span> + constructors1.length + <span class="string">&quot;）：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Constructor c : constructors1) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Constructor&lt;?&gt;[] constructors2 = String.class.getConstructors();</span><br><span class="line">        System.out.println(<span class="string">&quot;String getConstructors 清单（数量 = &quot;</span> + constructors2.length + <span class="string">&quot;）：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Constructor c : constructors2) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> String.class.getConstructor(String.class);</span><br><span class="line">        System.out.println(constructor);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) constructor.newInstance(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="绕开访问限制"><a href="#绕开访问限制" class="headerlink" title="绕开访问限制"></a>绕开访问限制</h3><p>有时候，我们需要通过反射访问私有成员、方法。可以使用 <code>Constructor/Field/Method.setAccessible(true)</code> 来绕开 Java 语言的访问限制。</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>动态代理是一种方便运行时动态构建代理、动态处理代理方法调用的机制，很多场景都是利用类似机制做到的，比如用来包装 RPC 调用、面向切面的编程（AOP）。</p>
<p>实现动态代理的方式很多，比如 JDK 自身提供的动态代理，就是主要利用了上面提到的反射机制。还有其他的实现方式，比如利用传说中更高性能的字节码操作机制，类似 ASM、cglib（基于 ASM）、Javassist 等。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/xmind/Java%E4%BB%A3%E7%90%86.svg" alt="img"></p>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><blockquote>
<p>静态代理其实就是指设计模式中的代理模式。</p>
<p><strong>代理模式为其他对象提供一种代理以控制对这个对象的访问。</strong></p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/3101171-6269723ea61527bd.png" alt="img"></p>
<p><strong>Subject</strong> 定义了 RealSubject 和 Proxy 的公共接口，这样就在任何使用 RealSubject 的地方都可以使用 Proxy 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">Request</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>RealSubject</strong> 定义 Proxy 所代表的真实实体。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RealSubject</span> <span class="keyword">extends</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Request</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;真实的请求&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Proxy</strong> 保存一个引用使得代理可以访问实体，并提供一个与 Subject 的接口相同的接口，这样代理就可以用来替代实体。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">extends</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> RealSubject real;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Request</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == real) &#123;</span><br><span class="line">            real = <span class="keyword">new</span> <span class="title class_">RealSubject</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        real.Request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：</p>
<p>静态代理模式固然在访问无法访问的资源，增强现有的接口业务功能方面有很大的优点，但是大量使用这种静态代理，会使我们系统内的类的规模增大，并且不易维护；并且由于 Proxy 和 RealSubject 的功能本质上是相同的，Proxy 只是起到了中介的作用，这种代理在系统中的存在，导致系统结构比较臃肿和松散。</p>
</blockquote>
<h3 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h3><p>为了解决静态代理的问题，就有了创建动态代理的想法：</p>
<p>在运行状态中，需要代理的地方，根据 Subject 和 RealSubject，动态地创建一个 Proxy，用完之后，就会销毁，这样就可以避免了 Proxy 角色的 class 在系统中冗杂的问题了。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/1553614585028.png" alt="img"></p>
<p>Java 动态代理基于经典代理模式，引入了一个 <code>InvocationHandler</code>，<code>InvocationHandler</code> 负责统一管理所有的方法调用。</p>
<p>动态代理步骤：</p>
<ol>
<li>获取 RealSubject 上的所有接口列表；</li>
<li>确定要生成的代理类的类名，默认为：<code>com.sun.proxy.$ProxyXXXX</code>；</li>
<li>根据需要实现的接口信息，在代码中动态创建 该 Proxy 类的字节码；</li>
<li>将对应的字节码转换为对应的 class 对象；</li>
<li>创建 <code>InvocationHandler</code> 实例 handler，用来处理 <code>Proxy</code> 所有方法调用；</li>
<li>Proxy 的 class 对象 以创建的 handler 对象为参数，实例化一个 proxy 对象。</li>
</ol>
<p>从上面可以看出，JDK 动态代理的实现是基于实现接口的方式，使得 Proxy 和 RealSubject 具有相同的功能。</p>
<p>但其实还有一种思路：通过继承。即：让 Proxy 继承 RealSubject，这样二者同样具有相同的功能，Proxy 还可以通过重写 RealSubject 中的方法，来实现多态。CGLIB 就是基于这种思路设计的。</p>
<p>在 Java 的动态代理机制中，有两个重要的类（接口），一个是 <code>InvocationHandler</code> 接口、另一个则是 <code>Proxy</code> 类，这一个类和一个接口是实现我们动态代理所必须用到的。</p>
<h4 id="InvocationHandler-接口"><a href="#InvocationHandler-接口" class="headerlink" title="InvocationHandler 接口"></a>InvocationHandler 接口</h4><p><code>InvocationHandler</code> 接口定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一个动态代理类都必须要实现 <code>InvocationHandler</code> 这个接口，并且每个代理类的实例都关联到了一个 Handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由 <code>InvocationHandler</code> 这个接口的 <code>invoke</code> 方法来进行调用。</p>
<p>我们来看看 InvocationHandler 这个接口的唯一一个方法 invoke 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><strong>proxy</strong> - 代理的真实对象。</li>
<li><strong>method</strong> - 所要调用真实对象的某个方法的 <code>Method</code> 对象</li>
<li><strong>args</strong> - 所要调用真实对象某个方法时接受的参数</li>
</ul>
<p>如果不是很明白，等下通过一个实例会对这几个参数进行更深的讲解。</p>
<h4 id="Proxy-类"><a href="#Proxy-类" class="headerlink" title="Proxy 类"></a>Proxy 类</h4><p><code>Proxy</code> 这个类的作用就是用来动态创建一个代理对象的类，它提供了许多的方法，但是我们用的最多的就是 <code>newProxyInstance</code> 这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces,  InvocationHandler h)</span>  <span class="keyword">throws</span> IllegalArgumentException</span><br></pre></td></tr></table></figure>

<p>这个方法的作用就是得到一个动态的代理对象。</p>
<p>参数说明：</p>
<ul>
<li><strong>loader</strong> - 一个 <code>ClassLoader</code> 对象，定义了由哪个 <code>ClassLoader</code> 对象来对生成的代理对象进行加载。</li>
<li><strong>interfaces</strong> - 一个 <code>Class&lt;?&gt;</code> 对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了</li>
<li><strong>h</strong> - 一个 <code>InvocationHandler</code> 对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个 <code>InvocationHandler</code> 对象上</li>
</ul>
<h4 id="JDK-动态代理实例"><a href="#JDK-动态代理实例" class="headerlink" title="JDK 动态代理实例"></a>JDK 动态代理实例</h4><p>上面的内容介绍完这两个接口(类)以后，我们来通过一个实例来看看我们的动态代理模式是什么样的：</p>
<p>首先我们定义了一个 Subject 类型的接口，为其声明了两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">(String str)</span>;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">bye</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着，定义了一个类来实现这个接口，这个类就是我们的真实对象，RealSubject 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RealSubject</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello  &quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">bye</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Goodbye&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Over&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下一步，我们就要定义一个动态代理类了，前面说个，每一个动态代理类都必须要实现 InvocationHandler 这个接口，因此我们这个动态代理类也不例外：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InvocationHandlerDemo</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">// 这个就是我们要代理的真实对象</span></span><br><span class="line">    <span class="keyword">private</span> Object subject;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法，给我们要代理的真实对象赋初值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InvocationHandlerDemo</span><span class="params">(Object subject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object object, Method method, Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 在代理真实对象前我们可以添加一些自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Before method&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Call Method: &quot;</span> + method);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> method.invoke(subject, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在代理真实对象后我们也可以添加一些自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After method&quot;</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，来看看我们的 Client 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 我们要代理的真实对象</span></span><br><span class="line">        <span class="type">Subject</span> <span class="variable">realSubject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealSubject</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我们要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法的</span></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvocationHandlerDemo</span>(realSubject);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 通过Proxy的newProxyInstance方法来创建我们的代理对象，我们来看看其三个参数</span></span><br><span class="line"><span class="comment">         * 第一个参数 handler.getClass().getClassLoader() ，我们这里使用handler这个类的ClassLoader对象来加载我们的代理对象</span></span><br><span class="line"><span class="comment">         * 第二个参数realSubject.getClass().getInterfaces()，我们这里为代理对象提供的接口是真实对象所实行的接口，表示我要代理的是该真实对象，这样我就能调用这组接口中的方法了</span></span><br><span class="line"><span class="comment">         * 第三个参数handler， 我们这里将这个代理对象关联到了上方的 InvocationHandler 这个对象上</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> (Subject)Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject</span><br><span class="line">                .getClass().getInterfaces(), handler);</span><br><span class="line"></span><br><span class="line">        System.out.println(subject.getClass().getName());</span><br><span class="line">        subject.hello(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> subject.bye();</span><br><span class="line">        System.out.println(<span class="string">&quot;Result is: &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先来看看控制台的输出：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">com<span class="selector-class">.sun</span><span class="selector-class">.proxy</span>.<span class="variable">$Proxy0</span></span><br><span class="line">Before method</span><br><span class="line">Call Method: public abstract void io<span class="selector-class">.github</span><span class="selector-class">.dunwu</span><span class="selector-class">.javacore</span><span class="selector-class">.reflect</span>.InvocationHandlerDemo<span class="variable">$Subject</span><span class="selector-class">.hello</span>(java<span class="selector-class">.lang</span>.String)</span><br><span class="line">Hello  World</span><br><span class="line">After method</span><br><span class="line"></span><br><span class="line">Before method</span><br><span class="line">Call Method: public abstract java<span class="selector-class">.lang</span><span class="selector-class">.String</span> io<span class="selector-class">.github</span><span class="selector-class">.dunwu</span><span class="selector-class">.javacore</span><span class="selector-class">.reflect</span>.InvocationHandlerDemo<span class="variable">$Subject</span><span class="selector-class">.bye</span>()</span><br><span class="line">Goodbye</span><br><span class="line">After method</span><br><span class="line"></span><br><span class="line">Result is: Over</span><br></pre></td></tr></table></figure>

<p>我们首先来看看 <code>com.sun.proxy.$Proxy0</code> 这东西，我们看到，这个东西是由 <code>System.out.println(subject.getClass().getName());</code> 这条语句打印出来的，那么为什么我们返回的这个代理对象的类名是这样的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> (Subject)Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject</span><br><span class="line">                .getClass().getInterfaces(), handler);</span><br></pre></td></tr></table></figure>

<p>可能我以为返回的这个代理对象会是 Subject 类型的对象，或者是 InvocationHandler 的对象，结果却不是，首先我们解释一下<strong>为什么我们这里可以将其转化为 Subject 类型的对象？</strong></p>
<p>原因就是：在 newProxyInstance 这个方法的第二个参数上，我们给这个代理对象提供了一组什么接口，那么我这个代理对象就会实现了这组接口，这个时候我们当然可以将这个代理对象强制类型转化为这组接口中的任意一个，因为这里的接口是 Subject 类型，所以就可以将其转化为 Subject 类型了。</p>
<p><strong>同时我们一定要记住，通过 <code>Proxy.newProxyInstance</code> 创建的代理对象是在 jvm 运行时动态生成的一个对象，它并不是我们的 InvocationHandler 类型，也不是我们定义的那组接口的类型，而是在运行是动态生成的一个对象，并且命名方式都是这样的形式，以$开头，proxy 为中，最后一个数字表示对象的标号</strong>。</p>
<p>接着我们来看看这两句</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subject.hello(<span class="string">&quot;World&quot;</span>)<span class="comment">;</span></span><br><span class="line">String result <span class="operator">=</span> subject.bye()<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>这里是通过代理对象来调用实现的那种接口中的方法，这个时候程序就会跳转到由这个代理对象关联到的 handler 中的 invoke 方法去执行，而我们的这个 handler 对象又接受了一个 RealSubject 类型的参数，表示我要代理的就是这个真实对象，所以此时就会调用 handler 中的 invoke 方法去执行。</p>
<p>我们看到，在真正通过代理对象来调用真实对象的方法的时候，我们可以在该方法前后添加自己的一些操作，同时我们看到我们的这个 method 对象是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> io.github.dunwu.javacore.reflect.InvocationHandlerDemo$Subject.hello(java.lang.String)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> java.lang.String io.github.dunwu.javacore.reflect.InvocationHandlerDemo$Subject.bye()</span><br></pre></td></tr></table></figure>

<p>正好就是我们的 Subject 接口中的两个方法，这也就证明了当我通过代理对象来调用方法的时候，起实际就是委托由其关联到的 handler 对象的 invoke 方法中来调用，并不是自己来真实调用，而是通过代理的方式来调用的。</p>
<h4 id="JDK-动态代理小结"><a href="#JDK-动态代理小结" class="headerlink" title="JDK 动态代理小结"></a>JDK 动态代理小结</h4><p>代理类与委托类实现同一接口，主要是通过代理类实现 <code>InvocationHandler</code> 并重写 <code>invoke</code> 方法来进行动态代理的，在 <code>invoke</code> 方法中将对方法进行处理。</p>
<p>JDK 动态代理特点：</p>
<ul>
<li><p>优点：相对于静态代理模式，不需要硬编码接口，代码复用率高。</p>
</li>
<li><p>缺点：强制要求代理类实现 <code>InvocationHandler</code> 接口。</p>
</li>
</ul>
<h3 id="CGLIB-动态代理"><a href="#CGLIB-动态代理" class="headerlink" title="CGLIB 动态代理"></a>CGLIB 动态代理</h3><p>CGLIB 提供了与 JDK 动态代理不同的方案。很多框架，例如 Spring AOP 中，就使用了 CGLIB 动态代理。</p>
<p>CGLIB 底层，其实是借助了 ASM 这个强大的 Java 字节码框架去进行字节码增强操作。</p>
<p>CGLIB 动态代理的工作步骤：</p>
<ul>
<li>生成代理类的二进制字节码文件；</li>
<li>加载二进制字节码，生成 <code>Class</code> 对象( 例如使用 <code>Class.forName()</code> 方法 )；</li>
<li>通过反射机制获得实例构造，并创建代理类对象。</li>
</ul>
<p>CGLIB 动态代理特点：</p>
<p>优点：使用字节码增强，比 JDK 动态代理方式性能高。可以在运行时对类或者是接口进行增强操作，且委托类无需实现接口。</p>
<p>缺点：不能对 <code>final</code> 类以及 <code>final</code> 方法进行代理。</p>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9a61af393e41">深入理解 CGLIB 动态代理机制</a></p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/2130190/">Java 编程思想</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/3146174/">Java 核心技术（卷 1）</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100010301">深入拆解 Java 虚拟机</a></li>
<li><a target="_blank" rel="noopener" href="https://www.sczyh30.com/posts/Java/java-reflection-1/">深入解析 Java 反射（1） - 基础</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_38259539/article/details/71799078">Java 基础之—反射（非常重要）</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/reflect/index.html">官方 Reflection API 文档</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoluo501395377/p/3383130.html">Java 的动态代理机制详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/luanlouis/article/details/24589193">Java 动态代理机制详解（JDK 和 CGLIB，Javassist，ASM）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/471c80a7e831">深入理解 JDK 动态代理机制</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9a61af393e41">深入理解 CGLIB 动态代理机制</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/5f886e/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/5f886e/" class="post-title-link" itemprop="url">Java 面试总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-04 13:51:00" itemprop="dateCreated datePublished" datetime="2020-06-04T13:51:00+08:00">2020-06-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>20k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>18 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java-面试总结"><a href="#Java-面试总结" class="headerlink" title="Java 面试总结"></a>Java 面试总结</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><blockquote>
<p>String 类能被继承吗？</p>
<p>String，StringBuffer，StringBuilder 的区别。</p>
</blockquote>
<p>String 类不能被继承。因为其被 final 修饰，所以无法被继承。</p>
<p>StringBuffer，StringBuilder 拼接字符串，使用 append 比 String 效率高。因为 String 会隐式 new String 对象。</p>
<p>StringBuffer 主要方法都用 synchronized 修饰，是线程安全的；而 StringBuilder 不是。</p>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><blockquote>
<p>抽象类和接口的区别？</p>
<p>类可以继承多个类么？接口可以继承多个接口么？类可以实现多个接口么？</p>
</blockquote>
<p>类只能继承一个类，但是可以实现多个接口。接口可以继承多个接口。</p>
<blockquote>
<p>继承和聚合的区别在哪？</p>
</blockquote>
<p>一般，能用聚合就别用继承。</p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h4 id="⭐-创建实例"><a href="#⭐-创建实例" class="headerlink" title="⭐ 创建实例"></a>⭐ 创建实例</h4><blockquote>
<p>反射创建实例有几种方式？</p>
</blockquote>
<p>通过反射来创建实例对象主要有两种方式：</p>
<ul>
<li>用 <code>Class</code> 对象的 <code>newInstance</code> 方法。</li>
<li>用 <code>Constructor</code> 对象的 <code>newInstance</code> 方法。</li>
</ul>
<h4 id="⭐-加载实例"><a href="#⭐-加载实例" class="headerlink" title="⭐ 加载实例"></a>⭐ 加载实例</h4><blockquote>
<p>加载实例有几种方式？</p>
<p>Class.forName(“className”) 和 ClassLoader.laodClass(“className”) 有什么区别？</p>
</blockquote>
<ul>
<li><code>Class.forName(&quot;className&quot;)</code> 加载的是已经初始化到 JVM 中的类。</li>
<li><code>ClassLoader.loadClass(&quot;className&quot;)</code> 装载的是还没有初始化到 JVM 中的类。</li>
</ul>
<h4 id="⭐⭐-动态代理"><a href="#⭐⭐-动态代理" class="headerlink" title="⭐⭐ 动态代理"></a>⭐⭐ 动态代理</h4><blockquote>
<p>动态代理有几种实现方式？有什么特点？</p>
<p>JDK 动态代理和 CGLIB 动态代理有什么区别？</p>
</blockquote>
<p>（1）JDK 方式</p>
<p>代理类与委托类实现同一接口，主要是通过代理类实现 <code>InvocationHandler</code> 并重写 <code>invoke</code> 方法来进行动态代理的，在 <code>invoke</code> 方法中将对方法进行处理。</p>
<p>JDK 动态代理特点：</p>
<ul>
<li>优点：相对于静态代理模式，不需要硬编码接口，代码复用率高。</li>
<li>缺点：强制要求代理类实现 <code>InvocationHandler</code> 接口。</li>
</ul>
<p>（2）CGLIB</p>
<p>CGLIB 底层，其实是借助了 ASM 这个强大的 Java 字节码框架去进行字节码增强操作。</p>
<p>CGLIB 动态代理特点：</p>
<p>优点：使用字节码增强，比 JDK 动态代理方式性能高。可以在运行时对类或者是接口进行增强操作，且委托类无需实现接口。</p>
<p>缺点：不能对 <code>final</code> 类以及 <code>final</code> 方法进行代理。</p>
<h3 id="JDK8"><a href="#JDK8" class="headerlink" title="JDK8"></a>JDK8</h3><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="⭐-hashcode"><a href="#⭐-hashcode" class="headerlink" title="⭐ hashcode"></a>⭐ hashcode</h4><blockquote>
<p>有<code>==</code>运算符了，为什么还需要 equals 啊？</p>
<p>说一说你对 java.lang.Object 对象中 hashCode 和 equals 方法的理解。在什么场景下需<br>要重新实现这两个方法。</p>
<p>有没有可能 2 个不相等的对象有相同的 hashcode</p>
</blockquote>
<p>（1）有<code>==</code>运算符了，为什么还需要 equals 啊？</p>
<p>equals 等价于<code>==</code>,而<code>==</code>运算符是判断两个对象是不是同一个对象，即他们的<strong>地址是否相等</strong>。而覆写 equals 更多的是追求两个对象在<strong>逻辑上的相等</strong>，你可以说是<strong>值相等</strong>，也可说是<strong>内容相等</strong>。</p>
<p>（2）说一说你对 java.lang.Object 对象中 hashCode 和 equals 方法的理解。在什么场景下需<br>要重新实现这两个方法。</p>
<p>在集合查找时，hashcode 能大大降低对象比较次数，提高查找效率！</p>
<p>（3）有没有可能 2 个不相等的对象有相同的 hashcode</p>
<p>有可能。</p>
<ul>
<li>如果两个对象 equals，Java 运行时环境会认为他们的 hashcode 一定相等。</li>
<li>如果两个对象不 equals，他们的 hashcode 有可能相等。</li>
<li>如果两个对象 hashcode 相等，他们不一定 equals。</li>
<li>如果两个对象 hashcode 不相等，他们一定不 equals。</li>
</ul>
<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><blockquote>
<p>什么是 NIO？</p>
<p>NIO 和 BIO、AIO 有何差别？</p>
</blockquote>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><h4 id="⭐-序列化问题"><a href="#⭐-序列化问题" class="headerlink" title="⭐ 序列化问题"></a>⭐ 序列化问题</h4><blockquote>
<p>序列化、反序列化有哪些问题？如何解决？</p>
</blockquote>
<p>Java 的序列化能保证对象状态的持久保存，但是遇到一些对象结构复杂的情况还是难以处理，这里归纳一下：</p>
<ul>
<li>当父类继承 <code>Serializable</code> 接口时，所有子类都可以被序列化。</li>
<li>子类实现了 <code>Serializable</code> 接口，父类没有，则父类的属性不会被序列化（不报错，数据丢失），子类的属性仍可以正确序列化。</li>
<li>如果序列化的属性是对象，则这个对象也必须实现 <code>Serializable</code> 接口，否则会报错。</li>
<li>在反序列化时，如果对象的属性有修改或删减，则修改的部分属性会丢失，但不会报错。</li>
<li>在反序列化时，如果 <code>serialVersionUID</code> 被修改，则反序列化时会失败。</li>
</ul>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="ArrayList-和-LinkedList-有什么区别？"><a href="#ArrayList-和-LinkedList-有什么区别？" class="headerlink" title="ArrayList 和 LinkedList 有什么区别？"></a>ArrayList 和 LinkedList 有什么区别？</h4><p>ArrayList 是数组链表，访问效率更高。</p>
<p>LinkedList 是双链表，数据有序存储。</p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>请描述 HashMap 的实现原理？</p>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="并发简介"><a href="#并发简介" class="headerlink" title="并发简介"></a>并发简介</h3><h4 id="什么是进程？什么是线程？进程和线程的区别？"><a href="#什么是进程？什么是线程？进程和线程的区别？" class="headerlink" title="什么是进程？什么是线程？进程和线程的区别？"></a>什么是进程？什么是线程？进程和线程的区别？</h4><ul>
<li>什么是进程？<ul>
<li>简言之，进程可视为一个正在运行的程序。</li>
<li>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动。进程是操作系统进行资源分配的基本单位。</li>
</ul>
</li>
<li>什么是线程？<ul>
<li>线程是操作系统进行调度的基本单位。</li>
</ul>
</li>
<li>进程 vs. 线程<ul>
<li>一个程序至少有一个进程，一个进程至少有一个线程。</li>
<li>线程比进程划分更细，所以执行开销更小，并发性更高。</li>
<li>进程是一个实体，拥有独立的资源；而同一个进程中的多个线程共享进程的资源。</li>
</ul>
</li>
</ul>
<h4 id="并发（多线程）编程的好处是什么？"><a href="#并发（多线程）编程的好处是什么？" class="headerlink" title="并发（多线程）编程的好处是什么？"></a>并发（多线程）编程的好处是什么？</h4><ul>
<li>更有效率的利用多处理器核心</li>
<li>更快的响应时间</li>
<li>更好的编程模型</li>
</ul>
<h4 id="并发一定比串行更快吗？"><a href="#并发一定比串行更快吗？" class="headerlink" title="并发一定比串行更快吗？"></a>并发一定比串行更快吗？</h4><p>答：否。</p>
<p>要点：<strong>创建线程和线程上下文切换有一定开销</strong>。</p>
<p>说明：即使是单核处理器也支持多线程。CPU 通过给每个线程分配时间切片的算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保持上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p>
<p>引申</p>
<ul>
<li>如何减少上下文切换？<ul>
<li>尽量少用锁</li>
<li>CAS 算法</li>
<li>线程数要合理</li>
<li>协程：在单线程中实现多任务调度，并在单线程中维持多个任务的切换</li>
</ul>
</li>
</ul>
<h4 id="如何让正在运行的线程暂停一段时间？"><a href="#如何让正在运行的线程暂停一段时间？" class="headerlink" title="如何让正在运行的线程暂停一段时间？"></a>如何让正在运行的线程暂停一段时间？</h4><p>我们可以使用 <code>Thread</code> 类的 Sleep() 方法让线程暂停一段时间。</p>
<p>需要注意的是，这并不会让线程终止，一旦从休眠中唤醒线程，线程的状态将会被改变为 Runnable，并且根据线程调度，它将得到执行。</p>
<h4 id="什么是线程调度器-Thread-Scheduler-和时间分片-Time-Slicing-？"><a href="#什么是线程调度器-Thread-Scheduler-和时间分片-Time-Slicing-？" class="headerlink" title="什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？"></a>什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？</h4><p>线程调度器是一个操作系统服务，它负责为 <code>Runnable</code> 状态的线程分配 CPU 时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。</p>
<p>时间分片是指将可用的 CPU 时间分配给可用的 <code>Runnable</code> 线程的过程。</p>
<p>分配 CPU 时间可以基于线程优先级或者线程等待的时间。线程调度并不受到 Java 虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级）。</p>
<h4 id="在多线程中，什么是上下文切换-context-switching-？"><a href="#在多线程中，什么是上下文切换-context-switching-？" class="headerlink" title="在多线程中，什么是上下文切换(context-switching)？"></a>在多线程中，什么是上下文切换(context-switching)？</h4><p>上下文切换是存储和恢复 CPU 状态的过程，它使得线程执行能够从中断点恢复执行。上下文切换是多任务操作系统和多线程环境的基本特征。</p>
<h4 id="如何确保线程安全？"><a href="#如何确保线程安全？" class="headerlink" title="如何确保线程安全？"></a>如何确保线程安全？</h4><ul>
<li>原子类(atomic concurrent classes)</li>
<li>锁</li>
<li><code>volatile</code> 关键字</li>
<li>不变类和线程安全类</li>
</ul>
<h4 id="什么是死锁-Deadlock-？如何分析和避免死锁？"><a href="#什么是死锁-Deadlock-？如何分析和避免死锁？" class="headerlink" title="什么是死锁(Deadlock)？如何分析和避免死锁？"></a>什么是死锁(Deadlock)？如何分析和避免死锁？</h4><p>死锁是指两个以上的线程永远相互阻塞的情况，这种情况产生至少需要两个以上的线程和两个以上的资源。</p>
<p>分析死锁，我们需要查看 Java 应用程序的线程转储。我们需要找出那些状态为 BLOCKED 的线程和他们等待的资源。每个资源都有一个唯一的 id，用这个 id 我们可以找出哪些线程已经拥有了它的对象锁。</p>
<p>避免嵌套锁，只在需要的地方使用锁和避免无限期等待是避免死锁的通常办法。</p>
<h3 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h3><h4 id="Java-线程生命周期中有哪些状态？各状态之间如何切换？"><a href="#Java-线程生命周期中有哪些状态？各状态之间如何切换？" class="headerlink" title="Java 线程生命周期中有哪些状态？各状态之间如何切换？"></a>Java 线程生命周期中有哪些状态？各状态之间如何切换？</h4><p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/concurrent/java-thread_1.png" alt="img"></p>
<p><code>java.lang.Thread.State</code> 中定义了 <strong>6</strong> 种不同的线程状态，在给定的一个时刻，线程只能处于其中的一个状态。</p>
<p>以下是各状态的说明，以及状态间的联系：</p>
<ul>
<li><strong>开始（New）</strong> - 还没有调用 <code>start()</code> 方法的线程处于此状态。</li>
<li><strong>可运行（Runnable）</strong> - 已经调用了 <code>start()</code> 方法的线程状态。此状态意味着，线程已经准备好了，一旦被线程调度器分配了 CPU 时间片，就可以运行线程。</li>
<li><strong>阻塞（Blocked）</strong> - 阻塞状态。线程阻塞的线程状态等待监视器锁定。处于阻塞状态的线程正在等待监视器锁定，以便在调用 <code>Object.wait()</code> 之后输入同步块&#x2F;方法或重新输入同步块&#x2F;方法。</li>
<li><strong>等待（Waiting）</strong> - 等待状态。一个线程处于等待状态，是由于执行了 3 个方法中的任意方法：<ul>
<li><code>Object.wait()</code></li>
<li><code>Thread.join()</code></li>
<li><code>LockSupport.park()</code></li>
</ul>
</li>
<li><strong>定时等待（Timed waiting）</strong> - 等待指定时间的状态。一个线程处于定时等待状态，是由于执行了以下方法中的任意方法：<ul>
<li><code>Thread.sleep(sleeptime)</code></li>
<li><code>Object.wait(timeout)</code></li>
<li><code>Thread.join(timeout)</code></li>
<li><code>LockSupport.parkNanos(timeout)</code></li>
<li><code>LockSupport.parkUntil(timeout)</code></li>
</ul>
</li>
<li><strong>终止(Terminated)</strong> - 线程 <code>run()</code> 方法执行结束，或者因异常退出了 <code>run()</code> 方法，则该线程结束生命周期。死亡的线程不可再次复生。</li>
</ul>
<blockquote>
<p>👉 参考阅读：<a target="_blank" rel="noopener" href="https://www.w3resource.com/java-tutorial/java-threadclass-methods-and-threadstates.php">Java<code>Thread</code> Methods and <code>Thread</code> States</a><br>👉 参考阅读：<a target="_blank" rel="noopener" href="https://blog.csdn.net/pange1991/article/details/53860651">Java 线程的 5 种状态及切换(透彻讲解)</a></p>
</blockquote>
<h4 id="创建线程有哪些方式？这些方法各自利弊是什么？"><a href="#创建线程有哪些方式？这些方法各自利弊是什么？" class="headerlink" title="创建线程有哪些方式？这些方法各自利弊是什么？"></a>创建线程有哪些方式？这些方法各自利弊是什么？</h4><p>创建线程主要有三种方式：</p>
<p><strong>1. 继承 <code>Thread</code> 类</strong></p>
<ul>
<li>定义 <code>Thread</code> 类的子类，并重写该类的 <code>run()</code> 方法，该 <code>run()</code> 方法的方法体就代表了线程要完成的任务。因此把 <code>run()</code> 方法称为执行体。</li>
<li>创建 <code>Thread</code> 子类的实例，即创建了线程对象。</li>
<li>调用线程对象的 <code>start()</code> 方法来启动该线程。</li>
</ul>
<p><strong>2. 实现 <code>Runnable</code> 接口</strong></p>
<ul>
<li>定义 <code>Runnable</code> 接口的实现类，并重写该接口的 <code>run()</code> 方法，该 <code>run()</code> 方法的方法体同样是该线程的线程执行体。</li>
<li>创建 <code>Runnable</code> 实现类的实例，并以此实例作为 <code>Thread</code> 对象，该 <code>Thread</code> 对象才是真正的线程对象。</li>
<li>调用线程对象的 start() 方法来启动该线程。</li>
</ul>
<p><strong>3. 通过 <code>Callable</code> 接口和 <code>Future</code> 接口</strong></p>
<ul>
<li>创建 <code>Callable</code> 接口的实现类，并实现 <code>call()</code> 方法，该 <code>call()</code> 方法将作为线程执行体，并且有返回值。</li>
<li>创建 <code>Callable</code> 实现类的实例，使用 <code>FutureTask</code> 类来包装 <code>Callable</code> 对象，该 <code>FutureTask</code> 对象封装了该 <code>Callable</code> 对象的 <code>call()</code> 方法的返回值。</li>
<li>使用 <code>FutureTask</code> 对象作为 <code>Thread</code> 对象的 target 创建并启动新线程。</li>
<li>调用 <code>FutureTask</code> 对象的 <code>get()</code> 方法来获得子线程执行结束后的返回值</li>
</ul>
<p>三种创建线程方式对比</p>
<ul>
<li>实现 <code>Runnable</code> 接口优于继承 <code>Thread</code> 类，因为根据开放封闭原则——实现接口更便于扩展；</li>
<li>实现 <code>Runnable</code> 接口的线程没有返回值；而使用 <code>Callable</code> &#x2F; <code>Future</code> 方式可以让线程有返回值。</li>
</ul>
<blockquote>
<p>👉 参考阅读：<a target="_blank" rel="noopener" href="https://blog.csdn.net/longshengguoji/article/details/41126119">Java 创建线程的三种方式及其对比</a></p>
</blockquote>
<h4 id="什么是-Callable-和-Future？什么是-FutureTask？"><a href="#什么是-Callable-和-Future？什么是-FutureTask？" class="headerlink" title="什么是 Callable 和 Future？什么是 FutureTask？"></a>什么是 <code>Callable</code> 和 <code>Future</code>？什么是 <code>FutureTask</code>？</h4><p><strong>什么是 <code>Callable</code> 和 <code>Future</code>？</strong></p>
<p>Java 5 在 concurrency 包中引入了 <code>Callable</code> 接口，它和 <code>Runnable</code> 接口很相似，但它可以返回一个对象或者抛出一个异常。</p>
<p><code>Callable</code> 接口使用泛型去定义它的返回类型。<code>Executors</code> 类提供了一些有用的方法去在线程池中执行 <code>Callable</code> 内的任务。由于 <code>Callable</code> 任务是并行的，我们必须等待它返回的结果。<code>Future</code> 对象为我们解决了这个问题。在线程池提交 <code>Callable</code> 任务后返回了一个 <code>Future</code> 对象，使用它我们可以知道 <code>Callable</code> 任务的状态和得到 <code>Callable</code> 返回的执行结果。<code>Future</code> 提供了 <code>get()</code> 方法让我们可以等待 <code>Callable</code> 结束并获取它的执行结果。</p>
<p><strong>什么是 <code>FutureTask</code>？</strong></p>
<p><code>FutureTask</code> 是 <code>Future</code> 的一个基础实现，我们可以将它同 <code>Executors</code> 使用处理异步任务。通常我们不需要使用 <code>FutureTask</code> 类，单当我们打算重写 <code>Future</code> 接口的一些方法并保持原来基础的实现是，它就变得非常有用。我们可以仅仅继承于它并重写我们需要的方法。阅读 Java <code>FutureTask</code> 例子，学习如何使用它。</p>
<blockquote>
<p>👉 参考阅读：<a target="_blank" rel="noopener" href="http://www.cnblogs.com/dolphin0520/p/3949310.html">Java 并发编程：Callable、Future 和 FutureTask</a></p>
</blockquote>
<h4 id="start-和-run-有什么区别？可以直接调用-Thread-类的-run-方法么？"><a href="#start-和-run-有什么区别？可以直接调用-Thread-类的-run-方法么？" class="headerlink" title="start() 和 run() 有什么区别？可以直接调用 Thread 类的 run() 方法么？"></a><code>start()</code> 和 <code>run()</code> 有什么区别？可以直接调用 <code>Thread</code> 类的 <code>run()</code> 方法么？</h4><ul>
<li><code>run()</code> 方法是线程的执行体。</li>
<li><code>start()</code> 方法负责启动线程，然后 JVM 会让这个线程去执行 <code>run()</code> 方法。</li>
</ul>
<p>可以直接调用 <code>Thread</code> 类的 <code>run()</code> 方法么？</p>
<ul>
<li>可以。但是如果直接调用 <code>Thread</code> 的 <code>run()</code> 方法，它的行为就会和普通的方法一样。</li>
<li>为了在新的线程中执行我们的代码，必须使用 <code>start()</code> 方法。</li>
</ul>
<h4 id="sleep-、yield-、join-方法有什么区别？为什么-sleep-和-yield-方法是静态（static）的？"><a href="#sleep-、yield-、join-方法有什么区别？为什么-sleep-和-yield-方法是静态（static）的？" class="headerlink" title="sleep()、yield()、join() 方法有什么区别？为什么 sleep() 和 yield() 方法是静态（static）的？"></a><code>sleep()</code>、<code>yield()</code>、<code>join()</code> 方法有什么区别？为什么 <code>sleep()</code> 和 <code>yield()</code> 方法是静态（static）的？</h4><p><strong><code>yield()</code></strong></p>
<ul>
<li><code>yield()</code> 方法可以让当前正在执行的线程暂停，但它不会阻塞该线程，它只是将该线程从 <strong>Running</strong> 状态转入 <code>Runnable</code> 状态。</li>
<li>当某个线程调用了 <code>yield()</code> 方法暂停之后，只有优先级与当前线程相同，或者优先级比当前线程更高的处于就绪状态的线程才会获得执行的机会。</li>
</ul>
<p><strong><code>sleep()</code></strong></p>
<ul>
<li><code>sleep()</code> 方法需要指定等待的时间，它可以让当前正在执行的线程在指定的时间内暂停执行，进入 <strong>Blocked</strong> 状态。</li>
<li>该方法既可以让其他同优先级或者高优先级的线程得到执行的机会，也可以让低优先级的线程得到执行机会。</li>
<li>但是，<code>sleep()</code> 方法不会释放“锁标志”，也就是说如果有 <code>synchronized</code> 同步块，其他线程仍然不能访问共享数据。</li>
</ul>
<p><strong><code>join()</code></strong></p>
<ul>
<li><code>join()</code> 方法会使当前线程转入 <strong>Blocked</strong> 状态，等待调用 <code>join()</code> 方法的线程结束后才能继续执行。</li>
</ul>
<p><strong>为什么 <code>sleep()</code> 和 <code>yield()</code> 方法是静态（static）的？</strong></p>
<ul>
<li><code>Thread</code> 类的 <code>sleep()</code> 和 <code>yield()</code> 方法将处理 <strong>Running</strong> 状态的线程。所以在其他处于非 <strong>Running</strong> 状态的线程上执行这两个方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。</li>
</ul>
<blockquote>
<p>👉 参考阅读：<a target="_blank" rel="noopener" href="http://www.importnew.com/14958.html">Java 线程中 yield 与 join 方法的区别</a><br>👉 参考阅读：<a target="_blank" rel="noopener" href="https://blog.csdn.net/xiangwanpeng/article/details/54972952">sleep()，wait()，yield()和 join()方法的区别</a></p>
</blockquote>
<h4 id="Java-的线程优先级如何控制？高优先级的-Java-线程一定先执行吗？"><a href="#Java-的线程优先级如何控制？高优先级的-Java-线程一定先执行吗？" class="headerlink" title="Java 的线程优先级如何控制？高优先级的 Java 线程一定先执行吗？"></a>Java 的线程优先级如何控制？高优先级的 Java 线程一定先执行吗？</h4><p><strong>Java 中的线程优先级如何控制</strong></p>
<ul>
<li>Java 中的线程优先级的范围是 <code>[1,10]</code>，一般来说，高优先级的线程在运行时会具有优先权。可以通过 <code>thread.setPriority(Thread.MAX_PRIORITY)</code> 的方式设置，默认优先级为 <code>5</code>。</li>
</ul>
<p><strong>高优先级的 Java 线程一定先执行吗</strong></p>
<ul>
<li>即使设置了线程的优先级，也<strong>无法保证高优先级的线程一定先执行</strong>。</li>
<li>原因：这是因为 <strong>Java 线程优先级依赖于操作系统的支持</strong>，然而，不同的操作系统支持的线程优先级并不相同，不能很好的和 Java 中线程优先级一一对应。</li>
<li>结论：Java 线程优先级控制并不可靠。</li>
</ul>
<h4 id="什么是守护线程？为什么要用守护线程？如何创建守护线程？"><a href="#什么是守护线程？为什么要用守护线程？如何创建守护线程？" class="headerlink" title="什么是守护线程？为什么要用守护线程？如何创建守护线程？"></a>什么是守护线程？为什么要用守护线程？如何创建守护线程？</h4><p><strong>什么是守护线程</strong></p>
<ul>
<li>守护线程（Daemon Thread）是在后台执行并且不会阻止 JVM 终止的线程。</li>
<li>与守护线程（Daemon Thread）相反的，叫用户线程（User Thread），也就是非守护线程。</li>
</ul>
<p><strong>为什么要用守护线程</strong></p>
<ul>
<li>守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。典型的应用就是垃圾回收器。</li>
</ul>
<p><strong>如何创建守护线程</strong></p>
<ul>
<li>使用 <code>thread.setDaemon(true)</code> 可以设置 thread 线程为守护线程。</li>
<li>注意点：<ul>
<li>正在运行的用户线程无法设置为守护线程，所以 <code>thread.setDaemon(true)</code> 必须在 <code>thread.start()</code> 之前设置，否则会抛出 <code>llegalThreadStateException</code> 异常；</li>
<li>一个守护线程创建的子线程依然是守护线程。</li>
<li>不要认为所有的应用都可以分配给守护线程来进行服务，比如读写操作或者计算逻辑。</li>
</ul>
</li>
</ul>
<blockquote>
<p>👉 参考阅读：<a target="_blank" rel="noopener" href="https://blog.csdn.net/shimiso/article/details/8964414">Java 中守护线程的总结</a></p>
</blockquote>
<h4 id="线程间是如何通信的？"><a href="#线程间是如何通信的？" class="headerlink" title="线程间是如何通信的？"></a>线程间是如何通信的？</h4><p>当线程间是可以共享资源时，线程间通信是协调它们的重要的手段。<code>Object</code> 类中 <code>wait()</code>, <code>notify()</code> 和 <code>notifyAll()</code> 方法可以用于线程间通信关于资源的锁的状态。</p>
<blockquote>
<p>👉 参考阅读：<a target="_blank" rel="noopener" href="http://www.cnblogs.com/dolphin0520/p/3920385.html">Java 并发编程：线程间协作的两种方式：wait、notify、notifyAll 和 Condition</a></p>
</blockquote>
<h4 id="为什么线程通信的方法-wait-notify-和-notifyAll-被定义在-Object-类里？"><a href="#为什么线程通信的方法-wait-notify-和-notifyAll-被定义在-Object-类里？" class="headerlink" title="为什么线程通信的方法 wait(), notify() 和 notifyAll() 被定义在 Object 类里？"></a>为什么线程通信的方法 <code>wait()</code>, <code>notify()</code> 和 <code>notifyAll()</code> 被定义在 Object 类里？</h4><p>Java 的每个对象中都有一个锁(monitor，也可以成为监视器) 并且 <code>wait()</code>、<code>notify()</code> 等方法用于等待对象的锁或者通知其他线程对象的监视器可用。在 Java 的线程中并没有可供任何对象使用的锁和同步器。这就是为什么这些方法是 Object 类的一部分，这样 Java 的每一个类都有用于线程间通信的基本方法</p>
<h4 id="为什么-wait-notify-和-notifyAll-必须在同步方法或者同步块中被调用？"><a href="#为什么-wait-notify-和-notifyAll-必须在同步方法或者同步块中被调用？" class="headerlink" title="为什么 wait(), notify() 和 notifyAll() 必须在同步方法或者同步块中被调用？"></a>为什么 <code>wait()</code>, <code>notify()</code> 和 <code>notifyAll()</code> 必须在同步方法或者同步块中被调用？</h4><p>当一个线程需要调用对象的 <code>wait()</code> 方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的 <code>notify()</code> 方法。同样的，当一个线程需要调用对象的 <code>notify()</code> 方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。</p>
<p>由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。</p>
<h3 id="并发机制的底层实现"><a href="#并发机制的底层实现" class="headerlink" title="并发机制的底层实现"></a>并发机制的底层实现</h3><blockquote>
<p>👉 参考阅读：<a target="_blank" rel="noopener" href="https://dunwu.github.io/waterdrop/pages/2c6488/">Java 并发核心机制</a></p>
</blockquote>
<h4 id="⭐⭐⭐-synchronized"><a href="#⭐⭐⭐-synchronized" class="headerlink" title="⭐⭐⭐ synchronized"></a>⭐⭐⭐ <code>synchronized</code></h4><blockquote>
<p><code>synchronized</code> 有什么作用？</p>
<p><code>synchronized</code> 的原理是什么？</p>
<p>同步方法和同步块，哪个更好？</p>
<p>JDK1.6 对<code>synchronized</code> 做了哪些优化？</p>
<p>使用 <code>synchronized</code> 修饰静态方法和非静态方法有什么区别？</p>
</blockquote>
<p><strong>作用</strong></p>
<p><strong><code>synchronized</code> 可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块</strong>。</p>
<p><code>synchronized</code> 有 3 种应用方式：</p>
<ul>
<li><strong>同步实例方法</strong> - 对于普通同步方法，锁是当前实例对象</li>
<li><strong>同步静态方法</strong> - 对于静态同步方法，锁是当前类的 <code>Class</code> 对象</li>
<li><strong>同步代码块</strong> - 对于同步方法块，锁是 <code>synchonized</code> 括号里配置的对象</li>
</ul>
<p><strong>原理</strong></p>
<p><code>synchronized</code> 经过编译后，会在同步块的前后分别形成 <code>monitorenter</code> 和 <code>monitorexit</code> 这两个字节码指令，这两个字节码指令都需要一个引用类型的参数来指明要锁定和解锁的对象。如果 <code>synchronized</code> 明确制定了对象参数，那就是这个对象的引用；如果没有明确指定，那就根据 <code>synchronized</code> 修饰的是实例方法还是静态方法，去对对应的对象实例或 <code>Class</code> 对象来作为锁对象。</p>
<p><code>synchronized</code> 同步块对同一线程来说是可重入的，不会出现锁死问题。</p>
<p><code>synchronized</code> 同步块是互斥的，即已进入的线程执行完成前，会阻塞其他试图进入的线程。</p>
<p><strong>优化</strong></p>
<p>Java 1.6 以后，<code>synchronized</code> 做了大量的优化，其性能已经与 <code>Lock</code> 、<code>ReadWriteLock</code> 基本上持平。</p>
<p><code>synchronized</code> 的优化是将锁粒度分为不同级别，<code>synchronized</code> 会根据运行状态动态的由低到高调整锁级别（<strong>偏向锁</strong> -&gt; <strong>轻量级锁</strong> -&gt; <strong>重量级锁</strong>），以减少阻塞。</p>
<p><strong>同步方法 or 同步块？</strong></p>
<ul>
<li>同步块是更好的选择。</li>
<li>因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。</li>
</ul>
<h4 id="⭐-volatile"><a href="#⭐-volatile" class="headerlink" title="⭐ volatile"></a>⭐ <code>volatile</code></h4><blockquote>
<p><code>volatile</code> 有什么作用？</p>
<p><code>volatile</code> 的原理是什么？</p>
<p><code>volatile</code> 能代替锁吗？</p>
<p><code>volatile</code> 和 <code>synchronized</code> 的区别？</p>
</blockquote>
<p><strong><code>volatile</code> 无法替代 <code>synchronized</code> ，因为 <code>volatile</code> 无法保证操作的原子性</strong>。</p>
<p><strong>作用</strong></p>
<p>被 <code>volatile</code> 关键字修饰的变量有两层含义：</p>
<ul>
<li><strong>保证了不同线程对这个变量进行操作时的可见性</strong>，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</li>
<li><strong>禁止指令重排序</strong>。</li>
</ul>
<p><strong>原理</strong></p>
<p>观察加入 volatile 关键字和没有加入 volatile 关键字时所生成的汇编代码发现，<strong>加入 <code>volatile</code> 关键字时，会多出一个 <code>lock</code> 前缀指令</strong>。</p>
<p><strong><code>lock</code> 前缀指令实际上相当于一个内存屏障</strong>（也成内存栅栏），内存屏障会提供 3 个功能：</p>
<ul>
<li>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</li>
<li>它会强制将对缓存的修改操作立即写入主存；</li>
<li>如果是写操作，它会导致其他 CPU 中对应的缓存行无效。</li>
</ul>
<p><strong><code>volatile</code> 和 <code>synchronized</code> 的区别？</strong></p>
<ul>
<li><code>volatile</code> 本质是在告诉 jvm 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； <code>synchronized</code> 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</li>
<li><code>volatile</code> 仅能使用在变量级别；synchronized 则可以使用在变量、方法、和类级别的。</li>
<li><code>volatile</code> 仅能实现变量的修改可见性，不能保证原子性；而 <code>synchronized</code> 则可以保证变量的修改可见性和原子性</li>
<li><code>volatile</code> 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</li>
<li><code>volatile</code> 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。</li>
</ul>
<h4 id="⭐⭐-CAS"><a href="#⭐⭐-CAS" class="headerlink" title="⭐⭐ CAS"></a>⭐⭐ CAS</h4><blockquote>
<p>什么是 CAS？</p>
<p>CAS 有什么作用？</p>
<p>CAS 的原理是什么？</p>
<p>CAS 的三大问题？</p>
</blockquote>
<p><strong>作用</strong></p>
<p><strong>CAS（Compare and Swap）</strong>，字面意思为<strong>比较并交换</strong>。CAS 有 3 个操作数，分别是：内存值 V，旧的预期值 A，要修改的新值 B。当且仅当预期值 A 和内存值 V 相同时，将内存值 V 修改为 B，否则什么都不做。</p>
<p><strong>原理</strong></p>
<p>Java 主要利用 <code>Unsafe</code> 这个类提供的 CAS 操作。<code>Unsafe</code> 的 CAS 依赖的是 JV M 针对不同的操作系统实现的 <code>Atomic::cmpxchg</code> 指令。</p>
<p><strong>三大问题</strong></p>
<ol>
<li><strong>ABA 问题</strong>：因为 CAS 需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是 A，变成了 B，又变成了 A，那么使用 CAS 进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA 问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么 A－B－A 就会变成 1A-2B－3A。</li>
<li><strong>循环时间长开销大</strong>。自旋 CAS 如果长时间不成功，会给 CPU 带来非常大的执行开销。如果 JVM 能支持处理器提供的 pause 指令那么效率会有一定的提升，pause 指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起 CPU 流水线被清空（CPU pipeline flush），从而提高 CPU 的执行效率。</li>
<li><strong>只能保证一个共享变量的原子操作</strong>。当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量 i ＝ 2,j&#x3D;a，合并一下 ij&#x3D;2a，然后用 CAS 来操作 ij。从 Java1.5 开始 JDK 提供了 AtomicReference 类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作。</li>
</ol>
<h4 id="⭐-ThreadLocal"><a href="#⭐-ThreadLocal" class="headerlink" title="⭐ ThreadLocal"></a>⭐ <code>ThreadLocal</code></h4><blockquote>
<p><code>ThreadLocal</code> 有什么作用？</p>
<p><code>ThreadLocal</code> 的原理是什么？</p>
<p>如何解决 <code>ThreadLocal</code> 内存泄漏问题？</p>
</blockquote>
<p><strong>作用</strong></p>
<p><strong><code>ThreadLocal</code> 是一个存储线程本地副本的工具类</strong>。</p>
<p><strong>原理</strong></p>
<p><code>Thread</code> 类中维护着一个 <code>ThreadLocal.ThreadLocalMap</code> 类型的成员 <code>threadLocals</code>。这个成员就是用来存储当前线程独占的变量副本。</p>
<p><code>ThreadLocalMap</code> 是 <code>ThreadLocal</code> 的内部类，它维护着一个 <code>Entry</code> 数组， <code>Entry</code> 用于保存键值对，其 key 是 <code>ThreadLocal</code> 对象，value 是传递进来的对象（变量副本）。 <code>Entry</code> 继承了 <code>WeakReference</code> ，所以是弱引用。</p>
<p><strong>内存泄漏问题</strong></p>
<p>ThreadLocalMap 的 <code>Entry</code> 继承了 <code>WeakReference</code>，所以它的 key （<code>ThreadLocal</code> 对象）是弱引用，而 value （变量副本）是强引用。</p>
<ul>
<li>如果 <code>ThreadLocal</code> 对象没有外部强引用来引用它，那么 <code>ThreadLocal</code> 对象会在下次 GC 时被回收。</li>
<li>此时，<code>Entry</code> 中的 key 已经被回收，但是 value 由于是强引用不会被垃圾收集器回收。如果创建 <code>ThreadLocal</code> 的线程一直持续运行，那么 value 就会一直得不到回收，产生内存泄露。</li>
</ul>
<p>那么如何避免内存泄漏呢？方法就是：<strong>使用 <code>ThreadLocal</code> 的 <code>set</code> 方法后，显示的调用 <code>remove</code> 方法</strong> 。</p>
<h3 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h3><h4 id="什么是-Java-内存模型"><a href="#什么是-Java-内存模型" class="headerlink" title="什么是 Java 内存模型"></a>什么是 Java 内存模型</h4><ul>
<li>Java 内存模型即 Java Memory Model，简称 JMM。JMM 定义了 JVM 在计算机内存(RAM)中的工作方式。JMM 是隶属于 JVM 的。</li>
<li>并发编程领域两个关键问题：线程间通信和线程间同步</li>
<li>线程间通信机制<ul>
<li>共享内存 - 线程间通过写-读内存中的公共状态来隐式进行通信。</li>
<li>消息传递 - java 中典型的消息传递方式就是 wait()和 notify()。</li>
</ul>
</li>
<li>线程间同步机制<ul>
<li>在共享内存模型中，必须显示指定某个方法或某段代码在线程间互斥地执行。</li>
<li>在消息传递模型中，由于发送消息必须在接收消息之前，因此同步是隐式进行的。</li>
</ul>
</li>
<li>Java 的并发采用的是共享内存模型</li>
<li>JMM 决定一个线程对共享变量的写入何时对另一个线程可见。</li>
<li>线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读&#x2F;写共享变量的副本。</li>
<li>JMM 把内存分成了两部分：线程栈区和堆区<ul>
<li>线程栈<ul>
<li>JVM 中运行的每个线程都拥有自己的线程栈，线程栈包含了当前线程执行的方法调用相关信息，我们也把它称作调用栈。随着代码的不断执行，调用栈会不断变化。</li>
<li>线程栈还包含了当前方法的所有本地变量信息。线程中的本地变量对其它线程是不可见的。</li>
</ul>
</li>
<li>堆区<ul>
<li>堆区包含了 Java 应用创建的所有对象信息，不管对象是哪个线程创建的，其中的对象包括原始类型的封装类（如 Byte、Integer、Long 等等）。不管对象是属于一个成员变量还是方法中的本地变量，它都会被存储在堆区。</li>
</ul>
</li>
<li>一个本地变量如果是原始类型，那么它会被完全存储到栈区。</li>
<li>一个本地变量也有可能是一个对象的引用，这种情况下，这个本地引用会被存储到栈中，但是对象本身仍然存储在堆区。</li>
<li>对于一个对象的成员方法，这些方法中包含本地变量，仍需要存储在栈区，即使它们所属的对象在堆区。</li>
<li>对于一个对象的成员变量，不管它是原始类型还是包装类型，都会被存储到堆区。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/concurrent/java-memory-model_3.png" alt="img"></p>
<blockquote>
<p>👉 参考阅读：<a target="_blank" rel="noopener" href="https://blog.csdn.net/suifeng3051/article/details/52611310">全面理解 Java 内存模型</a></p>
</blockquote>
<h3 id="同步容器和并发容器"><a href="#同步容器和并发容器" class="headerlink" title="同步容器和并发容器"></a>同步容器和并发容器</h3><blockquote>
<p>👉 参考阅读：<a target="_blank" rel="noopener" href="https://dunwu.github.io/waterdrop/pages/b067d6/">Java 并发容器</a></p>
</blockquote>
<h4 id="⭐-同步容器"><a href="#⭐-同步容器" class="headerlink" title="⭐ 同步容器"></a>⭐ 同步容器</h4><blockquote>
<p>什么是同步容器？</p>
<p>有哪些常见同步容器？</p>
<p>它们是如何实现线程安全的？</p>
<p>同步容器真的线程安全吗？</p>
</blockquote>
<p><strong>类型</strong></p>
<p><code>Vector</code>、<code>Stack</code>、<code>Hashtable</code></p>
<p><strong>作用&#x2F;原理</strong></p>
<p>同步容器的同步原理就是在方法上用 <code>synchronized</code> 修饰。 <strong><code>synchronized</code> 可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块</strong>。</p>
<p><code>synchronized</code> 的互斥同步会产生阻塞和唤醒线程的开销。显然，这种方式比没有使用 <code>synchronized</code> 的容器性能要差。</p>
<p><strong>线程安全</strong></p>
<p>同步容器真的绝对安全吗？</p>
<p>其实也未必。在做复合操作（非原子操作）时，仍然需要加锁来保护。常见复合操作如下：</p>
<ul>
<li><strong>迭代</strong>：反复访问元素，直到遍历完全部元素；</li>
<li><strong>跳转</strong>：根据指定顺序寻找当前元素的下一个（下 n 个）元素；</li>
<li><strong>条件运算</strong>：例如若没有则添加等；</li>
</ul>
<h4 id="⭐⭐⭐-ConcurrentHashMap"><a href="#⭐⭐⭐-ConcurrentHashMap" class="headerlink" title="⭐⭐⭐ ConcurrentHashMap"></a>⭐⭐⭐ ConcurrentHashMap</h4><blockquote>
<p>请描述 ConcurrentHashMap 的实现原理？</p>
<p>ConcurrentHashMap 为什么放弃了分段锁？</p>
</blockquote>
<p>基础数据结构原理和 <code>HashMap</code> 一样，JDK 1.7 采用 数组＋单链表；JDK 1.8 采用数组＋单链表＋红黑树。</p>
<p>并发安全特性的实现：</p>
<p>JDK 1.7：</p>
<ul>
<li>使用分段锁，设计思路是缩小锁粒度，提高并发吞吐。</li>
<li>写数据时，会使用可重入锁去锁住分段（segment）。</li>
</ul>
<p>JDK 1.8：</p>
<ul>
<li>取消分段锁，直接采用 <code>transient volatile HashEntry&lt;K,V&gt;[] table</code> 保存数据，采用 table 数组元素作为锁，从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率。</li>
<li>写数据时，使用是 CAS + <code>synchronized</code>。<ul>
<li>根据 key 计算出 hashcode 。</li>
<li>判断是否需要进行初始化。</li>
<li><code>f</code> 即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</li>
<li>如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。</li>
<li>如果都不满足，则利用 synchronized 锁写入数据。</li>
<li>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要转换为红黑树。</li>
</ul>
</li>
</ul>
<h4 id="⭐⭐-CopyOnWriteArrayList"><a href="#⭐⭐-CopyOnWriteArrayList" class="headerlink" title="⭐⭐ CopyOnWriteArrayList"></a>⭐⭐ CopyOnWriteArrayList</h4><blockquote>
<p>CopyOnWriteArrayList 的作用？</p>
<p>CopyOnWriteArrayList 的原理？</p>
</blockquote>
<p><strong>作用</strong></p>
<p>CopyOnWrite 字面意思为写入时复制。CopyOnWriteArrayList 是线程安全的 ArrayList。</p>
<p><strong>原理</strong></p>
<ul>
<li>在 <code>CopyOnWriteAarrayList</code> 中，读操作不同步，因为它们在内部数组的快照上工作，所以多个迭代器可以同时遍历而不会相互阻塞（1,2,4）。</li>
<li>所有的写操作都是同步的。他们在备份数组（3）的副本上工作。写操作完成后，后备阵列将被替换为复制的阵列，并释放锁定。支持数组变得易变，所以替换数组的调用是原子（5）。</li>
<li>写操作后创建的迭代器将能够看到修改的结构（6,7）。</li>
<li>写时复制集合返回的迭代器不会抛出 ConcurrentModificationException，因为它们在数组的快照上工作，并且无论后续的修改（2,4）如何，都会像迭代器创建时那样完全返回元素。</li>
</ul>
<p align="center">
  <img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/container/CopyOnWriteArrayList.png">
</p>

<h3 id="并发锁"><a href="#并发锁" class="headerlink" title="并发锁"></a>并发锁</h3><blockquote>
<p>👉 参考阅读：<a target="_blank" rel="noopener" href="https://dunwu.github.io/waterdrop/pages/e2e047/">Java 并发锁</a></p>
</blockquote>
<h4 id="⭐⭐-锁类型"><a href="#⭐⭐-锁类型" class="headerlink" title="⭐⭐ 锁类型"></a>⭐⭐ 锁类型</h4><blockquote>
<p>Java 中有哪些锁？</p>
<p>这些锁有什么特性？</p>
</blockquote>
<p><strong>可重入锁</strong></p>
<ul>
<li><strong><code>ReentrantLock</code> 、<code>ReentrantReadWriteLock</code> 是可重入锁</strong>。这点，从其命名也不难看出。</li>
<li><strong><code>synchronized</code> 也是一个可重入锁</strong>。</li>
</ul>
<p><strong>公平锁与非公平锁</strong></p>
<ul>
<li><strong><code>synchronized</code> 只支持非公平锁</strong>。</li>
<li><strong><code>ReentrantLock</code> 、<code>ReentrantReadWriteLock</code>，默认是非公平锁，但支持公平锁</strong>。</li>
</ul>
<p><strong>独享锁与共享锁</strong></p>
<ul>
<li><strong><code>synchronized</code> 、<code>ReentrantLock</code> 只支持独享锁</strong>。</li>
<li><strong><code>ReentrantReadWriteLock</code> 其写锁是独享锁，其读锁是共享锁</strong>。读锁是共享锁使得并发读是非常高效的，读写，写读 ，写写的过程是互斥的。</li>
</ul>
<p><strong>悲观锁与乐观锁</strong></p>
<ul>
<li><p>悲观锁在 Java 中的应用就是通过使用 <code>synchronized</code> 和 <code>Lock</code> 显示加锁来进行互斥同步，这是一种阻塞同步。</p>
</li>
<li><p>乐观锁在 Java 中的应用就是采用 CAS 机制（CAS 操作通过 <code>Unsafe</code> 类提供，但这个类不直接暴露为 API，所以都是间接使用，如各种原子类）。</p>
</li>
</ul>
<p><strong>偏向锁、轻量级锁、重量级锁</strong></p>
<p>Java 1.6 以前，重量级锁一般指的是 <code>synchronized</code> ，而轻量级锁指的是 <code>volatile</code>。</p>
<p>Java 1.6 以后，针对 <code>synchronized</code> 做了大量优化，引入 4 种锁状态： 无锁状态、偏向锁、轻量级锁和重量级锁。锁可以单向的从偏向锁升级到轻量级锁，再从轻量级锁升级到重量级锁 。</p>
<p><strong>分段锁</strong></p>
<p>分段锁其实是一种锁的设计，并不是具体的一种锁。典型：JDK1.7 之前的 <code>ConcurrentHashMap</code></p>
<p><strong>显示锁和内置锁</strong></p>
<ul>
<li>内置锁：<code>synchronized</code></li>
<li>显示锁：<code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code> 等。</li>
</ul>
<h4 id="⭐⭐-AQS"><a href="#⭐⭐-AQS" class="headerlink" title="⭐⭐ AQS"></a>⭐⭐ AQS</h4><blockquote>
<p>什么是 AQS？</p>
<p>AQS 的作用是什么？</p>
<p>AQS 的原理？</p>
</blockquote>
<p><strong>作用</strong></p>
<p><code>AbstractQueuedSynchronizer</code>（简称 <strong>AQS</strong>）是<strong>队列同步器</strong>，顾名思义，其主要作用是处理同步。它是并发锁和很多同步工具类的实现基石（如 <code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code>、<code>Semaphore</code> 等）。</p>
<p><strong>AQS 提供了对独享锁与共享锁的支持</strong>。</p>
<p><strong>原理</strong></p>
<p>（1）数据结构</p>
<ul>
<li><code>state</code> - AQS 使用一个整型的 <code>volatile</code> 变量来 <strong>维护同步状态</strong>。<ul>
<li>这个整数状态的意义由子类来赋予，如<code>ReentrantLock</code> 中该状态值表示所有者线程已经重复获取该锁的次数，<code>Semaphore</code> 中该状态值表示剩余的许可数量。</li>
</ul>
</li>
<li><code>head</code> 和 <code>tail</code> - AQS <strong>维护了一个 <code>Node</code> 类型（AQS 的内部类）的双链表来完成同步状态的管理</strong>。这个双链表是一个双向的 FIFO 队列，通过 <code>head</code> 和 <code>tail</code> 指针进行访问。当 <strong>有线程获取锁失败后，就被添加到队列末尾</strong>。</li>
</ul>
<p>（2）获取独占锁</p>
<p>AQS 中使用 <code>acquire(int arg)</code> 方法获取独占锁，其大致流程如下：</p>
<ol>
<li>先尝试获取同步状态，如果获取同步状态成功，则结束方法，直接返回。</li>
<li>如果获取同步状态不成功，AQS 会不断尝试利用 CAS 操作将当前线程插入等待同步队列的队尾，直到成功为止。</li>
<li>接着，不断尝试为等待队列中的线程节点获取独占锁。</li>
</ol>
<p>（3）释放独占锁</p>
<p>AQS 中使用 <code>release(int arg)</code> 方法释放独占锁，其大致流程如下：</p>
<ol>
<li>先尝试获取解锁线程的同步状态，如果获取同步状态不成功，则结束方法，直接返回。</li>
<li>如果获取同步状态成功，AQS 会尝试唤醒当前线程节点的后继节点。</li>
</ol>
<p>（4）获取共享锁</p>
<p>AQS 中使用 <code>acquireShared(int arg)</code> 方法获取共享锁。</p>
<p><code>acquireShared</code> 方法和 <code>acquire</code> 方法的逻辑很相似，区别仅在于自旋的条件以及节点出队的操作有所不同。</p>
<p>成功获得共享锁的条件如下：</p>
<ul>
<li><code>tryAcquireShared(arg)</code> 返回值大于等于 0 （这意味着共享锁的 permit 还没有用完）。</li>
<li>当前节点的前驱节点是头结点。</li>
</ul>
<p>（5）释放共享锁</p>
<p>AQS 中使用 <code>releaseShared(int arg)</code> 方法释放共享锁。</p>
<p><code>releaseShared</code> 首先会尝试释放同步状态，如果成功，则解锁一个或多个后继线程节点。释放共享锁和释放独享锁流程大体相似，区别在于：</p>
<p>对于独享模式，如果需要 SIGNAL，释放仅相当于调用头节点的 <code>unparkSuccessor</code>。</p>
<h4 id="⭐⭐-ReentrantLock"><a href="#⭐⭐-ReentrantLock" class="headerlink" title="⭐⭐ ReentrantLock"></a>⭐⭐ ReentrantLock</h4><blockquote>
<p>什么是 ReentrantLock？</p>
<p>什么是可重入锁？</p>
<p>ReentrantLock 有什么用？</p>
<p>ReentrantLock 原理？</p>
</blockquote>
<p><strong>作用</strong></p>
<p><strong><code>ReentrantLock</code> 提供了一组无条件的、可轮询的、定时的以及可中断的锁操作</strong></p>
<p><code>ReentrantLock</code> 的特性如下：</p>
<ul>
<li><strong><code>ReentrantLock</code> 提供了与 <code>synchronized</code> 相同的互斥性、内存可见性和可重入性</strong>。</li>
<li><code>ReentrantLock</code> 支持公平锁和非公平锁（默认）两种模式。</li>
<li><code>ReentrantLock</code> 实现了 <code>Lock</code> 接口，支持了 <code>synchronized</code> 所不具备的<strong>灵活性</strong>。<ul>
<li><code>synchronized</code> 无法中断一个正在等待获取锁的线程</li>
<li><code>synchronized</code> 无法在请求获取一个锁时无休止地等待</li>
</ul>
</li>
</ul>
<p><strong>原理</strong></p>
<p><code>ReentrantLock</code> 基于其内部类 <code>ReentrantLock.Sync</code> 实现，<code>Sync</code> 继承自 AQS。它有两个子类：</p>
<ul>
<li><code>ReentrantLock.FairSync</code> - 公平锁。</li>
<li><code>ReentrantLock.NonfairSync</code> - 非公平锁。</li>
</ul>
<p>本质上，就是基于 AQS 实现。</p>
<h4 id="⭐-ReentrantReadWriteLock"><a href="#⭐-ReentrantReadWriteLock" class="headerlink" title="⭐ ReentrantReadWriteLock"></a>⭐ ReentrantReadWriteLock</h4><blockquote>
<p>ReentrantReadWriteLock 是什么？</p>
<p>ReentrantReadWriteLock 的作用？</p>
<p>ReentrantReadWriteLock 的原理？</p>
</blockquote>
<p><strong>作用</strong></p>
<p><code>ReentrantReadWriteLock</code> 是一个<strong>可重入的读写锁</strong>。**<code>ReentrantReadWriteLock</code> 维护了一对读写锁，将读写锁分开，有利于提高并发效率**。</p>
<p><strong>原理</strong></p>
<p><code>ReentrantReadWriteLock</code> 本质上也是基于 AQS 实现。有三个核心字段：</p>
<ul>
<li><code>sync</code> - 内部类 <code>ReentrantReadWriteLock.Sync</code> 对象。与 <code>ReentrantLock</code> 类似，它有两个子类：<code>ReentrantReadWriteLock.FairSync</code> 和 <code>ReentrantReadWriteLock.NonfairSync</code> ，分别表示公平锁和非公平锁的实现。</li>
<li><code>readerLock</code> - 内部类 <code>ReentrantReadWriteLock.ReadLock</code> 对象，这是一把读锁。</li>
<li><code>writerLock</code> - 内部类 <code>ReentrantReadWriteLock.WriteLock</code> 对象，这是一把写锁。</li>
</ul>
<h4 id="⭐-Condition"><a href="#⭐-Condition" class="headerlink" title="⭐ Condition"></a>⭐ Condition</h4><blockquote>
<p>Condition 有什么用？</p>
<p>使用 Lock 的线程，彼此如何通信？</p>
</blockquote>
<p><strong>作用</strong></p>
<p>可以理解为，什么样的锁配什么样的钥匙。</p>
<p><strong>内置锁（<code>synchronized</code>）配合内置条件队列（<code>wait</code>、<code>notify</code>、<code>notifyAll</code> ），显式锁（<code>Lock</code>）配合显式条件队列（<code>Condition</code> ）</strong>。</p>
<h4 id="⭐⭐-死锁"><a href="#⭐⭐-死锁" class="headerlink" title="⭐⭐ 死锁"></a>⭐⭐ 死锁</h4><blockquote>
<p>如何避免死锁？</p>
</blockquote>
<ul>
<li>避免一个线程同时获取多个锁</li>
<li>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源</li>
<li>尝试使用定时锁 lock.tryLock(timeout)，避免锁一直不能释放</li>
<li>对于数据库锁，加锁和解锁必须在一个数据库连接中里，否则会出现解锁失败的情况。</li>
</ul>
<h3 id="原子变量类"><a href="#原子变量类" class="headerlink" title="原子变量类"></a>原子变量类</h3><blockquote>
<p>👉 参考阅读：<a target="_blank" rel="noopener" href="https://dunwu.github.io/waterdrop/pages/25f78a/">Java 原子类</a></p>
</blockquote>
<h4 id="⭐-原子类简介"><a href="#⭐-原子类简介" class="headerlink" title="⭐ 原子类简介"></a>⭐ 原子类简介</h4><blockquote>
<p>为什么要用原子类？</p>
<p>用过哪些原子类？</p>
</blockquote>
<p><strong>作用</strong></p>
<p>常规的锁（<code>Lock</code>、<code>sychronized</code>）由于是阻塞式的，势必影响并发吞吐量。</p>
<p><code>volatile</code> 号称轻量级的锁，但不能保证原子性。</p>
<p>为了兼顾原子性和锁的性能问题，所以引入了原子类。</p>
<p><strong>类型</strong></p>
<p>原子变量类可以分为 4 组：</p>
<ul>
<li>基本类型<ul>
<li><code>AtomicBoolean</code> - 布尔类型原子类</li>
<li><code>AtomicInteger</code> - 整型原子类</li>
<li><code>AtomicLong</code> - 长整型原子类</li>
</ul>
</li>
<li>引用类型<ul>
<li><code>AtomicReference</code> - 引用类型原子类</li>
<li><code>AtomicMarkableReference</code> - 带有标记位的引用类型原子类</li>
<li><code>AtomicStampedReference</code> - 带有版本号的引用类型原子类</li>
</ul>
</li>
<li>数组类型<ul>
<li><code>AtomicIntegerArray</code> - 整形数组原子类</li>
<li><code>AtomicLongArray</code> - 长整型数组原子类</li>
<li><code>AtomicReferenceArray</code> - 引用类型数组原子类</li>
</ul>
</li>
<li>属性更新器类型<ul>
<li><code>AtomicIntegerFieldUpdater</code> - 整型字段的原子更新器。</li>
<li><code>AtomicLongFieldUpdater</code> - 长整型字段的原子更新器。</li>
<li><code>AtomicReferenceFieldUpdater</code> - 原子更新引用类型里的字段。</li>
</ul>
</li>
</ul>
<h4 id="⭐-原子类的原理"><a href="#⭐-原子类的原理" class="headerlink" title="⭐ 原子类的原理"></a>⭐ 原子类的原理</h4><ol>
<li>处理器实现原子操作：使用总线锁保证原子性，使用缓存锁保证原子性（修改内存地址，缓存一致性机制：阻止同时修改由 2 个以上的处理器缓存的内存区域数据）</li>
<li>JAVA 实现原子操作：循环使用 CAS （自旋 CAS）实现原子操作</li>
</ol>
<h3 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h3><blockquote>
<p>👉 参考阅读：<a target="_blank" rel="noopener" href="https://dunwu.github.io/waterdrop/pages/02d274/">Java 并发工具类</a></p>
</blockquote>
<h4 id="⭐-CountDownLatch"><a href="#⭐-CountDownLatch" class="headerlink" title="⭐ CountDownLatch"></a>⭐ CountDownLatch</h4><blockquote>
<p>CountDownLatch 作用？</p>
<p>CountDownLatch 原理？</p>
</blockquote>
<p><strong>作用</strong></p>
<p>字面意思为 <strong>递减计数锁</strong>。用于控制一个或者多个线程等待多个线程。</p>
<p><code>CountDownLatch</code> 维护一个计数器 count，表示需要等待的事件数量。<code>countDown</code> 方法递减计数器，表示有一个事件已经发生。调用 <code>await</code> 方法的线程会一直阻塞直到计数器为零，或者等待中的线程中断，或者等待超时。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/concurrent/CountDownLatch.png" alt="img"></p>
<p><strong>原理</strong></p>
<p><code>CountDownLatch</code> 是基于 AQS(<code>AbstractQueuedSynchronizer</code>) 实现的。</p>
<h4 id="⭐-CyclicBarrier"><a href="#⭐-CyclicBarrier" class="headerlink" title="⭐ CyclicBarrier"></a>⭐ CyclicBarrier</h4><blockquote>
<p>CyclicBarrier 有什么用？</p>
<p>CyclicBarrier 的原理是什么？</p>
<p>CyclicBarrier 和 CountDownLatch 有什么区别？</p>
</blockquote>
<p><strong>作用</strong></p>
<p>字面意思是 <strong>循环栅栏</strong>。**<code>CyclicBarrier</code> 可以让一组线程等待至某个状态（遵循字面意思，不妨称这个状态为栅栏）之后再全部同时执行**。之所以叫循环栅栏是因为：当所有等待线程都被释放以后，<code>CyclicBarrier</code> 可以被重用。</p>
<p><code>CyclicBarrier</code> 维护一个计数器 count。每次执行 <code>await</code> 方法之后，count 加 1，直到计数器的值和设置的值相等，等待的所有线程才会继续执行。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/concurrent/CyclicBarrier.png" alt="img"></p>
<p><strong>原理</strong></p>
<p><code>CyclicBarrier</code> 是基于 <code>ReentrantLock</code> 和 <code>Condition</code> 实现的。</p>
<p><strong>区别</strong></p>
<p><code>CyclicBarrier</code> 和 <code>CountDownLatch</code> 都可以用来让一组线程等待其它线程。与 <code>CyclicBarrier</code> 不同的是，<code>CountdownLatch</code> 不能重用。</p>
<h4 id="⭐-Semaphore"><a href="#⭐-Semaphore" class="headerlink" title="⭐ Semaphore"></a>⭐ Semaphore</h4><blockquote>
<p>Semaphore 作用？</p>
</blockquote>
<p><strong>作用</strong></p>
<p>字面意思为 <strong>信号量</strong>。<code>Semaphore</code> 用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量。</p>
<p><code>Semaphore</code> 管理着一组虚拟的许可（permit），permit 的初始数量可通过构造方法来指定。每次执行 <code>acquire</code> 方法可以获取一个 permit，如果没有就等待；而 <code>release</code> 方法可以释放一个 permit。</p>
<ul>
<li><code>Semaphore</code> 可以用于实现资源池，如数据库连接池。</li>
<li><code>Semaphore</code> 可以用于将任何一种容器变成有界阻塞容器。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/concurrent/Semaphore.png" alt="img"></p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><blockquote>
<p>👉 参考阅读：<a target="_blank" rel="noopener" href="https://dunwu.github.io/waterdrop/pages/ad9680/">Java 线程池</a></p>
</blockquote>
<h4 id="⭐⭐-ThreadPoolExecutor"><a href="#⭐⭐-ThreadPoolExecutor" class="headerlink" title="⭐⭐ ThreadPoolExecutor"></a>⭐⭐ ThreadPoolExecutor</h4><blockquote>
<p><code>ThreadPoolExecutor</code> 有哪些参数，各自有什么用？</p>
<p><code>ThreadPoolExecutor</code> 工作原理？</p>
</blockquote>
<p><strong>原理</strong></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/concurrent/java-thread-pool_1.png" alt="img"></p>
<p><strong>参数</strong></p>
<p><code>java.uitl.concurrent.ThreadPoolExecutor</code> 类是 <code>Executor</code> 框架中最核心的一个类。</p>
<p>ThreadPoolExecutor 有四个构造方法，前三个都是基于第四个实现。第四个构造方法定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span> &#123;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>corePoolSize</code> - <strong>核心线程数量</strong>。当有新任务通过 <code>execute</code> 方法提交时 ，线程池会执行以下判断：<ul>
<li>如果运行的线程数少于 <code>corePoolSize</code>，则创建新线程来处理任务，即使线程池中的其他线程是空闲的。</li>
<li>如果线程池中的线程数量大于等于 <code>corePoolSize</code> 且小于 <code>maximumPoolSize</code>，则只有当 <code>workQueue</code> 满时才创建新的线程去处理任务；</li>
<li>如果设置的 <code>corePoolSize</code> 和 <code>maximumPoolSize</code> 相同，则创建的线程池的大小是固定的。这时如果有新任务提交，若 <code>workQueue</code> 未满，则将请求放入 <code>workQueue</code> 中，等待有空闲的线程去从 <code>workQueue</code> 中取任务并处理；</li>
<li>如果运行的线程数量大于等于 <code>maximumPoolSize</code>，这时如果 <code>workQueue</code> 已经满了，则使用 <code>handler</code> 所指定的策略来处理任务；</li>
<li>所以，任务提交时，判断的顺序为 <code>corePoolSize</code> &#x3D;&gt; <code>workQueue</code> &#x3D;&gt; <code>maximumPoolSize</code>。</li>
</ul>
</li>
<li><code>maximumPoolSize</code> - <strong>最大线程数量</strong>。<ul>
<li>如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。</li>
<li>值得注意的是：如果使用了无界的任务队列这个参数就没什么效果。</li>
</ul>
</li>
<li><code>keepAliveTime</code>：<strong>线程保持活动的时间</strong>。<ul>
<li>当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>。</li>
<li>所以，如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。</li>
</ul>
</li>
<li><code>unit</code> - <strong><code>keepAliveTime</code> 的时间单位</strong>。有 7 种取值。可选的单位有天（DAYS），小时（HOURS），分钟（MINUTES），毫秒(MILLISECONDS)，微秒(MICROSECONDS, 千分之一毫秒)和毫微秒(NANOSECONDS, 千分之一微秒)。</li>
<li><code>workQueue</code> - <strong>等待执行的任务队列</strong>。用于保存等待执行的任务的阻塞队列。 可以选择以下几个阻塞队列。<ul>
<li><code>ArrayBlockingQueue</code> - <strong>有界阻塞队列</strong>。<ul>
<li>此队列是<strong>基于数组的先进先出队列（FIFO）</strong>。</li>
<li>此队列创建时必须指定大小。</li>
</ul>
</li>
<li><code>LinkedBlockingQueue</code> - <strong>无界阻塞队列</strong>。<ul>
<li>此队列是<strong>基于链表的先进先出队列（FIFO）</strong>。</li>
<li>如果创建时没有指定此队列大小，则默认为 <code>Integer.MAX_VALUE</code>。</li>
<li>吞吐量通常要高于 <code>ArrayBlockingQueue</code>。</li>
<li>使用 <code>LinkedBlockingQueue</code> 意味着： <code>maximumPoolSize</code> 将不起作用，线程池能创建的最大线程数为 <code>corePoolSize</code>，因为任务等待队列是无界队列。</li>
<li><code>Executors.newFixedThreadPool</code> 使用了这个队列。</li>
</ul>
</li>
<li><code>SynchronousQueue</code> - <strong>不会保存提交的任务，而是将直接新建一个线程来执行新来的任务</strong>。<ul>
<li>每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态。</li>
<li>吞吐量通常要高于 <code>LinkedBlockingQueue</code>。</li>
<li><code>Executors.newCachedThreadPool</code> 使用了这个队列。</li>
</ul>
</li>
<li><code>PriorityBlockingQueue</code> - <strong>具有优先级的无界阻塞队列</strong>。</li>
</ul>
</li>
<li><code>threadFactory</code> - <strong>线程工厂</strong>。可以通过线程工厂给每个创建出来的线程设置更有意义的名字。</li>
<li><code>handler</code> - <strong>饱和策略</strong>。它是 <code>RejectedExecutionHandler</code> 类型的变量。当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。线程池支持以下策略：<ul>
<li><code>AbortPolicy</code> - 丢弃任务并抛出异常。这也是默认策略。</li>
<li><code>DiscardPolicy</code> - 丢弃任务，但不抛出异常。</li>
<li><code>DiscardOldestPolicy</code> - 丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）。</li>
<li><code>CallerRunsPolicy</code> - 只用调用者所在的线程来运行任务。</li>
<li>如果以上策略都不能满足需要，也可以通过实现 <code>RejectedExecutionHandler</code> 接口来定制处理策略。如记录日志或持久化不能处理的任务。</li>
</ul>
</li>
</ul>
<h4 id="⭐-Executors"><a href="#⭐-Executors" class="headerlink" title="⭐ Executors"></a>⭐ Executors</h4><blockquote>
<p>Executors 提供了哪些内置的线程池？</p>
<p>这些线程池各自有什么特性？适合用于什么场景？</p>
</blockquote>
<p>Executors 为 Executor，ExecutorService，ScheduledExecutorService，ThreadFactory 和 <code>Callable</code> 类提供了一些工具方法。</p>
<p>（1）newSingleThreadExecutor</p>
<p><strong>创建一个单线程的线程池</strong>。</p>
<p>只会创建唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 <strong>如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它</strong> 。</p>
<p>单工作线程最大的特点是：<strong>可保证顺序地执行各个任务</strong>。</p>
<p>（2）newFixedThreadPool</p>
<p><strong>创建一个固定大小的线程池</strong>。</p>
<p><strong>每次提交一个任务就会新创建一个工作线程，如果工作线程数量达到线程池最大线程数，则将提交的任务存入到阻塞队列中</strong>。</p>
<p><code>FixedThreadPool</code> 是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。</p>
<p>（3）newCachedThreadPool</p>
<p><strong>创建一个可缓存的线程池</strong>。</p>
<ul>
<li>如果线程池大小超过处理任务所需要的线程数，就会回收部分空闲的线程；</li>
<li>如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间（默认为 1 分钟），则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。</li>
<li>此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 JVM）能够创建的最大线程大小。 因此，使用 <code>CachedThreadPool</code> 时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。</li>
</ul>
<p>（4）newScheduleThreadPool</p>
<p>创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</p>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><h3 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h3><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><strong>书籍</strong><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/10484692/">《Java 并发编程实战》</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/26591326/">《Java 并发编程的艺术》</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/34907497/">《深入理解 Java 虚拟机》</a></li>
</ul>
</li>
<li><strong>文章</strong><ul>
<li><a target="_blank" rel="noopener" href="http://www.importnew.com/12773.html">Java 线程面试题 Top 50</a></li>
<li><a target="_blank" rel="noopener" href="http://ifeve.com/java-multi-threading-concurrency-interview-questions-with-answers/">Java 多线程和并发基础面试问答</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/yaosiming2011/article/details/44280797">进程和线程关系及区别</a></li>
<li><a target="_blank" rel="noopener" href="https://www.w3resource.com/java-tutorial/java-threadclass-methods-and-threadstates.php">JavaThread Methods and Thread States</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/pange1991/article/details/53860651">Java 线程的 5 种状态及切换(透彻讲解)</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/shimiso/article/details/8964414">Java 中守护线程的总结</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/longshengguoji/article/details/41126119">Java 创建线程的三种方式及其对比</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/pange1991/article/details/53860651">Java 线程的 5 种状态及切换(透彻讲解)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lcplcpjava/p/6896904.html">Java 线程方法 join 的简单总结</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/dolphin0520/p/3920385.html">Java 并发编程：线程间协作的两种方式：wait、notify、notifyAll 和 Condition</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/dolphin0520/p/3920373.html">Java 并发编程：volatile 关键字解析</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/dolphin0520/p/3949310.html">Java 并发编程：Callable、Future 和 FutureTask</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/dolphin0520/p/3932921.html">Java 并发编程：线程池的使用</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/0256c2995cec">Java 并发编程</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/396816/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/396816/" class="post-title-link" itemprop="url">Mysql 优化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-03 20:16:48" itemprop="dateCreated datePublished" datetime="2020-06-03T20:16:48+08:00">2020-06-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">关系型数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/" itemprop="url" rel="index"><span itemprop="name">Mysql</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Mysql-优化"><a href="#Mysql-优化" class="headerlink" title="Mysql 优化"></a>Mysql 优化</h1><h2 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h2><p>慢查询日志可以帮我们找到执行慢的 SQL。</p>
<p>可以通过以下命令查看慢查询日志是否开启：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%slow_query_log&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name  <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+-------+</span></span><br><span class="line"><span class="operator">|</span> slow_query_log <span class="operator">|</span> <span class="keyword">ON</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure>

<p>启停慢查询日志开关：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 开启慢查询日志</span><br><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> slow_query_log<span class="operator">=</span><span class="string">&#x27;ON&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 关闭慢查询日志</span><br><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> slow_query_log<span class="operator">=</span><span class="string">&#x27;OFF&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>查看慢查询的时间阈值：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%long_query_time%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name   <span class="operator">|</span> <span class="keyword">Value</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> long_query_time <span class="operator">|</span> <span class="number">10.000000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure>

<p>设置慢查询的时间阈值：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> long_query_time <span class="operator">=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>MySQL 自带了一个 mysqldumpslow 工具，用于统计慢查询日志（这个工具是个 Perl 脚本，需要先安装好 Perl）。</p>
<p>mysqldumpslow 命令的具体参数如下：</p>
<ul>
<li><code>-s</code> - 采用 order 排序的方式，排序方式可以有以下几种。分别是 c（访问次数）、t（查询时间）、l（锁定时间）、r（返回记录）、ac（平均查询次数）、al（平均锁定时间）、ar（平均返回记录数）和 at（平均查询时间）。其中 at 为默认排序方式。</li>
<li><code>-t</code> - 返回前 N 条数据 。</li>
<li><code>-g</code> - 后面可以是正则表达式，对大小写不敏感。</li>
</ul>
<p>比如想要按照查询时间排序，查看前两条 SQL 语句，可以执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl mysqldumpslow.pl -s t -t 2 &quot;C:\ProgramData\MySQL\MySQL Server 8.0\Data\slow.log&quot;</span><br></pre></td></tr></table></figure>

<h2 id="执行计划（EXPLAIN）"><a href="#执行计划（EXPLAIN）" class="headerlink" title="执行计划（EXPLAIN）"></a>执行计划（EXPLAIN）</h2><p><strong>“执行计划”是对 SQL 查询语句在数据库中执行过程的描述</strong>。 如果要分析某条 SQL 的性能问题，通常需要先查看 SQL 的执行计划，排查每一步 SQL 执行是否存在问题。</p>
<p>很多数据库都支持执行计划，Mysql 也不例外。在 Mysql 中，用户可以通过 <code>EXPLAIN</code> 命令查看优化器针对指定 SQL 生成的逻辑执行计划。 </p>
<p>【示例】Mysql 执行计划示例</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user_info <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span>\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        <span class="keyword">table</span>: user_info</span><br><span class="line">   partitions: <span class="keyword">NULL</span></span><br><span class="line">         type: const</span><br><span class="line">possible_keys: <span class="keyword">PRIMARY</span></span><br><span class="line">          key: <span class="keyword">PRIMARY</span></span><br><span class="line">      key_len: <span class="number">8</span></span><br><span class="line">          <span class="keyword">ref</span>: const</span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">1</span></span><br><span class="line">     filtered: <span class="number">100.00</span></span><br><span class="line">        Extra: <span class="keyword">NULL</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>执行计划返回结果参数说明：</p>
<ul>
<li><code>id</code> - SELECT 查询的标识符。每个 <code>SELECT</code> 都会自动分配一个唯一的标识符。</li>
<li><code>select_type</code> - <code>SELECT</code> 查询的类型。<ul>
<li><code>SIMPLE</code> - 表示此查询不包含 <code>UNION</code> 查询或子查询。</li>
<li><code>PRIMARY</code> - 表示此查询是最外层的查询。</li>
<li><code>UNION</code> - 表示此查询是 <code>UNION</code> 的第二或随后的查询。</li>
<li><code>DEPENDENT UNION</code> - <code>UNION</code> 中的第二个或后面的查询语句, 取决于外面的查询。</li>
<li><code>UNION RESULT</code> - <code>UNION</code> 的结果。</li>
<li><code>SUBQUERY</code> - 子查询中的第一个 <code>SELECT</code>。</li>
<li><code>DEPENDENT SUBQUERY</code> - 子查询中的第一个 <code>SELECT</code>, 取决于外面的查询. 即子查询依赖于外层查询的结果。</li>
</ul>
</li>
<li><code>table</code> - 查询的是哪个表，如果给表起别名了，则显示别名。</li>
<li><code>partitions</code> - 匹配的分区。</li>
<li><code>type</code> - 表示从表中查询到行所执行的方式，查询方式是 SQL 优化中一个很重要的指标，执行效率由高到低依次为：<ul>
<li><code>system</code>&#x2F;<code>const</code> - 表中只有一行数据匹配。此时根据索引查询一次就能找到对应的数据。如果是 B+ 树索引，我们知道此时索引构造成了多个层级的树，当查询的索引在树的底层时，查询效率就越低。<code>const</code> 表示此时索引在第一层，只需访问一层便能得到数据。</li>
<li><code>eq_ref</code> - 使用唯一索引扫描。常见于多表连接中使用主键和唯一索引作为关联条件。</li>
<li><code>ref</code> - 非唯一索引扫描。还可见于唯一索引最左原则匹配扫描。</li>
<li><code>range</code> - 索引范围扫描。比如 <code>&lt;</code>，<code>&gt;</code>，<code>between</code> 等操作。</li>
<li><code>index</code> - 索引全表扫描。此时遍历整个索引树。</li>
<li><code>ALL</code> - 表示全表扫描。需要遍历全表来找到对应的行。</li>
</ul>
</li>
<li><code>possible_keys</code> - 此次查询中可能选用的索引。</li>
<li><code>key</code> - 此次查询中实际使用的索引。如果这一项为 <code>NULL</code>，说明没有使用索引。</li>
<li><code>ref</code> - 哪个字段或常数与 key 一起被使用。</li>
<li><code>rows</code> - 显示此查询一共扫描了多少行，这个是一个估计值。</li>
<li><code>filtered</code> - 表示此查询条件所过滤的数据的百分比。</li>
<li><code>extra</code> - 额外的信息。<ul>
<li><code>Using filesort</code> - 当查询语句中包含 <code>GROUP BY</code> 操作，而且无法利用索引完成排序操作的时候， 这时不得不选择相应的排序算法进行，甚至可能会通过文件排序，效率是很低的，所以要避免这种问题的出现。</li>
<li><code>Using temporary</code> - 使了用临时表保存中间结果，MySQL 在对查询结果排序时使用临时表，常见于排序 <code>ORDER BY</code> 和分组查询 <code>GROUP BY</code>。效率低，要避免这种问题的出现。</li>
<li><code>Using index</code> - 所需数据只需在索引即可全部获得，不须要再到表中取数据，也就是使用了覆盖索引，避免了回表操作，效率不错。</li>
</ul>
</li>
</ul>
<blockquote>
<p>更多内容请参考：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000008131735">MySQL 性能优化神器 Explain 使用分析</a></p>
</blockquote>
<h2 id="optimizer-trace"><a href="#optimizer-trace" class="headerlink" title="optimizer trace"></a>optimizer trace</h2><p>在 MySQL 5.6 及之后的版本中，我们可以使用 optimizer trace 功能查看优化器生成执行计划的整个过程。有了这个功能，我们不仅可以了解优化器的选择过程，更可以了解每一个执行环节的成本，然后依靠这些信息进一步优化查询。</p>
<p>如下代码所示，打开 optimizer_trace 后，再执行 SQL 就可以查询 information_schema.OPTIMIZER_TRACE 表查看执行计划了，最后可以关闭 optimizer_trace 功能：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> optimizer_trace<span class="operator">=</span>&quot;enabled=on&quot;;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> person <span class="keyword">WHERE</span> NAME <span class="operator">&gt;</span><span class="string">&#x27;name84059&#x27;</span> <span class="keyword">AND</span> create_time<span class="operator">&gt;</span><span class="string">&#x27;2020-01-24 05:00</span></span><br><span class="line"><span class="string">SELECT * FROM information_schema.OPTIMIZER_TRACE;</span></span><br><span class="line"><span class="string">SET optimizer_trace=&quot;enabled=off&quot;;</span></span><br></pre></td></tr></table></figure>

<h2 id="SQL-优化"><a href="#SQL-优化" class="headerlink" title="SQL 优化"></a>SQL 优化</h2><h3 id="SQL-优化基本思路"><a href="#SQL-优化基本思路" class="headerlink" title="SQL 优化基本思路"></a>SQL 优化基本思路</h3><p>使用 <code>EXPLAIN</code> 命令查看当前 SQL 是否使用了索引，优化后，再通过执行计划（<code>EXPLAIN</code>）来查看优化效果。</p>
<p>SQL 优化的基本思路：</p>
<ul>
<li><p><strong>只返回必要的列</strong> - 最好不要使用 <code>SELECT *</code> 语句。</p>
</li>
<li><p><strong>只返回必要的行</strong> - 使用 <code>WHERE</code> 子查询语句进行过滤查询，有时候也需要使用 <code>LIMIT</code> 语句来限制返回的数据。</p>
</li>
<li><p><strong>缓存重复查询的数据</strong> - 应该考虑在客户端使用缓存，尽量不要使用 Mysql 服务器缓存（存在较多问题和限制）。</p>
</li>
<li><p><strong>使用索引覆盖查询</strong></p>
</li>
</ul>
<h3 id="优化分页"><a href="#优化分页" class="headerlink" title="优化分页"></a>优化分页</h3><p>当需要分页操作时，通常会使用 <code>LIMIT</code> 加上偏移量的办法实现，同时加上合适的 <code>ORDER BY</code> 字句。<strong>如果有对应的索引，通常效率会不错，否则，MySQL 需要做大量的文件排序操作</strong>。</p>
<p>一个常见的问题是当偏移量非常大的时候，比如：<code>LIMIT 1000000 20</code> 这样的查询，MySQL 需要查询 1000020 条记录然后只返回 20 条记录，前面的 1000000  条都将被抛弃，这样的代价非常高。</p>
<p>针对分页优化，有以下两种方案</p>
<p>（1）方案 - 延迟关联</p>
<p>优化这种查询一个最简单的办法就是尽可能的使用覆盖索引扫描，而不是查询所有的列。然后根据需要做一次关联查询再返回所有的列。对于偏移量很大时，这样做的效率会提升非常大。考虑下面的查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film_id,description <span class="keyword">FROM</span> film <span class="keyword">ORDER</span> <span class="keyword">BY</span> title LIMIT <span class="number">1000000</span>,<span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>如果这张表非常大，那么这个查询最好改成下面的样子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film.film_id,film.description</span><br><span class="line"><span class="keyword">FROM</span> film <span class="keyword">INNER</span> <span class="keyword">JOIN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> film_id <span class="keyword">FROM</span> film <span class="keyword">ORDER</span> <span class="keyword">BY</span> title LIMIT <span class="number">50</span>,<span class="number">5</span></span><br><span class="line">) <span class="keyword">AS</span> tmp <span class="keyword">USING</span>(film_id);</span><br></pre></td></tr></table></figure>

<p>这里的延迟关联将大大提升查询效率，让 MySQL 扫描尽可能少的页面，获取需要访问的记录后在根据关联列回原表查询所需要的列。</p>
<p>（2）方案 - 书签方式</p>
<p>有时候如果可以使用书签记录上次取数据的位置，那么下次就可以直接从该书签记录的位置开始扫描，这样就可以避免使用 <code>OFFSET</code>，比如下面的查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 原语句</span></span><br><span class="line"><span class="keyword">SELECT</span> id <span class="keyword">FROM</span> t LIMIT <span class="number">1000000</span>, <span class="number">10</span>;</span><br><span class="line"><span class="comment">-- 优化语句</span></span><br><span class="line"><span class="keyword">SELECT</span> id <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">1000000</span> LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>其他优化的办法还包括使用预先计算的汇总表，或者关联到一个冗余表，冗余表中只包含主键列和需要做排序的列。</p>
<h3 id="优化-JOIN"><a href="#优化-JOIN" class="headerlink" title="优化 JOIN"></a>优化 JOIN</h3><p>优化子查询</p>
<p>尽量使用 <code>JOIN</code> 语句来替代子查询。因为子查询是嵌套查询，而嵌套查询会新创建一张临时表，而临时表的创建与销毁会占用一定的系统资源以及花费一定的时间，同时对于返回结果集比较大的子查询，其对查询性能的影响更大。</p>
<p>小表驱动大表</p>
<p>JOIN 查询时，应该用小表驱动大表。因为 JOIN 时，MySQL 内部会先遍历驱动表，再去遍历被驱动表。</p>
<p>比如 left join，左表就是驱动表，A 表小于 B 表，建立连接的次数就少，查询速度就被加快了。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> A <span class="keyword">left</span> <span class="keyword">join</span> B ;</span><br></pre></td></tr></table></figure>

<p>适当冗余字段</p>
<p>增加冗余字段可以减少大量的连表查询，因为多张表的连表查询性能很低，所有可以适当的增加冗余字段，以减少多张表的关联查询，这是以空间换时间的优化策略</p>
<p>避免 JOIN 太多表</p>
<p>《阿里巴巴 Java 开发手册》规定不要 join 超过三张表，第一 join 太多降低查询的速度，第二 join 的 buffer 会占用更多的内存。</p>
<p>如果不可避免要 join 多张表，可以考虑使用数据异构的方式异构到 ES 中查询。</p>
<h3 id="优化-UNION"><a href="#优化-UNION" class="headerlink" title="优化 UNION"></a>优化 UNION</h3><p>MySQL 执行 <code>UNION</code> 的策略是：先创建临时表，然后将各个查询结果填充到临时表中，最后再进行查询。很多优化策略在 <code>UNION</code> 查询中都会失效，因为它无法利用索引。</p>
<p>最好将 <code>WHERE</code>、<code>LIMIT</code> 等子句下推到 <code>UNION</code> 的各个子查询中，以便优化器可以充分利用这些条件进行优化。</p>
<p>此外，尽量使用 <code>UNION ALL</code>，避免使用 <code>UNION</code>。</p>
<p><code>UNION</code> 和 <code>UNION ALL</code> 都是将两个结果集合并为一个，<strong>两个要联合的 SQL 语句字段个数必须一样，而且字段类型要“相容”（一致）</strong>。</p>
<ul>
<li><code>UNION</code> 需要进行去重扫描，因此消息较低；而 <code>UNION ALL</code> 不会进行去重。</li>
<li><code>UNION</code> 会按照字段的顺序进行排序；而 <code>UNION ALL</code> 只是简单的将两个结果合并就返回。</li>
</ul>
<h3 id="优化-COUNT-查询"><a href="#优化-COUNT-查询" class="headerlink" title="优化 COUNT() 查询"></a>优化 COUNT() 查询</h3><p><code>COUNT()</code> 有两种作用：</p>
<ul>
<li>统计某个列值的数量。统计列值时，要求列值是非 <code>NULL</code> 的，它不会统计 <code>NULL</code>。</li>
<li>统计行数。</li>
</ul>
<p><strong>统计列值时，要求列值是非空的，它不会统计 NULL</strong>。如果确认括号中的表达式不可能为空时，实际上就是在统计行数。最简单的就是当使用 <code>COUNT(*)</code> 时，并不是我们所想象的那样扩展成所有的列，实际上，它会忽略所有的列而直接统计行数。</p>
<p>我们最常见的误解也就在这儿，在括号内指定了一列却希望统计结果是行数，而且还常常误以为前者的性能会更好。但实际并非这样，如果要统计行数，直接使用 <code>COUNT(*)</code>，意义清晰，且性能更好。</p>
<p>（1）简单优化</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> world.city <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> (<span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> world.city) <span class="operator">-</span> <span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> world.city <span class="keyword">WHERE</span> id <span class="operator">&lt;=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>（2）使用近似值</p>
<p>有时候某些业务场景并不需要完全精确的统计值，可以用近似值来代替，<code>EXPLAIN</code> 出来的行数就是一个不错的近似值，而且执行 <code>EXPLAIN</code> 并不需要真正地去执行查询，所以成本非常低。通常来说，执行 <code>COUNT()</code> 都需要扫描大量的行才能获取到精确的数据，因此很难优化，MySQL 层面还能做得也就只有覆盖索引了。如果不还能解决问题，只有从架构层面解决了，比如添加汇总表，或者使用 Redis 这样的外部缓存系统。</p>
<h3 id="优化查询方式"><a href="#优化查询方式" class="headerlink" title="优化查询方式"></a>优化查询方式</h3><h4 id="切分大查询"><a href="#切分大查询" class="headerlink" title="切分大查询"></a>切分大查询</h4><p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELEFT <span class="keyword">FROM</span> messages <span class="keyword">WHERE</span> <span class="keyword">create</span> <span class="operator">&lt;</span> DATE_SUB(NOW(), <span class="type">INTERVAL</span> <span class="number">3</span> <span class="keyword">MONTH</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rows_affected <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">do &#123;</span><br><span class="line">    rows_affected <span class="operator">=</span> do_query(</span><br><span class="line">    &quot;DELETE FROM messages WHERE create  &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000&quot;)</span><br><span class="line">&#125; while rows_affected <span class="operator">&gt;</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h4 id="分解大连接查询"><a href="#分解大连接查询" class="headerlink" title="分解大连接查询"></a>分解大连接查询</h4><p>将一个大连接查询（JOIN）分解成对每一个表进行一次单表查询，然后将结果在应用程序中进行关联，这样做的好处有：</p>
<ul>
<li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li>
<li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</li>
<li>减少锁竞争；</li>
<li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可扩展。</li>
<li>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tag</span><br><span class="line"><span class="keyword">JOIN</span> tag_post <span class="keyword">ON</span> tag_post.tag_id<span class="operator">=</span>tag.id</span><br><span class="line"><span class="keyword">JOIN</span> post <span class="keyword">ON</span> tag_post.post_id<span class="operator">=</span>post.id</span><br><span class="line"><span class="keyword">WHERE</span> tag.tag<span class="operator">=</span><span class="string">&#x27;mysql&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tag <span class="keyword">WHERE</span> tag<span class="operator">=</span><span class="string">&#x27;mysql&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tag_post <span class="keyword">WHERE</span> tag_id<span class="operator">=</span><span class="number">1234</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> post <span class="keyword">WHERE</span> post.id <span class="keyword">IN</span> (<span class="number">123</span>,<span class="number">456</span>,<span class="number">567</span>,<span class="number">9098</span>,<span class="number">8904</span>);</span><br></pre></td></tr></table></figure>

<h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><p>通过索引覆盖查询，可以优化排序、分组。</p>
<p>详情见 <a target="_blank" rel="noopener" href="https://dunwu.github.io/waterdrop/pages/fcb19c/">Mysql 索引</a></p>
<h2 id="数据结构优化"><a href="#数据结构优化" class="headerlink" title="数据结构优化"></a>数据结构优化</h2><p>良好的逻辑设计和物理设计是高性能的基石。</p>
<h3 id="数据类型优化"><a href="#数据类型优化" class="headerlink" title="数据类型优化"></a>数据类型优化</h3><h4 id="数据类型优化基本原则"><a href="#数据类型优化基本原则" class="headerlink" title="数据类型优化基本原则"></a>数据类型优化基本原则</h4><ul>
<li><strong>更小的通常更好</strong> - 越小的数据类型通常会更快，占用更少的磁盘、内存，处理时需要的 CPU 周期也更少。<ul>
<li>例如：整型比字符类型操作代价低，因而会使用整型来存储 IP 地址，使用 <code>DATETIME</code> 来存储时间，而不是使用字符串。</li>
</ul>
</li>
<li><strong>简单就好</strong> - 如整型比字符型操作代价低。<ul>
<li>例如：很多软件会用整型来存储 IP 地址。</li>
<li>例如：**<code>UNSIGNED</code> 表示不允许负值，大致可以使正数的上限提高一倍**。</li>
</ul>
</li>
<li><strong>尽量避免 NULL</strong> - 可为 NULL 的列会使得索引、索引统计和值比较都更复杂。</li>
</ul>
<h4 id="类型的选择"><a href="#类型的选择" class="headerlink" title="类型的选择"></a>类型的选择</h4><ul>
<li><p>整数类型通常是标识列最好的选择，因为它们很快并且可以使用 <code>AUTO_INCREMENT</code>。</p>
</li>
<li><p><code>ENUM</code> 和 <code>SET</code> 类型通常是一个糟糕的选择，应尽量避免。</p>
</li>
<li><p>应该尽量避免用字符串类型作为标识列，因为它们很消耗空间，并且通常比数字类型慢。对于 <code>MD5</code>、<code>SHA</code>、<code>UUID</code> 这类随机字符串，由于比较随机，所以可能分布在很大的空间内，导致 <code>INSERT</code> 以及一些 <code>SELECT</code> 语句变得很慢。</p>
<ul>
<li>如果存储 UUID ，应该移除 <code>-</code> 符号；更好的做法是，用 <code>UNHEX()</code> 函数转换 UUID 值为 16 字节的数字，并存储在一个 <code>BINARY(16)</code> 的列中，检索时，可以通过 <code>HEX()</code> 函数来格式化为 16 进制格式。</li>
</ul>
</li>
</ul>
<h3 id="表设计"><a href="#表设计" class="headerlink" title="表设计"></a>表设计</h3><p>应该避免的设计问题：</p>
<ul>
<li><strong>太多的列</strong> - 设计者为了图方便，将大量冗余列加入表中，实际查询中，表中很多列是用不到的。这种宽表模式设计，会造成不小的性能代价，尤其是 <code>ALTER TABLE</code> 非常耗时。</li>
<li><strong>太多的关联</strong> - 所谓的实体 - 属性 - 值（EAV）设计模式是一个常见的糟糕设计模式。Mysql 限制了每个关联操作最多只能有 61 张表，但 EAV 模式需要许多自关联。</li>
<li><strong>枚举</strong> - 尽量不要用枚举，因为添加和删除字符串（枚举选项）必须使用 <code>ALTER TABLE</code>。</li>
<li>尽量避免 <code>NULL</code></li>
</ul>
<h3 id="范式和反范式"><a href="#范式和反范式" class="headerlink" title="范式和反范式"></a>范式和反范式</h3><p><strong>范式化目标是尽量减少冗余，而反范式化则相反</strong>。</p>
<p>范式化的优点：</p>
<ul>
<li>比反范式更节省空间</li>
<li>更新操作比反范式快</li>
<li>更少需要 <code>DISTINCT</code> 或 <code>GROUP BY</code> 语句</li>
</ul>
<p>范式化的缺点：</p>
<ul>
<li>通常需要关联查询。而关联查询代价较高，如果是分表的关联查询，代价更是高昂。</li>
</ul>
<p>在真实世界中，很少会极端地使用范式化或反范式化。实际上，应该权衡范式和反范式的利弊，混合使用。</p>
<h3 id="索引优化-1"><a href="#索引优化-1" class="headerlink" title="索引优化"></a>索引优化</h3><blockquote>
<p>索引优化应该是查询性能优化的最有效手段。</p>
<p>如果想详细了解索引特性请参考：<a target="_blank" rel="noopener" href="https://github.com/dunwu/db-tutorial/blob/master/docs/sql/mysql/mysql-index.md">Mysql 索引</a></p>
</blockquote>
<h4 id="何时使用索引"><a href="#何时使用索引" class="headerlink" title="何时使用索引"></a>何时使用索引</h4><ul>
<li>对于非常小的表，大部分情况下简单的全表扫描更高效。</li>
<li>对于中、大型表，索引非常有效。</li>
<li>对于特大型表，建立和使用索引的代价将随之增长。可以考虑使用分区技术。</li>
<li>如果表的数量特别多，可以建立一个元数据信息表，用来查询需要用到的某些特性。</li>
</ul>
<h4 id="索引优化策略"><a href="#索引优化策略" class="headerlink" title="索引优化策略"></a>索引优化策略</h4><ul>
<li><strong>索引基本原则</strong><ul>
<li>索引不是越多越好，不要为所有列都创建索引。</li>
<li>要尽量避免冗余和重复索引。</li>
<li>要考虑删除未使用的索引。</li>
<li>尽量的扩展索引，不要新建索引。</li>
<li>频繁作为 <code>WHERE</code> 过滤条件的列应该考虑添加索引。</li>
</ul>
</li>
<li><strong>独立的列</strong> - “独立的列” 是指索引列不能是表达式的一部分，也不能是函数的参数。</li>
<li><strong>前缀索引</strong> - 索引很长的字符列，可以索引开始的部分字符，这样可以大大节约索引空间。</li>
<li><strong>最左匹配原则</strong> - 将选择性高的列或基数大的列优先排在多列索引最前列。</li>
<li><strong>使用索引来排序</strong> - 索引最好既满足排序，又用于查找行。这样，就可以使用索引来对结果排序。</li>
<li><code>=</code>、<code>IN</code> 可以乱序 - 不需要考虑 <code>=</code>、<code>IN</code> 等的顺序</li>
<li><strong>覆盖索引</strong></li>
<li><strong>自增字段作主键</strong></li>
</ul>
<h2 id="数据模型和业务"><a href="#数据模型和业务" class="headerlink" title="数据模型和业务"></a>数据模型和业务</h2><ul>
<li>表字段比较复杂、易变动、结构难以统一的情况下，可以考虑使用 Nosql 来代替关系数据库表存储，如 ElasticSearch、MongoDB。</li>
<li>在高并发情况下的查询操作，可以使用缓存（如 Redis）代替数据库操作，提高并发性能。</li>
<li>数据量增长较快的表，需要考虑水平分表或分库，避免单表操作的性能瓶颈。</li>
<li>除此之外，我们应该通过一些优化，尽量避免比较复杂的 JOIN 查询操作，例如冗余一些字段，减少 JOIN 查询；创建一些中间表，减少 JOIN 查询。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/23008813/">《高性能 MySQL》</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/139">MySQL 实战 45 讲</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100028001">《Java 性能调优实战》</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d7665192aaaf">我必须得告诉大家的 MySQL 优化原理</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jfox.info/20-tiao-mysql-xing-nen-you-hua-de-zui-jia-jing-yan.html">20+ 条 MySQL 性能优化的最佳经验</a></li>
<li><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/execution-plan-information.html">Mysql 官方文档之执行计划</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000008131735">MySQL 性能优化神器 Explain 使用分析</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/00b04d/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/00b04d/" class="post-title-link" itemprop="url">Mysql 事务</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-03 19:32:09" itemprop="dateCreated datePublished" datetime="2020-06-03T19:32:09+08:00">2020-06-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">关系型数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/" itemprop="url" rel="index"><span itemprop="name">Mysql</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>14k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>12 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Mysql-事务"><a href="#Mysql-事务" class="headerlink" title="Mysql 事务"></a>Mysql 事务</h1><blockquote>
<p>不是所有的 Mysql 存储引擎都实现了事务处理。支持事务的存储引擎有：<code>InnoDB</code> 和 <code>NDB Cluster</code>。不支持事务的存储引擎，代表有：<code>MyISAM</code>。</p>
<p>用户可以根据业务是否需要事务处理（事务处理可以保证数据安全，但会增加系统开销），选择合适的存储引擎。</p>
</blockquote>
<h2 id="事务简介"><a href="#事务简介" class="headerlink" title="事务简介"></a>事务简介</h2><h3 id="事务概念"><a href="#事务概念" class="headerlink" title="事务概念"></a>事务概念</h3><p><strong>“事务”指的是满足 ACID 特性的一组操作</strong>。事务内的 SQL 语句，要么全执行成功，要么全执行失败。可以通过 <code>Commit</code> 提交一个事务，也可以使用 <code>Rollback</code> 进行回滚。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202311030701337.png"></p>
<h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><p>ACID 是数据库事务正确执行的四个基本要素。</p>
<ul>
<li><strong>原子性（Atomicity）</strong><ul>
<li>事务被视为不可分割的最小单元，事务中的所有操作要么全部提交成功，要么全部失败回滚。</li>
<li>回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</li>
</ul>
</li>
<li><strong>一致性（Consistency）</strong><ul>
<li>数据库在事务执行前后都保持一致性状态。</li>
<li>在一致性状态下，所有事务对一个数据的读取结果都是相同的。</li>
</ul>
</li>
<li><strong>隔离性（Isolation）</strong><ul>
<li>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</li>
</ul>
</li>
<li><strong>持久性（Durability）</strong><ul>
<li>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</li>
<li>可以通过数据库备份和恢复来实现，在系统发生奔溃时，使用备份的数据库进行数据恢复。</li>
</ul>
</li>
</ul>
<p>一个支持事务（Transaction）中的数据库系统，必需要具有这四种特性，否则在事务过程（Transaction processing）当中无法保证数据的正确性。</p>
<ul>
<li>只有满足一致性，事务的执行结果才是正确的。</li>
<li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li>
<li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li>
<li>事务满足持久化是为了能应对系统崩溃的情况。</li>
</ul>
<h3 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h3><p>事务相关的语句如下：</p>
<ul>
<li><code>BEGIN</code> &#x2F; <code>START TRANSACTION</code> - <strong>用于标记事务的起始点</strong>。</li>
<li><code>START TRANSACTION WITH CONSISTENT SNAPSHOT</code> - <strong>用于标记事务的起始点</strong>。</li>
<li><code>SAVEPOINT</code> - <strong>用于创建保存点</strong>。方便后续针对保存点进行回滚。一个事务中可以存在多个保存点。</li>
<li><code>RELEASE SAVEPOINT</code> - 删除某个保存点。</li>
<li><code>ROLLBACK TO</code> - <strong>用于回滚到指定的保存点</strong>。如果没有设置保存点，则回退到 <code>START TRANSACTION</code> 语句处。</li>
<li><code>COMMIT</code> - <strong>提交事务</strong>。</li>
<li><code>SET TRANSACTION</code> - 设置事务的隔离级别。</li>
</ul>
<blockquote>
<p>注意：</p>
<p>两种开启事务的命令，启动时机是不同的：</p>
<ul>
<li>执行了 <code>BEGIN</code> &#x2F; <code>START TRANSACTION</code> 命令后，并不代表事务立刻启动，而是当执行了增删查操作时，才真正启动事务。</li>
<li>执行了 <code>START TRANSACTION WITH CONSISTENT SNAPSHOT</code> 命令，会立刻启动事务。</li>
</ul>
</blockquote>
<p>事务处理示例：</p>
<p>（1）创建一张示例表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 撤销表 user</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `<span class="keyword">user</span>`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建表 user</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">	`id` <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;Id&#x27;</span>,</span><br><span class="line">	`username` <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;default&#x27;</span> COMMENT <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">	`password` <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;default&#x27;</span> COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">	`email` <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;default&#x27;</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span></span><br><span class="line">) COMMENT <span class="operator">=</span><span class="string">&#x27;用户表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>（2）执行事务操作</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开始事务</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入操作 A</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>`</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;root1&#x27;</span>, <span class="string">&#x27;root1&#x27;</span>, <span class="string">&#x27;xxxx@163.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建保留点 updateA</span></span><br><span class="line"><span class="keyword">SAVEPOINT</span> `updateA`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入操作 B</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>`</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;root2&#x27;</span>, <span class="string">&#x27;root2&#x27;</span>, <span class="string">&#x27;xxxx@163.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 回滚到保留点 updateA</span></span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> `updateA`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提交事务，只有操作 A 生效</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>（3）查询结果</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `<span class="keyword">user</span>`;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+--------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> username <span class="operator">|</span> password <span class="operator">|</span> email        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+--------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> root1    <span class="operator">|</span> root1    <span class="operator">|</span> xxxx<span class="variable">@163</span>.com <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+----------+--------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure>

<h3 id="AUTOCOMMIT"><a href="#AUTOCOMMIT" class="headerlink" title="AUTOCOMMIT"></a>AUTOCOMMIT</h3><p><strong>MySQL 默认采用隐式提交策略（<code>autocommit</code>）</strong>。每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 <code>START TRANSACTION</code> 语句时，会关闭隐式提交；当 <code>COMMIT</code> 或 <code>ROLLBACK</code> 语句执行后，事务会自动关闭，重新恢复隐式提交。</p>
<p>通过 <code>set autocommit=0</code> 可以取消自动提交，直到 <code>set autocommit=1</code> 才会提交；<code>autocommit</code> 标记是针对每个连接而不是针对服务器的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看 AUTOCOMMIT</span></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;AUTOCOMMIT&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 关闭 AUTOCOMMIT</span></span><br><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 开启 AUTOCOMMIT</span></span><br><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h2 id="并发一致性问题"><a href="#并发一致性问题" class="headerlink" title="并发一致性问题"></a>并发一致性问题</h2><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p>
<h3 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h3><p><strong>“丢失修改”是指一个事务的更新操作被另外一个事务的更新操作替换</strong>。</p>
<p>如下图所示，T<sub>1</sub> 和 T<sub>2</sub> 两个事务对同一个数据进行修改，T<sub>1</sub> 先修改，T<sub>2</sub> 随后修改，T<sub>2</sub> 的修改覆盖了 T<sub>1</sub> 的修改。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202311030706586.png"></p>
<h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p><strong>“脏读（dirty read）”是指当前事务可以读取其他事务未提交的数据</strong>。</p>
<p>如下图所示，T<sub>1</sub> 修改一个数据，T<sub>2</sub> 随后读取这个数据。如果 T<sub>1</sub> 撤销了这次修改，那么 T<sub>2</sub> 读取的数据是脏数据。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202311030706587.png"></p>
<h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p><strong>“不可重复读（non-repeatable read）”是指一个事务内多次读取同一数据，过程中，该数据被其他事务所修改，导致当前事务多次读取的数据可能不一致</strong>。</p>
<p>如下图所示，T<sub>2</sub> 读取一个数据，T<sub>1</sub> 对该数据做了修改。如果 T<sub>2</sub> 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202311030706588.png"></p>
<h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p><strong>“幻读（phantom read）”是指一个事务内多次读取同一范围的数据，过程中，其他事务在该数据范围新增了数据，导致当前事务未发现新增数据</strong>。</p>
<p>事务 T<sub>1</sub> 读取某个范围内的记录时，事务 T<sub>2</sub> 在该范围内插入了新的记录，T<sub>1</sub> 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202311030706589.png"></p>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><h3 id="事务隔离级别简介"><a href="#事务隔离级别简介" class="headerlink" title="事务隔离级别简介"></a>事务隔离级别简介</h3><p>为了解决以上提到的<a href="#%E5%B9%B6%E5%8F%91%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98">“并发一致性问题”</a>，SQL 标准提出了四种“事务隔离级别”来应对这些问题。事务隔离级别等级越高，越能保证数据的一致性和完整性，但是执行效率也越低。因此，设置数据库的事务隔离级别时需要做一下权衡。</p>
<p>事务隔离级别从低到高分别是：</p>
<ul>
<li><strong>“读未提交（read uncommitted）”</strong> - 是指，<strong>事务中的修改，即使没有提交，对其它事务也是可见的</strong>。</li>
<li><strong>“读已提交（read committed）” ** - 是指，</strong>事务提交后，其他事务才能看到它的修改**。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。<ul>
<li><strong>读已提交解决了脏读的问题</strong>。</li>
<li>读已提交是大多数数据库的默认事务隔离级别，如 Oracle。</li>
</ul>
</li>
<li><strong>“可重复读（repeatable read）”</strong> - 是指：<strong>保证在同一个事务中多次读取同样数据的结果是一样的</strong>。<ul>
<li><strong>可重复读解决了不可重复读问题</strong>。</li>
<li><strong>可重复读是 InnoDB 存储引擎的默认事务隔离级别</strong>。</li>
</ul>
</li>
<li><strong>串行化（serializable ）</strong> - 是指，<strong>强制事务串行执行</strong>，对于同一行记录，加读写锁，一旦出现锁冲突，必须等前面的事务释放锁。<ul>
<li><strong>串行化解决了幻读问题</strong>。由于强制事务串行执行，自然避免了所有的并发问题。</li>
<li><strong>串行化策略会在读取的每一行数据上都加锁</strong>，这可能导致大量的超时和锁竞争。这对于高并发应用基本上是不可接受的，所以一般不会采用这个级别。</li>
</ul>
</li>
</ul>
<p>事务隔离级别对并发一致性问题的解决情况：</p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">丢失修改</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">读未提交</td>
<td align="center">✔️️️</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">❌</td>
</tr>
<tr>
<td align="center">读已提交</td>
<td align="center">✔️️️</td>
<td align="center">✔️️️</td>
<td align="center">❌</td>
<td align="center">❌</td>
</tr>
<tr>
<td align="center">可重复读</td>
<td align="center">✔️️️</td>
<td align="center">✔️️️</td>
<td align="center">✔️️️</td>
<td align="center">❌</td>
</tr>
<tr>
<td align="center">可串行化</td>
<td align="center">✔️️️</td>
<td align="center">✔️️️</td>
<td align="center">✔️️️</td>
<td align="center">✔️️️</td>
</tr>
</tbody></table>
<h3 id="查看和设置事务隔离级别"><a href="#查看和设置事务隔离级别" class="headerlink" title="查看和设置事务隔离级别"></a>查看和设置事务隔离级别</h3><p>可以通过 <code>SHOW VARIABLES LIKE &#39;transaction_isolation&#39;</code> 语句查看事务隔离级别。</p>
<p>【示例】查看事务隔离示例</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;transaction_isolation&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name         <span class="operator">|</span> <span class="keyword">Value</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> transaction_isolation <span class="operator">|</span> REPEATABLE<span class="operator">-</span>READ <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-----------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.03</span> sec)</span><br></pre></td></tr></table></figure>

<p>MySQL 提供了 <code>SET TRANSACTION</code> 语句，该语句可以改变单个会话或全局的事务隔离级别。语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> [SESSION <span class="operator">|</span> <span class="keyword">GLOBAL</span>] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED <span class="operator">|</span> READ COMMITTED <span class="operator">|</span> REPEATABLE READ <span class="operator">|</span> SERIALIZABLE&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>SESSION</code> 和 <code>GLOBAL</code> 关键字用来指定修改的事务隔离级别的范围：</p>
<ul>
<li><code>SESSION</code> - 表示修改的事务隔离级别，将应用于当前会话内的所有事务。</li>
<li><code>GLOBAL</code> - 表示修改的事务隔离级别，将应用于所有会话内的所有事务（即全局修改），且当前已经存在的会话不受影响；</li>
<li>如果省略 <code>SESSION</code> 和 <code>GLOBAL</code>，表示修改的事务隔离级别，将应用于当前会话内的下一个还未开始的事务。</li>
</ul>
<p>【示例】设置事务隔离示例</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置事务隔离级别为 READ UNCOMMITTED</span></span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置事务隔离级别为 READ COMMITTED</span></span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置事务隔离级别为 REPEATABLE READ</span></span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置事务隔离级别为 SERIALIZABLE</span></span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br></pre></td></tr></table></figure>

<h3 id="事务隔离级别实现方式"><a href="#事务隔离级别实现方式" class="headerlink" title="事务隔离级别实现方式"></a>事务隔离级别实现方式</h3><p>Mysql 中的事务功能是在存储引擎层实现的，<strong>并非所有存储引擎都支持事务功能</strong>。InnoDB 是 Mysql 的首先事务存储引擎。</p>
<p>四种隔离级别具体是如何实现的呢？</p>
<p>以 InnoDB 的事务实现来说明：</p>
<ul>
<li>对于“读未提交”隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；</li>
<li>对于“串行化”隔离级别的事务来说，通过加读写锁的方式来避免并行访问；</li>
<li>对于“读提交”和“可重复读”隔离级别的事务来说，它们都是通过 ReadView 来实现的，区别仅在于创建 ReadView 的时机不同。ReadView 可以理解为一个数据快照。<ul>
<li>“读提交”隔离级别是在“每个语句执行前”都会重新生成一个 ReadView</li>
<li>“可重复读”隔离级别是在“启动事务时”生成一个 ReadView，然后整个事务期间都在用这个 ReadView。</li>
</ul>
</li>
</ul>
<blockquote>
<p>关于 ReadView 更多细节，将在 MVCC 章节中阐述。</p>
</blockquote>
<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><h3 id="当前读和快照读"><a href="#当前读和快照读" class="headerlink" title="当前读和快照读"></a>当前读和快照读</h3><p>在高并发场景下，多事务同时执行，可能会出现种种并发一致性问题。最常见，也是最容易想到的解决问题思路就是：对访问的数据加锁，通过强制互斥来解决问题。但是，加锁就意味着阻塞，势必会增加响应时间，降低系统整体吞吐量。在大多数真实的业务场景中，读请求远大于写请求，由于读请求并不会修改数据，自然也不存在一致性问题，因此为占大多数的读请求加锁是一种不必要的开销。那么，我们很自然的会想到，如果只针对写操作加锁，不就能大大提升吞吐量了吗？没错，有一种名为<strong>“写时复制（Copy-On-Write，简称 COW）”</strong>的技术，正是基于这个想法而设计，并广泛应用于各种软件领域，例如：Java 中的 <code>CopyOnWriteArrayList</code> 等容器；Redis 中的 RDB 持久化过程。</p>
<p>Copy-On-Write 的核心思想是：假设有多个请求需要访问相同的数据，先为这份数据生成一个副本（也可以称为快照）。然后将读写分离，所有的读请求都直接访问原数据；所有的写请求都访问副本数据，为了实现并发一致性，写数据时需要通过加锁保证每次写操作只能由一个写请求完成。当写操作完成后，用副本数据替换原数据。</p>
<p>在 Mysql 中，也采用了 Copy-On-Write 设计思想，将读写分离。</p>
<ul>
<li>这里的“写”指的是当前读。<strong>“当前读”，顾名思义，指的是读取记录当前的数据。</strong>为了保证读取当前数据时，没有其他事务修改，因此需要对读取记录加锁。当前读的场景有下面几种：<ul>
<li><code>INSERT</code> - 插入操作</li>
<li><code>UPDATE</code> - 更新操作</li>
<li><code>DELETE</code> - 删除操作</li>
<li><code>SELECT ... LOCK IN SHARE MODE</code> - 加共享锁（读锁）</li>
<li><code>SELECT ... FOR UPDATE</code> - 加独享锁（写锁）</li>
</ul>
</li>
<li>这里的“读”指的是快照读。<strong>“快照读”，顾名思义，指的是读取记录的某个历史快照版本</strong>。不加锁的普通 <code>SELECT</code> 都属于快照读，例如：<code>SELECT ... FROM</code>。采用快照读的前提是，事务隔离级别不是串行化级别。串行化级别下的快照读会退化成当前读。快照读的实现是基于 MVCC。</li>
</ul>
<h3 id="什么是-MVCC"><a href="#什么是-MVCC" class="headerlink" title="什么是 MVCC"></a>什么是 MVCC</h3><blockquote>
<p>前文提到，快照读的实现是基于 MVCC。那么，什么是 MVCC 呢？</p>
</blockquote>
<p><strong>MVCC 是 Multi Version Concurrency Control 的缩写，即“多版本并发控制”</strong>。MVCC 的设计目标是提高数据库的并发性，采用非阻塞的方式去处理读&#x2F;写并发冲突，可以将其看成一种乐观锁。</p>
<p>不仅是 Mysql，包括 Oracle、PostgreSQL 等其他关系型数据库都实现了各自的 MVCC，实现机制没有统一标准。<strong>MVCC 是 InnoDB 存储引擎实现事务隔离级别的一种具体方式</strong>。其主要用于实现读已提交和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p>
<h3 id="MVCC-实现原理"><a href="#MVCC-实现原理" class="headerlink" title="MVCC 实现原理"></a>MVCC 实现原理</h3><p>MVCC 的实现原理，主要基于隐式字段、UndoLog、ReadView 来实现。</p>
<h4 id="隐式字段"><a href="#隐式字段" class="headerlink" title="隐式字段"></a>隐式字段</h4><p>InnoDB 存储引擎中，数据表的每行记录，除了用户显示定义的字段以外，还有几个数据库隐式定义的字段：</p>
<ul>
<li><code>DB_ROW_ID</code> - <strong>隐藏的自增 ID</strong>，如果数据表没有指定主键，InnoDB 会自动基于 <code>row_id</code> 产生一个聚簇索引。</li>
<li><code>DB_TRX_ID</code> - <strong>最近修改的事务 ID</strong>。事务对某条聚簇索引记录进行改动时，就会把该事务的事务 id 记录在 trx_id 隐藏列里；</li>
<li><code>DB_ROLL_PTR</code> - <strong>回滚指针</strong>，指向这条记录的上一个版本。</li>
</ul>
<h4 id="UndoLog"><a href="#UndoLog" class="headerlink" title="UndoLog"></a>UndoLog</h4><p>MVCC 的多版本指的是多个版本的快照，快照存储在 UndoLog 中。该日志通过回滚指针 <code>roll_pointer</code> 把一个数据行的所有快照链接起来，构成一个<strong>版本链</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202311030708591.png"></p>
<h4 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h4><p><strong>ReadView 就是事务进行快照读时产生的读视图（快照）</strong>。</p>
<p>ReadView 有四个重要的字段：</p>
<ul>
<li><code>m_ids</code> - 指的是在创建 ReadView 时，当前数据库中“活跃事务”的事务 ID 列表。注意：这是一个列表，<strong>“活跃事务”指的就是，启动了但还没提交的事务</strong>。</li>
<li><code>min_trx_id</code> - 指的是在创建 ReadView 时，当前数据库中“活跃事务”中事务 id 最小的事务，也就是 <code>m_ids</code> 的最小值。</li>
<li><code>max_trx_id</code> - 这个并不是 m_ids 的最大值，而是指创建 ReadView 时当前数据库中应该给下一个事务分配的 ID 值，也就是全局事务中最大的事务 ID 值 + 1；</li>
<li><code>creator_trx_id</code> - 指的是创建该 ReadView 的事务的事务 ID。</li>
</ul>
<p>在创建 ReadView 后，我们可以将记录中的 trx_id 划分为三种情况：</p>
<ul>
<li>已提交事务</li>
<li>已启动但未提交的事务</li>
<li>未启动的事务</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202311030708265.png"></p>
<blockquote>
<p>ReadView 如何判断版本链中哪个版本可见？</p>
</blockquote>
<p>一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：</p>
<ul>
<li><code>trx_id == creator_trx_id</code> - 表示 <code>trx_id</code> 版本记录由 ReadView 所代表的当前事务产生，当然可以访问。</li>
<li><code>trx_id &lt; min_trx_id</code> - 表示 <code>trx_id</code> 版本记录是在创建 ReadView 之前已提交的事务生成的，当前事务可以访问。</li>
<li><code>trx_id &gt;= max_trx_id</code> - 表示 <code>trx_id</code> 版本记录是在创建 ReadView 之后才启动的事务生成的，当前事务不可以访问。</li>
<li><code>min_trx_id &lt;= trx_id &lt; max_trx_id</code> - 需要判断 <code>trx_id</code> 是否在 <code>m_ids</code> 列表中<ul>
<li>如果 <code>trx_id</code> 在 <code>m_ids</code> 列表中，表示生成 <code>trx_id</code> 版本记录的事务依然活跃（未提交事务），当前事务不可以访问。</li>
<li>如果 <code>trx_id</code> 不在 <code>m_ids</code> 列表中，表示生成 <code>trx_id</code> 版本记录的事务已提交，当前事务可以访问。</li>
</ul>
</li>
</ul>
<p>这种通过“版本链”来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）。</p>
<h3 id="MVCC-如何实现多种事务隔离级别"><a href="#MVCC-如何实现多种事务隔离级别" class="headerlink" title="MVCC 如何实现多种事务隔离级别"></a>MVCC 如何实现多种事务隔离级别</h3><p>对于“读已提交”和“可重复读”隔离级别的事务来说，它们都是通过 MVCC 的 ReadView 机制来实现的，区别仅在于创建 ReadView 的时机不同。ReadView 可以理解为一个数据快照。</p>
<ul>
<li>“读已提交”隔离级别，会在“每个语句执行前”都会重新生成一个 ReadView。</li>
<li>“可重复读”隔离级别，会在“启动事务时”生成一个 ReadView，然后整个事务期间都在复用这个 ReadView。</li>
</ul>
<p>MySQL InnoDB 引擎的默认隔离级别虽然是“可重复读”，但是它很大程度上避免幻读现象（并不是完全解决了），解决的方案有两种：</p>
<ul>
<li>针对<strong>快照读</strong>（普通 select 语句），<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li>
<li>针对<strong>当前读</strong>（select … for update 等语句），<strong>通过 Next-Key Lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select … for update 语句的时候，会加上 Next-Key Lock，如果有其他事务在 Next-Key Lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</li>
</ul>
<h4 id="MVCC-实现可重复读"><a href="#MVCC-实现可重复读" class="headerlink" title="MVCC 实现可重复读"></a>MVCC 实现可重复读</h4><p><strong>可重复读隔离级别只有在启动事务时才会创建 ReadView，然后整个事务期间都使用这个 ReadView</strong>。这样就保证了在事务期间读到的数据都是事务启动前的记录。</p>
<p>举个例子，假设有两个事务依次执行以下操作：</p>
<ul>
<li>初始，表中 id &#x3D; 1 的 value 列值为 100。</li>
<li>事务 2 读取数据，value 为 100；</li>
<li>事务 1 将 value 设为 200；</li>
<li>事务 2 读取数据，value 为 100；</li>
<li>事务 1 提交事务；</li>
<li>事务 2 读取数据，value 依旧为 100；</li>
</ul>
<p>以上操作，如下图所示。T2 事务在事务过程中，是否可以看到 T1 事务的修改，可以根据 <a href="#ReadView">ReadView</a> 中描述的规则去判断。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202311030709235.png"></p>
<p>从图中不难看出：</p>
<ul>
<li>对于 <code>trx_id = 100</code> 的版本记录，比对 T2 事务 ReadView ，<code>trx_id &lt; min_trx_id</code>，因此在 T2 事务中的任意时刻都可见；</li>
<li>对于 <code>trx_id = 101</code> 的版本记录，比对 T2 事务 ReadView ，可以看出 <code>min_trx_id &lt;= trx_id &lt; max_trx_id</code> ，且 <code>trx_id</code> 在 <code>m_ids</code> 中，因此 T2 事务中不可见。</li>
</ul>
<p>综上所述，在 T2 事务中，自始至终只能看到 <code>trx_id = 100</code> 的版本记录。</p>
<h4 id="MVCC-实现读已提交"><a href="#MVCC-实现读已提交" class="headerlink" title="MVCC 实现读已提交"></a>MVCC 实现读已提交</h4><p><strong>读已提交隔离级别每次读取数据时都会创建一个 ReadView</strong>。这意味着，事务期间的多次读取同一条数据，前后读取的数据可能会出现不一致——因为，这期间可能有另外一个事务修改了该记录，并提交了事务。</p>
<p>举个例子，假设有两个事务依次执行以下操作：</p>
<ul>
<li>初始，表中 id &#x3D; 1 的 value 列值为 100。</li>
<li>事务 2 读取数据（创建 ReadView），value 为 0；</li>
<li>事务 1 将 value 设为 100；</li>
<li>事务 2 读取数据（创建 ReadView），value 为 0；</li>
<li>事务 1 提交事务；</li>
<li>事务 2 读取数据（创建 ReadView），value 为 100；</li>
</ul>
<p>以上操作，如下图所示，T2 事务在事务过程中，是否可以看到其他事务的修改，可以根据 <a href="#ReadView">ReadView</a> 中描述的规则去判断。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202311030709986.png"></p>
<p>从图中不难看出：</p>
<ul>
<li>对于 <code>trx_id = 100</code> 的版本记录，比对 T2 事务 ReadView ，<code>trx_id &lt; min_trx_id</code>，因此在 T2 事务中的任意时刻都可见；</li>
<li>对于 <code>trx_id = 101</code> 的版本记录，比对 T2 事务 ReadView ，可以看出第二次查询时（T1 更新未提交），<code>min_trx_id &lt;= trx_id &lt; max_trx_id</code> ，且 <code>trx_id</code> 在 <code>m_ids</code> 中，因此 T2 事务中不可见；而第三次查询时（T1 更新已提交），<code>trx_id &lt; min_trx_id</code>，因此在 T2 事务中可见；</li>
</ul>
<p>综上所述，在 T2 事务中，当 T1 事务提交前，可读取到的是 <code>trx_id = 100</code> 的版本记录；当 T1 事务提交后，可读取到的是 <code>trx_id = 101</code> 的版本记录。</p>
<h4 id="MVCC-Next-Key-Lock-解决幻读"><a href="#MVCC-Next-Key-Lock-解决幻读" class="headerlink" title="MVCC + Next-Key Lock 解决幻读"></a>MVCC + Next-Key Lock 解决幻读</h4><p>MySQL InnoDB 引擎的默认隔离级别虽然是“可重复读”，但是它很大程度上避免幻读现象（并不是完全解决了）。针对快照读和当前读，InnoDB 的处理方式各不相同。</p>
<blockquote>
<p>快照读是如何避免幻读的？</p>
</blockquote>
<p>针对<strong>快照读</strong>（普通 <code>SELECT</code> 语句），<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</p>
<blockquote>
<p>当前读是如何避免幻读的？</p>
</blockquote>
<p>针对<strong>当前读</strong>（<code>SELECT ... FOR UPDATE</code> 等语句），<strong>通过 Next-Key Lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 <code>SELECT ... FOR UPDATE</code> 语句的时候，会加上 Next-Key Lock，如果有其他事务在 Next-Key Lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好的避免了幻读问题。</p>
<blockquote>
<p>幻读被完全解决了吗？</p>
</blockquote>
<p><strong>可重复读隔离级别下虽然很大程度上避免了幻读，但是还是没有能完全解决幻读</strong>。</p>
<p>【示例】幻读案例一</p>
<p>环境：存储引擎为 InnoDB；事务隔离级别为可重复读</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- --------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">-- 实验说明：以下 SQL 脚本必须严格按照顺序执行，并且事务 A 和事务 B 必须在不同的 Client 中执行。</span></span><br><span class="line"><span class="comment">-- ----------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- --------------------------------------------------------------------- （1）数据初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建表 test</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `test` (</span><br><span class="line">	`id` <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">	`<span class="keyword">value</span>` <span class="type">INT</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 数据初始化</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `<span class="keyword">value</span>`) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `<span class="keyword">value</span>`) <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `<span class="keyword">value</span>`) <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- --------------------------------------------------------------------- （2）事务 A</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询 id = 4 的记录</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test` <span class="keyword">WHERE</span> `id` <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="comment">-- 结果为空</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- --------------------------------------------------------------------- （3）事务 B</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `<span class="keyword">value</span>`) <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- --------------------------------------------------------------------- （4）事务 A</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询 id = 4 的记录</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test` <span class="keyword">WHERE</span> `id` <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="comment">-- 结果依然为空</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 成功更新本应看不到的记录 id = 4</span></span><br><span class="line"><span class="keyword">UPDATE</span> `test` <span class="keyword">SET</span> `<span class="keyword">value</span>` <span class="operator">=</span> <span class="number">0</span> <span class="keyword">WHERE</span> `id` <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 再一次查询 id = 4 的记录</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test` <span class="keyword">WHERE</span> `id` <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="comment">-- 结果为：</span></span><br><span class="line"><span class="comment">-- +----+-------+</span></span><br><span class="line"><span class="comment">-- | id | value |</span></span><br><span class="line"><span class="comment">-- +----+-------+</span></span><br><span class="line"><span class="comment">-- |  4 |     0 |</span></span><br><span class="line"><span class="comment">-- +----+-------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>以上示例代码的时序图如下：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202311070630072.png"></p>
<p>【示例】幻读案例二</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- --------------------------------------------------------------------- （1）数据初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建表 test</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `test` (</span><br><span class="line">	`id` <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">	`<span class="keyword">value</span>` <span class="type">INT</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 数据初始化</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `<span class="keyword">value</span>`) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `<span class="keyword">value</span>`) <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `<span class="keyword">value</span>`) <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- --------------------------------------------------------------------- （2）事务 A</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询 id &gt; 2 的记录数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> `test` <span class="keyword">WHERE</span> `id` <span class="operator">&gt;</span> <span class="number">2</span>;</span><br><span class="line"><span class="comment">-- 结果为：</span></span><br><span class="line"><span class="comment">-- +----------+</span></span><br><span class="line"><span class="comment">-- | count(*) |</span></span><br><span class="line"><span class="comment">-- +----------+</span></span><br><span class="line"><span class="comment">-- |        1 |</span></span><br><span class="line"><span class="comment">-- +----------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- --------------------------------------------------------------------- （3）事务 B</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test` (`id`, `<span class="keyword">value</span>`) <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- --------------------------------------------------------------------- （4）事务 A</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询 id &gt; 2 的记录数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> `test` <span class="keyword">WHERE</span> `id` <span class="operator">&gt;</span> <span class="number">2</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="comment">-- 结果为：</span></span><br><span class="line"><span class="comment">-- +----------+</span></span><br><span class="line"><span class="comment">-- | count(*) |</span></span><br><span class="line"><span class="comment">-- +----------+</span></span><br><span class="line"><span class="comment">-- |        2 |</span></span><br><span class="line"><span class="comment">-- +----------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p><strong>要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 <code>select ... for update</code> 这类当前读的语句</strong>，因为它会对记录加 Next-Key Lock，从而避免其他事务插入一条新记录。</p>
<h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p>在单一数据节点中，事务仅限于对单一数据库资源的访问控制，称之为 <strong>本地事务</strong>。几乎所有的成熟的关系型数据库都提供了对本地事务的原生支持。</p>
<p><strong>分布式事务指的是事务操作跨越多个节点，并且要求满足事务的 ACID 特性。</strong></p>
<p>分布式事务的常见方案如下：</p>
<ul>
<li><strong>两阶段提交（2PC）</strong> - 将事务的提交过程分为两个阶段来进行处理：准备阶段和提交阶段。参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。</li>
<li><strong>三阶段提交（3PC）</strong> - 与二阶段提交不同的是，引入超时机制。同时在协调者和参与者中都引入超时机制。将二阶段的准备阶段拆分为 2 个阶段，插入了一个 preCommit 阶段，使得原先在二阶段提交中，参与者在准备之后，由于协调者发生崩溃或错误，而导致参与者处于无法知晓是否提交或者中止的“不确定状态”所产生的可能相当长的延时的问题得以解决。</li>
<li><strong>补偿事务（TCC）</strong><ul>
<li><strong>Try</strong> - 操作作为一阶段，负责资源的检查和预留。</li>
<li><strong>Confirm</strong> - 操作作为二阶段提交操作，执行真正的业务。</li>
<li><strong>Cancel</strong> - 是预留资源的取消。</li>
</ul>
</li>
<li><strong>本地消息表</strong> - 在事务主动发起方额外新建事务消息表，事务发起方处理业务和记录事务消息在本地事务中完成，轮询事务消息表的数据发送事务消息，事务被动方基于消息中间件消费事务消息表中的事务。</li>
<li><strong>MQ 事务</strong> - 基于 MQ 的分布式事务方案其实是对本地消息表的封装。</li>
<li><strong>SAGA</strong> - Saga 事务核心思想是将长事务拆分为多个本地短事务，由 Saga 事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。</li>
</ul>
<p>分布式事务方案分析：</p>
<ul>
<li>2PC&#x2F;3PC 依赖于数据库，能够很好的提供强一致性和强事务性，但相对来说延迟比较高，比较适合传统的单体应用，在同一个方法中存在跨库操作的情况，不适合高并发和高性能要求的场景。</li>
<li>TCC 适用于执行时间确定且较短，实时性要求高，对数据一致性要求高，比如互联网金融企业最核心的三个服务：交易、支付、账务。</li>
<li>本地消息表&#x2F;MQ 事务 都适用于事务中参与方支持操作幂等，对一致性要求不高，业务上能容忍数据不一致到一个人工检查周期，事务涉及的参与方、参与环节较少，业务上有对账&#x2F;校验系统兜底。</li>
<li>Saga 事务 由于 Saga 事务不能保证隔离性，需要在业务层控制并发，适合于业务场景事务并发操作同一资源较少的情况。 Saga 相比缺少预提交动作，导致补偿动作的实现比较麻烦，例如业务是发送短信，补偿动作则得再发送一次短信说明撤销，用户体验比较差。Saga 事务较适用于补偿动作容易处理的场景。</li>
</ul>
<blockquote>
<p>分布式事务详细说明、分析请参考：<a target="_blank" rel="noopener" href="https://dunwu.github.io/waterdrop/pages/e1881c/">分布式事务基本原理</a></p>
</blockquote>
<h2 id="事务最佳实践"><a href="#事务最佳实践" class="headerlink" title="事务最佳实践"></a>事务最佳实践</h2><p>高并发场景下的事务到底该如何调优？</p>
<h3 id="尽量使用低级别事务隔离"><a href="#尽量使用低级别事务隔离" class="headerlink" title="尽量使用低级别事务隔离"></a>尽量使用低级别事务隔离</h3><p>结合业务场景，尽量使用低级别事务隔离</p>
<h3 id="避免行锁升级表锁"><a href="#避免行锁升级表锁" class="headerlink" title="避免行锁升级表锁"></a>避免行锁升级表锁</h3><p>在 InnoDB 中，行锁是通过索引实现的，如果不通过索引条件检索数据，行锁将会升级到表锁。我们知道，表锁是会严重影响到整张表的操作性能的，所以应该尽力避免。</p>
<h3 id="缩小事务范围"><a href="#缩小事务范围" class="headerlink" title="缩小事务范围"></a>缩小事务范围</h3><p>有时候，数据库并发访问量太大，会出现以下异常：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MySQLQueryInterruptedException: Query execution was <span class="built_in">int</span>errupted</span><br></pre></td></tr></table></figure>

<p>高并发时对一条记录进行更新的情况下，由于更新记录所在的事务还可能存在其他操作，导致一个事务比较长，当有大量请求进入时，就可能导致一些请求同时进入到事务中。</p>
<p>又因为锁的竞争是不公平的，当多个事务同时对一条记录进行更新时，极端情况下，一个更新操作进去排队系统后，可能会一直拿不到锁，最后因超时被系统打断踢出。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200630112600.png" alt="img"></p>
<p>如上图中的操作，虽然都是在一个事务中，但锁的申请在不同时间，只有当其他操作都执行完，才会释放所有锁。因为扣除库存是更新操作，属于行锁，这将会影响到其他操作该数据的事务，所以我们应该尽量避免长时间地持有该锁，尽快释放该锁。又因为先新建订单和先扣除库存都不会影响业务，所以我们可以将扣除库存操作放到最后，也就是使用执行顺序 1，以此尽量减小锁的持有时间。</p>
<p><strong>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</strong></p>
<p>知道了这个设定，对我们使用事务有什么帮助呢？那就是，如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/23008813/">《高性能 MySQL》</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/139">MySQL 实战 45 讲</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/25/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><span class="page-number current">26</span><a class="page-number" href="/page/27/">27</a><span class="space">&hellip;</span><a class="page-number" href="/page/47/">47</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/27/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备2021160229号 </a>
  </div>
  <div class="copyright">
    &copy; 2015 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">李狗蛋</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">3.5m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">53:28</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/yiyirushi/" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.1/dist/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  




<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>

</body>
</html>
