<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/uploads/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/uploads/favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.ligoudan.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="天气不错哇，你看这大冰雹下得">
<meta property="og:type" content="website">
<meta property="og:title" content="LIGOUDAN">
<meta property="og:url" content="https://www.ligoudan.cn/page/14/index.html">
<meta property="og:site_name" content="LIGOUDAN">
<meta property="og:description" content="天气不错哇，你看这大冰雹下得">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="李狗蛋">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://www.ligoudan.cn/page/14/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/14/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>LIGOUDAN</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">LIGOUDAN</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">好好学习，天天向上</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">326</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">137</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">462</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="李狗蛋"
      src="/uploads/ligoudan.png">
  <p class="site-author-name" itemprop="name">李狗蛋</p>
  <div class="site-description" itemprop="description">天气不错哇，你看这大冰雹下得</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">462</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">137</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">326</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/yiyirushi" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yiyirushi" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yuanhaohoo@163.com" title="E-Mail → mailto:yuanhaohoo@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/13f070/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/13f070/" class="post-title-link" itemprop="url">Tomcat连接器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-17 22:34:30" itemprop="dateCreated datePublished" datetime="2022-02-17T22:34:30+08:00">2022-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JavaEE/" itemprop="url" rel="index"><span itemprop="name">JavaEE</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JavaEE/%E6%9C%8D%E5%8A%A1%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">服务器</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JavaEE/%E6%9C%8D%E5%8A%A1%E5%99%A8/Tomcat/" itemprop="url" rel="index"><span itemprop="name">Tomcat</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>18k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>16 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Tomcat-连接器"><a href="#Tomcat-连接器" class="headerlink" title="Tomcat 连接器"></a>Tomcat 连接器</h1><h2 id="1-NioEndpoint-组件"><a href="#1-NioEndpoint-组件" class="headerlink" title="1. NioEndpoint 组件"></a>1. NioEndpoint 组件</h2><p>Tomcat 的 NioEndPoint 组件利用 Java NIO 实现了 I&#x2F;O 多路复用模型。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20201127094302.jpg" alt="img"></p>
<p>NioEndPoint 子组件功能简介：</p>
<ul>
<li><code>LimitLatch</code> 是连接控制器，负责控制最大连接数。NIO 模式下默认是 10000，达到这个阈值后，连接请求被拒绝。</li>
<li><code>Acceptor</code> 负责监听连接请求。<code>Acceptor</code> 运行在一个单独的线程里，它在一个死循环里调用 accept 方法来接收新连接，一旦有新的连接请求到来，accept 方法返回一个 <code>Channel</code> 对象，接着把 <code>Channel</code> 对象交给 <code>Poller</code> 去处理。</li>
<li><code>Poller</code> 的本质是一个 <code>Selector</code>，也运行在单独线程里。<code>Poller</code> 内部维护一个 <code>Channel</code> 数组，它在一个死循环里不断检测 <code>Channel</code> 的数据就绪状态，一旦有 <code>Channel</code> 可读，就生成一个 <code>SocketProcessor</code> 任务对象扔给 <code>Executor</code> 去处理。</li>
<li><code>Executor</code> 就是线程池，负责运行 <code>SocketProcessor</code> 任务类，<code>SocketProcessor</code> 的 run 方法会调用 <code>Http11Processor</code> 来读取和解析请求数据。我们知道，<code>Http11Processor</code> 是应用层协议的封装，它会调用容器获得响应，再把响应通过 <code>Channel</code> 写出。</li>
</ul>
<p>NioEndpoint 如何实现高并发的呢？</p>
<p>要实现高并发需要合理设计线程模型充分利用 CPU 资源，尽量不要让线程阻塞；另外，就是有多少任务，就用相应规模的线程数去处理。</p>
<p>NioEndpoint 要完成三件事情：接收连接、检测 I&#x2F;O 事件以及处理请求，那么最核心的就是把这三件事情分开，用不同规模的线程去处理，比如用专门的线程组去跑 Acceptor，并且 Acceptor 的个数可以配置；用专门的线程组去跑 Poller，Poller 的个数也可以配置；最后具体任务的执行也由专门的线程池来处理，也可以配置线程池的大小。</p>
<h3 id="1-1-LimitLatch"><a href="#1-1-LimitLatch" class="headerlink" title="1.1. LimitLatch"></a>1.1. LimitLatch</h3><p><code>LimitLatch</code> 用来控制连接个数，当连接数到达最大时阻塞线程，直到后续组件处理完一个连接后将连接数减 1。请你注意到达最大连接数后操作系统底层还是会接收客户端连接，但用户层已经不再接收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LimitLatch</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">newCount</span> <span class="operator">=</span> count.incrementAndGet();</span><br><span class="line">            <span class="keyword">if</span> (newCount &gt; limit) &#123;</span><br><span class="line">                count.decrementAndGet();</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">            count.decrementAndGet();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> limit;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程调用这个方法来获得接收新连接的许可，线程可能被阻塞</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countUpOrAwait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用这个方法来释放一个连接许可，那么前面阻塞的线程可能被唤醒</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countDown</span><span class="params">()</span> &#123;</span><br><span class="line">      sync.releaseShared(<span class="number">0</span>);</span><br><span class="line">      <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> getCount();</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LimitLatch 内步定义了内部类 Sync，而 Sync 扩展了 AQS，AQS 是 Java 并发包中的一个核心类，它在内部维护一个状态和一个线程队列，可以用来<strong>控制线程什么时候挂起，什么时候唤醒</strong>。我们可以扩展它来实现自己的同步器，实际上 Java 并发包里的锁和条件变量等等都是通过 AQS 来实现的，而这里的 LimitLatch 也不例外。</p>
<p>理解源码要点：</p>
<ul>
<li>用户线程通过调用 LimitLatch 的 countUpOrAwait 方法来拿到锁，如果暂时无法获取，这个线程会被阻塞到 AQS 的队列中。那 AQS 怎么知道是阻塞还是不阻塞用户线程呢？其实这是由 AQS 的使用者来决定的，也就是内部类 Sync 来决定的，因为 Sync 类重写了 AQS 的<strong>tryAcquireShared() 方法</strong>。它的实现逻辑是如果当前连接数 count 小于 limit，线程能获取锁，返回 1，否则返回 -1。</li>
<li>如何用户线程被阻塞到了 AQS 的队列，那什么时候唤醒呢？同样是由 Sync 内部类决定，Sync 重写了 AQS 的<strong>releaseShared() 方法</strong>，其实就是当一个连接请求处理完了，这时又可以接收一个新连接了，这样前面阻塞的线程将会被唤醒。</li>
</ul>
<h3 id="1-2-Acceptor"><a href="#1-2-Acceptor" class="headerlink" title="1.2. Acceptor"></a>1.2. Acceptor</h3><p>Acceptor 实现了 Runnable 接口，因此可以跑在单独线程里。一个端口号只能对应一个 ServerSocketChannel，因此这个 ServerSocketChannel 是在多个 Acceptor 线程之间共享的，它是 Endpoint 的属性，由 Endpoint 完成初始化和端口绑定。</p>
<figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">serverSock = <span class="type">ServerSocketChannel</span>.open();</span><br><span class="line">serverSock.socket().<span class="keyword">bind</span>(<span class="keyword">addr</span>,getAcceptCount());</span><br><span class="line">serverSock.configureBlocking(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>bind 方法的第二个参数表示操作系统的等待队列长度，我在上面提到，当应用层面的连接数到达最大值时，操作系统可以继续接收连接，那么操作系统能继续接收的最大连接数就是这个队列长度，可以通过 acceptCount 参数配置，默认是 100。</li>
<li>ServerSocketChannel 被设置成阻塞模式，也就是说它是以阻塞的方式接收连接的。ServerSocketChannel 通过 accept() 接受新的连接，accept() 方法返回获得 SocketChannel 对象，然后将 SocketChannel 对象封装在一个 PollerEvent 对象中，并将 PollerEvent 对象压入 Poller 的 Queue 里，这是个典型的生产者 - 消费者模式，Acceptor 与 Poller 线程之间通过 Queue 通信。</li>
</ul>
<h3 id="1-3-Poller"><a href="#1-3-Poller" class="headerlink" title="1.3. Poller"></a>1.3. Poller</h3><p><code>Poller</code> 本质是一个 <code>Selector</code>，它内部维护一个 <code>Queue</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">SynchronizedQueue</span>&lt;<span class="type">PollerEvent</span>&gt; events <span class="operator">=</span> new <span class="type">SynchronizedQueue</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p><code>SynchronizedQueue</code> 的核心方法都使用了 <code>Synchronized</code> 关键字进行修饰，用来保证同一时刻只有一个线程进行读写。</p>
<p>使用 <code>SynchronizedQueue</code>，意味着同一时刻只有一个 <code>Acceptor</code> 线程对队列进行读写；同时有多个 <code>Poller</code> 线程在运行，每个 <code>Poller</code> 线程都有自己的队列。每个 <code>Poller</code> 线程可能同时被多个 <code>Acceptor</code> 线程调用来注册 <code>PollerEvent</code>。同样 <code>Poller</code> 的个数可以通过 pollers 参数配置。</p>
<p><code>Poller</code> 不断的通过内部的 <code>Selector</code> 对象向内核查询 <code>Channel</code> 的状态，一旦可读就生成任务类 <code>SocketProcessor</code> 交给 <code>Executor</code> 去处理。<code>Poller</code> 的另一个重要任务是循环遍历检查自己所管理的 <code>SocketChannel</code> 是否已经超时，如果有超时就关闭这个 <code>SocketChannel</code>。</p>
<h3 id="1-4-SocketProcessor"><a href="#1-4-SocketProcessor" class="headerlink" title="1.4. SocketProcessor"></a>1.4. SocketProcessor</h3><p>我们知道，<code>Poller</code> 会创建 <code>SocketProcessor</code> 任务类交给线程池处理，而 <code>SocketProcessor</code> 实现了 <code>Runnable</code> 接口，用来定义 <code>Executor</code> 中线程所执行的任务，主要就是调用 <code>Http11Processor</code> 组件来处理请求。<code>Http11Processor</code> 读取 <code>Channel</code> 的数据来生成 <code>ServletRequest</code> 对象，这里请你注意：</p>
<p><code>Http11Processor</code> 并不是直接读取 <code>Channel</code> 的。这是因为 Tomcat 支持同步非阻塞 I&#x2F;O 模型和异步 I&#x2F;O 模型，在 Java API 中，相应的 Channel 类也是不一样的，比如有 <code>AsynchronousSocketChannel</code> 和 <code>SocketChannel</code>，为了对 <code>Http11Processor</code> 屏蔽这些差异，Tomcat 设计了一个包装类叫作 <code>SocketWrapper</code>，<code>Http11Processor</code> 只调用 <code>SocketWrapper</code> 的方法去读写数据。</p>
<h2 id="2-Nio2Endpoint-组件"><a href="#2-Nio2Endpoint-组件" class="headerlink" title="2. Nio2Endpoint 组件"></a>2. Nio2Endpoint 组件</h2><p>Nio2Endpoint 工作流程跟 NioEndpoint 较为相似。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20201127143839.jpg" alt="img"></p>
<p>Nio2Endpoint 子组件功能说明：</p>
<ul>
<li><code>LimitLatch</code> 是连接控制器，它负责控制最大连接数。</li>
<li><code>Nio2Acceptor</code> 扩展了 <code>Acceptor</code>，用异步 I&#x2F;O 的方式来接收连接，跑在一个单独的线程里，也是一个线程组。<code>Nio2Acceptor</code> 接收新的连接后，得到一个 <code>AsynchronousSocketChannel</code>，<code>Nio2Acceptor</code> 把 <code>AsynchronousSocketChannel</code> 封装成一个 <code>Nio2SocketWrapper</code>，并创建一个 <code>SocketProcessor</code> 任务类交给线程池处理，并且 <code>SocketProcessor</code> 持有 <code>Nio2SocketWrapper</code> 对象。</li>
<li><code>Executor</code> 在执行 <code>SocketProcessor</code> 时，<code>SocketProcessor</code> 的 run 方法会调用 <code>Http11Processor</code> 来处理请求，<code>Http11Processor</code> 会通过 <code>Nio2SocketWrapper</code> 读取和解析请求数据，请求经过容器处理后，再把响应通过 <code>Nio2SocketWrapper</code> 写出。</li>
</ul>
<p>Nio2Endpoint 跟 NioEndpoint 的一个明显不同点是，<strong>Nio2Endpoint 中没有 Poller 组件，也就是没有 Selector。这是为什么呢？因为在异步 I&#x2F;O 模式下，Selector 的工作交给内核来做了。</strong></p>
<h3 id="2-1-Nio2Acceptor"><a href="#2-1-Nio2Acceptor" class="headerlink" title="2.1. Nio2Acceptor"></a>2.1. Nio2Acceptor</h3><p>和 <code>NioEndpint</code> 一样，<code>Nio2Endpoint</code> 的基本思路是用 <code>LimitLatch</code> 组件来控制连接数。</p>
<p>但是 <code>Nio2Acceptor</code> 的监听连接的过程不是在一个死循环里不断的调 accept 方法，而是通过回调函数来完成的。我们来看看它的连接监听方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serverSock.accept(<span class="literal">null</span>, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>

<p>其实就是调用了 accept 方法，注意它的第二个参数是 this，表明 <code>Nio2Acceptor</code> 自己就是处理连接的回调类，因此 <code>Nio2Acceptor</code> 实现了 <code>CompletionHandler</code> 接口。那么它是如何实现 <code>CompletionHandler</code> 接口的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">class</span> <span class="title class_">Nio2Acceptor</span> <span class="keyword">extends</span> <span class="title class_">Acceptor</span>&lt;AsynchronousSocketChannel&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">CompletionHandler</span>&lt;AsynchronousSocketChannel, Void&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(AsynchronousSocketChannel socket,</span></span><br><span class="line"><span class="params">        Void attachment)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isRunning() &amp;&amp; !isPaused()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getMaxConnections() == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果没有连接限制，继续接收新的连接</span></span><br><span class="line">                serverSock.accept(<span class="literal">null</span>, <span class="built_in">this</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果有连接限制，就在线程池里跑 Run 方法，Run 方法会检查连接数</span></span><br><span class="line">                getExecutor().execute(<span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理请求</span></span><br><span class="line">            <span class="keyword">if</span> (!setSocketOptions(socket)) &#123;</span><br><span class="line">                closeSocket(socket);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>CompletionHandler</code> 的两个模板参数分别是 <code>AsynchronousServerSocketChannel</code> 和 Void，我在前面说过第一个参数就是 <code>accept</code> 方法的返回值，第二个参数是附件类，由用户自己决定，这里为 Void。<code>completed</code> 方法的处理逻辑比较简单：</p>
<ul>
<li>如果没有连接限制，继续在本线程中调用 <code>accept</code> 方法接收新的连接。</li>
<li>如果有连接限制，就在线程池里跑 <code>run</code> 方法去接收新的连接。那为什么要跑 <code>run</code> 方法呢，因为在 <code>run</code> 方法里会检查连接数，当连接达到最大数时，线程可能会被 <code>LimitLatch</code> 阻塞。为什么要放在线程池里跑呢？这是因为如果放在当前线程里执行，<code>completed</code> 方法可能被阻塞，会导致这个回调方法一直不返回。</li>
</ul>
<p>接着 <code>completed</code> 方法会调用 <code>setSocketOptions</code> 方法，在这个方法里，会创建 <code>Nio2SocketWrapper</code> 和 <code>SocketProcessor</code>，并交给线程池处理。</p>
<h3 id="2-2-Nio2SocketWrapper"><a href="#2-2-Nio2SocketWrapper" class="headerlink" title="2.2. Nio2SocketWrapper"></a>2.2. Nio2SocketWrapper</h3><p><code>Nio2SocketWrapper</code> 的主要作用是封装 Channel，并提供接口给 <code>Http11Processor</code> 读写数据。讲到这里你是不是有个疑问：<code>Http11Processor</code> 是不能阻塞等待数据的，按照异步 I&#x2F;O 的套路，<code>Http11Processor</code> 在调用 <code>Nio2SocketWrapper</code> 的 read 方法时需要注册回调类，read 调用会立即返回，问题是立即返回后 <code>Http11Processor</code> 还没有读到数据， 怎么办呢？这个请求的处理不就失败了吗？</p>
<p>为了解决这个问题，<code>Http11Processor</code> 是通过 2 次 read 调用来完成数据读取操作的。</p>
<ul>
<li>第一次 read 调用：连接刚刚建立好后，<code>Acceptor</code> 创建 <code>SocketProcessor</code> 任务类交给线程池去处理，<code>Http11Processor</code> 在处理请求的过程中，会调用 <code>Nio2SocketWrapper</code> 的 read 方法发出第一次读请求，同时注册了回调类 <code>readCompletionHandler</code>，因为数据没读到，<code>Http11Processor</code> 把当前的 <code>Nio2SocketWrapper</code> 标记为数据不完整。<strong>接着 <code>SocketProcessor</code> 线程被回收，<code>Http11Processor</code> 并没有阻塞等待数据</strong>。这里请注意，<code>Http11Processor</code> 维护了一个 <code>Nio2SocketWrapper</code> 列表，也就是维护了连接的状态。</li>
<li>第二次 read 调用：当数据到达后，内核已经把数据拷贝到 <code>Http11Processor</code> 指定的 Buffer 里，同时回调类 <code>readCompletionHandler</code> 被调用，在这个回调处理方法里会<strong>重新创建一个新的 <code>SocketProcessor</code> 任务来继续处理这个连接</strong>，而这个新的 <code>SocketProcessor</code> 任务类持有原来那个 <code>Nio2SocketWrapper</code>，这一次 <code>Http11Processor</code> 可以通过 <code>Nio2SocketWrapper</code> 读取数据了，因为数据已经到了应用层的 Buffer。</li>
</ul>
<p>这个回调类 <code>readCompletionHandler</code> 的源码如下，最关键的一点是，**<code>Nio2SocketWrapper</code> 是作为附件类来传递的**，这样在回调函数里能拿到所有的上下文。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">readCompletionHandler</span> = <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;<span class="title class_">Integer</span>, <span class="title class_">SocketWrapperBase</span>&lt;<span class="title class_">Nio2Channel</span>&gt;&gt;() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">completed</span>(<span class="params"><span class="title class_">Integer</span> nBytes, <span class="title class_">SocketWrapperBase</span>&lt;<span class="title class_">Nio2Channel</span>&gt; attachment</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 通过附件类 SocketWrapper 拿到所有的上下文</span></span><br><span class="line">        <span class="title class_">Nio2SocketWrapper</span>.<span class="property">this</span>.<span class="title function_">getEndpoint</span>().<span class="title function_">processSocket</span>(attachment, <span class="title class_">SocketEvent</span>.<span class="property">OPEN_READ</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">failed</span>(<span class="params"><span class="title class_">Throwable</span> exc, <span class="title class_">SocketWrapperBase</span>&lt;<span class="title class_">Nio2Channel</span>&gt; attachment</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-AprEndpoint-组件"><a href="#3-AprEndpoint-组件" class="headerlink" title="3. AprEndpoint 组件"></a>3. AprEndpoint 组件</h2><p>我们在使用 Tomcat 时，可能会在启动日志里看到这样的提示信息：</p>
<blockquote>
<p>The APR based Apache Tomcat Native library which allows optimal performance in production environments was not found on the java.library.path: ***</p>
</blockquote>
<p>这句话的意思就是推荐你去安装 APR 库，可以提高系统性能。</p>
<p>APR（Apache Portable Runtime Libraries）是 Apache 可移植运行时库，它是用 C 语言实现的，其目的是向上层应用程序提供一个跨平台的操作系统接口库。Tomcat 可以用它来处理包括文件和网络 I&#x2F;O，从而提升性能。Tomcat 支持的连接器有 NIO、NIO.2 和 APR。跟 NioEndpoint 一样，AprEndpoint 也实现了非阻塞 I&#x2F;O，它们的区别是：NioEndpoint 通过调用 Java 的 NIO API 来实现非阻塞 I&#x2F;O，而 AprEndpoint 是通过 JNI 调用 APR 本地库而实现非阻塞 I&#x2F;O 的。</p>
<p>同样是非阻塞 I&#x2F;O，为什么 Tomcat 会提示使用 APR 本地库的性能会更好呢？这是因为在某些场景下，比如需要频繁与操作系统进行交互，Socket 网络通信就是这样一个场景，特别是如果你的 Web 应用使用了 TLS 来加密传输，我们知道 TLS 协议在握手过程中有多次网络交互，在这种情况下 Java 跟 C 语言程序相比还是有一定的差距，而这正是 APR 的强项。</p>
<p>Tomcat 本身是 Java 编写的，为了调用 C 语言编写的 APR，需要通过 JNI 方式来调用。JNI（Java Native Interface） 是 JDK 提供的一个编程接口，它允许 Java 程序调用其他语言编写的程序或者代码库，其实 JDK 本身的实现也大量用到 JNI 技术来调用本地 C 程序库。</p>
<h3 id="3-1-AprEndpoint-工作流程"><a href="#3-1-AprEndpoint-工作流程" class="headerlink" title="3.1. AprEndpoint 工作流程"></a>3.1. AprEndpoint 工作流程</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20201127145740.jpg" alt="img"></p>
<h4 id="3-1-1-Acceptor"><a href="#3-1-1-Acceptor" class="headerlink" title="3.1.1. Acceptor"></a>3.1.1. Acceptor</h4><p>Accpetor 的功能就是监听连接，接收并建立连接。它的本质就是调用了四个操作系统 API：socket、bind、listen 和 accept。那 Java 语言如何直接调用 C 语言 API 呢？答案就是通过 JNI。具体来说就是两步：先封装一个 Java 类，在里面定义一堆用<strong>native 关键字</strong>修饰的方法，像下面这样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Socket</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 用 native 修饰这个方法，表明这个函数是 C 语言实现</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">create</span><span class="params">(<span class="type">int</span> family, <span class="type">int</span> type,</span></span><br><span class="line"><span class="params">                                 <span class="type">int</span> protocol, <span class="type">long</span> cont)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">long</span> sock, <span class="type">long</span> sa)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">long</span> sock, <span class="type">int</span> backlog)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">accept</span><span class="params">(<span class="type">long</span> sock)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着用 C 代码实现这些方法，比如 bind 函数就是这样实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意函数的名字要符合 JNI 规范的要求</span></span><br><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line"><span class="title function_">Java_org_apache_tomcat_jni_Socket_bind</span><span class="params">(JNIEnv *e, jlong sock,jlong sa)</span></span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="type">jint</span> <span class="variable">rv</span> <span class="operator">=</span> APR_SUCCESS;</span><br><span class="line">	    tcn_socket_t *s = (tcn_socket_t *）sock;</span><br><span class="line">	    apr_sockaddr_t *a = (apr_sockaddr_t *) sa;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 APR 库自己实现的 bind 函数</span></span><br><span class="line">	    rv = (jint)apr_socket_bind(s-&gt;sock, a);</span><br><span class="line">	    <span class="keyword">return</span> rv;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>专栏里我就不展开 JNI 的细节了，你可以<a target="_blank" rel="noopener" href="http://jnicookbook.owsiak.org/contents/">扩展阅读</a>获得更多信息和例子。我们要注意的是函数名字要符合 JNI 的规范，以及 Java 和 C 语言如何互相传递参数，比如在 C 语言有指针，Java 没有指针的概念，所以在 Java 中用 long 类型来表示指针。AprEndpoint 的 Acceptor 组件就是调用了 APR 实现的四个 API。</p>
<h4 id="3-1-2-Poller"><a href="#3-1-2-Poller" class="headerlink" title="3.1.2. Poller"></a>3.1.2. Poller</h4><p>Acceptor 接收到一个新的 Socket 连接后，按照 NioEndpoint 的实现，它会把这个 Socket 交给 Poller 去查询 I&#x2F;O 事件。AprEndpoint 也是这样做的，不过 AprEndpoint 的 Poller 并不是调用 Java NIO 里的 Selector 来查询 Socket 的状态，而是通过 JNI 调用 APR 中的 poll 方法，而 APR 又是调用了操作系统的 epoll API 来实现的。</p>
<p>这里有个特别的地方是在 AprEndpoint 中，我们可以配置一个叫<code>deferAccept</code>的参数，它对应的是 TCP 协议中的<code>TCP_DEFER_ACCEPT</code>，设置这个参数后，当 TCP 客户端有新的连接请求到达时，TCP 服务端先不建立连接，而是再等等，直到客户端有请求数据发过来时再建立连接。这样的好处是服务端不需要用 Selector 去反复查询请求数据是否就绪。</p>
<p>这是一种 TCP 协议层的优化，不是每个操作系统内核都支持，因为 Java 作为一种跨平台语言，需要屏蔽各种操作系统的差异，因此并没有把这个参数提供给用户；但是对于 APR 来说，它的目的就是尽可能提升性能，因此它向用户暴露了这个参数。</p>
<h3 id="3-2-APR-提升性能的秘密"><a href="#3-2-APR-提升性能的秘密" class="headerlink" title="3.2. APR 提升性能的秘密"></a>3.2. APR 提升性能的秘密</h3><p>APR 连接器之所以能提高 Tomcat 的性能，除了 APR 本身是 C 程序库之外，还有哪些提速的秘密呢？</p>
<p><strong>JVM 堆 VS 本地内存</strong></p>
<p>我们知道 Java 的类实例一般在 JVM 堆上分配，而 Java 是通过 JNI 调用 C 代码来实现 Socket 通信的，那么 C 代码在运行过程中需要的内存又是从哪里分配的呢？C 代码能否直接操作 Java 堆？</p>
<p>为了回答这些问题，我先来说说 JVM 和用户进程的关系。如果你想运行一个 Java 类文件，可以用下面的 Java 命令来执行。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java <span class="keyword">my</span>.<span class="built_in">class</span></span><br></pre></td></tr></table></figure>

<p>这个命令行中的<code>java</code>其实是<strong>一个可执行程序，这个程序会创建 JVM 来加载和运行你的 Java 类</strong>。操作系统会创建一个进程来执行这个<code>java</code>可执行程序，而每个进程都有自己的虚拟地址空间，JVM 用到的内存（包括堆、栈和方法区）就是从进程的虚拟地址空间上分配的。请你注意的是，JVM 内存只是进程空间的一部分，除此之外进程空间内还有代码段、数据段、内存映射区、内核空间等。从 JVM 的角度看，JVM 内存之外的部分叫作本地内存，C 程序代码在运行过程中用到的内存就是本地内存中分配的。下面我们通过一张图来理解一下。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20201127150729.jpg" alt="img"></p>
<p>Tomcat 的 Endpoint 组件在接收网络数据时需要预先分配好一块 Buffer，所谓的 Buffer 就是字节数组<code>byte[]</code>，Java 通过 JNI 调用把这块 Buffer 的地址传给 C 代码，C 代码通过操作系统 API 读取 Socket 并把数据填充到这块 Buffer。Java NIO API 提供了两种 Buffer 来接收数据：HeapByteBuffer 和 DirectByteBuffer，下面的代码演示了如何创建两种 Buffer。</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 分配 HeapByteBuffer</span><br><span class="line">ByteBuffer buf <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">// 分配 DirectByteBuffer</span><br><span class="line">ByteBuffer buf <span class="operator">=</span> ByteBuffer.allocateDirect(<span class="number">1024</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>创建好 Buffer 后直接传给 Channel 的 read 或者 write 函数，最终这块 Buffer 会通过 JNI 调用传递给 C 程序。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 buf 作为 read 函数的参数</span></span><br><span class="line"><span class="keyword">int</span> bytesRead = socketChannel.<span class="keyword">read</span>(buf);</span><br></pre></td></tr></table></figure>

<p>那 HeapByteBuffer 和 DirectByteBuffer 有什么区别呢？HeapByteBuffer 对象本身在 JVM 堆上分配，并且它持有的字节数组<code>byte[]</code>也是在 JVM 堆上分配。但是如果用<strong>HeapByteBuffer</strong>来接收网络数据，<strong>需要把数据从内核先拷贝到一个临时的本地内存，再从临时本地内存拷贝到 JVM 堆</strong>，而不是直接从内核拷贝到 JVM 堆上。这是为什么呢？这是因为数据从内核拷贝到 JVM 堆的过程中，JVM 可能会发生 GC，GC 过程中对象可能会被移动，也就是说 JVM 堆上的字节数组可能会被移动，这样的话 Buffer 地址就失效了。如果这中间经过本地内存中转，从本地内存到 JVM 堆的拷贝过程中 JVM 可以保证不做 GC。</p>
<p>如果使用 HeapByteBuffer，你会发现 JVM 堆和内核之间多了一层中转，而 DirectByteBuffer 用来解决这个问题，DirectByteBuffer 对象本身在 JVM 堆上，但是它持有的字节数组不是从 JVM 堆上分配的，而是从本地内存分配的。DirectByteBuffer 对象中有个 long 类型字段 address，记录着本地内存的地址，这样在接收数据的时候，直接把这个本地内存地址传递给 C 程序，C 程序会将网络数据从内核拷贝到这个本地内存，JVM 可以直接读取这个本地内存，这种方式比 HeapByteBuffer 少了一次拷贝，因此一般来说它的速度会比 HeapByteBuffer 快好几倍。你可以通过上面的图加深理解。</p>
<p>Tomcat 中的 AprEndpoint 就是通过 DirectByteBuffer 来接收数据的，而 NioEndpoint 和 Nio2Endpoint 是通过 HeapByteBuffer 来接收数据的。你可能会问，NioEndpoint 和 Nio2Endpoint 为什么不用 DirectByteBuffer 呢？这是因为本地内存不好管理，发生内存泄漏难以定位，从稳定性考虑，NioEndpoint 和 Nio2Endpoint 没有去冒这个险。</p>
<h4 id="3-2-1-sendfile"><a href="#3-2-1-sendfile" class="headerlink" title="3.2.1. sendfile"></a>3.2.1. sendfile</h4><p>我们再来考虑另一个网络通信的场景，也就是静态文件的处理。浏览器通过 Tomcat 来获取一个 HTML 文件，而 Tomcat 的处理逻辑无非是两步：</p>
<ol>
<li>从磁盘读取 HTML 到内存。</li>
<li>将这段内存的内容通过 Socket 发送出去。</li>
</ol>
<p>但是在传统方式下，有很多次的内存拷贝：</p>
<ul>
<li>读取文件时，首先是内核把文件内容读取到内核缓冲区。</li>
<li>如果使用 HeapByteBuffer，文件数据从内核到 JVM 堆内存需要经过本地内存中转。</li>
<li>同样在将文件内容推入网络时，从 JVM 堆到内核缓冲区需要经过本地内存中转。</li>
<li>最后还需要把文件从内核缓冲区拷贝到网卡缓冲区。</li>
</ul>
<p>从下面的图你会发现这个过程有 6 次内存拷贝，并且 read 和 write 等系统调用将导致进程从用户态到内核态的切换，会耗费大量的 CPU 和内存资源。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20201127151041.jpg" alt="img"></p>
<p>而 Tomcat 的 AprEndpoint 通过操作系统层面的 sendfile 特性解决了这个问题，sendfile 系统调用方式非常简洁。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sendfile</span>(socket, file, len);</span><br></pre></td></tr></table></figure>

<p>它带有两个关键参数：Socket 和文件句柄。将文件从磁盘写入 Socket 的过程只有两步：</p>
<p>第一步：将文件内容读取到内核缓冲区。</p>
<p>第二步：数据并没有从内核缓冲区复制到 Socket 关联的缓冲区，只有记录数据位置和长度的描述符被添加到 Socket 缓冲区中；接着把数据直接从内核缓冲区传递给网卡。这个过程你可以看下面的图。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20201127151155.jpg" alt="img"></p>
<h2 id="4-Executor-组件"><a href="#4-Executor-组件" class="headerlink" title="4. Executor 组件"></a>4. Executor 组件</h2><p>为了提高处理能力和并发度，Web 容器一般会把处理请求的工作放到线程池里来执行，Tomcat 扩展了原生的 Java 线程池，来满足 Web 容器高并发的需求。</p>
<h3 id="4-1-Tomcat-定制线程池"><a href="#4-1-Tomcat-定制线程池" class="headerlink" title="4.1. Tomcat 定制线程池"></a>4.1. Tomcat 定制线程池</h3><p>Tomcat 的线程池也是一个定制版的 ThreadPoolExecutor。Tomcat 传入的参数是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定制版的任务队列</span></span><br><span class="line">taskqueue = <span class="keyword">new</span> <span class="title class_">TaskQueue</span>(maxQueueSize);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定制版的线程工厂</span></span><br><span class="line"><span class="type">TaskThreadFactory</span> <span class="variable">tf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskThreadFactory</span>(namePrefix,daemon,getThreadPriority());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定制版的线程池</span></span><br><span class="line">executor = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(getMinSpareThreads(), getMaxThreads(), maxIdleTime, TimeUnit.MILLISECONDS,taskqueue, tf);</span><br></pre></td></tr></table></figure>

<p>其中的两个关键点：</p>
<ul>
<li>Tomcat 有自己的定制版任务队列和线程工厂，并且可以限制任务队列的长度，它的最大长度是 maxQueueSize。</li>
<li>Tomcat 对线程数也有限制，设置了核心线程数（minSpareThreads）和最大线程池数（maxThreads）。</li>
</ul>
<p>除了资源限制以外，Tomcat 线程池还定制自己的任务处理流程。我们知道 Java 原生线程池的任务处理逻辑比较简单：</p>
<ol>
<li>前 corePoolSize 个任务时，来一个任务就创建一个新线程。</li>
<li>后面再来任务，就把任务添加到任务队列里让所有的线程去抢，如果队列满了就创建临时线程。</li>
<li>如果总线程数达到 maximumPoolSize，<strong>执行拒绝策略。</strong></li>
</ol>
<p>Tomcat 线程池扩展了原生的 ThreadPoolExecutor，通过重写 execute 方法实现了自己的任务处理逻辑：</p>
<ol>
<li>前 corePoolSize 个任务时，来一个任务就创建一个新线程。</li>
<li>再来任务的话，就把任务添加到任务队列里让所有的线程去抢，如果队列满了就创建临时线程。</li>
<li>如果总线程数达到 maximumPoolSize，<strong>则继续尝试把任务添加到任务队列中去。</strong></li>
<li><strong>如果缓冲队列也满了，插入失败，执行拒绝策略。</strong></li>
</ol>
<p>观察 Tomcat 线程池和 Java 原生线程池的区别，其实就是在第 3 步，Tomcat 在线程总数达到最大数时，不是立即执行拒绝策略，而是再尝试向任务队列添加任务，添加失败后再执行拒绝策略。那具体如何实现呢，其实很简单，我们来看一下 Tomcat 线程池的 execute 方法的核心代码。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">concurrent</span>.<span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  public void execute(<span class="type">Runnable</span> command, long timeout, <span class="type">TimeUnit</span> unit) &#123;</span><br><span class="line">      submittedCount.incrementAndGet();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 调用 Java 原生线程池的 execute 去执行任务</span></span><br><span class="line">          <span class="keyword">super</span>.execute(command);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (<span class="type">RejectedExecutionException</span> rx) &#123;</span><br><span class="line">         <span class="comment">// 如果总线程数达到 maximumPoolSize，Java 原生线程池执行拒绝策略</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">super</span>.getQueue() instanceof <span class="type">TaskQueue</span>) &#123;</span><br><span class="line">              <span class="keyword">final</span> <span class="type">TaskQueue</span> queue = (<span class="type">TaskQueue</span>)<span class="keyword">super</span>.getQueue();</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// 继续尝试把任务放到任务队列中去</span></span><br><span class="line">                  <span class="keyword">if</span> (!queue.force(command, timeout, unit)) &#123;</span><br><span class="line">                      submittedCount.decrementAndGet();</span><br><span class="line">                      <span class="comment">// 如果缓冲队列也满了，插入失败，执行拒绝策略。</span></span><br><span class="line">                      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RejectedExecutionException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这个方法你可以看到，Tomcat 线程池的 execute 方法会调用 Java 原生线程池的 execute 去执行任务，如果总线程数达到 maximumPoolSize，Java 原生线程池的 execute 方法会抛出 RejectedExecutionException 异常，但是这个异常会被 Tomcat 线程池的 execute 方法捕获到，并继续尝试把这个任务放到任务队列中去；如果任务队列也满了，再执行拒绝策略。</p>
<h3 id="4-2-Tomcat-定制任务队列"><a href="#4-2-Tomcat-定制任务队列" class="headerlink" title="4.2. Tomcat 定制任务队列"></a>4.2. Tomcat 定制任务队列</h3><p>细心的你有没有发现，在 Tomcat 线程池的 execute 方法最开始有这么一行：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">submittedCount.incrementAndGet()<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>这行代码的意思把 submittedCount 这个原子变量加一，并且在任务执行失败，抛出拒绝异常时，将这个原子变量减一：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">submittedCount.decrementAndGet()<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>其实 Tomcat 线程池是用这个变量 submittedCount 来维护已经提交到了线程池，但是还没有执行完的任务个数。Tomcat 为什么要维护这个变量呢？这跟 Tomcat 的定制版的任务队列有关。Tomcat 的任务队列 TaskQueue 扩展了 Java 中的 LinkedBlockingQueue，我们知道 LinkedBlockingQueue 默认情况下长度是没有限制的，除非给它一个 capacity。因此 Tomcat 给了它一个 capacity，TaskQueue 的构造函数中有个整型的参数 capacity，TaskQueue 将 capacity 传给父类 LinkedBlockingQueue 的构造函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskQueue</span> <span class="keyword">extends</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">TaskQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>(capacity);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 capacity 参数是通过 Tomcat 的 maxQueueSize 参数来设置的，但问题是默认情况下 maxQueueSize 的值是<code>Integer.MAX_VALUE</code>，等于没有限制，这样就带来一个问题：当前线程数达到核心线程数之后，再来任务的话线程池会把任务添加到任务队列，并且总是会成功，这样永远不会有机会创建新线程了。</p>
<p>为了解决这个问题，TaskQueue 重写了 LinkedBlockingQueue 的 offer 方法，在合适的时机返回 false，返回 false 表示任务添加失败，这时线程池会创建新的线程。那什么是合适的时机呢？请看下面 offer 方法的核心源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskQueue</span> <span class="keyword">extends</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt; &#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">  <span class="comment">// 线程池调用任务队列的方法时，当前线程数肯定已经大于核心线程数了</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(Runnable o)</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果线程数已经到了最大值，不能创建新线程了，只能把任务添加到任务队列。</span></span><br><span class="line">      <span class="keyword">if</span> (parent.getPoolSize() == parent.getMaximumPoolSize())</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">super</span>.offer(o);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 执行到这里，表明当前线程数大于核心线程数，并且小于最大线程数。</span></span><br><span class="line">      <span class="comment">// 表明是可以创建新线程的，那到底要不要创建呢？分两种情况：</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//1. 如果已提交的任务数小于当前线程数，表示还有空闲线程，无需创建新线程</span></span><br><span class="line">      <span class="keyword">if</span> (parent.getSubmittedCount()&lt;=(parent.getPoolSize()))</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">super</span>.offer(o);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//2. 如果已提交的任务数大于当前线程数，线程不够用了，返回 false 去创建新线程</span></span><br><span class="line">      <span class="keyword">if</span> (parent.getPoolSize()&lt;parent.getMaximumPoolSize())</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 默认情况下总是把任务添加到任务队列</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">super</span>.offer(o);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码我们看到，只有当前线程数大于核心线程数、小于最大线程数，并且已提交的任务个数大于当前线程数时，也就是说线程不够用了，但是线程数又没达到极限，才会去创建新的线程。这就是为什么 Tomcat 需要维护已提交任务数这个变量，它的目的就是<strong>在任务队列的长度无限制的情况下，让线程池有机会创建新的线程</strong>。</p>
<p>当然默认情况下 Tomcat 的任务队列是没有限制的，你可以通过设置 maxQueueSize 参数来限制任务队列的长度。</p>
<h2 id="5-WebSocket-组件"><a href="#5-WebSocket-组件" class="headerlink" title="5. WebSocket 组件"></a>5. WebSocket 组件</h2><p>HTTP 协议是“请求 - 响应”模式，浏览器必须先发请求给服务器，服务器才会响应这个请求。也就是说，服务器不会主动发送数据给浏览器。</p>
<p>对于实时性要求比较的高的应用，比如在线游戏、股票基金实时报价和在线协同编辑等，浏览器需要实时显示服务器上最新的数据，因此出现了 Ajax 和 Comet 技术。Ajax 本质上还是轮询，而 Comet 是在 HTTP 长连接的基础上做了一些 hack，但是它们的实时性不高，另外频繁的请求会给服务器带来压力，也会浪费网络流量和带宽。于是 HTML5 推出了 WebSocket 标准，使得浏览器和服务器之间任何一方都可以主动发消息给对方，这样服务器有新数据时可以主动推送给浏览器。</p>
<p>Tomcat 如何支持 WebSocket？简单来说，Tomcat 做了两件事：</p>
<ul>
<li>Endpoint 加载</li>
<li>WebSocket 请求处理</li>
</ul>
<h3 id="5-1-WebSocket-加载"><a href="#5-1-WebSocket-加载" class="headerlink" title="5.1. WebSocket 加载"></a>5.1. WebSocket 加载</h3><p>Tomcat 的 WebSocket 加载是通过 SCI 机制完成的。SCI 全称 ServletContainerInitializer，是 Servlet 3.0 规范中定义的用来<strong>接收 Web 应用启动事件的接口</strong>。那为什么要监听 Servlet 容器的启动事件呢？因为这样我们有机会在 Web 应用启动时做一些初始化工作，比如 WebSocket 需要扫描和加载 Endpoint 类。SCI 的使用也比较简单，将实现 ServletContainerInitializer 接口的类增加 HandlesTypes 注解，并且在注解内指定的一系列类和接口集合。比如 Tomcat 为了扫描和加载 Endpoint 而定义的 SCI 类如下：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@HandlesTypes(&#123;ServerEndpoint.<span class="keyword">class</span>, ServerApplicationConfig.<span class="keyword">class</span>, Endpoint.<span class="keyword">class</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> WsSci <span class="keyword">implements</span> ServletContainerInitializer &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> onStartup(Set&lt;<span class="keyword">Class</span>&lt;?&gt;&gt; clazzes, ServletContext ctx) <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦定义好了 SCI，Tomcat 在启动阶段扫描类时，会将 HandlesTypes 注解中指定的类都扫描出来，作为 SCI 的 onStartup 方法的参数，并调用 SCI 的 onStartup 方法。注意到 WsSci 的 HandlesTypes 注解中定义了<code>ServerEndpoint.class</code>、<code>ServerApplicationConfig.class</code>和<code>Endpoint.class</code>，因此在 Tomcat 的启动阶段会将这些类的类实例（注意不是对象实例）传递给 WsSci 的 onStartup 方法。那么 WsSci 的 onStartup 方法又做了什么事呢？</p>
<p>它会构造一个 WebSocketContainer 实例，你可以把 WebSocketContainer 理解成一个专门处理 WebSocket 请求的<strong>Endpoint 容器</strong>。也就是说 Tomcat 会把扫描到的 Endpoint 子类和添加了注解<code>@ServerEndpoint</code>的类注册到这个容器中，并且这个容器还维护了 URL 到 Endpoint 的映射关系，这样通过请求 URL 就能找到具体的 Endpoint 来处理 WebSocket 请求。</p>
<h3 id="5-2-WebSocket-请求处理"><a href="#5-2-WebSocket-请求处理" class="headerlink" title="5.2. WebSocket 请求处理"></a>5.2. WebSocket 请求处理</h3><p>Tomcat 用 ProtocolHandler 组件屏蔽应用层协议的差异，其中 ProtocolHandler 中有两个关键组件：Endpoint 和 Processor。需要注意，这里的 Endpoint 跟上文提到的 WebSocket 中的 Endpoint 完全是两回事，连接器中的 Endpoint 组件用来处理 I&#x2F;O 通信。WebSocket 本质就是一个应用层协议，因此不能用 HttpProcessor 来处理 WebSocket 请求，而要用专门 Processor 来处理，而在 Tomcat 中这样的 Processor 叫作 UpgradeProcessor。</p>
<p>为什么叫 Upgrade Processor 呢？这是因为 Tomcat 是将 HTTP 协议升级成 WebSocket 协议的。</p>
<p>WebSocket 是通过 HTTP 协议来进行握手的，因此当 WebSocket 的握手请求到来时，HttpProtocolHandler 首先接收到这个请求，在处理这个 HTTP 请求时，Tomcat 通过一个特殊的 Filter 判断该当前 HTTP 请求是否是一个 WebSocket Upgrade 请求（即包含<code>Upgrade: websocket</code>的 HTTP 头信息），如果是，则在 HTTP 响应里添加 WebSocket 相关的响应头信息，并进行协议升级。具体来说就是用 UpgradeProtocolHandler 替换当前的 HttpProtocolHandler，相应的，把当前 Socket 的 Processor 替换成 UpgradeProcessor，同时 Tomcat 会创建 WebSocket Session 实例和 Endpoint 实例，并跟当前的 WebSocket 连接一一对应起来。这个 WebSocket 连接不会立即关闭，并且在请求处理中，不再使用原有的 HttpProcessor，而是用专门的 UpgradeProcessor，UpgradeProcessor 最终会调用相应的 Endpoint 实例来处理请求。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20201127153521.jpg" alt="img"></p>
<p>你可以看到，Tomcat 对 WebSocket 请求的处理没有经过 Servlet 容器，而是通过 UpgradeProcessor 组件直接把请求发到 ServerEndpoint 实例，并且 Tomcat 的 WebSocket 实现不需要关注具体 I&#x2F;O 模型的细节，从而实现了与具体 I&#x2F;O 方式的解耦。</p>
<h2 id="6-参考资料"><a href="#6-参考资料" class="headerlink" title="6. 参考资料"></a>6. 参考资料</h2><ul>
<li><strong>官方</strong><ul>
<li><a target="_blank" rel="noopener" href="http://tomcat.apache.org/">Tomcat 官方网站</a></li>
<li><a target="_blank" rel="noopener" href="http://wiki.apache.org/tomcat/FrontPage">Tomcat Wiki</a></li>
<li><a target="_blank" rel="noopener" href="http://tomee.apache.org/">Tomee 官方网站</a></li>
</ul>
</li>
<li><strong>教程</strong><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100027701">深入拆解 Tomcat &amp; Jetty</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/d5076a/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/d5076a/" class="post-title-link" itemprop="url">Tomcat容器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-17 22:34:30" itemprop="dateCreated datePublished" datetime="2022-02-17T22:34:30+08:00">2022-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JavaEE/" itemprop="url" rel="index"><span itemprop="name">JavaEE</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JavaEE/%E6%9C%8D%E5%8A%A1%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">服务器</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JavaEE/%E6%9C%8D%E5%8A%A1%E5%99%A8/Tomcat/" itemprop="url" rel="index"><span itemprop="name">Tomcat</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>20k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>18 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Tomcat-容器"><a href="#Tomcat-容器" class="headerlink" title="Tomcat 容器"></a>Tomcat 容器</h1><h2 id="Tomcat-实现热部署和热加载"><a href="#Tomcat-实现热部署和热加载" class="headerlink" title="Tomcat 实现热部署和热加载"></a>Tomcat 实现热部署和热加载</h2><ul>
<li>热加载的实现方式是 Web 容器启动一个后台线程，定期检测类文件的变化，如果有变化，就重新加载类，在这个过程中不会清空 Session ，一般用在开发环境。</li>
<li>热部署原理类似，也是由后台线程定时检测 Web 应用的变化，但它会重新加载整个 Web 应用。这种方式会清空 Session，比热加载更加干净、彻底，一般用在生产环境。</li>
</ul>
<p>Tomcat 通过开启后台线程，使得各个层次的容器组件都有机会完成一些周期性任务。Tomcat 是基于 ScheduledThreadPoolExecutor 实现周期性任务的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bgFuture = exec.scheduleWithFixedDelay(</span><br><span class="line">              <span class="keyword">new</span> <span class="title class_">ContainerBackgroundProcessor</span>(),<span class="comment">// 要执行的 Runnable</span></span><br><span class="line">              backgroundProcessorDelay, <span class="comment">// 第一次执行延迟多久</span></span><br><span class="line">              backgroundProcessorDelay, <span class="comment">// 之后每次执行间隔多久</span></span><br><span class="line">              TimeUnit.SECONDS);        <span class="comment">// 时间单位</span></span><br></pre></td></tr></table></figure>

<p>第一个参数就是要周期性执行的任务类 ContainerBackgroundProcessor，它是一个 Runnable，同时也是 ContainerBase 的内部类，ContainerBase 是所有容器组件的基类，我们来回忆一下容器组件有哪些，有 Engine、Host、Context 和 Wrapper 等，它们具有父子关系。</p>
<h3 id="ContainerBackgroundProcessor-实现"><a href="#ContainerBackgroundProcessor-实现" class="headerlink" title="ContainerBackgroundProcessor 实现"></a>ContainerBackgroundProcessor 实现</h3><p>我们接来看 ContainerBackgroundProcessor 具体是如何实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">class</span> <span class="title class_">ContainerBackgroundProcessor</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 请注意这里传入的参数是 &quot; 宿主类 &quot; 的实例</span></span><br><span class="line">        processChildren(ContainerBase.<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processChildren</span><span class="params">(Container container)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1. 调用当前容器的 backgroundProcess 方法。</span></span><br><span class="line">            container.backgroundProcess();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2. 遍历所有的子容器，递归调用 processChildren，</span></span><br><span class="line">            <span class="comment">// 这样当前容器的子孙都会被处理</span></span><br><span class="line">            Container[] children = container.findChildren();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 这里请你注意，容器基类有个变量叫做 backgroundProcessorDelay，如果大于 0，表明子容器有自己的后台线程，无需父容器来调用它的 processChildren 方法。</span></span><br><span class="line">                <span class="keyword">if</span> (children[i].getBackgroundProcessorDelay() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    processChildren(children[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码逻辑也是比较清晰的，首先 ContainerBackgroundProcessor 是一个 Runnable，它需要实现 run 方法，它的 run 很简单，就是调用了 processChildren 方法。这里有个小技巧，它把“宿主类”，也就是<strong>ContainerBase 的类实例当成参数传给了 run 方法</strong>。</p>
<p>而在 processChildren 方法里，就做了两步：调用当前容器的 backgroundProcess 方法，以及递归调用子孙的 backgroundProcess 方法。请你注意 backgroundProcess 是 Container 接口中的方法，也就是说所有类型的容器都可以实现这个方法，在这个方法里完成需要周期性执行的任务。</p>
<p>这样的设计意味着什么呢？我们只需要在顶层容器，也就是 Engine 容器中启动一个后台线程，那么这个线程<strong>不但会执行 Engine 容器的周期性任务，它还会执行所有子容器的周期性任务</strong>。</p>
<h3 id="backgroundProcess-方法"><a href="#backgroundProcess-方法" class="headerlink" title="backgroundProcess 方法"></a>backgroundProcess 方法</h3><p>上述代码都是在基类 ContainerBase 中实现的，那具体容器类需要做什么呢？其实很简单，如果有周期性任务要执行，就实现 backgroundProcess 方法；如果没有，就重用基类 ContainerBase 的方法。ContainerBase 的 backgroundProcess 方法实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backgroundProcess</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 执行容器中 Cluster 组件的周期性任务</span></span><br><span class="line">    <span class="type">Cluster</span> <span class="variable">cluster</span> <span class="operator">=</span> getClusterInternal();</span><br><span class="line">    <span class="keyword">if</span> (cluster != <span class="literal">null</span>) &#123;</span><br><span class="line">        cluster.backgroundProcess();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 执行容器中 Realm 组件的周期性任务</span></span><br><span class="line">    <span class="type">Realm</span> <span class="variable">realm</span> <span class="operator">=</span> getRealmInternal();</span><br><span class="line">    <span class="keyword">if</span> (realm != <span class="literal">null</span>) &#123;</span><br><span class="line">        realm.backgroundProcess();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3. 执行容器中 Valve 组件的周期性任务</span></span><br><span class="line">    <span class="type">Valve</span> <span class="variable">current</span> <span class="operator">=</span> pipeline.getFirst();</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">       current.backgroundProcess();</span><br><span class="line">       current = current.getNext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 触发容器的 &quot; 周期事件 &quot;，Host 容器的监听器 HostConfig 就靠它来调用</span></span><br><span class="line">    fireLifecycleEvent(Lifecycle.PERIODIC_EVENT, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看到，不仅每个容器可以有周期性任务，每个容器中的其他通用组件，比如跟集群管理有关的 Cluster 组件、跟安全管理有关的 Realm 组件都可以有自己的周期性任务。</p>
<p>我在前面的专栏里提到过，容器之间的链式调用是通过 Pipeline-Valve 机制来实现的，从上面的代码你可以看到容器中的 Valve 也可以有周期性任务，并且被 ContainerBase 统一处理。</p>
<p>请你特别注意的是，在 backgroundProcess 方法的最后，还触发了容器的“周期事件”。我们知道容器的生命周期事件有初始化、启动和停止等，那“周期事件”又是什么呢？它跟生命周期事件一样，是一种扩展机制，你可以这样理解：</p>
<p>又一段时间过去了，容器还活着，你想做点什么吗？如果你想做点什么，就创建一个监听器来监听这个“周期事件”，事件到了我负责调用你的方法。</p>
<p>总之，有了 ContainerBase 中的后台线程和 backgroundProcess 方法，各种子容器和通用组件不需要各自弄一个后台线程来处理周期性任务，这样的设计显得优雅和整洁。</p>
<h3 id="Tomcat-热加载"><a href="#Tomcat-热加载" class="headerlink" title="Tomcat 热加载"></a>Tomcat 热加载</h3><p>有了 ContainerBase 的周期性任务处理“框架”，作为具体容器子类，只需要实现自己的周期性任务就行。而 Tomcat 的热加载，就是在 Context 容器中实现的。Context 容器的 backgroundProcess 方法是这样实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backgroundProcess</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//WebappLoader 周期性的检查 WEB-INF/classes 和 WEB-INF/lib 目录下的类文件</span></span><br><span class="line">    <span class="type">Loader</span> <span class="variable">loader</span> <span class="operator">=</span> getLoader();</span><br><span class="line">    <span class="keyword">if</span> (loader != <span class="literal">null</span>) &#123;</span><br><span class="line">        loader.backgroundProcess();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Session 管理器周期性的检查是否有过期的 Session</span></span><br><span class="line">    <span class="type">Manager</span> <span class="variable">manager</span> <span class="operator">=</span> getManager();</span><br><span class="line">    <span class="keyword">if</span> (manager != <span class="literal">null</span>) &#123;</span><br><span class="line">        manager.backgroundProcess();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 周期性的检查静态资源是否有变化</span></span><br><span class="line">    <span class="type">WebResourceRoot</span> <span class="variable">resources</span> <span class="operator">=</span> getResources();</span><br><span class="line">    <span class="keyword">if</span> (resources != <span class="literal">null</span>) &#123;</span><br><span class="line">        resources.backgroundProcess();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用父类 ContainerBase 的 backgroundProcess 方法</span></span><br><span class="line">    <span class="built_in">super</span>.backgroundProcess();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码我们看到 Context 容器通过 WebappLoader 来检查类文件是否有更新，通过 Session 管理器来检查是否有 Session 过期，并且通过资源管理器来检查静态资源是否有更新，最后还调用了父类 ContainerBase 的 backgroundProcess 方法。</p>
<p>这里我们要重点关注，WebappLoader 是如何实现热加载的，它主要是调用了 Context 容器的 reload 方法，而 Context 的 reload 方法比较复杂，总结起来，主要完成了下面这些任务：</p>
<ol>
<li>停止和销毁 Context 容器及其所有子容器，子容器其实就是 Wrapper，也就是说 Wrapper 里面 Servlet 实例也被销毁了。</li>
<li>停止和销毁 Context 容器关联的 Listener 和 Filter。</li>
<li>停止和销毁 Context 下的 Pipeline 和各种 Valve。</li>
<li>停止和销毁 Context 的类加载器，以及类加载器加载的类文件资源。</li>
<li>启动 Context 容器，在这个过程中会重新创建前面四步被销毁的资源。</li>
</ol>
<p>在这个过程中，类加载器发挥着关键作用。一个 Context 容器对应一个类加载器，类加载器在销毁的过程中会把它加载的所有类也全部销毁。Context 容器在启动过程中，会创建一个新的类加载器来加载新的类文件。</p>
<p>在 Context 的 reload 方法里，并没有调用 Session 管理器的 distroy 方法，也就是说这个 Context 关联的 Session 是没有销毁的。你还需要注意的是，Tomcat 的热加载默认是关闭的，你需要在 conf 目录下的 Context.xml 文件中设置 reloadable 参数来开启这个功能，像下面这样：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Context <span class="attribute">reloadable</span>=<span class="string">&quot;true&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Tomcat-热部署"><a href="#Tomcat-热部署" class="headerlink" title="Tomcat 热部署"></a>Tomcat 热部署</h3><p>我们再来看看热部署，热部署跟热加载的本质区别是，热部署会重新部署 Web 应用，原来的 Context 对象会整个被销毁掉，因此这个 Context 所关联的一切资源都会被销毁，包括 Session。</p>
<p>那么 Tomcat 热部署又是由哪个容器来实现的呢？应该不是由 Context，因为热部署过程中 Context 容器被销毁了，那么这个重担就落在 Host 身上了，因为它是 Context 的父容器。</p>
<p>跟 Context 不一样，Host 容器并没有在 backgroundProcess 方法中实现周期性检测的任务，而是通过监听器 HostConfig 来实现的，HostConfig 就是前面提到的“周期事件”的监听器，那“周期事件”达到时，HostConfig 会做什么事呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lifecycleEvent</span><span class="params">(LifecycleEvent event)</span> &#123;</span><br><span class="line">    <span class="comment">// 执行 check 方法。</span></span><br><span class="line">    <span class="keyword">if</span> (event.getType().equals(Lifecycle.PERIODIC_EVENT)) &#123;</span><br><span class="line">        check();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它执行了 check 方法，我们接着来看 check 方法里做了什么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (host.getAutoDeploy()) &#123;</span><br><span class="line">        <span class="comment">// 检查这个 Host 下所有已经部署的 Web 应用</span></span><br><span class="line">        DeployedApplication[] apps =</span><br><span class="line">            deployed.values().toArray(<span class="keyword">new</span> <span class="title class_">DeployedApplication</span>[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; apps.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 检查 Web 应用目录是否有变化</span></span><br><span class="line">            checkResources(apps[i], <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行部署</span></span><br><span class="line">        deployApps();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实 HostConfig 会检查 webapps 目录下的所有 Web 应用：</p>
<ul>
<li>如果原来 Web 应用目录被删掉了，就把相应 Context 容器整个销毁掉。</li>
<li>是否有新的 Web 应用目录放进来了，或者有新的 WAR 包放进来了，就部署相应的 Web 应用。</li>
</ul>
<p>因此 HostConfig 做的事情都是比较“宏观”的，它不会去检查具体类文件或者资源文件是否有变化，而是检查 Web 应用目录级别的变化。</p>
<h2 id="Tomcat-的类加载机制"><a href="#Tomcat-的类加载机制" class="headerlink" title="Tomcat 的类加载机制"></a>Tomcat 的类加载机制</h2><p>Tomcat 的自定义类加载器 <code>WebAppClassLoader</code> 打破了双亲委派机制，它<strong>首先自己尝试去加载某个类，如果找不到再代理给父类加载器</strong>，其目的是优先加载 Web 应用自己定义的类。具体实现就是重写 ClassLoader 的两个方法：findClass 和 loadClass。</p>
<h3 id="findClass-方法"><a href="#findClass-方法" class="headerlink" title="findClass 方法"></a>findClass 方法</h3><p>我们先来看看 findClass 方法的实现，为了方便理解和阅读，我去掉了一些细节：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; clazz = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1. 先在 Web 应用目录下查找类</span></span><br><span class="line">            clazz = findClassInternal(name);</span><br><span class="line">    &#125;  <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> e;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//2. 如果在本地目录没有找到，交给父加载器去查找</span></span><br><span class="line">            clazz = <span class="built_in">super</span>.findClass(name);</span><br><span class="line">    &#125;  <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> e;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 如果父类也没找到，抛出 ClassNotFoundException</span></span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 findClass 方法里，主要有三个步骤：</p>
<ol>
<li>先在 Web 应用本地目录下查找要加载的类。</li>
<li>如果没有找到，交给父加载器去查找，它的父加载器就是上面提到的系统类加载器 AppClassLoader。</li>
<li>如何父加载器也没找到这个类，抛出 ClassNotFound 异常。</li>
</ol>
<h3 id="loadClass-方法"><a href="#loadClass-方法" class="headerlink" title="loadClass 方法"></a>loadClass 方法</h3><p>接着我们再来看 Tomcat 类加载器的 loadClass 方法的实现，同样我也去掉了一些细节：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; clazz = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 先在本地 cache 查找该类是否已经加载过</span></span><br><span class="line">        clazz = findLoadedClass0(name);</span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (resolve)</span><br><span class="line">                resolveClass(clazz);</span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 从系统类加载器的 cache 中查找是否加载过</span></span><br><span class="line">        clazz = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (resolve)</span><br><span class="line">                resolveClass(clazz);</span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 尝试用 ExtClassLoader 类加载器类加载，为什么？</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">javaseLoader</span> <span class="operator">=</span> getJavaseClassLoader();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clazz = javaseLoader.loadClass(name);</span><br><span class="line">            <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (resolve)</span><br><span class="line">                    resolveClass(clazz);</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// Ignore</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 尝试在本地目录搜索 class 并加载</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clazz = findClass(name);</span><br><span class="line">            <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (resolve)</span><br><span class="line">                    resolveClass(clazz);</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// Ignore</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 尝试用系统类加载器 (也就是 AppClassLoader) 来加载</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                clazz = Class.forName(name, <span class="literal">false</span>, parent);</span><br><span class="line">                <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (resolve)</span><br><span class="line">                        resolveClass(clazz);</span><br><span class="line">                    <span class="keyword">return</span> clazz;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6. 上述过程都加载失败，抛出异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>loadClass 方法稍微复杂一点，主要有六个步骤：</p>
<ol>
<li>先在本地 Cache 查找该类是否已经加载过，也就是说 Tomcat 的类加载器是否已经加载过这个类。</li>
<li>如果 Tomcat 类加载器没有加载过这个类，再看看系统类加载器是否加载过。</li>
<li>如果都没有，就让<strong>ExtClassLoader</strong>去加载，这一步比较关键，目的<strong>防止 Web 应用自己的类覆盖 JRE 的核心类</strong>。因为 Tomcat 需要打破双亲委派机制，假如 Web 应用里自定义了一个叫 Object 的类，如果先加载这个 Object 类，就会覆盖 JRE 里面的那个 Object 类，这就是为什么 Tomcat 的类加载器会优先尝试用 ExtClassLoader 去加载，因为 ExtClassLoader 会委托给 BootstrapClassLoader 去加载，BootstrapClassLoader 发现自己已经加载了 Object 类，直接返回给 Tomcat 的类加载器，这样 Tomcat 的类加载器就不会去加载 Web 应用下的 Object 类了，也就避免了覆盖 JRE 核心类的问题。</li>
<li>如果 ExtClassLoader 加载器加载失败，也就是说 JRE 核心类中没有这类，那么就在本地 Web 应用目录下查找并加载。</li>
<li>如果本地目录下没有这个类，说明不是 Web 应用自己定义的类，那么由系统类加载器去加载。这里请你注意，Web 应用是通过<code>Class.forName</code>调用交给系统类加载器的，因为<code>Class.forName</code>的默认加载器就是系统类加载器。</li>
<li>如果上述加载过程全部失败，抛出 ClassNotFound 异常。</li>
</ol>
<p>从上面的过程我们可以看到，Tomcat 的类加载器打破了双亲委派机制，没有一上来就直接委托给父加载器，而是先在本地目录下加载，为了避免本地目录下的类覆盖 JRE 的核心类，先尝试用 JVM 扩展类加载器 ExtClassLoader 去加载。那为什么不先用系统类加载器 AppClassLoader 去加载？很显然，如果是这样的话，那就变成双亲委派机制了，这就是 Tomcat 类加载器的巧妙之处。</p>
<h3 id="Tomcat-实现应用隔离"><a href="#Tomcat-实现应用隔离" class="headerlink" title="Tomcat 实现应用隔离"></a>Tomcat 实现应用隔离</h3><p>Tomcat 作为 Web 容器，需要解决以下问题：</p>
<ol>
<li>如果在 Tomcat 中运行了两个 Web 应用程序，两个 Web 应用中有同名的 Servlet，但是功能不同，Tomcat 需要同时加载和管理这两个同名的 Servlet 类，保证它们不会冲突，因此 Web 应用之间的类需要隔离。</li>
<li>两个 Web 应用都依赖同一个第三方的 JAR 包，比如 Spring，那 Spring 的 JAR 包被加载到内存后，Tomcat 要保证这两个 Web 应用能够共享，也就是说 Spring 的 JAR 包只被加载一次，否则随着依赖的第三方 JAR 包增多，JVM 的内存会膨胀。</li>
<li>需要隔离 Tomcat 本身的类和 Web 应用的类。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20201130141536.png" alt="img"></p>
<h4 id="WebAppClassLoader"><a href="#WebAppClassLoader" class="headerlink" title="WebAppClassLoader"></a>WebAppClassLoader</h4><p>针对第一个问题：</p>
<p>如果使用 JVM 默认 AppClassLoader 来加载 Web 应用，AppClassLoader 只能加载一个 Servlet 类，在加载第二个同名 Servlet 类时，AppClassLoader 会返回第一个 Servlet 类的 Class 实例，这是因为在 AppClassLoader 看来，同名的 Servlet 类只被加载一次。</p>
<p>Tomcat 的解决方案是自定义一个类加载器 WebAppClassLoader， 并且给每个 Web 应用创建一个类加载器实例。我们知道，Context 容器组件对应一个 Web 应用，因此，每个 Context 容器负责创建和维护一个 WebAppClassLoader 加载器实例。这背后的原理是，<strong>不同的加载器实例加载的类被认为是不同的类</strong>，即使它们的类名相同。这就相当于在 Java 虚拟机内部创建了一个个相互隔离的 Java 类空间，每一个 Web 应用都有自己的类空间，Web 应用之间通过各自的类加载器互相隔离。</p>
<h4 id="SharedClassLoader"><a href="#SharedClassLoader" class="headerlink" title="SharedClassLoader"></a>SharedClassLoader</h4><p>针对第二个问题：</p>
<p>本质需求是两个 Web 应用之间怎么共享库类，并且不能重复加载相同的类。我们知道，在双亲委派机制里，各个子加载器都可以通过父加载器去加载类，那么把需要共享的类放到父加载器的加载路径下不就行了吗，应用程序也正是通过这种方式共享 JRE 的核心类。因此 Tomcat 的设计者又加了一个类加载器 SharedClassLoader，作为 WebAppClassLoader 的父加载器，专门来加载 Web 应用之间共享的类。如果 WebAppClassLoader 自己没有加载到某个类，就会委托父加载器 SharedClassLoader 去加载这个类，SharedClassLoader 会在指定目录下加载共享类，之后返回给 WebAppClassLoader，这样共享的问题就解决了。</p>
<h4 id="CatalinaClassloader"><a href="#CatalinaClassloader" class="headerlink" title="CatalinaClassloader"></a>CatalinaClassloader</h4><p>如何隔离 Tomcat 本身的类和 Web 应用的类？</p>
<p>要共享可以通过父子关系，要隔离那就需要兄弟关系了。兄弟关系就是指两个类加载器是平行的，它们可能拥有同一个父加载器，但是两个兄弟类加载器加载的类是隔离的。基于此 Tomcat 又设计一个类加载器 CatalinaClassloader，专门来加载 Tomcat 自身的类。这样设计有个问题，那 Tomcat 和各 Web 应用之间需要共享一些类时该怎么办呢？</p>
<h4 id="CommonClassLoader"><a href="#CommonClassLoader" class="headerlink" title="CommonClassLoader"></a>CommonClassLoader</h4><p>老办法，还是再增加一个 CommonClassLoader，作为 CatalinaClassloader 和 SharedClassLoader 的父加载器。CommonClassLoader 能加载的类都可以被 CatalinaClassLoader 和 SharedClassLoader 使用，而 CatalinaClassLoader 和 SharedClassLoader 能加载的类则与对方相互隔离。WebAppClassLoader 可以使用 SharedClassLoader 加载到的类，但各个 WebAppClassLoader 实例之间相互隔离。</p>
<h2 id="Tomcat-实现-Servlet-规范"><a href="#Tomcat-实现-Servlet-规范" class="headerlink" title="Tomcat 实现 Servlet 规范"></a>Tomcat 实现 Servlet 规范</h2><p>Servlet 容器最重要的任务就是创建 Servlet 的实例并且调用 Servlet。</p>
<p>一个 Web 应用里往往有多个 Servlet，而在 Tomcat 中一个 Web 应用对应一个 Context 容器，也就是说一个 Context 容器需要管理多个 Servlet 实例。但 Context 容器并不直接持有 Servlet 实例，而是通过子容器 Wrapper 来管理 Servlet，你可以把 Wrapper 容器看作是 Servlet 的包装。</p>
<p>为什么需要 Wrapper 呢？Context 容器直接维护一个 Servlet 数组不就行了吗？这是因为 Servlet 不仅仅是一个类实例，它还有相关的配置信息，比如它的 URL 映射、它的初始化参数，因此设计出了一个包装器，把 Servlet 本身和它相关的数据包起来，没错，这就是面向对象的思想。</p>
<p>除此以外，Servlet 规范中还有两个重要特性：Listener 和 Filter，Tomcat 也需要创建它们的实例，并在合适的时机去调用它们的方法。</p>
<h3 id="Servlet-管理"><a href="#Servlet-管理" class="headerlink" title="Servlet 管理"></a>Servlet 管理</h3><p>Tomcat 是用 Wrapper 容器来管理 Servlet 的，那 Wrapper 容器具体长什么样子呢？我们先来看看它里面有哪些关键的成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="type">Servlet</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>它拥有一个 Servlet 实例，并且 Wrapper 通过 loadServlet 方法来实例化 Servlet。为了方便你阅读，我简化了代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Servlet <span class="title function_">loadServlet</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    Servlet servlet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 创建一个 Servlet 实例</span></span><br><span class="line">    servlet = (Servlet) instanceManager.newInstance(servletClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 调用了 Servlet 的 init 方法，这是 Servlet 规范要求的</span></span><br><span class="line">    initServlet(servlet);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> servlet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实 loadServlet 主要做了两件事：创建 Servlet 的实例，并且调用 Servlet 的 init 方法，因为这是 Servlet 规范要求的。</p>
<p>那接下来的问题是，什么时候会调到这个 loadServlet 方法呢？为了加快系统的启动速度，我们往往会采取资源延迟加载的策略，Tomcat 也不例外，默认情况下 Tomcat 在启动时不会加载你的 Servlet，除非你把 Servlet 的<code>loadOnStartup</code>参数设置为<code>true</code>。</p>
<p>这里还需要你注意的是，虽然 Tomcat 在启动时不会创建 Servlet 实例，但是会创建 Wrapper 容器，就好比尽管枪里面还没有子弹，先把枪造出来。那子弹什么时候造呢？是真正需要开枪的时候，也就是说有请求来访问某个 Servlet 时，这个 Servlet 的实例才会被创建。</p>
<p>那 Servlet 是被谁调用的呢？我们回忆一下专栏前面提到过 Tomcat 的 Pipeline-Valve 机制，每个容器组件都有自己的 Pipeline，每个 Pipeline 中有一个 Valve 链，并且每个容器组件有一个 BasicValve（基础阀）。Wrapper 作为一个容器组件，它也有自己的 Pipeline 和 BasicValve，Wrapper 的 BasicValve 叫 <strong>StandardWrapperValve</strong>。</p>
<p>你可以想到，当请求到来时，Context 容器的 BasicValve 会调用 Wrapper 容器中 Pipeline 中的第一个 Valve，然后会调用到 StandardWrapperValve。我们先来看看它的 invoke 方法是如何实现的，同样为了方便你阅读，我简化了代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Request request, Response response)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 实例化 Servlet</span></span><br><span class="line">    servlet = wrapper.allocate();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 给当前请求创建一个 Filter 链</span></span><br><span class="line">    <span class="type">ApplicationFilterChain</span> <span class="variable">filterChain</span> <span class="operator">=</span></span><br><span class="line">        ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3. 调用这个 Filter 链，Filter 链中的最后一个 Filter 会调用 Servlet</span></span><br><span class="line">   filterChain.doFilter(request.getRequest(), response.getResponse());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StandardWrapperValve 的 invoke 方法比较复杂，去掉其他异常处理的一些细节，本质上就是三步：</p>
<ul>
<li>第一步，创建 Servlet 实例；</li>
<li>第二步，给当前请求创建一个 Filter 链；</li>
<li>第三步，调用这个 Filter 链。</li>
</ul>
<p>你可能会问，为什么需要给每个请求创建一个 Filter 链？这是因为每个请求的请求路径都不一样，而 Filter 都有相应的路径映射，因此不是所有的 Filter 都需要来处理当前的请求，我们需要根据请求的路径来选择特定的一些 Filter 来处理。</p>
<p>第二个问题是，为什么没有看到调到 Servlet 的 service 方法？这是因为 Filter 链的 doFilter 方法会负责调用 Servlet，具体来说就是 Filter 链中的最后一个 Filter 会负责调用 Servlet。</p>
<p>接下来我们来看 Filter 的实现原理。</p>
<h3 id="Filter-管理"><a href="#Filter-管理" class="headerlink" title="Filter 管理"></a>Filter 管理</h3><p>我们知道，跟 Servlet 一样，Filter 也可以在<code>web.xml</code>文件里进行配置，不同的是，Filter 的作用域是整个 Web 应用，因此 Filter 的实例是在 Context 容器中进行管理的，Context 容器用 Map 集合来保存 Filter。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, FilterDef&gt; filterDefs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>那上面提到的 Filter 链又是什么呢？Filter 链的存活期很短，它是跟每个请求对应的。一个新的请求来了，就动态创建一个 FIlter 链，请求处理完了，Filter 链也就被回收了。理解它的原理也非常关键，我们还是来看看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ApplicationFilterChain</span> <span class="keyword">implements</span> <span class="title class_">FilterChain</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Filter 链中有 Filter 数组，这个好理解</span></span><br><span class="line">  <span class="keyword">private</span> ApplicationFilterConfig[] filters = <span class="keyword">new</span> <span class="title class_">ApplicationFilterConfig</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Filter 链中的当前的调用位置</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 总共有多少了 Filter</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 每个 Filter 链对应一个 Servlet，也就是它要调用的 Servlet</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">Servlet</span> <span class="variable">servlet</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse res)</span> &#123;</span><br><span class="line">        internalDoFilter(request,response);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">internalDoFilter</span><span class="params">(ServletRequest req,</span></span><br><span class="line"><span class="params">                                ServletResponse res)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个 Filter 链在内部维护了一个 Filter 数组</span></span><br><span class="line">    <span class="keyword">if</span> (pos &lt; n) &#123;</span><br><span class="line">        <span class="type">ApplicationFilterConfig</span> <span class="variable">filterConfig</span> <span class="operator">=</span> filters[pos++];</span><br><span class="line">        <span class="type">Filter</span> <span class="variable">filter</span> <span class="operator">=</span> filterConfig.getFilter();</span><br><span class="line"></span><br><span class="line">        filter.doFilter(request, response, <span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    servlet.service(request, response);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 ApplicationFilterChain 的源码我们可以看到几个关键信息：</p>
<ul>
<li>Filter 链中除了有 Filter 对象的数组，还有一个整数变量 pos，这个变量用来记录当前被调用的 Filter 在数组中的位置。</li>
<li>Filter 链中有个 Servlet 实例，这个好理解，因为上面提到了，每个 Filter 链最后都会调到一个 Servlet。</li>
<li>Filter 链本身也实现了 doFilter 方法，直接调用了一个内部方法 internalDoFilter。</li>
<li>internalDoFilter 方法的实现比较有意思，它做了一个判断，如果当前 Filter 的位置小于 Filter 数组的长度，也就是说 Filter 还没调完，就从 Filter 数组拿下一个 Filter，调用它的 doFilter 方法。否则，意味着所有 Filter 都调到了，就调用 Servlet 的 service 方法。</li>
</ul>
<p>但问题是，方法体里没看到循环，谁在不停地调用 Filter 链的 doFIlter 方法呢？Filter 是怎么依次调到的呢？</p>
<p>答案是<strong>Filter 本身的 doFilter 方法会调用 Filter 链的 doFilter 方法</strong>，我们还是来看看代码就明白了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response,</span></span><br><span class="line"><span class="params">        FilterChain chain)</span>&#123;</span><br><span class="line"></span><br><span class="line">          ...</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 调用 Filter 的方法</span></span><br><span class="line">          chain.doFilter(request, response);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>注意 Filter 的 doFilter 方法有个关键参数 FilterChain，就是 Filter 链。并且每个 Filter 在实现 doFilter 时，必须要调用 Filter 链的 doFilter 方法，而 Filter 链中保存当前 FIlter 的位置，会调用下一个 FIlter 的 doFilter 方法，这样链式调用就完成了。</p>
<p>Filter 链跟 Tomcat 的 Pipeline-Valve 本质都是责任链模式，但是在具体实现上稍有不同，你可以细细体会一下。</p>
<h3 id="Listener-管理"><a href="#Listener-管理" class="headerlink" title="Listener 管理"></a>Listener 管理</h3><p>我们接着聊 Servlet 规范里 Listener。跟 Filter 一样，Listener 也是一种扩展机制，你可以监听容器内部发生的事件，主要有两类事件：</p>
<ul>
<li>第一类是生命状态的变化，比如 Context 容器启动和停止、Session 的创建和销毁。</li>
<li>第二类是属性的变化，比如 Context 容器某个属性值变了、Session 的某个属性值变了以及新的请求来了等。</li>
</ul>
<p>我们可以在<code>web.xml</code>配置或者通过注解的方式来添加监听器，在监听器里实现我们的业务逻辑。对于 Tomcat 来说，它需要读取配置文件，拿到监听器类的名字，实例化这些类，并且在合适的时机调用这些监听器的方法。</p>
<p>Tomcat 是通过 Context 容器来管理这些监听器的。Context 容器将两类事件分开来管理，分别用不同的集合来存放不同类型事件的监听器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听属性值变化的监听器</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Object&gt; applicationEventListenersList = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听生命事件的监听器</span></span><br><span class="line"><span class="keyword">private</span> Object applicationLifecycleListenersObjects[] = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>剩下的事情就是触发监听器了，比如在 Context 容器的启动方法里，就触发了所有的 ServletContextListener：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 拿到所有的生命周期监听器</span></span><br><span class="line">Object instances[] = getApplicationLifecycleListeners();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; instances.length; i++) &#123;</span><br><span class="line">   <span class="comment">//2. 判断 Listener 的类型是不是 ServletContextListener</span></span><br><span class="line">   <span class="keyword">if</span> (!(instances[i] <span class="keyword">instanceof</span> ServletContextListener))</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3. 触发 Listener 的方法</span></span><br><span class="line">   <span class="type">ServletContextListener</span> <span class="variable">lr</span> <span class="operator">=</span> (ServletContextListener) instances[i];</span><br><span class="line">   lr.contextInitialized(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，这里的 ServletContextListener 接口是一种留给用户的扩展机制，用户可以实现这个接口来定义自己的监听器，监听 Context 容器的启停事件。Spring 就是这么做的。ServletContextListener 跟 Tomcat 自己的生命周期事件 LifecycleListener 是不同的。LifecycleListener 定义在生命周期管理组件中，由基类 LifeCycleBase 统一管理。</p>
<h2 id="Tomcat-支持异步-Servlet"><a href="#Tomcat-支持异步-Servlet" class="headerlink" title="Tomcat 支持异步 Servlet"></a>Tomcat 支持异步 Servlet</h2><h3 id="异步示例"><a href="#异步示例" class="headerlink" title="异步示例"></a>异步示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &#123;&quot;/async&quot;&#125;, asyncSupported = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Web 应用线程池，用来处理异步 Servlet</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 调用 startAsync 或者异步上下文</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">AsyncContext</span> <span class="variable">ctx</span> <span class="operator">=</span> req.startAsync();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 用线程池来执行耗时操作</span></span><br><span class="line">        executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 在这里做耗时的操作</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ctx.getResponse().getWriter().println(<span class="string">&quot;Handling Async Servlet&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;&#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//3. 异步 Servlet 处理完了调用异步上下文的 complete 方法</span></span><br><span class="line">                ctx.complete();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有三个要点：</p>
<ol>
<li>通过注解的方式来注册 Servlet，除了 @WebServlet 注解，还需要加上 asyncSupported&#x3D;true 的属性，表明当前的 Servlet 是一个异步 Servlet。</li>
<li>Web 应用程序需要调用 Request 对象的 startAsync 方法来拿到一个异步上下文 AsyncContext。这个上下文保存了请求和响应对象。</li>
<li>Web 应用需要开启一个新线程来处理耗时的操作，处理完成后需要调用 AsyncContext 的 complete 方法。目的是告诉 Tomcat，请求已经处理完成。</li>
</ol>
<p>这里请你注意，虽然异步 Servlet 允许用更长的时间来处理请求，但是也有超时限制的，默认是 30 秒，如果 30 秒内请求还没处理完，Tomcat 会触发超时机制，向浏览器返回超时错误，如果这个时候你的 Web 应用再调用<code>ctx.complete</code>方法，会得到一个 IllegalStateException 异常。</p>
<h3 id="异步-Servlet-原理"><a href="#异步-Servlet-原理" class="headerlink" title="异步 Servlet 原理"></a>异步 Servlet 原理</h3><p>通过上面的例子，相信你对 Servlet 的异步实现有了基本的理解。要理解 Tomcat 在这个过程都做了什么事情，关键就是要弄清楚<code>req.startAsync</code>方法和<code>ctx.complete</code>方法都做了什么。</p>
<h4 id="startAsync-方法"><a href="#startAsync-方法" class="headerlink" title="startAsync 方法"></a>startAsync 方法</h4><p>startAsync 方法其实就是创建了一个异步上下文 AsyncContext 对象，AsyncContext 对象的作用是保存请求的中间信息，比如 Request 和 Response 对象等上下文信息。你来思考一下为什么需要保存这些信息呢？</p>
<p>这是因为 Tomcat 的工作线程在<code>Request.startAsync</code>调用之后，就直接结束回到线程池中了，线程本身不会保存任何信息。也就是说一个请求到服务端，执行到一半，你的 Web 应用正在处理，这个时候 Tomcat 的工作线程没了，这就需要有个缓存能够保存原始的 Request 和 Response 对象，而这个缓存就是 AsyncContext。</p>
<p>有了 AsyncContext，你的 Web 应用通过它拿到 request 和 response 对象，拿到 Request 对象后就可以读取请求信息，请求处理完了还需要通过 Response 对象将 HTTP 响应发送给浏览器。</p>
<p>除了创建 AsyncContext 对象，startAsync 还需要完成一个关键任务，那就是告诉 Tomcat 当前的 Servlet 处理方法返回时，不要把响应发到浏览器，因为这个时候，响应还没生成呢；并且不能把 Request 对象和 Response 对象销毁，因为后面 Web 应用还要用呢。</p>
<p>在 Tomcat 中，负责 flush 响应数据的是 CoyoteAdaptor，它还会销毁 Request 对象和 Response 对象，因此需要通过某种机制通知 CoyoteAdaptor，具体来说是通过下面这行代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.request.getCoyoteRequest().action(ActionCode.ASYNC_START, <span class="built_in">this</span>);</span><br></pre></td></tr></table></figure>

<p>你可以把它理解为一个 Callback，在这个 action 方法里设置了 Request 对象的状态，设置它为一个异步 Servlet 请求。</p>
<p>我们知道连接器是调用 CoyoteAdapter 的 service 方法来处理请求的，而 CoyoteAdapter 会调用容器的 service 方法，当容器的 service 方法返回时，CoyoteAdapter 判断当前的请求是不是异步 Servlet 请求，如果是，就不会销毁 Request 和 Response 对象，也不会把响应信息发到浏览器。你可以通过下面的代码理解一下，这是 CoyoteAdapter 的 service 方法，我对它进行了简化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(org.apache.coyote.Request req, org.apache.coyote.Response res)</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 调用容器的 service 方法处理请求</span></span><br><span class="line">    connector.getService().getContainer().getPipeline().</span><br><span class="line">           getFirst().invoke(request, response);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果是异步 Servlet 请求，仅仅设置一个标志，</span></span><br><span class="line">   <span class="comment">// 否则说明是同步 Servlet 请求，就将响应数据刷到浏览器</span></span><br><span class="line">    <span class="keyword">if</span> (request.isAsync()) &#123;</span><br><span class="line">        async = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        request.finishRequest();</span><br><span class="line">        response.finishResponse();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果不是异步 Servlet 请求，就销毁 Request 对象和 Response 对象</span></span><br><span class="line">    <span class="keyword">if</span> (!async) &#123;</span><br><span class="line">        request.recycle();</span><br><span class="line">        response.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，当 CoyoteAdaptor 的 service 方法返回到 ProtocolHandler 组件时，ProtocolHandler 判断返回值，如果当前请求是一个异步 Servlet 请求，它会把当前 Socket 的协议处理者 Processor 缓存起来，将 SocketWrapper 对象和相应的 Processor 存到一个 Map 数据结构里。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;S,Processor&gt; connections = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>之所以要缓存是因为这个请求接下来还要接着处理，还是由原来的 Processor 来处理，通过 SocketWrapper 就能从 Map 里找到相应的 Processor。</p>
<h4 id="complete-方法"><a href="#complete-方法" class="headerlink" title="complete 方法"></a>complete 方法</h4><p>接着我们再来看关键的<code>ctx.complete</code>方法，当请求处理完成时，Web 应用调用这个方法。那么这个方法做了些什么事情呢？最重要的就是把响应数据发送到浏览器。</p>
<p>这件事情不能由 Web 应用线程来做，也就是说<code>ctx.complete</code>方法不能直接把响应数据发送到浏览器，因为这件事情应该由 Tomcat 线程来做，但具体怎么做呢？</p>
<p>我们知道，连接器中的 Endpoint 组件检测到有请求数据达到时，会创建一个 SocketProcessor 对象交给线程池去处理，因此 Endpoint 的通信处理和具体请求处理在两个线程里运行。</p>
<p>在异步 Servlet 的场景里，Web 应用通过调用<code>ctx.complete</code>方法时，也可以生成一个新的 SocketProcessor 任务类，交给线程池处理。对于异步 Servlet 请求来说，相应的 Socket 和协议处理组件 Processor 都被缓存起来了，并且这些对象都可以通过 Request 对象拿到。</p>
<p>讲到这里，你可能已经猜到<code>ctx.complete</code>是如何实现的了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">complete</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 检查状态合法性，我们先忽略这句</span></span><br><span class="line">    check();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 Request 对象的 action 方法，其实就是通知连接器，这个异步请求处理完了</span></span><br><span class="line">request.getCoyoteRequest().action(ActionCode.ASYNC_COMPLETE, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到 complete 方法调用了 Request 对象的 action 方法。而在 action 方法里，则是调用了 Processor 的 processSocketEvent 方法，并且传入了操作码 OPEN_READ。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> ASYNC_COMPLETE: &#123;</span><br><span class="line">    clearDispatches();</span><br><span class="line">    <span class="keyword">if</span> (asyncStateMachine.asyncComplete()) &#123;</span><br><span class="line">        processSocketEvent(SocketEvent.OPEN_READ, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们接着看 processSocketEvent 方法，它调用 SocketWrapper 的 processSocket 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processSocketEvent</span><span class="params">(SocketEvent event, <span class="type">boolean</span> dispatch)</span> &#123;</span><br><span class="line">    SocketWrapperBase&lt;?&gt; socketWrapper = getSocketWrapper();</span><br><span class="line">    <span class="keyword">if</span> (socketWrapper != <span class="literal">null</span>) &#123;</span><br><span class="line">        socketWrapper.processSocket(event, dispatch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 SocketWrapper 的 processSocket 方法会创建 SocketProcessor 任务类，并通过 Tomcat 线程池来处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">processSocket</span><span class="params">(SocketWrapperBase&lt;S&gt; socketWrapper,</span></span><br><span class="line"><span class="params">        SocketEvent event, <span class="type">boolean</span> dispatch)</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (socketWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      SocketProcessorBase&lt;S&gt; sc = processorCache.pop();</span><br><span class="line">      <span class="keyword">if</span> (sc == <span class="literal">null</span>) &#123;</span><br><span class="line">          sc = createSocketProcessor(socketWrapper, event);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          sc.reset(socketWrapper, event);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 线程池运行</span></span><br><span class="line">      <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> getExecutor();</span><br><span class="line">      <span class="keyword">if</span> (dispatch &amp;&amp; executor != <span class="literal">null</span>) &#123;</span><br><span class="line">          executor.execute(sc);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          sc.run();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请你注意 createSocketProcessor 函数的第二个参数是 SocketEvent，这里我们传入的是 OPEN_READ。通过这个参数，我们就能控制 SocketProcessor 的行为，因为我们不需要再把请求发送到容器进行处理，只需要向浏览器端发送数据，并且重新在这个 Socket 上监听新的请求就行了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><strong>官方</strong><ul>
<li><a target="_blank" rel="noopener" href="http://tomcat.apache.org/">Tomcat 官方网站</a></li>
<li><a target="_blank" rel="noopener" href="http://wiki.apache.org/tomcat/FrontPage">Tomcat Wiki</a></li>
<li><a target="_blank" rel="noopener" href="http://tomee.apache.org/">Tomee 官方网站</a></li>
</ul>
</li>
<li><strong>教程</strong><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100027701">深入拆解 Tomcat &amp; Jetty</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/f37326/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/f37326/" class="post-title-link" itemprop="url">Tomcat 和 Jetty</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-17 22:34:30" itemprop="dateCreated datePublished" datetime="2022-02-17T22:34:30+08:00">2022-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JavaEE/" itemprop="url" rel="index"><span itemprop="name">JavaEE</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JavaEE/%E6%9C%8D%E5%8A%A1%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">服务器</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JavaEE/%E6%9C%8D%E5%8A%A1%E5%99%A8/Tomcat/" itemprop="url" rel="index"><span itemprop="name">Tomcat</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>845</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Tomcat-和-Jetty"><a href="#Tomcat-和-Jetty" class="headerlink" title="Tomcat 和 Jetty"></a>Tomcat 和 Jetty</h2><p>Web 容器 Tomcat 或 Jetty，作为重要的系统中间件，连接着浏览器和你的 Web 应用，并且支撑着 Web 程序的运行，可以说，<strong>弄懂了 Tomcat 和 Jetty 的原理，Java Web 开发对你来说就毫无秘密可言</strong>。</p>
<h2 id="Web-容器"><a href="#Web-容器" class="headerlink" title="Web 容器"></a>Web 容器</h2><p>早期的 Web 应用主要用于浏览新闻等静态页面，HTTP 服务器（比如 Apache、Nginx）向浏览器返回静态 HTML，浏览器负责解析 HTML，将结果呈现给用户。</p>
<p>随着互联网的发展，我们已经不满足于仅仅浏览静态页面，还希望通过一些交互操作，来获取动态结果，因此也就需要一些扩展机制能够让 HTTP 服务器调用服务端程序。</p>
<p>于是 Sun 公司推出了 Servlet 技术。你可以把 Servlet 简单理解为运行在服务端的 Java 小程序，但是 Servlet 没有 main 方法，不能独立运行，因此必须把它部署到 Servlet 容器中，由容器来实例化并调用 Servlet。</p>
<p>而 Tomcat 和 Jetty 就是一个 Servlet 容器。为了方便使用，它们也具有 HTTP 服务器的功能，因此<strong>Tomcat 或者 Jetty 就是一个“HTTP 服务器 + Servlet 容器”，我们也叫它们 Web 容器。</strong></p>
<p>其他应用服务器比如 JBoss 和 WebLogic，它们不仅仅有 Servlet 容器的功能，也包含 EJB 容器，是完整的 Java EE 应用服务器。从这个角度看，Tomcat 和 Jetty 算是一个轻量级的应用服务器。</p>
<p>在微服务架构日渐流行的今天，开发人员更喜欢稳定的、轻量级的应用服务器，并且应用程序用内嵌的方式来运行 Servlet 容器也逐渐流行起来。之所以选择轻量级，是因为在微服务架构下，我们把一个大而全的单体应用，拆分成一个个功能单一的微服务，在这个过程中，服务的数量必然要增加，但为了减少资源的消耗，并且降低部署的成本，我们希望运行服务的 Web 容器也是轻量级的，Web 容器本身应该消耗较少的内存和 CPU 资源，并且由应用本身来启动一个嵌入式的 Web 容器，而不是通过 Web 容器来部署和启动应用，这样可以降低应用部署的复杂度。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/f9e1e6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/f9e1e6/" class="post-title-link" itemprop="url">Tomcat优化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-17 22:34:30" itemprop="dateCreated datePublished" datetime="2022-02-17T22:34:30+08:00">2022-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JavaEE/" itemprop="url" rel="index"><span itemprop="name">JavaEE</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JavaEE/%E6%9C%8D%E5%8A%A1%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">服务器</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JavaEE/%E6%9C%8D%E5%8A%A1%E5%99%A8/Tomcat/" itemprop="url" rel="index"><span itemprop="name">Tomcat</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Tomcat-优化"><a href="#Tomcat-优化" class="headerlink" title="Tomcat 优化"></a>Tomcat 优化</h1><h2 id="Tomcat-启动优化"><a href="#Tomcat-启动优化" class="headerlink" title="Tomcat 启动优化"></a>Tomcat 启动优化</h2><p>如果 Tomcat 启动比较慢，可以考虑一些优化点</p>
<h3 id="清理-Tomcat"><a href="#清理-Tomcat" class="headerlink" title="清理 Tomcat"></a>清理 Tomcat</h3><ul>
<li><strong>清理不必要的 Web 应用</strong>：首先我们要做的是删除掉 webapps 文件夹下不需要的工程，一般是 host-manager、example、doc 等这些默认的工程，可能还有以前添加的但现在用不着的工程，最好把这些全都删除掉。</li>
<li><strong>清理 XML 配置文件</strong>：Tomcat 在启动时会解析所有的 XML 配置文件，解析 XML 较为耗时，所以应该尽量保持配置文件的简洁。</li>
<li><strong>清理 JAR 文件</strong>：JVM 的类加载器在加载类时，需要查找每一个 JAR 文件，去找到所需要的类。如果删除了不需要的 JAR 文件，查找的速度就会快一些。这里请注意：<strong>Web 应用中的 lib 目录下不应该出现 Servlet API 或者 Tomcat 自身的 JAR</strong>，这些 JAR 由 Tomcat 负责提供。</li>
<li><strong>清理其他文件</strong>：及时清理日志，删除 logs 文件夹下不需要的日志文件。同样还有 work 文件夹下的 catalina 文件夹，它其实是 Tomcat 把 JSP 转换为 Class 文件的工作目录。有时候我们也许会遇到修改了代码，重启了 Tomcat，但是仍没效果，这时候便可以删除掉这个文件夹，Tomcat 下次启动的时候会重新生成。</li>
</ul>
<h3 id="禁止-Tomcat-TLD-扫描"><a href="#禁止-Tomcat-TLD-扫描" class="headerlink" title="禁止 Tomcat TLD 扫描"></a>禁止 Tomcat TLD 扫描</h3><p>Tomcat 为了支持 JSP，在应用启动的时候会扫描 JAR 包里面的 TLD 文件，加载里面定义的标签库。所以在 Tomcat 的启动日志里，你可能会碰到这种提示：</p>
<blockquote>
<p>At least one JAR was scanned for TLDs yet contained no TLDs. Enable debug logging for this logger for a complete list of JARs that were scanned but no TLDs were found in them. Skipping unneeded JARs during scanning can improve startup time and JSP compilation time.</p>
</blockquote>
<p>Tomcat 的意思是，我扫描了你 Web 应用下的 JAR 包，发现 JAR 包里没有 TLD 文件。我建议配置一下 Tomcat 不要去扫描这些 JAR 包，这样可以提高 Tomcat 的启动速度，并节省 JSP 编译时间。</p>
<p>如何配置不去扫描这些 JAR 包呢，这里分两种情况：</p>
<ul>
<li><p>如果你的项目没有使用 JSP 作为 Web 页面模板，而是使用 Velocity 之类的模板引擎，你完全可以把 TLD 扫描禁止掉。方法是，找到 Tomcat 的<code>conf/</code>目录下的<code>context.xml</code>文件，在这个文件里 Context 标签下，加上<strong>JarScanner</strong>和<strong>JarScanFilter</strong>子标签，像下面这样。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">JarScanner</span> &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">JarScanFilter</span> <span class="attr">defaultTldScan</span>=<span class="string">&quot;true&quot;</span> <span class="attr">defaultpluggabilityScan</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">JarScanner</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Context</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果你的项目使用了 JSP 作为 Web 页面模块，意味着 TLD 扫描无法避免，但是我们可以通过配置来告诉 Tomcat，只扫描那些包含 TLD 文件的 JAR 包。方法是，找到 Tomcat 的<code>conf/</code>目录下的<code>catalina.properties</code>文件，在这个文件里的 jarsToSkip 配置项中，加上你的 JAR 包。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tomcat<span class="selector-class">.util</span><span class="selector-class">.scan</span><span class="selector-class">.StandardJarScanFilter</span>.jarsToSkip=xxx.jar</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="关闭-WebSocket-支持"><a href="#关闭-WebSocket-支持" class="headerlink" title="关闭 WebSocket 支持"></a>关闭 WebSocket 支持</h3><p>Tomcat 会扫描 WebSocket 注解的 API 实现，比如 <code>@ServerEndpoint</code> 注解的类。如果不需要使用 WebSockets 就可以关闭它。具体方法是，找到 Tomcat 的 <code>conf/</code> 目录下的 <code>context.xml</code> 文件，给 <code>Context</code> 标签加一个 <strong><code>containerSciFilter</code></strong> 的属性：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">containerSciFilter</span>=<span class="string">&quot;org.apache.tomcat.websocket.server.WsSci&quot;</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">Context</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>更进一步，如果你不需要 WebSockets 这个功能，你可以把 Tomcat <code>lib</code> 目录下的 <code>websocket-api.jar</code> 和 <code>tomcat-websocket.jar</code> 这两个 JAR 文件删除掉，进一步提高性能。</p>
<h3 id="关闭-JSP-支持"><a href="#关闭-JSP-支持" class="headerlink" title="关闭 JSP 支持"></a>关闭 JSP 支持</h3><p>如果不需要使用 JSP，可以关闭 JSP 功能：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">containerSciFilter</span>=<span class="string">&quot;org.apache.jasper.servlet.JasperInitializer&quot;</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">Context</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果要同时关闭 WebSocket 和 Jsp，可以这样配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">containerSciFilter</span>=<span class="string">&quot;org.apache.tomcat.websocket.server.WsSci | org.apache.jasper.servlet.JasperInitializer&quot;</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">Context</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="禁止扫描-Servlet-注解"><a href="#禁止扫描-Servlet-注解" class="headerlink" title="禁止扫描 Servlet 注解"></a>禁止扫描 Servlet 注解</h3><p>Servlet 3.0 引入了注解 Servlet，Tomcat 为了支持这个特性，会在 Web 应用启动时扫描你的类文件，因此如果你没有使用 Servlet 注解这个功能，可以告诉 Tomcat 不要去扫描 Servlet 注解。具体配置方法是，在你的 Web 应用的<code>web.xml</code>文件中，设置<code>&lt;web-app&gt;</code>元素的属性<code>metadata-complete=&quot;true&quot;</code>，像下面这样。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">metadata-complete</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>metadata-complete</code> 的意思是，<code>web.xml</code> 里配置的 Servlet 是完整的，不需要再去库类中找 Servlet 的定义。</p>
<h3 id="配置-Web-Fragment-扫描"><a href="#配置-Web-Fragment-扫描" class="headerlink" title="配置 Web-Fragment 扫描"></a>配置 Web-Fragment 扫描</h3><p>Servlet 3.0 还引入了“Web 模块部署描述符片段”的 <code>web-fragment.xml</code>，这是一个部署描述文件，可以完成 <code>web.xml</code> 的配置功能。而这个 <code>web-fragment.xml</code> 文件必须存放在 JAR 文件的 <code>META-INF</code> 目录下，而 JAR 包通常放在 <code>WEB-INF/lib</code> 目录下，因此 Tomcat 需要对 JAR 文件进行扫描才能支持这个功能。</p>
<p>可以通过配置 <code>web.xml</code> 里面的 <code>&lt;absolute-ordering&gt;</code> 元素直接指定了哪些 JAR 包需要扫描 <code>web fragment</code>，如果 <code>&lt;absolute-ordering/&gt;</code> 元素是空的， 则表示不需要扫描，像下面这样。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">metadata-complete</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">absolute-ordering</span> /&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="随机数熵源优化"><a href="#随机数熵源优化" class="headerlink" title="随机数熵源优化"></a>随机数熵源优化</h3><p>Tomcat 7 以上的版本依赖 Java 的 SecureRandom 类来生成随机数，比如 Session ID。而 JVM 默认使用阻塞式熵源（<code>/dev/random</code>）， 在某些情况下就会导致 Tomcat 启动变慢。当阻塞时间较长时， 你会看到这样一条警告日志：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;DATE&gt; org.apache.catalina.util.SessionIdGenerator createSecureRandom</span><br><span class="line">INFO: Creation of SecureRandom<span class="built_in"> instance </span>for session ID generation using [SHA1PRNG] took [8152] milliseconds.</span><br></pre></td></tr></table></figure>

<p>解决方案是通过设置，让 JVM 使用非阻塞式的熵源。</p>
<p>我们可以设置 JVM 的参数：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Djava.security.egd=<span class="keyword">file</span>:<span class="regexp">/dev/</span>./urandom</span><br></pre></td></tr></table></figure>

<p>或者是设置 <code>java.security</code> 文件，位于 <code>$JAVA_HOME/jre/lib/security</code> 目录之下： <code>securerandom.source=file:/dev/./urandom</code></p>
<p>这里请你注意，<code>/dev/./urandom</code> 中间有个 <code>./</code> 的原因是 Oracle JRE 中的 Bug，Java 8 里面的 SecureRandom 类已经修正这个 Bug。 阻塞式的熵源（<code>/dev/random</code>）安全性较高， 非阻塞式的熵源（<code>/dev/./urandom</code>）安全性会低一些，因为如果你对随机数的要求比较高， 可以考虑使用硬件方式生成熵源。</p>
<h3 id="并行启动多个-Web-应用"><a href="#并行启动多个-Web-应用" class="headerlink" title="并行启动多个 Web 应用"></a>并行启动多个 Web 应用</h3><p>Tomcat 启动的时候，默认情况下 Web 应用都是一个一个启动的，等所有 Web 应用全部启动完成，Tomcat 才算启动完毕。如果在一个 Tomcat 下有多个 Web 应用，为了优化启动速度，你可以配置多个应用程序并行启动，可以通过修改 <code>server.xml</code> 中 Host 元素的 <code>startStopThreads</code> 属性来完成。<code>startStopThreads</code> 的值表示你想用多少个线程来启动你的 Web 应用，如果设成 0 表示你要并行启动 Web 应用，像下面这样的配置。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Engine</span> <span class="attr">startStopThreads</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">Host</span> <span class="attr">startStopThreads</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，Engine 元素里也配置了这个参数，这意味着如果你的 Tomcat 配置了多个 Host（虚拟主机），Tomcat 会以并行的方式启动多个 Host。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><strong>官方</strong><ul>
<li><a target="_blank" rel="noopener" href="http://tomcat.apache.org/">Tomcat 官方网站</a></li>
<li><a target="_blank" rel="noopener" href="http://wiki.apache.org/tomcat/FrontPage">Tomcat Wiki</a></li>
<li><a target="_blank" rel="noopener" href="http://tomee.apache.org/">Tomee 官方网站</a></li>
</ul>
</li>
<li><strong>教程</strong><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100027701">深入拆解 Tomcat &amp; Jetty</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/baf673/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/baf673/" class="post-title-link" itemprop="url">消息队列面试</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-17 22:34:30" itemprop="dateCreated datePublished" datetime="2022-02-17T22:34:30+08:00">2022-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:53" itemprop="dateModified" datetime="2024-12-12T10:02:53+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/" itemprop="url" rel="index"><span itemprop="name">分布式通信</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/MQ/" itemprop="url" rel="index"><span itemprop="name">MQ</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/MQ/MQ%E7%BB%BC%E5%90%88/" itemprop="url" rel="index"><span itemprop="name">MQ综合</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>13k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>12 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="消息队列面试夺命连环问"><a href="#消息队列面试夺命连环问" class="headerlink" title="消息队列面试夺命连环问"></a>消息队列面试夺命连环问</h1><h2 id="为什么使用消息队列？"><a href="#为什么使用消息队列？" class="headerlink" title="为什么使用消息队列？"></a>为什么使用消息队列？</h2><h3 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h3><p>看这么个场景。A 系统发送数据到 BCD 三个系统，通过接口调用发送。如果 E 系统也要这个数据呢？那如果 C 系统现在不需要了呢？A 系统负责人几乎崩溃……</p>
<p><img src="https://github.com/doocs/advanced-java/blob/master/images/mq-1.png" alt="img"></p>
<p>在这个场景中，A 系统跟其它各种乱七八糟的系统严重耦合，A 系统产生一条比较关键的数据，很多系统都需要 A 系统将这个数据发送过来。A 系统要时时刻刻考虑 BCDE 四个系统如果挂了该咋办？要不要重发，要不要把消息存起来？头发都白了啊！</p>
<p>如果使用 MQ，A 系统产生一条数据，发送到 MQ 里面去，哪个系统需要数据自己去 MQ 里面消费。如果新系统需要数据，直接从 MQ 里消费即可；如果某个系统不需要这条数据了，就取消对 MQ 消息的消费即可。这样下来，A 系统压根儿不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。</p>
<p><img src="https://github.com/doocs/advanced-java/blob/master/images/mq-2.png" alt="img"></p>
<p><strong>总结</strong>：通过一个 MQ，Pub&#x2F;Sub 发布订阅消息这么一个模型，A 系统就跟其它系统彻底解耦了。</p>
<p><strong>面试技巧</strong>：你需要去考虑一下你负责的系统中是否有类似的场景，就是一个系统或者一个模块，调用了多个系统或者模块，互相之间的调用很复杂，维护起来很麻烦。但是其实这个调用是不需要直接同步调用接口的，如果用 MQ 给它异步化解耦，也是可以的，你就需要去考虑在你的项目里，是不是可以运用这个 MQ 去进行系统的解耦。在简历中体现出来这块东西，用 MQ 作解耦。</p>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>再来看一个场景，A 系统接收一个请求，需要在自己本地写库，还需要在 BCD 三个系统写库，自己本地写库要 3ms，BCD 三个系统分别写库要 300ms、450ms、200ms。最终请求总延时是 3 + 300 + 450 + 200 &#x3D; 953ms，接近 1s，用户感觉搞个什么东西，慢死了慢死了。用户通过浏览器发起请求，等待个 1s，这几乎是不可接受的。</p>
<p><img src="https://github.com/doocs/advanced-java/blob/master/images/mq-3.png" alt="img"></p>
<p>一般互联网类的企业，对于用户直接的操作，一般要求是每个请求都必须在 200 ms 以内完成，对用户几乎是无感知的。</p>
<p>如果<strong>使用 MQ</strong>，那么 A 系统连续发送 3 条消息到 MQ 队列中，假如耗时 5ms，A 系统从接受一个请求到返回响应给用户，总时长是 3 + 5 &#x3D; 8ms，对于用户而言，其实感觉上就是点个按钮，8ms 以后就直接返回了，爽！网站做得真好，真快！</p>
<p><img src="https://github.com/doocs/advanced-java/blob/master/images/mq-4.png" alt="img"></p>
<h3 id="削峰"><a href="#削峰" class="headerlink" title="削峰"></a>削峰</h3><p>每天 0:00 到 12:00，A 系统风平浪静，每秒并发请求数量就 50 个。结果每次一到 12:00 ~ 13:00 ，每秒并发请求数量突然会暴增到 5k+ 条。但是系统是直接基于 MySQL 的，大量的请求涌入 MySQL，每秒钟对 MySQL 执行约 5k 条 SQL。</p>
<p>一般的 MySQL，扛到每秒 2k 个请求就差不多了，如果每秒请求到 5k 的话，可能就直接把 MySQL 给打死了，导致系统崩溃，用户也就没法再使用系统了。</p>
<p>但是高峰期一过，到了下午的时候，就成了低峰期，可能也就 1w 的用户同时在网站上操作，每秒中的请求数量可能也就 50 个请求，对整个系统几乎没有任何的压力。</p>
<p><img src="https://github.com/doocs/advanced-java/blob/master/images/mq-5.png" alt="img"></p>
<p>如果使用 MQ，每秒 5k 个请求写入 MQ，A 系统每秒钟最多处理 2k 个请求，因为 MySQL 每秒钟最多处理 2k 个。A 系统从 MQ 中慢慢拉取请求，每秒钟就拉取 2k 个请求，不要超过自己每秒能处理的最大请求数量就 ok，这样下来，哪怕是高峰期的时候，A 系统也绝对不会挂掉。而 MQ 每秒钟 5k 个请求进来，就 2k 个请求出去，结果就导致在中午高峰期（1 个小时），可能有几十万甚至几百万的请求积压在 MQ 中。</p>
<p><img src="https://github.com/doocs/advanced-java/blob/master/images/mq-6.png" alt="img"></p>
<p>这个短暂的高峰期积压是 ok 的，因为高峰期过了之后，每秒钟就 50 个请求进 MQ，但是 A 系统依然会按照每秒 2k 个请求的速度在处理。所以说，只要高峰期一过，A 系统就会快速将积压的消息给解决掉。</p>
<h2 id="消息队列有什么优缺点"><a href="#消息队列有什么优缺点" class="headerlink" title="消息队列有什么优缺点"></a>消息队列有什么优缺点</h2><p>优点上面已经说了，就是<strong>在特殊场景下有其对应的好处</strong>，<strong>解耦</strong>、<strong>异步</strong>、<strong>削峰</strong>。</p>
<p>缺点有以下几个：</p>
<ul>
<li>系统可用性降低<br>系统引入的外部依赖越多，越容易挂掉。本来你就是 A 系统调用 BCD 三个系统的接口就好了，人 ABCD 四个系统好好的，没啥问题，你偏加个 MQ 进来，万一 MQ 挂了咋整，MQ 一挂，整套系统崩溃的，你不就完了？如何保证消息队列的高可用，可以<a target="_blank" rel="noopener" href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/how-to-ensure-high-availability-of-message-queues.md">点击这里查看</a>。</li>
<li>系统复杂度提高<br>硬生生加个 MQ 进来，你怎么<a target="_blank" rel="noopener" href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/how-to-ensure-that-messages-are-not-repeatedly-consumed.md">保证消息没有重复消费</a>？怎么<a target="_blank" rel="noopener" href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/how-to-ensure-the-reliable-transmission-of-messages.md">处理消息丢失的情况</a>？怎么保证消息传递的顺序性？头大头大，问题一大堆，痛苦不已。</li>
<li>一致性问题<br>A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致了。</li>
</ul>
<p>所以消息队列实际是一种非常复杂的架构，你引入它有很多好处，但是也得针对它带来的坏处做各种额外的技术方案和架构来规避掉，做好之后，你会发现，妈呀，系统复杂度提升了一个数量级，也许是复杂了 10 倍。但是关键时刻，用，还是得用的。</p>
<h2 id="Kafka、ActiveMQ、RabbitMQ、RocketMQ-有什么优缺点？"><a href="#Kafka、ActiveMQ、RabbitMQ、RocketMQ-有什么优缺点？" class="headerlink" title="Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点？"></a>Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点？</h2><table>
<thead>
<tr>
<th>特性</th>
<th>ActiveMQ</th>
<th>RabbitMQ</th>
<th>RocketMQ</th>
<th>Kafka</th>
</tr>
</thead>
<tbody><tr>
<td>单机吞吐量</td>
<td>万级，比 RocketMQ、Kafka 低一个数量级</td>
<td>同 ActiveMQ</td>
<td>10 万级，支撑高吞吐</td>
<td>10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td>
</tr>
<tr>
<td>topic 数量对吞吐量的影响</td>
<td></td>
<td></td>
<td>topic 可以达到几百&#x2F;几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic</td>
<td>topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源</td>
</tr>
<tr>
<td>时效性</td>
<td>ms 级</td>
<td>微秒级，这是 RabbitMQ 的一大特点，延迟最低</td>
<td>ms 级</td>
<td>延迟在 ms 级以内</td>
</tr>
<tr>
<td>可用性</td>
<td>高，基于主从架构实现高可用</td>
<td>同 ActiveMQ</td>
<td>非常高，分布式架构</td>
<td>非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td>
</tr>
<tr>
<td>消息可靠性</td>
<td>有较低的概率丢失数据</td>
<td>基本不丢</td>
<td>经过参数优化配置，可以做到 0 丢失</td>
<td>同 RocketMQ</td>
</tr>
<tr>
<td>功能支持</td>
<td>MQ 领域的功能极其完备</td>
<td>基于 erlang 开发，并发能力很强，性能极好，延时很低</td>
<td>MQ 功能较为完善，还是分布式的，扩展性好</td>
<td>功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用</td>
</tr>
</tbody></table>
<p>综上，各种对比之后，有如下建议：</p>
<ul>
<li>一般的业务系统要引入 MQ，最早大家都用 ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还是算了吧，我个人不推荐用这个了；</li>
<li>后来大家开始用 RabbitMQ，但是确实 erlang 语言阻止了大量的 Java 工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高；</li>
<li>不过现在确实越来越多的公司会去用 RocketMQ，确实很不错，毕竟是阿里出品，但社区可能有突然黄掉的风险（目前 RocketMQ 已捐给 <a target="_blank" rel="noopener" href="https://github.com/apache/rocketmq">Apache</a>，但 GitHub 上的活跃度其实不算高）对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则回去老老实实用 RabbitMQ 吧，人家有活跃的开源社区，绝对不会黄。</li>
<li>所以<strong>中小型公司</strong>，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；<strong>大型公司</strong>，基础架构研发实力较强，用 RocketMQ 是很好的选择。</li>
<li>如果是<strong>大数据领域</strong>的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</li>
</ul>
<h2 id="如何保证消息队列的高可用？"><a href="#如何保证消息队列的高可用？" class="headerlink" title="如何保证消息队列的高可用？"></a>如何保证消息队列的高可用？</h2><h3 id="RabbitMQ-的高可用性"><a href="#RabbitMQ-的高可用性" class="headerlink" title="RabbitMQ 的高可用性"></a>RabbitMQ 的高可用性</h3><p>RabbitMQ 是比较有代表性的，因为是<strong>基于主从</strong>（非分布式）做高可用性的，我们就以 RabbitMQ 为例子讲解第一种 MQ 的高可用性怎么实现。</p>
<p>RabbitMQ 有三种模式：单机模式、普通集群模式、镜像集群模式。</p>
<h4 id="单机模式"><a href="#单机模式" class="headerlink" title="单机模式"></a>单机模式</h4><p>单机模式，就是 Demo 级别的，一般就是你本地启动了玩玩儿的 😄，没人生产用单机模式。</p>
<h4 id="普通集群模式（无高可用性）"><a href="#普通集群模式（无高可用性）" class="headerlink" title="普通集群模式（无高可用性）"></a>普通集群模式（无高可用性）</h4><p>普通集群模式，意思就是在多台机器上启动多个 RabbitMQ 实例，每个机器启动一个。你<strong>创建的 queue，只会放在一个 RabbitMQ 实例上</strong>，但是每个实例都同步 queue 的元数据（元数据可以认为是 queue 的一些配置信息，通过元数据，可以找到 queue 所在实例）。你消费的时候，实际上如果连接到了另外一个实例，那么那个实例会从 queue 所在实例上拉取数据过来。</p>
<p><img src="https://github.com/doocs/advanced-java/blob/master/images/mq-7.png" alt="img"></p>
<p>这种方式确实很麻烦，也不怎么好，<strong>没做到所谓的分布式</strong>，就是个普通集群。因为这导致你要么消费者每次随机连接一个实例然后拉取数据，要么固定连接那个 queue 所在实例消费数据，前者有<strong>数据拉取的开销</strong>，后者导致<strong>单实例性能瓶颈</strong>。</p>
<p>而且如果那个放 queue 的实例宕机了，会导致接下来其他实例就无法从那个实例拉取，如果你<strong>开启了消息持久化</strong>，让 RabbitMQ 落地存储消息的话，<strong>消息不一定会丢</strong>，得等这个实例恢复了，然后才可以继续从这个 queue 拉取数据。</p>
<p>所以这个事儿就比较尴尬了，这就<strong>没有什么所谓的高可用性</strong>，<strong>这方案主要是提高吞吐量的</strong>，就是说让集群中多个节点来服务某个 queue 的读写操作。</p>
<h4 id="镜像集群模式（高可用性）"><a href="#镜像集群模式（高可用性）" class="headerlink" title="镜像集群模式（高可用性）"></a>镜像集群模式（高可用性）</h4><p>这种模式，才是所谓的 RabbitMQ 的高可用模式。跟普通集群模式不一样的是，在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会<strong>存在于多个实例上</strong>，就是说，每个 RabbitMQ 节点都有这个 queue 的一个<strong>完整镜像</strong>，包含 queue 的全部数据的意思。然后每次你写消息到 queue 的时候，都会自动把<strong>消息同步</strong>到多个实例的 queue 上。</p>
<p><img src="https://github.com/doocs/advanced-java/blob/master/images/mq-8.png" alt="img"></p>
<p>那么<strong>如何开启这个镜像集群模式</strong>呢？其实很简单，RabbitMQ 有很好的管理控制台，就是在后台新增一个策略，这个策略是<strong>镜像集群模式的策略</strong>，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。</p>
<p>这样的话，好处在于，你任何一个机器宕机了，没事儿，其它机器（节点）还包含了这个 queue 的完整数据，别的 consumer 都可以到其它节点上去消费数据。坏处在于，第一，这个性能开销也太大了吧，消息需要同步到所有机器上，导致网络带宽压力和消耗很重！第二，这么玩儿，不是分布式的，就<strong>没有扩展性可言</strong>了，如果某个 queue 负载很重，你加机器，新增的机器也包含了这个 queue 的所有数据，并<strong>没有办法线性扩展</strong>你的 queue。你想，如果这个 queue 的数据量很大，大到这个机器上的容量无法容纳了，此时该怎么办呢？</p>
<h3 id="Kafka-的高可用性"><a href="#Kafka-的高可用性" class="headerlink" title="Kafka 的高可用性"></a>Kafka 的高可用性</h3><p>Kafka 一个最基本的架构认识：由多个 broker 组成，每个 broker 是一个节点；你创建一个 topic，这个 topic 可以划分为多个 partition，每个 partition 可以存在于不同的 broker 上，每个 partition 就放一部分数据。</p>
<p>这就是<strong>天然的分布式消息队列</strong>，就是说一个 topic 的数据，是<strong>分散放在多个机器上的，每个机器就放一部分数据</strong>。</p>
<p>实际上 RabbmitMQ 之类的，并不是分布式消息队列，它就是传统的消息队列，只不过提供了一些集群、HA(High Availability, 高可用性) 的机制而已，因为无论怎么玩儿，RabbitMQ 一个 queue 的数据都是放在一个节点里的，镜像集群下，也是每个节点都放这个 queue 的完整数据。</p>
<p>Kafka 0.8 以前，是没有 HA 机制的，就是任何一个 broker 宕机了，那个 broker 上的 partition 就废了，没法写也没法读，没有什么高可用性可言。</p>
<p>比如说，我们假设创建了一个 topic，指定其 partition 数量是 3 个，分别在三台机器上。但是，如果第二台机器宕机了，会导致这个 topic 的 1&#x2F;3 的数据就丢了，因此这个是做不到高可用的。</p>
<p><img src="https://github.com/doocs/advanced-java/blob/master/images/kafka-before.png" alt="img"></p>
<p>Kafka 0.8 以后，提供了 HA 机制，就是 replica（复制品） 副本机制。每个 partition 的数据都会同步到其它机器上，形成自己的多个 replica 副本。所有 replica 会选举一个 leader 出来，那么生产和消费都跟这个 leader 打交道，然后其他 replica 就是 follower。写的时候，leader 会负责把数据同步到所有 follower 上去，读的时候就直接读 leader 上的数据即可。只能读写 leader？很简单，<strong>要是你可以随意读写每个 follower，那么就要 care 数据一致性的问题</strong>，系统复杂度太高，很容易出问题。Kafka 会均匀地将一个 partition 的所有 replica 分布在不同的机器上，这样才可以提高容错性。</p>
<p><img src="https://github.com/doocs/advanced-java/blob/master/images/kafka-after.png" alt="img"></p>
<p>这么搞，就有所谓的<strong>高可用性</strong>了，因为如果某个 broker 宕机了，没事儿，那个 broker 上面的 partition 在其他机器上都有副本的。如果这个宕机的 broker 上面有某个 partition 的 leader，那么此时会从 follower 中<strong>重新选举</strong>一个新的 leader 出来，大家继续读写那个新的 leader 即可。这就有所谓的高可用性了。</p>
<p><strong>写数据</strong>的时候，生产者就写 leader，然后 leader 将数据落地写本地磁盘，接着其他 follower 自己主动从 leader 来 pull 数据。一旦所有 follower 同步好数据了，就会发送 ack 给 leader，leader 收到所有 follower 的 ack 之后，就会返回写成功的消息给生产者。（当然，这只是其中一种模式，还可以适当调整这个行为）</p>
<p><strong>消费</strong>的时候，只会从 leader 去读，但是只有当一个消息已经被所有 follower 都同步成功返回 ack 的时候，这个消息才会被消费者读到。</p>
<p>看到这里，相信你大致明白了 Kafka 是如何保证高可用机制的了，对吧？不至于一无所知，现场还能给面试官画画图。要是遇上面试官确实是 Kafka 高手，深挖了问，那你只能说不好意思，太深入的你没研究过。</p>
<h2 id="如何保证消息不被重复消费？（如何保证消息消费的幂等性）"><a href="#如何保证消息不被重复消费？（如何保证消息消费的幂等性）" class="headerlink" title="如何保证消息不被重复消费？（如何保证消息消费的幂等性）"></a>如何保证消息不被重复消费？（如何保证消息消费的幂等性）</h2><p>首先，比如 RabbitMQ、RocketMQ、Kafka，都有可能会出现消息重复消费的问题，正常。因为这问题通常不是 MQ 自己保证的，是由我们开发来保证的。挑一个 Kafka 来举个例子，说说怎么重复消费吧。</p>
<p>Kafka 实际上有个 offset 的概念，就是每个消息写进去，都有一个 offset，代表消息的序号，然后 consumer 消费了数据之后，<strong>每隔一段时间</strong>（定时定期），会把自己消费过的消息的 offset 提交一下，表示“我已经消费过了，下次我要是重启啥的，你就让我继续从上次消费到的 offset 来继续消费吧”。</p>
<p>但是凡事总有意外，比如我们之前生产经常遇到的，就是你有时候重启系统，看你怎么重启了，如果碰到点着急的，直接 kill 进程了，再重启。这会导致 consumer 有些消息处理了，但是没来得及提交 offset，尴尬了。重启之后，少数消息会再次消费一次。</p>
<p>举个栗子。</p>
<p>有这么个场景。数据 1&#x2F;2&#x2F;3 依次进入 kafka，kafka 会给这三条数据每条分配一个 offset，代表这条数据的序号，我们就假设分配的 offset 依次是 152&#x2F;153&#x2F;154。消费者从 kafka 去消费的时候，也是按照这个顺序去消费。假如当消费者消费了 <code>offset=153</code> 的这条数据，刚准备去提交 offset 到 zookeeper，此时消费者进程被重启了。那么此时消费过的数据 1&#x2F;2 的 offset 并没有提交，kafka 也就不知道你已经消费了 <code>offset=153</code> 这条数据。那么重启之后，消费者会找 kafka 说，嘿，哥儿们，你给我接着把上次我消费到的那个地方后面的数据继续给我传递过来。由于之前的 offset 没有提交成功，那么数据 1&#x2F;2 会再次传过来，如果此时消费者没有去重的话，那么就会导致重复消费。</p>
<p><img src="https://github.com/doocs/advanced-java/blob/master/images/mq-10.png" alt="img"></p>
<p>如果消费者干的事儿是拿一条数据就往数据库里写一条，会导致说，你可能就把数据 1&#x2F;2 在数据库里插入了 2 次，那么数据就错啦。</p>
<p>其实重复消费不可怕，可怕的是你没考虑到重复消费之后，<strong>怎么保证幂等性</strong>。</p>
<p>举个例子吧。假设你有个系统，消费一条消息就往数据库里插入一条数据，要是你一个消息重复两次，你不就插入了两条，这数据不就错了？但是你要是消费到第二次的时候，自己判断一下是否已经消费过了，若是就直接扔了，这样不就保留了一条数据，从而保证了数据的正确性。</p>
<p>一条数据重复出现两次，数据库里就只有一条数据，这就保证了系统的幂等性。</p>
<p>幂等性，通俗点说，就一个数据，或者一个请求，给你重复来多次，你得确保对应的数据是不会改变的，<strong>不能出错</strong>。</p>
<p>所以第二个问题来了，怎么保证消息队列消费的幂等性？</p>
<p>其实还是得结合业务来思考，我这里给几个思路：</p>
<ul>
<li>比如你拿个数据要写库，你先根据主键查一下，如果这数据都有了，你就别插入了，update 一下好吧。</li>
<li>比如你是写 Redis，那没问题了，反正每次都是 set，天然幂等性。</li>
<li>比如你不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面加一个全局唯一的 id，类似订单 id 之类的东西，然后你这里消费到了之后，先根据这个 id 去比如 Redis 里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个 id 写 Redis。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可。</li>
<li>比如基于数据库的唯一键来保证重复数据不会重复插入多条。因为有唯一键约束了，重复数据插入只会报错，不会导致数据库中出现脏数据。</li>
</ul>
<p><img src="https://github.com/doocs/advanced-java/blob/master/images/mq-11.png" alt="img"></p>
<p>当然，如何保证 MQ 的消费是幂等性的，需要结合具体的业务来看。</p>
<h2 id="如何保证消息的可靠性传输？（如何处理消息丢失的问题）"><a href="#如何保证消息的可靠性传输？（如何处理消息丢失的问题）" class="headerlink" title="如何保证消息的可靠性传输？（如何处理消息丢失的问题）"></a>如何保证消息的可靠性传输？（如何处理消息丢失的问题）</h2><p>数据的丢失问题，可能出现在生产者、MQ、消费者中，咱们从 RabbitMQ 和 Kafka 分别来分析一下吧。</p>
<h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><p><img src="https://github.com/doocs/advanced-java/blob/master/images/rabbitmq-message-lose.png" alt="img"></p>
<h4 id="生产者弄丢了数据"><a href="#生产者弄丢了数据" class="headerlink" title="生产者弄丢了数据"></a>生产者弄丢了数据</h4><p>生产者将数据发送到 RabbitMQ 的时候，可能数据就在半路给搞丢了，因为网络问题啥的，都有可能。</p>
<p>此时可以选择用 RabbitMQ 提供的事务功能，就是生产者<strong>发送数据之前</strong>开启 RabbitMQ 事务<code>channel.txSelect</code>，然后发送消息，如果消息没有成功被 RabbitMQ 接收到，那么生产者会收到异常报错，此时就可以回滚事务<code>channel.txRollback</code>，然后重试发送消息；如果收到了消息，那么可以提交事务<code>channel.txCommit</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启事务</span></span><br><span class="line">channel.txSelect</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 这里发送消息</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    channel.txRollback</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里再次重发这条消息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交事务</span></span><br><span class="line">channel.txCommit</span><br></pre></td></tr></table></figure>

<p>但是问题是，RabbitMQ 事务机制（同步）一搞，基本上<strong>吞吐量会下来，因为太耗性能</strong>。</p>
<p>所以一般来说，如果你要确保说写 RabbitMQ 的消息别丢，可以开启 <code>confirm</code> 模式，在生产者那里设置开启 <code>confirm</code>模式之后，你每次写的消息都会分配一个唯一的 id，然后如果写入了 RabbitMQ 中，RabbitMQ 会给你回传一个 <code>ack</code> 消息，告诉你说这个消息 ok 了。如果 RabbitMQ 没能处理这个消息，会回调你的一个 <code>nack</code> 接口，告诉你这个消息接收失败，你可以重试。而且你可以结合这个机制自己在内存里维护每个消息 id 的状态，如果超过一定时间还没接收到这个消息的回调，那么你可以重发。</p>
<p>事务机制和 <code>confirm</code> 机制最大的不同在于，<strong>事务机制是同步的</strong>，你提交一个事务之后会<strong>阻塞</strong>在那儿，但是 <code>confirm</code> 机制是<strong>异步</strong>的，你发送个消息之后就可以发送下一个消息，然后那个消息 RabbitMQ 接收了之后会异步回调你的一个接口通知你这个消息接收到了。</p>
<p>所以一般在生产者这块<strong>避免数据丢失</strong>，都是用 <code>confirm</code> 机制的。</p>
<h4 id="RabbitMQ-弄丢了数据"><a href="#RabbitMQ-弄丢了数据" class="headerlink" title="RabbitMQ 弄丢了数据"></a>RabbitMQ 弄丢了数据</h4><p>就是 RabbitMQ 自己弄丢了数据，这个你必须<strong>开启 RabbitMQ 的持久化</strong>，就是消息写入之后会持久化到磁盘，哪怕是 RabbitMQ 自己挂了，<strong>恢复之后会自动读取之前存储的数据</strong>，一般数据不会丢。除非极其罕见的是，RabbitMQ 还没持久化，自己就挂了，<strong>可能导致少量数据丢失</strong>，但是这个概率较小。</p>
<p>设置持久化有<strong>两个步骤</strong>：</p>
<ul>
<li>创建 queue 的时候将其设置为持久化<br>这样就可以保证 RabbitMQ 持久化 queue 的元数据，但是它是不会持久化 queue 里的数据的。</li>
<li>第二个是发送消息的时候将消息的 <code>deliveryMode</code> 设置为 2<br>就是将消息设置为持久化的，此时 RabbitMQ 就会将消息持久化到磁盘上去。</li>
</ul>
<p>必须要同时设置这两个持久化才行，RabbitMQ 哪怕是挂了，再次重启，也会从磁盘上重启恢复 queue，恢复这个 queue 里的数据。</p>
<p>注意，哪怕是你给 RabbitMQ 开启了持久化机制，也有一种可能，就是这个消息写到了 RabbitMQ 中，但是还没来得及持久化到磁盘上，结果不巧，此时 RabbitMQ 挂了，就会导致内存里的一点点数据丢失。</p>
<p>所以，持久化可以跟生产者那边的 <code>confirm</code> 机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者 <code>ack</code> 了，所以哪怕是在持久化到磁盘之前，RabbitMQ 挂了，数据丢了，生产者收不到 <code>ack</code>，你也是可以自己重发的。</p>
<h4 id="消费端弄丢了数据"><a href="#消费端弄丢了数据" class="headerlink" title="消费端弄丢了数据"></a>消费端弄丢了数据</h4><p>RabbitMQ 如果丢失了数据，主要是因为你消费的时候，<strong>刚消费到，还没处理，结果进程挂了</strong>，比如重启了，那么就尴尬了，RabbitMQ 认为你都消费了，这数据就丢了。</p>
<p>这个时候得用 RabbitMQ 提供的 <code>ack</code> 机制，简单来说，就是你必须关闭 RabbitMQ 的自动 <code>ack</code>，可以通过一个 api 来调用就行，然后每次你自己代码里确保处理完的时候，再在程序里 <code>ack</code> 一把。这样的话，如果你还没处理完，不就没有 <code>ack</code> 了？那 RabbitMQ 就认为你还没处理完，这个时候 RabbitMQ 会把这个消费分配给别的 consumer 去处理，消息是不会丢的。</p>
<p><img src="https://github.com/doocs/advanced-java/blob/master/images/rabbitmq-message-lose-solution.png" alt="img"></p>
<h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><h4 id="消费端弄丢了数据-1"><a href="#消费端弄丢了数据-1" class="headerlink" title="消费端弄丢了数据"></a>消费端弄丢了数据</h4><p>唯一可能导致消费者弄丢数据的情况，就是说，你消费到了这个消息，然后消费者那边<strong>自动提交了 offset</strong>，让 Kafka 以为你已经消费好了这个消息，但其实你才刚准备处理这个消息，你还没处理，你自己就挂了，此时这条消息就丢咯。</p>
<p>这不是跟 RabbitMQ 差不多吗，大家都知道 Kafka 会自动提交 offset，那么只要<strong>关闭自动提交</strong> offset，在处理完之后自己手动提交 offset，就可以保证数据不会丢。但是此时确实还是<strong>可能会有重复消费</strong>，比如你刚处理完，还没提交 offset，结果自己挂了，此时肯定会重复消费一次，自己保证幂等性就好了。</p>
<p>生产环境碰到的一个问题，就是说我们的 Kafka 消费者消费到了数据之后是写到一个内存的 queue 里先缓冲一下，结果有的时候，你刚把消息写入内存 queue，然后消费者会自动提交 offset。然后此时我们重启了系统，就会导致内存 queue 里还没来得及处理的数据就丢失了。</p>
<h4 id="Kafka-弄丢了数据"><a href="#Kafka-弄丢了数据" class="headerlink" title="Kafka 弄丢了数据"></a>Kafka 弄丢了数据</h4><p>这块比较常见的一个场景，就是 Kafka 某个 broker 宕机，然后重新选举 partition 的 leader。大家想想，要是此时其他的 follower 刚好还有些数据没有同步，结果此时 leader 挂了，然后选举某个 follower 成 leader 之后，不就少了一些数据？这就丢了一些数据啊。</p>
<p>生产环境也遇到过，我们也是，之前 Kafka 的 leader 机器宕机了，将 follower 切换为 leader 之后，就会发现说这个数据就丢了。</p>
<p>所以此时一般是要求起码设置如下 4 个参数：</p>
<ul>
<li>给 topic 设置 <code>replication.factor</code> 参数：这个值必须大于 1，要求每个 partition 必须有至少 2 个副本。</li>
<li>在 Kafka 服务端设置 <code>min.insync.replicas</code> 参数：这个值必须大于 1，这个是要求一个 leader 至少感知到有至少一个 follower 还跟自己保持联系，没掉队，这样才能确保 leader 挂了还有一个 follower 吧。</li>
<li>在 producer 端设置 <code>acks=all</code>：这个是要求每条数据，必须是<strong>写入所有 replica 之后，才能认为是写成功了</strong>。</li>
<li>在 producer 端设置 <code>retries=MAX</code>（很大很大很大的一个值，无限次重试的意思）：这个是<strong>要求一旦写入失败，就无限重试</strong>，卡在这里了。</li>
</ul>
<p>我们生产环境就是按照上述要求配置的，这样配置之后，至少在 Kafka broker 端就可以保证在 leader 所在 broker 发生故障，进行 leader 切换时，数据不会丢失。</p>
<h4 id="生产者会不会弄丢数据？"><a href="#生产者会不会弄丢数据？" class="headerlink" title="生产者会不会弄丢数据？"></a>生产者会不会弄丢数据？</h4><p>如果按照上述的思路设置了 <code>acks=all</code>，一定不会丢，要求是，你的 leader 接收到消息，所有的 follower 都同步到了消息之后，才认为本次写成功了。如果没满足这个条件，生产者会自动不断的重试，重试无限次。</p>
<h2 id="如何保证消息的顺序性？"><a href="#如何保证消息的顺序性？" class="headerlink" title="如何保证消息的顺序性？"></a>如何保证消息的顺序性？</h2><p>我举个例子，我们以前做过一个 mysql <code>binlog</code> 同步的系统，压力还是非常大的，日同步数据要达到上亿，就是说数据从一个 mysql 库原封不动地同步到另一个 mysql 库里面去（mysql -&gt; mysql）。常见的一点在于说比如大数据 team，就需要同步一个 mysql 库过来，对公司的业务系统的数据做各种复杂的操作。</p>
<p>你在 mysql 里增删改一条数据，对应出来了增删改 3 条 <code>binlog</code> 日志，接着这三条 <code>binlog</code> 发送到 MQ 里面，再消费出来依次执行，起码得保证人家是按照顺序来的吧？不然本来是：增加、修改、删除；你楞是换了顺序给执行成删除、修改、增加，不全错了么。</p>
<p>本来这个数据同步过来，应该最后这个数据被删除了；结果你搞错了这个顺序，最后这个数据保留下来了，数据同步就出错了。</p>
<p>先看看顺序会错乱的俩场景：</p>
<ul>
<li><strong>RabbitMQ</strong>：一个 queue，多个 consumer。比如，生产者向 RabbitMQ 里发送了三条数据，顺序依次是 data1&#x2F;data2&#x2F;data3，压入的是 RabbitMQ 的一个内存队列。有三个消费者分别从 MQ 中消费这三条数据中的一条，结果消费者 2 先执行完操作，把 data2 存入数据库，然后是 data1&#x2F;data3。这不明显乱了。</li>
</ul>
<p><img src="https://github.com/doocs/advanced-java/blob/master/images/rabbitmq-order-01.png" alt="img"></p>
<ul>
<li><strong>Kafka</strong>：比如说我们建了一个 topic，有三个 partition。生产者在写的时候，其实可以指定一个 key，比如说我们指定了某个订单 id 作为 key，那么这个订单相关的数据，一定会被分发到同一个 partition 中去，而且这个 partition 中的数据一定是有顺序的。<br>消费者从 partition 中取出来数据的时候，也一定是有顺序的。到这里，顺序还是 ok 的，没有错乱。接着，我们在消费者里可能会搞<strong>多个线程来并发处理消息</strong>。因为如果消费者是单线程消费处理，而处理比较耗时的话，比如处理一条消息耗时几十 ms，那么 1 秒钟只能处理几十条消息，这吞吐量太低了。而多个线程并发跑的话，顺序可能就乱掉了。</li>
</ul>
<p><img src="https://github.com/doocs/advanced-java/blob/master/images/kafka-order-01.png" alt="img"></p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="RabbitMQ-1"><a href="#RabbitMQ-1" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h4><p><img src="https://github.com/doocs/advanced-java/blob/master/images/rabbitmq-order-02.png" alt="img"></p>
<h4 id="Kafka-1"><a href="#Kafka-1" class="headerlink" title="Kafka"></a>Kafka</h4><ul>
<li>一个 topic，一个 partition，一个 consumer，内部单线程消费，单线程吞吐量太低，一般不会用这个。</li>
<li>写 N 个内存 queue，具有相同 key 的数据都到同一个内存 queue；然后对于 N 个线程，每个线程分别消费一个内存 queue 即可，这样就能保证顺序性。</li>
</ul>
<p><img src="https://github.com/doocs/advanced-java/blob/master/images/kafka-order-02.png" alt="img"></p>
<h2 id="如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？"><a href="#如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？" class="headerlink" title="如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？"></a>如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？</h2><p>你看这问法，其实本质针对的场景，都是说，可能你的消费端出了问题，不消费了；或者消费的速度极其慢。接着就坑爹了，可能你的消息队列集群的磁盘都快写满了，都没人消费，这个时候怎么办？或者是这整个就积压了几个小时，你这个时候怎么办？或者是你积压的时间太长了，导致比如 RabbitMQ 设置了消息过期时间后就没了怎么办？</p>
<p>所以就这事儿，其实线上挺常见的，一般不出，一出就是大 case。一般常见于，举个例子，消费端每次消费之后要写 mysql，结果 mysql 挂了，消费端 hang 那儿了，不动了；或者是消费端出了个什么岔子，导致消费速度极其慢。</p>
<h3 id="面试题剖析"><a href="#面试题剖析" class="headerlink" title="面试题剖析"></a>面试题剖析</h3><p>关于这个事儿，我们一个一个来梳理吧，先假设一个场景，我们现在消费端出故障了，然后大量消息在 mq 里积压，现在出事故了，慌了。</p>
<h3 id="大量消息在-mq-里积压了几个小时了还没解决"><a href="#大量消息在-mq-里积压了几个小时了还没解决" class="headerlink" title="大量消息在 mq 里积压了几个小时了还没解决"></a>大量消息在 mq 里积压了几个小时了还没解决</h3><p>几千万条数据在 MQ 里积压了七八个小时，从下午 4 点多，积压到了晚上 11 点多。这个是我们真实遇到过的一个场景，确实是线上故障了，这个时候要不然就是修复 consumer 的问题，让它恢复消费速度，然后傻傻的等待几个小时消费完毕。这个肯定不能在面试的时候说吧。</p>
<p>一个消费者一秒是 1000 条，一秒 3 个消费者是 3000 条，一分钟就是 18 万条。所以如果你积压了几百万到上千万的数据，即使消费者恢复了，也需要大概 1 小时的时间才能恢复过来。</p>
<p>一般这个时候，只能临时紧急扩容了，具体操作步骤和思路如下：</p>
<ul>
<li>先修复 consumer 的问题，确保其恢复消费速度，然后将现有 consumer 都停掉。</li>
<li>新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量。</li>
<li>然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，<strong>消费之后不做耗时的处理</strong>，直接均匀轮询写入临时建立好的 10 倍数量的 queue。</li>
<li>接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。</li>
<li>等快速消费完积压数据之后，<strong>得恢复原先部署的架构</strong>，<strong>重新</strong>用原先的 consumer 机器来消费消息。</li>
</ul>
<h3 id="mq-中的消息过期失效了"><a href="#mq-中的消息过期失效了" class="headerlink" title="mq 中的消息过期失效了"></a>mq 中的消息过期失效了</h3><p>假设你用的是 RabbitMQ，RabbtiMQ 是可以设置过期时间的，也就是 TTL。如果消息在 queue 中积压超过一定的时间就会被 RabbitMQ 给清理掉，这个数据就没了。那这就是第二个坑了。这就不是说数据会大量积压在 mq 里，而是<strong>大量的数据会直接搞丢</strong>。</p>
<p>这个情况下，就不是说要增加 consumer 消费积压的消息，因为实际上没啥积压，而是丢了大量的消息。我们可以采取一个方案，就是<strong>批量重导</strong>，这个我们之前线上也有类似的场景干过。就是大量积压的时候，我们当时就直接丢弃数据了，然后等过了高峰期以后，比如大家一起喝咖啡熬夜到晚上 12 点以后，用户都睡觉了。这个时候我们就开始写程序，将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入 mq 里面去，把白天丢的数据给他补回来。也只能是这样了。</p>
<p>假设 1 万个订单积压在 mq 里面，没有处理，其中 1000 个订单都丢了，你只能手动写程序把那 1000 个订单给查出来，手动发到 mq 里去再补一次。</p>
<h3 id="mq-都快写满了"><a href="#mq-都快写满了" class="headerlink" title="mq 都快写满了"></a>mq 都快写满了</h3><p>如果消息积压在 mq 里，你很长时间都没有处理掉，此时导致 mq 都快写满了，咋办？这个还有别的办法吗？没有，谁让你第一个方案执行的太慢了，你临时写程序，接入数据来消费，<strong>消费一个丢弃一个，都不要了</strong>，快速消费掉所有的消息。然后走第二个方案，到了晚上再补数据吧。</p>
<h2 id="如果让你写一个消息队列，该如何进行架构设计啊？说一下你的思路。"><a href="#如果让你写一个消息队列，该如何进行架构设计啊？说一下你的思路。" class="headerlink" title="如果让你写一个消息队列，该如何进行架构设计啊？说一下你的思路。"></a>如果让你写一个消息队列，该如何进行架构设计啊？说一下你的思路。</h2><h3 id="面试官心理分析"><a href="#面试官心理分析" class="headerlink" title="面试官心理分析"></a>面试官心理分析</h3><p>其实聊到这个问题，一般面试官要考察两块：</p>
<ul>
<li>你有没有对某一个消息队列做过较为深入的原理的了解，或者从整体了解把握住一个消息队列的架构原理。</li>
<li>看看你的设计能力，给你一个常见的系统，就是消息队列系统，看看你能不能从全局把握一下整体架构设计，给出一些关键点出来。</li>
</ul>
<p>说实话，问类似问题的时候，大部分人基本都会蒙，因为平时从来没有思考过类似的问题，大多数人就是平时埋头用，从来不去思考背后的一些东西。类似的问题，比如，如果让你来设计一个 Spring 框架你会怎么做？如果让你来设计一个 Dubbo 框架你会怎么做？如果让你来设计一个 MyBatis 框架你会怎么做？</p>
<h3 id="面试题剖析-1"><a href="#面试题剖析-1" class="headerlink" title="面试题剖析"></a>面试题剖析</h3><p>其实回答这类问题，说白了，不求你看过那技术的源码，起码你要大概知道那个技术的基本原理、核心组成部分、基本架构构成，然后参照一些开源的技术把一个系统设计出来的思路说一下就好。</p>
<p>比如说这个消息队列系统，我们从以下几个角度来考虑一下：</p>
<ul>
<li>首先这个 mq 得支持可伸缩性吧，就是需要的时候快速扩容，就可以增加吞吐量和容量，那怎么搞？设计个分布式的系统呗，参照一下 kafka 的设计理念，broker -&gt; topic -&gt; partition，每个 partition 放一个机器，就存一部分数据。如果现在资源不够了，简单啊，给 topic 增加 partition，然后做数据迁移，增加机器，不就可以存放更多数据，提供更高的吞吐量了？</li>
<li>其次你得考虑一下这个 mq 的数据要不要落地磁盘吧？那肯定要了，落磁盘才能保证别进程挂了数据就丢了。那落磁盘的时候怎么落啊？顺序写，这样就没有磁盘随机读写的寻址开销，磁盘顺序读写的性能是很高的，这就是 kafka 的思路。</li>
<li>其次你考虑一下你的 mq 的可用性啊？这个事儿，具体参考之前可用性那个环节讲解的 kafka 的高可用保障机制。多副本 -&gt; leader &amp; follower -&gt; broker 挂了重新选举 leader 即可对外服务。</li>
<li>能不能支持数据 0 丢失啊？可以的，参考我们之前说的那个 kafka 数据零丢失方案。</li>
</ul>
<p>mq 肯定是很复杂的，面试官问你这个问题，其实是个开放题，他就是看看你有没有从架构角度整体构思和设计的思维以及能力。确实这个问题可以刷掉一大批人，因为大部分人平时不思考这些东西。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/d404be/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/d404be/" class="post-title-link" itemprop="url">RocketMQ 快速入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-17 22:34:30" itemprop="dateCreated datePublished" datetime="2022-02-17T22:34:30+08:00">2022-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:53" itemprop="dateModified" datetime="2024-12-12T10:02:53+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/" itemprop="url" rel="index"><span itemprop="name">分布式通信</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/MQ/" itemprop="url" rel="index"><span itemprop="name">MQ</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/MQ/RocketMQ/" itemprop="url" rel="index"><span itemprop="name">RocketMQ</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>13k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>12 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="RocketMQ-快速入门"><a href="#RocketMQ-快速入门" class="headerlink" title="RocketMQ 快速入门"></a>RocketMQ 快速入门</h1><p>Apache RocketMQ 是一个分布式 MQ 和流处理平台，具有低延迟、高性能和可靠性、万亿级容量和灵活的可扩展性。</p>
<p>RocketMQ 由阿里巴巴孵化，被捐赠给 Apache，成为 Apache 的顶级项目。</p>
<h2 id="RocketMQ-概念"><a href="#RocketMQ-概念" class="headerlink" title="RocketMQ 概念"></a>RocketMQ 概念</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/distributed/mq/rocketmq/rmq-model.png" alt="img"></p>
<h3 id="消息模型（Message-Model）"><a href="#消息模型（Message-Model）" class="headerlink" title="消息模型（Message Model）"></a>消息模型（Message Model）</h3><p>RocketMQ 主要由 Producer、Broker、Consumer 三部分组成，其中 Producer 负责生产消息，Consumer 负责消费消息，Broker 负责存储消息。Broker 在实际部署过程中对应一台服务器，每个 Broker 可以存储多个 Topic 的消息，每个 Topic 的消息也可以分片存储于不同的 Broker。Message Queue 用于存储消息的物理地址，每个 Topic 中的消息地址存储于多个 Message Queue 中。ConsumerGroup 由多个 Consumer 实例构成。</p>
<h3 id="消息（Message）"><a href="#消息（Message）" class="headerlink" title="消息（Message）"></a>消息（Message）</h3><p>消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题。RocketMQ 中每个消息拥有唯一的 Message ID，且可以携带具有业务标识的 Key。系统提供了通过 Message ID 和 Key 查询消息的功能。</p>
<p>消息还可以具有可选 Tag 和额外的键值对。例如，您可以为消息设置业务密钥，并在代理服务器上查找消息以诊断开发期间的问题。</p>
<h3 id="标签（Tag）"><a href="#标签（Tag）" class="headerlink" title="标签（Tag）"></a>标签（Tag）</h3><p>为消息设置的标志，用于同一主题下区分不同类型的消息。来自同一业务单元的消息，可以根据不同业务目的在同一主题下设置不同标签。标签能够有效地保持代码的清晰度和连贯性，并优化 RocketMQ 提供的查询系统。消费者可以根据 Tag 实现对不同子主题的不同消费逻辑，实现更好的扩展性。</p>
<p>Tag 相当于子主题，为用户提供了额外的灵活性。对于 Tag，来自同一业务模块的具有不同目的的消息可以具有相同的主题和不同的 Tag。</p>
<h3 id="主题（Topic）"><a href="#主题（Topic）" class="headerlink" title="主题（Topic）"></a>主题（Topic）</h3><p>表示一类消息的集合，每个主题包含若干条消息，每条消息只能属于一个主题，是 RocketMQ 进行消息订阅的基本单位。</p>
<h3 id="代理服务器（Broker-Server）"><a href="#代理服务器（Broker-Server）" class="headerlink" title="代理服务器（Broker Server）"></a>代理服务器（Broker Server）</h3><p>消息中转角色，负责存储消息、转发消息。代理服务器在 RocketMQ 系统中负责接收从生产者发送来的消息并存储、同时为消费者的拉取请求作准备。代理服务器也存储消息相关的元数据，包括消费者组、消费进度偏移和主题和队列消息等。</p>
<h3 id="名称服务（Name-Server）"><a href="#名称服务（Name-Server）" class="headerlink" title="名称服务（Name Server）"></a>名称服务（Name Server）</h3><p>名称服务充当路由消息的提供者。生产者或消费者能够通过名称服务查找各主题相应的 Broker IP 列表。多个 Namesrv 实例组成集群，但相互独立，没有信息交换。</p>
<h3 id="消息生产者（Producer）"><a href="#消息生产者（Producer）" class="headerlink" title="消息生产者（Producer）"></a>消息生产者（Producer）</h3><p>负责生产消息，一般由业务系统负责生产消息。一个消息生产者会把业务应用系统里产生的消息发送到 broker 服务器。RocketMQ 提供多种发送方式，同步发送、异步发送、顺序发送、单向发送。同步和异步方式均需要 Broker 返回确认信息，单向发送不需要。</p>
<h3 id="生产者组（Producer-Group）"><a href="#生产者组（Producer-Group）" class="headerlink" title="生产者组（Producer Group）"></a>生产者组（Producer Group）</h3><p>同一类 Producer 的集合，这类 Producer 发送同一类消息且发送逻辑一致。如果发送的是事务消息且原始生产者在发送之后崩溃，则 Broker 服务器会联系同一生产者组的其他生产者实例以提交或回溯消费。</p>
<p>警告：考虑到提供的 Producer 在发送消息方面足够强大，<strong>每个 Producer 组只允许一个实例，以避免不必要的生成器实例初始化</strong>。</p>
<h3 id="消息消费者（Consumer）"><a href="#消息消费者（Consumer）" class="headerlink" title="消息消费者（Consumer）"></a>消息消费者（Consumer）</h3><p>负责消费消息，一般是后台系统负责异步消费。一个消息消费者会从 Broker 服务器拉取消息、并将其提供给应用程序。从用户应用的角度而言提供了两种消费形式：拉取式消费、推动式消费。</p>
<h3 id="消费者组（Consumer-Group）"><a href="#消费者组（Consumer-Group）" class="headerlink" title="消费者组（Consumer Group）"></a>消费者组（Consumer Group）</h3><p>同一类 Consumer 的集合，这类 Consumer 通常消费同一类消息且消费逻辑一致。消费者组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易。要注意的是，<strong>消费者组的消费者实例必须订阅完全相同的 Topic</strong>。RocketMQ 支持两种消息模式：集群消费（Clustering）和广播消费（Broadcasting）。</p>
<h3 id="拉取式消费（Pull-Consumer）"><a href="#拉取式消费（Pull-Consumer）" class="headerlink" title="拉取式消费（Pull Consumer）"></a>拉取式消费（Pull Consumer）</h3><p>Consumer 消费的一种类型，应用通常主动调用 Consumer 的拉消息方法从 Broker 服务器拉消息、主动权由应用控制。一旦获取了批量消息，应用就会启动消费过程。</p>
<h3 id="推动式消费（Push-Consumer）"><a href="#推动式消费（Push-Consumer）" class="headerlink" title="推动式消费（Push Consumer）"></a>推动式消费（Push Consumer）</h3><p>Consumer 消费的一种类型，该模式下 Broker 收到数据后会主动推送给消费端，该消费模式一般实时性较高。</p>
<h3 id="集群消费（Clustering）"><a href="#集群消费（Clustering）" class="headerlink" title="集群消费（Clustering）"></a>集群消费（Clustering）</h3><p>集群消费模式下,相同 Consumer Group 的每个 Consumer 实例平均分摊消息。</p>
<h3 id="广播消费（Broadcasting）"><a href="#广播消费（Broadcasting）" class="headerlink" title="广播消费（Broadcasting）"></a>广播消费（Broadcasting）</h3><p>广播消费模式下，相同 Consumer Group 的每个 Consumer 实例都接收全量的消息。</p>
<h3 id="普通顺序消息（Normal-Ordered-Message）"><a href="#普通顺序消息（Normal-Ordered-Message）" class="headerlink" title="普通顺序消息（Normal Ordered Message）"></a>普通顺序消息（Normal Ordered Message）</h3><p>普通顺序消费模式下，消费者通过同一个消息队列（ Topic 分区，称作 Message Queue） 收到的消息是有顺序的，不同消息队列收到的消息则可能是无顺序的。</p>
<h3 id="严格顺序消息（Strictly-Ordered-Message）"><a href="#严格顺序消息（Strictly-Ordered-Message）" class="headerlink" title="严格顺序消息（Strictly Ordered Message）"></a>严格顺序消息（Strictly Ordered Message）</h3><p>严格顺序消息模式下，消费者收到的所有消息均是有顺序的。</p>
<h2 id="RocketMQ-特性"><a href="#RocketMQ-特性" class="headerlink" title="RocketMQ 特性"></a>RocketMQ 特性</h2><h3 id="订阅与发布"><a href="#订阅与发布" class="headerlink" title="订阅与发布"></a>订阅与发布</h3><p>消息的发布是指某个生产者向某个 topic 发送消息；消息的订阅是指某个消费者关注了某个 topic 中带有某些 tag 的消息，进而从该 topic 消费数据。</p>
<h3 id="消息顺序"><a href="#消息顺序" class="headerlink" title="消息顺序"></a>消息顺序</h3><p>消息有序指的是一类消息消费时，能按照发送的顺序来消费。例如：一个订单产生了三条消息分别是订单创建、订单付款、订单完成。消费时要按照这个顺序消费才能有意义，但是同时订单之间是可以并行消费的。RocketMQ 可以严格的保证消息有序。</p>
<p>顺序消息分为全局顺序消息与分区顺序消息，全局顺序是指某个 Topic 下的所有消息都要保证顺序；部分顺序消息只要保证每一组消息被顺序消费即可。</p>
<ul>
<li>全局顺序 对于指定的一个 Topic，所有消息按照严格的先入先出（FIFO）的顺序进行发布和消费。 适用场景：性能要求不高，所有的消息严格按照 FIFO 原则进行消息发布和消费的场景</li>
<li>分区顺序 对于指定的一个 Topic，所有消息根据 sharding key 进行区块分区。 同一个分区内的消息按照严格的 FIFO 顺序进行发布和消费。 Sharding key 是顺序消息中用来区分不同分区的关键字段，和普通消息的 Key 是完全不同的概念。 适用场景：性能要求高，以 sharding key 作为分区字段，在同一个区块中严格的按照 FIFO 原则进行消息发布和消费的场景。</li>
</ul>
<h3 id="消息过滤"><a href="#消息过滤" class="headerlink" title="消息过滤"></a>消息过滤</h3><p>RocketMQ 的消费者可以根据 Tag 进行消息过滤，也支持自定义属性过滤。消息过滤目前是在 Broker 端实现的，优点是减少了对于 Consumer 无用消息的网络传输，缺点是增加了 Broker 的负担、而且实现相对复杂。</p>
<h3 id="消息可靠性"><a href="#消息可靠性" class="headerlink" title="消息可靠性"></a>消息可靠性</h3><p>RocketMQ 支持消息的高可靠，影响消息可靠性的几种情况：</p>
<ol>
<li>Broker 非正常关闭</li>
<li>Broker 异常 Crash</li>
<li>OS Crash</li>
<li>机器掉电，但是能立即恢复供电情况</li>
<li>机器无法开机（可能是 cpu、主板、内存等关键设备损坏）</li>
<li>磁盘设备损坏</li>
</ol>
<p>1)、2)、3)、4) 四种情况都属于硬件资源可立即恢复情况，RocketMQ 在这四种情况下能保证消息不丢，或者丢失少量数据（依赖刷盘方式是同步还是异步）。</p>
<p>5)、6)属于单点故障，且无法恢复，一旦发生，在此单点上的消息全部丢失。RocketMQ 在这两种情况下，通过异步复制，可保证 99%的消息不丢，但是仍然会有极少量的消息可能丢失。通过同步双写技术可以完全避免单点，同步双写势必会影响性能，适合对消息可靠性要求极高的场合，例如与 Money 相关的应用。注：RocketMQ 从 3.0 版本开始支持同步双写。</p>
<h3 id="至少一次"><a href="#至少一次" class="headerlink" title="至少一次"></a>至少一次</h3><p>至少一次(At least Once)指每个消息必须投递一次。Consumer 先 Pull 消息到本地，消费完成后，才向服务器返回 ack，如果没有消费一定不会 ack 消息，所以 RocketMQ 可以很好的支持此特性。</p>
<h3 id="回溯消费"><a href="#回溯消费" class="headerlink" title="回溯消费"></a>回溯消费</h3><p>回溯消费是指 Consumer 已经消费成功的消息，由于业务上需求需要重新消费，要支持此功能，Broker 在向 Consumer 投递成功消息后，消息仍然需要保留。并且重新消费一般是按照时间维度，例如由于 Consumer 系统故障，恢复后需要重新消费 1 小时前的数据，那么 Broker 要提供一种机制，可以按照时间维度来回退消费进度。RocketMQ 支持按照时间回溯消费，时间维度精确到毫秒。</p>
<h3 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h3><p>RocketMQ 事务消息（Transactional Message）是指应用本地事务和发送消息操作可以被定义到全局事务中，要么同时成功，要么同时失败。RocketMQ 的事务消息提供类似 X&#x2F;Open XA 的分布事务功能，通过事务消息能达到分布式事务的最终一致。</p>
<h3 id="定时消息"><a href="#定时消息" class="headerlink" title="定时消息"></a>定时消息</h3><p>定时消息（延迟队列）是指消息发送到 broker 后，不会立即被消费，等待特定时间投递给真正的 topic。 broker 有配置项 messageDelayLevel，默认值为“1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h”，18 个 level。可以配置自定义 messageDelayLevel。注意，messageDelayLevel 是 broker 的属性，不属于某个 topic。发消息时，设置 delayLevel 等级即可：msg.setDelayLevel(level)。level 有以下三种情况：</p>
<ul>
<li>level &#x3D;&#x3D; 0，消息为非延迟消息</li>
<li>1&lt;&#x3D;level&lt;&#x3D;maxLevel，消息延迟特定时间，例如 level&#x3D;&#x3D;1，延迟 1s</li>
<li>level &gt; maxLevel，则 level&#x3D;&#x3D; maxLevel，例如 level&#x3D;&#x3D;20，延迟 2h</li>
</ul>
<p>定时消息会暂存在名为 SCHEDULE_TOPIC_XXXX 的 topic 中，并根据 delayTimeLevel 存入特定的 queue，queueId &#x3D; delayTimeLevel – 1，即一个 queue 只存相同延迟的消息，保证具有相同发送延迟的消息能够顺序消费。broker 会调度地消费 SCHEDULE_TOPIC_XXXX，将消息写入真实的 topic。</p>
<p>需要注意的是，定时消息会在第一次写入和调度写入真实 topic 时都会计数，因此发送数量、tps 都会变高。</p>
<h3 id="消息重试"><a href="#消息重试" class="headerlink" title="消息重试"></a>消息重试</h3><p>Consumer 消费消息失败后，要提供一种重试机制，令消息再消费一次。Consumer 消费消息失败通常可以认为有以下几种情况：</p>
<ul>
<li>由于消息本身的原因，例如反序列化失败，消息数据本身无法处理（例如话费充值，当前消息的手机号被注销，无法充值）等。这种错误通常需要跳过这条消息，再消费其它消息，而这条失败的消息即使立刻重试消费，99%也不成功，所以最好提供一种定时重试机制，即过 10 秒后再重试。</li>
<li>由于依赖的下游应用服务不可用，例如 db 连接不可用，外系统网络不可达等。遇到这种错误，即使跳过当前失败的消息，消费其他消息同样也会报错。这种情况建议应用 sleep 30s，再消费下一条消息，这样可以减轻 Broker 重试消息的压力。</li>
</ul>
<p>RocketMQ 会为每个消费组都设置一个 Topic 名称为“%RETRY%+consumerGroup”的重试队列（这里需要注意的是，这个 Topic 的重试队列是针对消费组，而不是针对每个 Topic 设置的），用于暂时保存因为各种异常而导致 Consumer 端无法消费的消息。考虑到异常恢复起来需要一些时间，会为重试队列设置多个重试级别，每个重试级别都有与之对应的重新投递延时，重试次数越多投递延时就越大。RocketMQ 对于重试消息的处理是先保存至 Topic 名称为“SCHEDULE_TOPIC_XXXX”的延迟队列中，后台定时任务按照对应的时间进行 Delay 后重新保存至“%RETRY%+consumerGroup”的重试队列中。</p>
<h3 id="消息重投"><a href="#消息重投" class="headerlink" title="消息重投"></a>消息重投</h3><p>生产者在发送消息时，同步消息失败会重投，异步消息有重试，oneway 没有任何保证。消息重投保证消息尽可能发送成功、不丢失，但可能会造成消息重复，消息重复在 RocketMQ 中是无法避免的问题。消息重复在一般情况下不会发生，当出现消息量大、网络抖动，消息重复就会是大概率事件。另外，生产者主动重发、consumer 负载变化也会导致重复消息。如下方法可以设置消息重试策略：</p>
<ul>
<li>retryTimesWhenSendFailed:同步发送失败重投次数，默认为 2，因此生产者会最多尝试发送 retryTimesWhenSendFailed + 1 次。不会选择上次失败的 broker，尝试向其他 broker 发送，最大程度保证消息不丢。超过重投次数，抛出异常，由客户端保证消息不丢。当出现 RemotingException、MQClientException 和部分 MQBrokerException 时会重投。</li>
<li>retryTimesWhenSendAsyncFailed:异步发送失败重试次数，异步重试不会选择其他 broker，仅在同一个 broker 上做重试，不保证消息不丢。</li>
<li>retryAnotherBrokerWhenNotStoreOK:消息刷盘（主或备）超时或 slave 不可用（返回状态非 SEND_OK），是否尝试发送到其他 broker，默认 false。十分重要消息可以开启。</li>
</ul>
<h3 id="量控制"><a href="#量控制" class="headerlink" title="量控制"></a>量控制</h3><p>生产者流控，因为 broker 处理能力达到瓶颈；消费者流控，因为消费能力达到瓶颈。</p>
<p>生产者流控：</p>
<ul>
<li>commitLog 文件被锁时间超过 osPageCacheBusyTimeOutMills 时，参数默认为 1000ms，返回流控。</li>
<li>如果开启 transientStorePoolEnable &#x3D;&#x3D; true，且 broker 为异步刷盘的主机，且 transientStorePool 中资源不足，拒绝当前 send 请求，返回流控。</li>
<li>broker 每隔 10ms 检查 send 请求队列头部请求的等待时间，如果超过 waitTimeMillsInSendQueue，默认 200ms，拒绝当前 send 请求，返回流控。</li>
<li>broker 通过拒绝 send 请求方式实现流量控制。</li>
</ul>
<p>注意，生产者流控，不会尝试消息重投。</p>
<p>消费者流控：</p>
<ul>
<li>消费者本地缓存消息数超过 pullThresholdForQueue 时，默认 1000。</li>
<li>消费者本地缓存消息大小超过 pullThresholdSizeForQueue 时，默认 100MB。</li>
<li>消费者本地缓存消息跨度超过 consumeConcurrentlyMaxSpan 时，默认 2000。</li>
</ul>
<p>消费者流控的结果是降低拉取频率。</p>
<h3 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h3><p>死信队列用于处理无法被正常消费的消息。当一条消息初次消费失败，消息队列会自动进行消息重试；达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息，此时，消息队列 不会立刻将消息丢弃，而是将其发送到该消费者对应的特殊队列中。</p>
<p>RocketMQ 将这种正常情况下无法被消费的消息称为死信消息（Dead-Letter Message），将存储死信消息的特殊队列称为死信队列（Dead-Letter Queue）。在 RocketMQ 中，可以通过使用 console 控制台对死信队列中的消息进行重发来使得消费者实例再次进行消费。</p>
<h2 id="RocketMQ-组件"><a href="#RocketMQ-组件" class="headerlink" title="RocketMQ 组件"></a>RocketMQ 组件</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220712060550.png" alt="img"></p>
<p>RocketMQ 由四部分组成：NameServer、Broker、Producer、Consumer。其中任意一个组成都可以水平扩展为集群模式，以避免单点故障问题。</p>
<h3 id="NameServer（命名服务器）"><a href="#NameServer（命名服务器）" class="headerlink" title="NameServer（命名服务器）"></a>NameServer（命名服务器）</h3><p>NameServer 是一个 Topic 路由注册中心，其角色类似 Kafka 中的 zookeeper，支持 Broker 的动态注册与发现。每个 NameServer 记录完整的路由信息，提供相应的读写服务，支持快速存储扩展。</p>
<p>NameServer 主要包括两个功能：</p>
<ul>
<li><strong>Broker 管理</strong>，NameServer 接受 Broker 集群的注册信息并且保存下来作为路由信息的基本数据。然后提供心跳检测机制，检查 Broker 是否还存活；</li>
<li><strong>路由信息管理</strong>，每个 NameServer 将保存关于 Broker 集群的整个路由信息和用于客户端查询的队列信息。然后 Producer 和 Conumser 通过 NameServer 就可以知道整个 Broker 集群的路由信息，从而进行消息的投递和消费。</li>
</ul>
<p>NameServer 通常也是集群的方式部署，各实例间相互不进行信息通讯。Broker 是向每一台 NameServer 注册自己的路由信息，所以每一个 NameServer 实例上面都保存一份完整的路由信息。当某个 NameServer 因某种原因下线了，Broker 仍然可以向其它 NameServer 同步其路由信息，Producer、Consumer 仍然可以动态感知 Broker 的路由的信息。</p>
<p>NameServer 是一个功能齐全的服务器，主要包括两个功能：</p>
<ol>
<li>Broker 管理 - NameServer 接受来自 Broker 集群的注册，并提供心跳机制来检查 Broker 节点是否存活。</li>
<li>路由管理 - 每个 NameServer 将保存有关 Broker 集群的完整路由信息和客户端查询的查询队列。</li>
</ol>
<p>RocketMQ 客户端（Producer&#x2F;Consumer）将从 NameServer 查询队列路由信息。</p>
<p>将 NameServer 地址列表提供给客户端有四种方法：</p>
<ol>
<li>编程方式 - 类似：<code>producer.setNamesrvAddr(&quot;ip:port&quot;)</code></li>
<li>Java 选项 - 使用 <code>rocketmq.namesrv.addr</code> 参数</li>
<li>环境变量 - 设置环境变量 <code>NAMESRV_ADDR</code></li>
<li>HTTP 端点</li>
</ol>
<blockquote>
<p>更详细信息可以参考官方文档：<a target="_blank" rel="noopener" href="http://rocketmq.apache.org/rocketmq/four-methods-to-feed-name-server-address-list/">here</a></p>
</blockquote>
<h3 id="Broker（代理）"><a href="#Broker（代理）" class="headerlink" title="Broker（代理）"></a>Broker（代理）</h3><p>Broker 主要负责消息的存储、投递和查询以及服务高可用保证。</p>
<p>Broker 同时支持推拉模型，包含容错机制（2 副本或 3 副本），并提供强大的峰值填充和按原始时间顺序累积数千亿消息的能力。此外，Broker 提供了灾难恢复、丰富的指标统计和警报机制，这些都是传统 MQ 所缺乏的。</p>
<p>为了实现这些功能，Broker 包含了以下几个重要子模块：</p>
<ul>
<li><strong>Remoting Module</strong>：整个 Broker 的实体，负责处理来自 clients 端的请求。</li>
<li><strong>Client Manager</strong>：负责管理客户端(Producer&#x2F;Consumer)和维护 Consumer 的 Topic 订阅信息。</li>
<li><strong>Store Service</strong>：提供方便简单的 API 接口处理消息存储到物理硬盘和查询功能。</li>
<li><strong>HA Service</strong>：高可用服务，提供 Master Broker 和 Slave Broker 之间的数据同步功能。</li>
<li><strong>Index Service</strong>：根据特定的 Message key 对投递到 Broker 的消息进行索引服务，以提供消息的快速查询。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/distributed/mq/rocketmq/rmq-basic-component.png" alt="img"></p>
<h3 id="Producer（生产者）"><a href="#Producer（生产者）" class="headerlink" title="Producer（生产者）"></a>Producer（生产者）</h3><p>Producers 支持分布式集群方式部署。Producer 通过 MQ 的负载均衡模块选择相应的 Broker 集群队列进行消息投递，投递的过程支持快速失败并且低延迟。</p>
<h3 id="Consumer（消费者）"><a href="#Consumer（消费者）" class="headerlink" title="Consumer（消费者）"></a>Consumer（消费者）</h3><p>Consumer 支持分布式集群方式部署。支持以 push 推，pull 拉两种模式对消息进行消费。同时也支持集群方式和广播方式的消费，它提供实时消息订阅机制，可以满足大多数用户的需求。</p>
<h2 id="RocketMQ-安装"><a href="#RocketMQ-安装" class="headerlink" title="RocketMQ 安装"></a>RocketMQ 安装</h2><h3 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h3><ul>
<li>推荐 64 位操作系统：Linux&#x2F;Unix&#x2F;Mac</li>
<li>64bit JDK 1.8+</li>
<li>Maven 3.2.x</li>
<li>Git</li>
</ul>
<h3 id="下载解压"><a href="#下载解压" class="headerlink" title="下载解压"></a>下载解压</h3><p>进入官方下载地址：<a target="_blank" rel="noopener" href="https://rocketmq.apache.org/dowloading/releases/%EF%BC%8C%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%89%88%E6%9C%AC">https://rocketmq.apache.org/dowloading/releases/，选择合适版本</a></p>
<p>建议选择 binary 版本。</p>
<p>解压到本地：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; unzip rocketmq-all-4.2.0-source-release.zip</span><br><span class="line">&gt; <span class="built_in">cd</span> rocketmq-all-4.2.0/</span><br></pre></td></tr></table></figure>

<h3 id="启动-Name-Server"><a href="#启动-Name-Server" class="headerlink" title="启动 Name Server"></a>启动 Name Server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">nohup</span> sh bin/mqnamesrv &amp;</span><br><span class="line">&gt; <span class="built_in">tail</span> -f ~/logs/rocketmqlogs/namesrv.log</span><br><span class="line">The Name Server boot success...</span><br></pre></td></tr></table></figure>

<h3 id="启动-Broker"><a href="#启动-Broker" class="headerlink" title="启动 Broker"></a>启动 Broker</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">nohup</span> sh bin/mqbroker -n localhost:9876 -c conf/broker.conf &amp;</span><br><span class="line">&gt; <span class="built_in">tail</span> -f ~/logs/rocketmqlogs/broker.log</span><br><span class="line">The broker[%s, 172.30.30.233:10911] boot success...</span><br></pre></td></tr></table></figure>

<h3 id="收发消息"><a href="#收发消息" class="headerlink" title="收发消息"></a>收发消息</h3><p>执行收发消息操作之前，不许告诉客户端命名服务器的位置。在 RocketMQ 中有多种方法来实现这个目的。这里，我们使用最简单的方法——设置环境变量 <code>NAMESRV_ADDR</code> ：</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">export</span> NAMESRV_ADDR=localhost:9876</span><br><span class="line">&gt; sh bin/tools.sh org.apache.rocketmq.example.quickstart.Producer</span><br><span class="line">SendResult [sendStatus=SEND_OK, msgId= ...</span><br><span class="line"></span><br><span class="line">&gt; sh bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer</span><br><span class="line">ConsumeMessageThread_%d Receive New Messages: [MessageExt...</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="关闭服务器"><a href="#关闭服务器" class="headerlink" title="关闭服务器"></a>关闭服务器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; sh bin/mqshutdown broker</span><br><span class="line">The mqbroker(36695) is running...</span><br><span class="line">Send shutdown request to mqbroker(36695) OK</span><br><span class="line"></span><br><span class="line">&gt; sh bin/mqshutdown namesrv</span><br><span class="line">The mqnamesrv(36664) is running...</span><br><span class="line">Send shutdown request to mqnamesrv(36664) OK</span><br></pre></td></tr></table></figure>

<h2 id="RocketMQ-入门级示例"><a href="#RocketMQ-入门级示例" class="headerlink" title="RocketMQ 入门级示例"></a>RocketMQ 入门级示例</h2><p>首先在项目中引入 maven 依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><p>Producer 在 RocketMQ 中负责发送消息。</p>
<p>RocketMQ 有三种消息发送方式：</p>
<ul>
<li>可靠的同步发送</li>
<li>可靠的异步发送</li>
<li>单项发送</li>
</ul>
<h4 id="可靠的同步发送"><a href="#可靠的同步发送" class="headerlink" title="可靠的同步发送"></a>可靠的同步发送</h4><p>可靠的同步传输用于广泛的场景，如重要的通知消息，短信通知，短信营销系统等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//Instantiate with a producer group name.</span></span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line">            <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class="line">        <span class="comment">//Launch the instance.</span></span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//Create a message instance, specifying topic, tag and message body.</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;TopicTest&quot;</span> <span class="comment">/* Topic */</span>,</span><br><span class="line">                <span class="string">&quot;TagA&quot;</span> <span class="comment">/* Tag */</span>,</span><br><span class="line">                (<span class="string">&quot;Hello RocketMQ &quot;</span> +</span><br><span class="line">                    i).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class="comment">/* Message body */</span></span><br><span class="line">            );</span><br><span class="line">            <span class="comment">//Call send message to deliver message to one of brokers.</span></span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(msg);</span><br><span class="line">            System.out.printf(<span class="string">&quot;%s%n&quot;</span>, sendResult);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Shut down once the producer instance is not longer in use.</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可靠的异步发送"><a href="#可靠的异步发送" class="headerlink" title="可靠的异步发送"></a>可靠的异步发送</h4><p>异步传输通常用于响应时间敏感的业务场景。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//Instantiate with a producer group name.</span></span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;ExampleProducerGroup&quot;</span>);</span><br><span class="line">        <span class="comment">//Launch the instance.</span></span><br><span class="line">        producer.start();</span><br><span class="line">        producer.setRetryTimesWhenSendAsyncFailed(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> i;</span><br><span class="line">                <span class="comment">//Create a message instance, specifying topic, tag and message body.</span></span><br><span class="line">                <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;TopicTest&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;TagA&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;OrderID188&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;Hello world&quot;</span>.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">                producer.send(msg, <span class="keyword">new</span> <span class="title class_">SendCallback</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(SendResult sendResult)</span> &#123;</span><br><span class="line">                        System.out.printf(<span class="string">&quot;%-10d OK %s %n&quot;</span>, index,</span><br><span class="line">                            sendResult.getMsgId());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onException</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">                        System.out.printf(<span class="string">&quot;%-10d Exception %s %n&quot;</span>, index, e);</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Shut down once the producer instance is not longer in use.</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="单向传输"><a href="#单向传输" class="headerlink" title="单向传输"></a>单向传输</h4><p>单向传输用于需要中等可靠性的情况，例如日志收集。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OnewayProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//Instantiate with a producer group name.</span></span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;ExampleProducerGroup&quot;</span>);</span><br><span class="line">        <span class="comment">//Launch the instance.</span></span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//Create a message instance, specifying topic, tag and message body.</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;TopicTest&quot;</span> <span class="comment">/* Topic */</span>,</span><br><span class="line">                <span class="string">&quot;TagA&quot;</span> <span class="comment">/* Tag */</span>,</span><br><span class="line">                (<span class="string">&quot;Hello RocketMQ &quot;</span> +</span><br><span class="line">                    i).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class="comment">/* Message body */</span></span><br><span class="line">            );</span><br><span class="line">            <span class="comment">//Call send message to deliver message to one of brokers.</span></span><br><span class="line">            producer.sendOneway(msg);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Shut down once the producer instance is not longer in use.</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>Consumer 在 RocketMQ 中负责接收消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderedConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;example_group_name&quot;</span>);</span><br><span class="line">        consumer.setNamesrvAddr(RocketConfig.HOST);</span><br><span class="line"></span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line"></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;TopicTest&quot;</span>, <span class="string">&quot;TagA || TagC || TagD&quot;</span>);</span><br><span class="line"></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerOrderly</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">AtomicLong</span> <span class="variable">consumeTimes</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeOrderlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span><br><span class="line"><span class="params">                ConsumeOrderlyContext context)</span> &#123;</span><br><span class="line">                context.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">                System.out.printf(Thread.currentThread().getName() + <span class="string">&quot; Receive New Messages: &quot;</span> + msgs + <span class="string">&quot;%n&quot;</span>);</span><br><span class="line">                <span class="built_in">this</span>.consumeTimes.incrementAndGet();</span><br><span class="line">                <span class="keyword">if</span> ((<span class="built_in">this</span>.consumeTimes.get() % <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="built_in">this</span>.consumeTimes.get() % <span class="number">3</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ConsumeOrderlyStatus.ROLLBACK;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="built_in">this</span>.consumeTimes.get() % <span class="number">4</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ConsumeOrderlyStatus.COMMIT;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="built_in">this</span>.consumeTimes.get() % <span class="number">5</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    context.setSuspendCurrentQueueTimeMillis(<span class="number">3000</span>);</span><br><span class="line">                    <span class="keyword">return</span> ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        consumer.start();</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;Consumer Started.%n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RocketMQ-官方示例"><a href="#RocketMQ-官方示例" class="headerlink" title="RocketMQ 官方示例"></a>RocketMQ 官方示例</h2><ul>
<li><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/docs/simple-example/">Simple Example</a><ul>
<li>使用 RocketMQ 通过三种方式发送消息：可靠同步、可靠异步、单向传输。</li>
<li>使用 RocketMQ 消费消息。</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/docs/order-example/">Order Example</a>：RocketMQ 使用 FIFO 顺序提供有序消息。</li>
<li><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/docs/broadcast-example/">Broadcasting Example</a></li>
<li><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/docs/schedule-example/">Schedule Example</a></li>
<li><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/docs/batch-example/">Batch Example</a></li>
<li><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/docs/filter-by-sql92-example/">Filter Example</a></li>
<li><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/docs/logappender-example/">Logappender Example</a></li>
<li><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/docs/openmessaging-example/">OpenMessaging Example</a></li>
<li><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/docs/transaction-example/">Transaction Example</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="http://rocketmq.apache.org/docs/quick-start/">RocketMQ 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/453c6e7ff81c">分布式开放消息系统(RocketMQ)的原理与实践</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/5aee88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/5aee88/" class="post-title-link" itemprop="url">ActiveMQ 快速入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-17 22:34:30" itemprop="dateCreated datePublished" datetime="2022-02-17T22:34:30+08:00">2022-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:53" itemprop="dateModified" datetime="2024-12-12T10:02:53+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/" itemprop="url" rel="index"><span itemprop="name">分布式通信</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/MQ/" itemprop="url" rel="index"><span itemprop="name">MQ</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/MQ/%E5%85%B6%E4%BB%96MQ/" itemprop="url" rel="index"><span itemprop="name">其他MQ</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="ActiveMQ-快速入门"><a href="#ActiveMQ-快速入门" class="headerlink" title="ActiveMQ 快速入门"></a>ActiveMQ 快速入门</h1><h2 id="JMS-基本概念"><a href="#JMS-基本概念" class="headerlink" title="JMS 基本概念"></a>JMS 基本概念</h2><p><code>JMS</code> 即 <strong>Java 消息服务（Java Message Service）API</strong>，是一个 Java 平台中关于面向消息中间件的 API。它用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。Java 消息服务是一个与具体平台无关的 API，绝大多数 MOM 提供商都对 JMS 提供支持。</p>
<h3 id="消息模型"><a href="#消息模型" class="headerlink" title="消息模型"></a>消息模型</h3><p>JMS 有两种消息模型：</p>
<ul>
<li>Point-to-Point(P2P)</li>
<li>Publish&#x2F;Subscribe(Pub&#x2F;Sub)</li>
</ul>
<h4 id="P2P-的特点"><a href="#P2P-的特点" class="headerlink" title="P2P 的特点"></a>P2P 的特点</h4><p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javalib/jms/jms-pointToPoint.gif" alt="img"></p>
<p>在点对点的消息系统中，消息分发给一个单独的使用者。点对点消息往往与队列 <code>javax.jms.Queue</code> 相关联。</p>
<p>每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在消息队列中)。</p>
<p>发送者和接收者之间在时间上没有依赖性，也就是说当发送者发送了消息之后，不管接收者有没有正在运行，它不会影响到消息被发送到队列。</p>
<p>接收者在成功接收消息之后需向队列应答成功。</p>
<p>如果你希望发送的每个消息都应该被成功处理的话，那么你需要 P2P 模式。</p>
<h4 id="Pub-Sub-的特点"><a href="#Pub-Sub-的特点" class="headerlink" title="Pub&#x2F;Sub 的特点"></a>Pub&#x2F;Sub 的特点</h4><p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javalib/jms/jms-publishSubscribe.gif" alt="img"></p>
<p>发布&#x2F;订阅消息系统支持一个事件驱动模型，消息生产者和消费者都参与消息的传递。生产者发布事件，而使用者订阅感兴趣的事件，并使用事件。该类型消息一般与特定的主题 <code>javax.jms.Topic</code> 关联。</p>
<p>每个消息可以有多个消费者。</p>
<p>发布者和订阅者之间有时间上的依赖性。针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息，而且为了消费消息，订阅者必须保持运行的状态。</p>
<p>为了缓和这样严格的时间相关性，JMS 允许订阅者创建一个可持久化的订阅。这样，即使订阅者没有被激活（运行），它也能接收到发布者的消息。</p>
<p>如果你希望发送的消息可以不被做任何处理、或者被一个消息者处理、或者可以被多个消费者处理的话，那么可以采用 Pub&#x2F;Sub 模型。</p>
<h3 id="JMS-编程模型"><a href="#JMS-编程模型" class="headerlink" title="JMS 编程模型"></a>JMS 编程模型</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javalib/jms/jms-publishSubscribe.gif" alt="img"></p>
<h4 id="ConnectionFactory"><a href="#ConnectionFactory" class="headerlink" title="ConnectionFactory"></a>ConnectionFactory</h4><p>创建 <code>Connection</code> 对象的工厂，针对两种不同的 jms 消息模型，分别有 <code>QueueConnectionFactory</code> 和<code>TopicConnectionFactory</code> 两种。可以通过 JNDI 来查找 <code>ConnectionFactory</code> 对象。</p>
<h4 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h4><p><code>Connection</code> 表示在客户端和 JMS 系统之间建立的链接（对 TCP&#x2F;IP socket 的包装）。<code>Connection</code> 可以产生一个或多个<code>Session</code>。跟 <code>ConnectionFactory</code> 一样，<code>Connection</code> 也有两种类型：<code>QueueConnection</code> 和 <code>TopicConnection</code>。</p>
<h4 id="Destination"><a href="#Destination" class="headerlink" title="Destination"></a>Destination</h4><p><code>Destination</code> 是一个包装了消息目标标识符的被管对象。消息目标是指消息发布和接收的地点，或者是队列 <code>Queue</code> ，或者是主题 <code>Topic</code> 。JMS 管理员创建这些对象，然后用户通过 JNDI 发现它们。和连接工厂一样，管理员可以创建两种类型的目标，点对点模型的 <code>Queue</code>，以及发布者&#x2F;订阅者模型的 <code>Topic</code>。</p>
<h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p><code>Session</code> 表示一个单线程的上下文，用于发送和接收消息。由于会话是单线程的，所以消息是连续的，就是说消息是按照发送的顺序一个一个接收的。会话的好处是它支持事务。如果用户选择了事务支持，会话上下文将保存一组消息，直到事务被提交才发送这些消息。在提交事务之前，用户可以使用回滚操作取消这些消息。一个会话允许用户创建消息，生产者来发送消息，消费者来接收消息。同样，<code>Session</code> 也分 <code>QueueSession</code> 和 <code>TopicSession</code>。</p>
<h4 id="MessageConsumer"><a href="#MessageConsumer" class="headerlink" title="MessageConsumer"></a>MessageConsumer</h4><p><code>MessageConsumer</code> 由 <code>Session</code> 创建，并用于将消息发送到 <code>Destination</code>。消费者可以同步地（阻塞模式），或（非阻塞）接收 <code>Queue</code> 和 <code>Topic</code> 类型的消息。同样，消息生产者分两种类型：<code>QueueSender</code> 和<code>TopicPublisher</code>。</p>
<h4 id="MessageProducer"><a href="#MessageProducer" class="headerlink" title="MessageProducer"></a>MessageProducer</h4><p><code>MessageProducer</code> 由 <code>Session</code> 创建，用于接收被发送到 <code>Destination</code> 的消息。<code>MessageProducer</code> 有两种类型：<code>QueueReceiver</code> 和 <code>TopicSubscriber</code>。可分别通过 <code>session</code> 的 <code>createReceiver(Queue)</code> 或 <code>createSubscriber(Topic)</code> 来创建。当然，也可以 <code>session</code> 的 <code>creatDurableSubscriber</code> 方法来创建持久化的订阅者。</p>
<h4 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h4><p>是在消费者和生产者之间传送的对象，也就是说从一个应用程序传送到另一个应用程序。一个消息有三个主要部分：</p>
<ul>
<li>消息头（必须）：包含用于识别和为消息寻找路由的操作设置。</li>
<li>一组消息属性（可选）：包含额外的属性，支持其他提供者和用户的兼容。可以创建定制的字段和过滤器（消息选择器）。</li>
<li>一个消息体（可选）：允许用户创建五种类型的消息（文本消息，映射消息，字节消息，流消息和对象消息）。</li>
</ul>
<p>消息接口非常灵活，并提供了许多方式来定制消息的内容。</p>
<table>
<thead>
<tr>
<th>Common</th>
<th>Point-to-Point</th>
<th>Publish-Subscribe</th>
</tr>
</thead>
<tbody><tr>
<td>ConnectionFactory</td>
<td>QueueConnectionFactory</td>
<td>TopicConnectionFactory</td>
</tr>
<tr>
<td>Connection</td>
<td>QueueConnection</td>
<td>TopicConnection</td>
</tr>
<tr>
<td>Destination</td>
<td>Queue</td>
<td>Topic</td>
</tr>
<tr>
<td>Session</td>
<td>QueueSession</td>
<td>TopicSession</td>
</tr>
<tr>
<td>MessageProducer</td>
<td>QueueSender</td>
<td>TopicPublisher</td>
</tr>
<tr>
<td>MessageSender</td>
<td>QueueReceiver, QueueBrowser</td>
<td>TopicSubscriber</td>
</tr>
</tbody></table>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><strong>安装条件</strong></p>
<p>JDK1.7 及以上版本</p>
<p>本地配置了 <strong>JAVA_HOME</strong> 环境变量。</p>
<p><strong>下载</strong></p>
<p>支持 Windows&#x2F;Unix&#x2F;Linux&#x2F;Cygwin</p>
<p><a target="_blank" rel="noopener" href="http://activemq.apache.org/download.html">ActiveMQ 官方下载地址</a></p>
<p><strong>Windows 下运行</strong></p>
<p>（1）解压压缩包到本地；</p>
<p>（2）打开控制台，进入安装目录的 <code>bin</code> 目录下；</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cd</span><span class="meta"> [activemq_install_dir]</span></span><br></pre></td></tr></table></figure>

<p>（3）执行 <code>activemq start</code> 来启动 ActiveMQ</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin\activemq <span class="literal">start</span></span><br></pre></td></tr></table></figure>

<p><strong>测试安装是否成功</strong></p>
<p>（1）ActiveMQ 默认监听端口为 61616</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -an|<span class="built_in">find</span> “61616”</span><br></pre></td></tr></table></figure>

<p>（2）访问 <a target="_blank" rel="noopener" href="http://127.0.0.1:8161/admin/">http://127.0.0.1:8161/admin/</a></p>
<p>（3）输入用户名、密码</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Login</span>: <span class="keyword">admin</span></span><br><span class="line">Passwort: <span class="keyword">admin</span></span><br></pre></td></tr></table></figure>

<p>（4）点击导航栏的 Queues 菜单</p>
<p>（5）添加一个队列（queue）</p>
<h2 id="项目中的应用"><a href="#项目中的应用" class="headerlink" title="项目中的应用"></a>项目中的应用</h2><p><strong>引入依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.activemq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activemq-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.14.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>Sender.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sender</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SEND_NUMBER</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// ConnectionFactory ：连接工厂，JMS 用它创建连接</span></span><br><span class="line">        ConnectionFactory connectionFactory;</span><br><span class="line">        <span class="comment">// Connection ：JMS 客户端到JMS Provider 的连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// Session： 一个发送或接收消息的线程</span></span><br><span class="line">        Session session;</span><br><span class="line">        <span class="comment">// Destination ：消息的目的地;消息发送给谁.</span></span><br><span class="line">        Destination destination;</span><br><span class="line">        <span class="comment">// MessageProducer：消息发送者</span></span><br><span class="line">        MessageProducer producer;</span><br><span class="line">        <span class="comment">// TextMessage message;</span></span><br><span class="line">        <span class="comment">// 构造ConnectionFactory实例对象，此处采用ActiveMq的实现jar</span></span><br><span class="line">        connectionFactory = <span class="keyword">new</span> <span class="title class_">ActiveMQConnectionFactory</span>(</span><br><span class="line">                ActiveMQConnection.DEFAULT_USER,</span><br><span class="line">                ActiveMQConnection.DEFAULT_PASSWORD,</span><br><span class="line">                <span class="string">&quot;tcp://localhost:61616&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 构造从工厂得到连接对象</span></span><br><span class="line">            connection = connectionFactory.createConnection();</span><br><span class="line">            <span class="comment">// 启动</span></span><br><span class="line">            connection.start();</span><br><span class="line">            <span class="comment">// 获取操作连接</span></span><br><span class="line">            session = connection.createSession(Boolean.TRUE,</span><br><span class="line">                    Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">            <span class="comment">// 获取session注意参数值xingbo.xu-queue是一个服务器的queue，须在在ActiveMq的console配置</span></span><br><span class="line">            destination = session.createQueue(<span class="string">&quot;FirstQueue&quot;</span>);</span><br><span class="line">            <span class="comment">// 得到消息生成者【发送者】</span></span><br><span class="line">            producer = session.createProducer(destination);</span><br><span class="line">            <span class="comment">// 设置不持久化，此处学习，实际根据项目决定</span></span><br><span class="line">            producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);</span><br><span class="line">            <span class="comment">// 构造消息，此处写死，项目就是参数，或者方法获取</span></span><br><span class="line">            sendMessage(session, producer);</span><br><span class="line">            session.commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != connection)</span><br><span class="line">                    connection.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(Session session, MessageProducer producer)</span></span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= SEND_NUMBER; i++) &#123;</span><br><span class="line">            <span class="type">TextMessage</span> <span class="variable">message</span> <span class="operator">=</span> session</span><br><span class="line">                    .createTextMessage(<span class="string">&quot;ActiveMq 发送的消息&quot;</span> + i);</span><br><span class="line">            <span class="comment">// 发送消息到目的地方</span></span><br><span class="line">            System.out.println(<span class="string">&quot;发送消息：&quot;</span> + <span class="string">&quot;ActiveMq 发送的消息&quot;</span> + i);</span><br><span class="line">            producer.send(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Receiver.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Receiver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// ConnectionFactory ：连接工厂，JMS 用它创建连接</span></span><br><span class="line">        ConnectionFactory connectionFactory;</span><br><span class="line">        <span class="comment">// Connection ：JMS 客户端到JMS Provider 的连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// Session： 一个发送或接收消息的线程</span></span><br><span class="line">        Session session;</span><br><span class="line">        <span class="comment">// Destination ：消息的目的地;消息发送给谁.</span></span><br><span class="line">        Destination destination;</span><br><span class="line">        <span class="comment">// 消费者，消息接收者</span></span><br><span class="line">        MessageConsumer consumer;</span><br><span class="line">        connectionFactory = <span class="keyword">new</span> <span class="title class_">ActiveMQConnectionFactory</span>(</span><br><span class="line">                ActiveMQConnection.DEFAULT_USER,</span><br><span class="line">                ActiveMQConnection.DEFAULT_PASSWORD,</span><br><span class="line">                <span class="string">&quot;tcp://localhost:61616&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 构造从工厂得到连接对象</span></span><br><span class="line">            connection = connectionFactory.createConnection();</span><br><span class="line">            <span class="comment">// 启动</span></span><br><span class="line">            connection.start();</span><br><span class="line">            <span class="comment">// 获取操作连接</span></span><br><span class="line">            session = connection.createSession(Boolean.FALSE,</span><br><span class="line">                    Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">            <span class="comment">// 获取session注意参数值xingbo.xu-queue是一个服务器的queue，须在在ActiveMq的console配置</span></span><br><span class="line">            destination = session.createQueue(<span class="string">&quot;FirstQueue&quot;</span>);</span><br><span class="line">            consumer = session.createConsumer(destination);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">//设置接收者接收消息的时间，为了便于测试，这里谁定为100s</span></span><br><span class="line">                <span class="type">TextMessage</span> <span class="variable">message</span> <span class="operator">=</span> (TextMessage) consumer.receive(<span class="number">100000</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != message) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;收到消息&quot;</span> + message.getText());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != connection)</span><br><span class="line">                    connection.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行</strong></p>
<p>先运行 Receiver.java 进行消息监听，再运行 Send.java 发送消息。</p>
<p><strong>输出</strong></p>
<p>Send 的输出内容</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">发送消息：Activemq 发送消息0</span><br><span class="line">发送消息：Activemq 发送消息1</span><br><span class="line">发送消息：Activemq 发送消息2</span><br><span class="line">发送消息：Activemq 发送消息3</span><br></pre></td></tr></table></figure>

<p>Receiver 的输出内容</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">收到消息ActiveMQ 发送消息0</span><br><span class="line">收到消息ActiveMQ 发送消息1</span><br><span class="line">收到消息ActiveMQ 发送消息2</span><br><span class="line">收到消息ActiveMQ 发送消息3</span><br></pre></td></tr></table></figure>

<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><ul>
<li><a target="_blank" rel="noopener" href="http://activemq.apache.org/">ActiveMQ 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/cd/E19575-01/819-3669/6n5sg7cgq/index.html">oracle 官方的 jms 介绍</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/3a499f/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/3a499f/" class="post-title-link" itemprop="url">Dubbo 快速入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-17 22:34:30" itemprop="dateCreated datePublished" datetime="2022-02-17T22:34:30+08:00">2022-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:53" itemprop="dateModified" datetime="2024-12-12T10:02:53+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/" itemprop="url" rel="index"><span itemprop="name">分布式通信</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/RPC/" itemprop="url" rel="index"><span itemprop="name">RPC</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/RPC/Dubbo/" itemprop="url" rel="index"><span itemprop="name">Dubbo</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>23k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>21 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Dubbo-快速入门"><a href="#Dubbo-快速入门" class="headerlink" title="Dubbo 快速入门"></a>Dubbo 快速入门</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://dubbo.apache.org/zh-cn/">Apache Dubbo</a> 是一款高性能、轻量级的开源 Java RPC 框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。</p>
</blockquote>
<h2 id="一、Dubbo-简介"><a href="#一、Dubbo-简介" class="headerlink" title="一、Dubbo 简介"></a>一、Dubbo 简介</h2><p><a target="_blank" rel="noopener" href="https://dubbo.apache.org/zh-cn/">Apache Dubbo</a> 是一款高性能、轻量级的开源 Java RPC 框架。</p>
<p>Dubbo 提供了三大核心能力：</p>
<ul>
<li>面向接口的远程方法调用</li>
<li>智能容错和负载均衡</li>
<li>服务自动注册和发现</li>
</ul>
<h3 id="RPC-原理简介"><a href="#RPC-原理简介" class="headerlink" title="RPC 原理简介"></a>RPC 原理简介</h3><h4 id="什么是-RPC"><a href="#什么是-RPC" class="headerlink" title="什么是 RPC"></a>什么是 RPC</h4><p>RPC（Remote Procedure Call），即远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。比如两个不同的服务 A、B 部署在两台不同的机器上，那么服务 A 如果想要调用服务 B 中的某个方法该怎么办呢？使用 HTTP 请求 当然可以，但是可能会比较慢而且一些优化做的并不好。 RPC 的出现就是为了解决这个问题。</p>
<h4 id="RPC-工作流程"><a href="#RPC-工作流程" class="headerlink" title="RPC 工作流程"></a>RPC 工作流程</h4><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200305121252.jpg" alt="img"></p>
<ol>
<li>服务消费方（client）调用以本地调用方式调用服务；</li>
<li>client stub 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；</li>
<li>client stub 找到服务地址，并将消息发送到服务端；</li>
<li>server stub 收到消息后进行解码；</li>
<li>server stub 根据解码结果调用本地的服务；</li>
<li>本地服务执行并将结果返回给 server stub；</li>
<li>server stub 将返回结果打包成消息并发送至消费方；</li>
<li>client stub 接收到消息，并进行解码；</li>
<li>服务消费方得到最终结果。</li>
</ol>
<h3 id="为什么需要-Dubbo"><a href="#为什么需要-Dubbo" class="headerlink" title="为什么需要 Dubbo"></a>为什么需要 Dubbo</h3><p><strong>如果你要开发分布式程序，你也可以直接基于 HTTP 接口进行通信，但是为什么要用 Dubbo 呢？</strong></p>
<p>我觉得主要可以从 Dubbo 提供的下面四点特性来说为什么要用 Dubbo：</p>
<ol>
<li><strong>负载均衡</strong>——同一个服务部署在不同的机器时该调用那一台机器上的服务。</li>
<li><strong>服务调用链路</strong>——随着系统的发展，服务越来越多，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。Dubbo 可以为我们解决服务之间互相是如何调用的。</li>
<li><strong>服务访问压力以及时长统计、资源调度和治理</strong>——基于访问压力实时管理集群容量，提高集群利用率。</li>
<li><strong>服务治理</strong>——某个服务挂掉之后调用备用服务。</li>
</ol>
<p>另外，Dubbo 除了能够应用在分布式系统中，也可以应用在现在比较火的微服务系统中。不过，由于 Spring Cloud 在微服务中应用更加广泛，所以，我觉得一般我们提 Dubbo 的话，大部分是分布式系统的情况。</p>
<h2 id="二、QuickStart"><a href="#二、QuickStart" class="headerlink" title="二、QuickStart"></a>二、QuickStart</h2><p>（1）添加 maven 依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;dubbo.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）定义 Provider</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DemoService</span> &#123;</span><br><span class="line">    String <span class="title function_">sayHello</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）实现 Provider</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.demo.provider;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.demo.DemoService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">DemoService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）配置 Provider</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;demo-provider&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;multicast://224.5.6.7:1234&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">port</span>=<span class="string">&quot;20880&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.alibaba.dubbo.demo.DemoService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;demoService&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;demoService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.dubbo.demo.provider.DemoServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（5）启动 Provider</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Provider</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;META-INF/spring/dubbo-demo-provider.xml&quot;</span>&#125;);</span><br><span class="line">        context.start();</span><br><span class="line">        <span class="comment">// press any key to exit</span></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（6）配置 Consumer</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;demo-consumer&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;multicast://224.5.6.7:1234&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;demoService&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;com.alibaba.dubbo.demo.DemoService&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（7）启动 Consumer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.demo.DemoService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;META-INF/spring/dubbo-demo-consumer.xml&quot;</span>&#125;);</span><br><span class="line">        context.start();</span><br><span class="line">        <span class="comment">// obtain proxy object for remote invocation</span></span><br><span class="line">        <span class="type">DemoService</span> <span class="variable">demoService</span> <span class="operator">=</span> (DemoService) context.getBean(<span class="string">&quot;demoService&quot;</span>);</span><br><span class="line">        <span class="comment">// execute remote invocation</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">hello</span> <span class="operator">=</span> demoService.sayHello(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        <span class="comment">// show the result</span></span><br><span class="line">        System.out.println(hello);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、Dubbo-配置"><a href="#三、Dubbo-配置" class="headerlink" title="三、Dubbo 配置"></a>三、Dubbo 配置</h2><p>Dubbo 所有配置最终都将转换为 URL 表示，并由服务提供方生成，经注册中心传递给消费方，各属性对应 URL 的参数，参见配置项一览表中的 “对应 URL 参数” 列。</p>
<p>只有 group，interface，version 是服务的匹配条件，三者决定是不是同一个服务，其它配置项均为调优和治理参数。</p>
<p>URL 格式：<code>protocol://username:password@host:port/path?key=value&amp;key=value</code></p>
<h3 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h3><p>Dubbo 支持多种配置方式：</p>
<ul>
<li>xml 配置</li>
<li>properties 配置</li>
<li>API 配置</li>
<li>注解配置</li>
</ul>
<p>如果同时存在多种配置方式，遵循以下覆盖策略：</p>
<ul>
<li>JVM 启动 -D 参数优先，这样可以使用户在部署和启动时进行参数重写，比如在启动时需改变协议的端口。</li>
<li>XML 次之，如果在 XML 中有配置，则 dubbo.properties 中的相应配置项无效。</li>
<li>Properties 最后，相当于缺省值，只有 XML 没有配置时，dubbo.properties 的相应配置项才会生效，通常用于共享公共配置，比如应用名。</li>
</ul>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/distributed/rpc/dubbo/dubbo配置覆盖策略.jpg" width="300"/>
</div>

<h4 id="xml-配置"><a href="#xml-配置" class="headerlink" title="xml 配置"></a>xml 配置</h4><p>示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://dubbo.apache.org/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;hello-world-app&quot;</span>  /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用 multicast 广播注册中心暴露服务地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;multicast://224.5.6.7:1234&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 用 dubbo 协议在 20880 端口暴露服务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">port</span>=<span class="string">&quot;20880&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 声明需要暴露的服务接口 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.alibaba.dubbo.demo.DemoService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;demoServiceLocal&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 和本地 bean 一样实现服务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;demoService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.dubbo.demo.provider.DemoServiceImpl&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 生成远程服务代理，可以和本地 bean 一样使用 demoService --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;demoServiceRemote&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;com.alibaba.dubbo.demo.DemoService&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Dubbo 会把以上配置项解析成下面的 URL 格式：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">dubbo:</span>//host-ip:<span class="number">20880</span>/<span class="keyword">com</span>.alibaba.dubbo.demo.DemoService</span><br></pre></td></tr></table></figure>

<p>然后基于<a target="_blank" rel="noopener" href="http://dubbo.incubator.apache.org/zh-cn/docs/dev/SPI.html">扩展点自适应机制</a>，通过 URL 的 <code>dubbo://</code> 协议头识别，就会调用 DubboProtocol 的 export() 方法，打开服务端口 20880，就可以把服务 demoService 暴露到 20880 端口了。</p>
<h4 id="properties-配置"><a href="#properties-配置" class="headerlink" title="properties 配置"></a>properties 配置</h4><p>示例：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dubbo.application.name</span>=<span class="string">foo</span></span><br><span class="line"><span class="attr">dubbo.application.owner</span>=<span class="string">bar</span></span><br><span class="line"><span class="attr">dubbo.registry.address</span>=<span class="string">10.20.153.10:9090</span></span><br></pre></td></tr></table></figure>

<h3 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h3><p>所有配置项分为三大类：</p>
<ul>
<li>服务发现：表示该配置项用于服务的注册与发现，目的是让消费方找到提供方。</li>
<li>服务治理：表示该配置项用于治理服务间的关系，或为开发测试提供便利条件。</li>
<li>性能调优：表示该配置项用于调优性能，不同的选项对性能会产生影响。</li>
</ul>
<p>配置项清单：</p>
<table>
<thead>
<tr>
<th>标签</th>
<th>用途</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>dubbo:service</code></td>
<td>服务配置</td>
<td>用于暴露一个服务，定义服务的元信息，一个服务可以用多个协议暴露，一个服务也可以注册到多个注册中心</td>
</tr>
<tr>
<td><code>dubbo:reference</code></td>
<td>引用配置</td>
<td>用于创建一个远程服务代理，一个引用可以指向多个注册中心</td>
</tr>
<tr>
<td><code>dubbo:protocol</code></td>
<td>协议配置</td>
<td>用于配置提供服务的协议信息，协议由提供方指定，消费方被动接受</td>
</tr>
<tr>
<td><code>dubbo:application</code></td>
<td>应用配置</td>
<td>用于配置当前应用信息，不管该应用是提供者还是消费者</td>
</tr>
<tr>
<td><code>dubbo:module</code></td>
<td>模块配置</td>
<td>用于配置当前模块信息，可选</td>
</tr>
<tr>
<td><code>dubbo:registry</code></td>
<td>注册中心配置</td>
<td>用于配置连接注册中心相关信息</td>
</tr>
<tr>
<td><code>dubbo:monitor</code></td>
<td>监控中心配置</td>
<td>用于配置连接监控中心相关信息，可选</td>
</tr>
<tr>
<td><code>dubbo:provider</code></td>
<td>提供方配置</td>
<td>当 ProtocolConfig 和 ServiceConfig 某属性没有配置时，采用此缺省值，可选</td>
</tr>
<tr>
<td><code>dubbo:consumer</code></td>
<td><code>消费方配置</code></td>
<td><code>当 ReferenceConfig 某属性没有配置时，采用此缺省值，可选</code></td>
</tr>
<tr>
<td><code>dubbo:method</code></td>
<td>方法配置</td>
<td>用于 ServiceConfig 和 ReferenceConfig 指定方法级的配置信息</td>
</tr>
<tr>
<td><code>dubbo:argument</code></td>
<td>参数配置</td>
<td>用于指定方法参数配置</td>
</tr>
</tbody></table>
<blockquote>
<p>详细配置说明请参考：<a target="_blank" rel="noopener" href="http://dubbo.apache.org/books/dubbo-user-book/references/xml/introduction.html">官方配置</a></p>
</blockquote>
<h4 id="配置之间的关系"><a href="#配置之间的关系" class="headerlink" title="配置之间的关系"></a>配置之间的关系</h4><div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/distributed/rpc/dubbo/dubbo配置关系.jpg" width="600"/>
</div>

<h4 id="配置覆盖关系"><a href="#配置覆盖关系" class="headerlink" title="配置覆盖关系"></a>配置覆盖关系</h4><p>以 timeout 为例，显示了配置的查找顺序，其它 retries, loadbalance, actives 等类似：</p>
<ul>
<li><strong>方法级优先，接口级次之，全局配置再次之</strong>。</li>
<li><strong>如果级别一样，则消费方优先，提供方次之</strong>。</li>
</ul>
<p>其中，服务提供方配置，通过 URL 经由注册中心传递给消费方。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/distributed/rpc/dubbo/dubbo配置覆盖关系.jpg" width="500"/>
</div>
### 动态配置中心

<p>配置中心（v2.7.0）在 Dubbo 中承担两个职责：</p>
<ol>
<li>外部化配置。启动配置的集中式存储 （简单理解为 dubbo.properties 的外部化存储）。</li>
<li>服务治理。服务治理规则的存储与通知。</li>
</ol>
<p>启用动态配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:config-center</span> <span class="attr">address</span>=<span class="string">&quot;zookeeper://127.0.0.1:2181&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dubbo.config-center.address</span>=<span class="string">zookeeper://127.0.0.1:2181</span></span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ConfigCenterConfig</span> <span class="variable">configCenter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConfigCenterConfig</span>();</span><br><span class="line">configCenter.setAddress(<span class="string">&quot;zookeeper://127.0.0.1:2181&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="四、Dubbo-架构"><a href="#四、Dubbo-架构" class="headerlink" title="四、Dubbo 架构"></a>四、Dubbo 架构</h2><h3 id="Dubbo-核心组件"><a href="#Dubbo-核心组件" class="headerlink" title="Dubbo 核心组件"></a>Dubbo 核心组件</h3><div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/distributed/rpc/dubbo/dubbo基本架构.png" width="500"/>
</div>

<p>节点角色：</p>
<table>
<thead>
<tr>
<th>节点</th>
<th>角色说明</th>
</tr>
</thead>
<tbody><tr>
<td>Provider</td>
<td>暴露服务的服务提供方</td>
</tr>
<tr>
<td>Consumer</td>
<td>调用远程服务的服务消费方</td>
</tr>
<tr>
<td>Registry</td>
<td>服务注册与发现的注册中心</td>
</tr>
<tr>
<td>Monitor</td>
<td>统计服务的调用次数和调用时间的监控中心</td>
</tr>
<tr>
<td>Container</td>
<td>服务运行容器</td>
</tr>
</tbody></table>
<p>调用关系：</p>
<ol>
<li>服务容器负责启动，加载，运行服务提供者。</li>
<li>服务提供者在启动时，向注册中心注册自己提供的服务。</li>
<li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li>
<li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li>
<li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li>
<li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li>
</ol>
<p><strong>重要知识点总结：</strong></p>
<ul>
<li><strong>注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小</strong></li>
<li><strong>监控中心负责统计各服务调用次数，调用时间等，统计先在内存汇总后每分钟一次发送到监控中心服务器，并以报表展示</strong></li>
<li><strong>注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外</strong></li>
<li><strong>注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者</strong></li>
<li><strong>注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表</strong></li>
<li><strong>注册中心和监控中心都是可选的，服务消费者可以直连服务提供者</strong></li>
<li><strong>服务提供者无状态，任意一台宕掉后，不影响使用</strong></li>
<li><strong>服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复</strong></li>
</ul>
<blockquote>
<p>问：注册中心挂了可以继续通信吗？</p>
<p>答：可以，因为刚开始初始化的时候，消费者会将提供者的地址等信息<strong>拉取到本地缓存</strong>，所以注册中心挂了可以继续通信。</p>
</blockquote>
<h3 id="Dubbo-架构层次"><a href="#Dubbo-架构层次" class="headerlink" title="Dubbo 架构层次"></a>Dubbo 架构层次</h3><div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/distributed/rpc/dubbo/dubbo整体设计.jpg" />
</div>

<p>图例说明：</p>
<ul>
<li>图中左边淡蓝背景的为服务消费方使用的接口，右边淡绿色背景的为服务提供方使用的接口，位于中轴线上的为双方都用到的接口。</li>
<li>图中从下至上分为十层，各层均为单向依赖，右边的黑色箭头代表层之间的依赖关系，每一层都可以剥离上层被复用，其中，Service 和 Config 层为 API，其它各层均为 SPI。</li>
<li>图中绿色小块的为扩展接口，蓝色小块为实现类，图中只显示用于关联各层的实现类。</li>
<li>图中蓝色虚线为初始化过程，即启动时组装链，红色实线为方法调用过程，即运行时调时链，紫色三角箭头为继承，可以把子类看作父类的同一个节点，线上的文字为调用的方法。</li>
</ul>
<h4 id="各层说明"><a href="#各层说明" class="headerlink" title="各层说明"></a>各层说明</h4><ul>
<li><strong>config 配置层</strong>：对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类</li>
<li><strong>proxy 服务代理层</strong>：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 ServiceProxy 为中心，扩展接口为 ProxyFactory</li>
<li><strong>registry 注册中心层</strong>：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 RegistryFactory, Registry, RegistryService</li>
<li><strong>cluster 路由层</strong>：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 Cluster, Directory, Router, LoadBalance</li>
<li><strong>monitor 监控层</strong>：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory, Monitor, MonitorService</li>
<li><strong>protocol 远程调用层</strong>：封装 RPC 调用，以 Invocation, Result 为中心，扩展接口为 Protocol, Invoker, Exporter</li>
<li><strong>exchange 信息交换层</strong>：封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer</li>
<li><strong>transport 网络传输层</strong>：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel, Transporter, Client, Server, Codec</li>
<li><strong>serialize 数据序列化层</strong>：可复用的一些工具，扩展接口为 Serialization, ObjectInput, ObjectOutput, ThreadPool</li>
<li><strong>serialize 数据序列化层</strong>：可复用的一些工具，扩展接口为 Serialization, ObjectInput, ObjectOutput, ThreadPool</li>
</ul>
<h4 id="各层关系说明"><a href="#各层关系说明" class="headerlink" title="各层关系说明"></a>各层关系说明</h4><ul>
<li>在 RPC 中，Protocol 是核心层，也就是只要有 Protocol + Invoker + Exporter 就可以完成非透明的 RPC 调用，然后在 Invoker 的主过程上 Filter 拦截点。</li>
<li>图中的 Consumer 和 Provider 是抽象概念，只是想让看图者更直观的了解哪些类分属于客户端与服务器端，不用 Client 和 Server 的原因是 Dubbo 在很多场景下都使用 Provider, Consumer, Registry, Monitor 划分逻辑拓普节点，保持统一概念。</li>
<li>而 Cluster 是外围概念，所以 Cluster 的目的是将多个 Invoker 伪装成一个 Invoker，这样其它人只要关注 Protocol 层 Invoker 即可，加上 Cluster 或者去掉 Cluster 对其它层都不会造成影响，因为只有一个提供者时，是不需要 Cluster 的。</li>
<li>Proxy 层封装了所有接口的透明化代理，而在其它层都以 Invoker 为中心，只有到了暴露给用户使用时，才用 Proxy 将 Invoker 转成接口，或将接口实现转成 Invoker，也就是去掉 Proxy 层 RPC 是可以 Run 的，只是不那么透明，不那么看起来像调本地服务一样调远程服务。</li>
<li>而 Remoting 实现是 Dubbo 协议的实现，如果你选择 RMI 协议，整个 Remoting 都不会用上，Remoting 内部再划为 Transport 传输层和 Exchange 信息交换层，Transport 层只负责单向消息传输，是对 Mina, Netty, Grizzly 的抽象，它也可以扩展 UDP 传输，而 Exchange 层是在传输层之上封装了 Request-Response 语义。</li>
<li>Registry 和 Monitor 实际上不算一层，而是一个独立的节点，只是为了全局概览，用层的方式画在一起。</li>
</ul>
<h2 id="五、服务发现"><a href="#五、服务发现" class="headerlink" title="五、服务发现"></a>五、服务发现</h2><p>服务提供者注册服务的过程：</p>
<p>Dubbo 配置项 <code>dubbo://registry</code> 声明了注册中心的地址，Dubbo 会把以上配置项解析成类似下面的 URL 格式：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registry:<span class="regexp">//mu</span>lticast:<span class="regexp">//</span><span class="number">224.5</span>.<span class="number">6.7</span>:<span class="number">1234</span><span class="regexp">/com.alibaba.dubbo.registry.RegistryService?export=URL.encode(&quot;dubbo:/</span><span class="regexp">/host-ip:20880/</span>com.alibaba.dubbo.demo.DemoService<span class="string">&quot;)</span></span><br></pre></td></tr></table></figure>

<p>然后基于扩展点自适应机制，通过 URL 的“registry:&#x2F;&#x2F;”协议头识别，就会调用 RegistryProtocol 的 export() 方法，将 export 参数中的提供者 URL，注册到注册中心。</p>
<p>服务消费者发现服务的过程：</p>
<p>Dubbo 配置项 <code>dubbo://registry</code> 声明了注册中心的地址，跟服务注册的原理类似，Dubbo 也会把以上配置项解析成下面的 URL 格式：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registry:<span class="regexp">//mu</span>lticast:<span class="regexp">//</span><span class="number">224.5</span>.<span class="number">6.7</span>:<span class="number">1234</span><span class="regexp">/com.alibaba.dubbo.registry.RegistryService?refer=URL.encode(&quot;consummer:/</span><span class="regexp">/host-ip/</span>com.alibaba.dubbo.demo.DemoService<span class="string">&quot;)</span></span><br></pre></td></tr></table></figure>

<p>然后基于扩展点自适应机制，通过 URL 的“registry:&#x2F;&#x2F;”协议头识别，就会调用 RegistryProtocol 的 refer() 方法，基于 refer 参数中的条件，查询服务 demoService 的地址。</p>
<h3 id="启动时检查"><a href="#启动时检查" class="headerlink" title="启动时检查"></a>启动时检查</h3><p>Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，以便上线时，能及早发现问题，默认 <code>check=&quot;true&quot;</code>。</p>
<p>可以通过 xml、properties、-D 参数三种方式设置。启动时检查</p>
<h2 id="六、Dubbo-协议"><a href="#六、Dubbo-协议" class="headerlink" title="六、Dubbo 协议"></a>六、Dubbo 协议</h2><p>Dubbo 支持多种通信协议，不同的协议针对不同的序列化方式。</p>
<h3 id="dubbo-协议"><a href="#dubbo-协议" class="headerlink" title="dubbo 协议"></a>dubbo 协议</h3><p><a target="_blank" rel="noopener" href="http://dubbo.apache.org/zh-cn/docs/user/references/protocol/dubbo.html">dubbo</a> 协议是 Dubbo 的默认通信协议，采用单一长连接和 NIO 异步通信，基于 hessian 作为序列化协议。</p>
<p><a target="_blank" rel="noopener" href="http://dubbo.apache.org/zh-cn/docs/user/references/protocol/dubbo.html">dubbo</a> 协议适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。反之，Dubbo 缺省协议不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。</p>
<p>为了要支持高并发场景，一般是服务提供者就几台机器，但是服务消费者有上百台，可能每天调用量达到上亿次！此时用长连接是最合适的，就是跟每个服务消费者维持一个长连接就可以，可能总共就 100 个连接。然后后面直接基于长连接 NIO 异步通信，可以支撑高并发请求。</p>
<h3 id="rmi-协议"><a href="#rmi-协议" class="headerlink" title="rmi 协议"></a>rmi 协议</h3><p><a target="_blank" rel="noopener" href="http://dubbo.apache.org/zh-cn/docs/user/references/protocol/rmi.html">rmi</a> - 采用 JDK 标准的 <code>java.rmi.*</code> 实现，采用阻塞式短连接和 JDK 标准序列化方式。</p>
<p>注意：如果正在使用 RMI 提供服务给外部访问，同时应用里依赖了老的 <code>common-collections</code> 包的情况下，存在反序列化安全风险。</p>
<h3 id="hessian-协议"><a href="#hessian-协议" class="headerlink" title="hessian 协议"></a>hessian 协议</h3><p><a target="_blank" rel="noopener" href="http://dubbo.apache.org/zh-cn/docs/user/references/protocol/hessian.html">hessian</a> 协议用于集成 Hessian 的服务，Hessian 底层采用 Http 通讯，采用 Servlet 暴露服务，Dubbo 缺省内嵌 Jetty 作为服务器实现。</p>
<p>Dubbo 的 Hessian 协议可以和原生 Hessian 服务互操作，即：</p>
<ul>
<li>提供者用 Dubbo 的 Hessian 协议暴露服务，消费者直接用标准 Hessian 接口调用</li>
<li>或者提供方用标准 Hessian 暴露服务，消费方用 Dubbo 的 Hessian 协议调用。</li>
</ul>
<h3 id="thrift-协议"><a href="#thrift-协议" class="headerlink" title="thrift 协议"></a>thrift 协议</h3><p>当前 dubbo 支持的 <a target="_blank" rel="noopener" href="http://dubbo.apache.org/zh-cn/docs/user/references/protocol/thrift.html">thrift</a> 协议是对 thrift 原生协议的扩展，在原生协议的基础上添加了一些额外的头信息，比如 service name，magic number 等。</p>
<p>使用 dubbo thrift 协议同样需要使用 thrift 的 idl compiler 编译生成相应的 java 代码，后续版本中会在这方面做一些增强。</p>
<h3 id="http-协议"><a href="#http-协议" class="headerlink" title="http 协议"></a>http 协议</h3><p><a target="_blank" rel="noopener" href="http://dubbo.apache.org/zh-cn/docs/user/references/protocol/http.html">http</a> 协议基于 HTTP 表单的远程调用协议，采用 Spring 的 HttpInvoker 实现。</p>
<p>使用 JSON 序列化方式。</p>
<h3 id="webservice-协议"><a href="#webservice-协议" class="headerlink" title="webservice 协议"></a>webservice 协议</h3><p>基于 WebService 的远程调用协议，基于 <a target="_blank" rel="noopener" href="http://cxf.apache.org/">Apache CXF</a> 的 <code>frontend-simple</code> 和 <code>transports-http</code> 实现。</p>
<p>使用 SOAP 序列化方式。</p>
<p>可以和原生 WebService 服务互操作，即：</p>
<ul>
<li>提供者用 Dubbo 的 WebService 协议暴露服务，消费者直接用标准 WebService 接口调用，</li>
<li>或者提供方用标准 WebService 暴露服务，消费方用 Dubbo 的 WebService 协议调用。</li>
</ul>
<h3 id="rest-协议"><a href="#rest-协议" class="headerlink" title="rest 协议"></a>rest 协议</h3><p>基于标准的 Java REST API——JAX-RS 2.0（Java API for RESTful Web Services 的简写）实现的 REST 调用支持</p>
<h3 id="memcached-协议"><a href="#memcached-协议" class="headerlink" title="memcached 协议"></a>memcached 协议</h3><p>基于 memcached 实现的 RPC 协议。</p>
<h3 id="redis-协议"><a href="#redis-协议" class="headerlink" title="redis 协议"></a>redis 协议</h3><p>基于 redis 实现的 RPC 协议。</p>
<blockquote>
<p>在现实世界中，序列化有多种方式。</p>
<p>JDK 自身提供的序列化方式，效率不高，但是 Java 程序使用最多。</p>
<p>如果想要较好的可读性，可以使用 JSON （常见库有：<a target="_blank" rel="noopener" href="https://github.com/FasterXML/jackson">jackson</a>、<a target="_blank" rel="noopener" href="https://github.com/google/gson">gson</a>、<a target="_blank" rel="noopener" href="https://github.com/alibaba/fastjson">fastjson</a>）或 SOAP （即 xml 形式）</p>
<p>如果想要更好的性能，可以使用 <a target="_blank" rel="noopener" href="https://github.com/apache/thrift">thrift</a>、<a target="_blank" rel="noopener" href="https://github.com/protocolbuffers/protobuf">protobuf</a>、<a target="_blank" rel="noopener" href="http://hessian.caucho.com/doc/hessian-overview.xtp">hessian</a></p>
<p>想深入了解可以参考：<a target="_blank" rel="noopener" href="https://github.com/dunwu/java-tutorial/blob/master/docs/lib/serialized">序列化</a></p>
</blockquote>
<h2 id="七、集群容错"><a href="#七、集群容错" class="headerlink" title="七、集群容错"></a>七、集群容错</h2><p>在集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/distributed/rpc/dubbo/dubbo集群容错.jpg" />
</div>

<ul>
<li><strong>Failover</strong> - <strong>失败自动切换</strong>，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries&#x3D;”2” 来设置重试次数(不含第一次)。</li>
<li><strong>Failfast</strong> - <strong>快速失败</strong>，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</li>
<li><strong>Failsafe</strong> - <strong>失败安全</strong>，出现异常时，直接忽略。通常用于写入审计日志等操作。</li>
<li><strong>Failback</strong> - <strong>失败自动恢复</strong>，后台记录失败请求，定时重发。通常用于消息通知操作。</li>
<li><strong>Forking</strong> - <strong>并行调用多个服务器</strong>，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks&#x3D;”2” 来设置最大并行数。</li>
<li><strong>Broadcast</strong> - <strong>广播调用所有提供者</strong>，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。</li>
</ul>
<p>集群容错配置示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">cluster</span>=<span class="string">&quot;failsafe&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">cluster</span>=<span class="string">&quot;failsafe&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="八、负载均衡"><a href="#八、负载均衡" class="headerlink" title="八、负载均衡"></a>八、负载均衡</h2><p>Dubbo 提供了多种负载均衡（LoadBalance）策略，缺省为 <code>Random</code> 随机调用。</p>
<p>Dubbo 的负载均衡配置可以细粒度到服务、方法级别，且 <code>dubbo:service</code> 和 <code>dubbo:reference</code> 均可配置。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 服务端服务级别 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;...&quot;</span> <span class="attr">loadbalance</span>=<span class="string">&quot;roundrobin&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 客户端服务级别 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">&quot;...&quot;</span> <span class="attr">loadbalance</span>=<span class="string">&quot;roundrobin&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 服务端方法级别 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">&quot;...&quot;</span> <span class="attr">loadbalance</span>=<span class="string">&quot;roundrobin&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 客户端方法级别 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">&quot;...&quot;</span> <span class="attr">loadbalance</span>=<span class="string">&quot;roundrobin&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h4><ul>
<li><strong>随机</strong>，按权重设置随机概率。</li>
<li>在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</li>
</ul>
<h4 id="RoundRobin"><a href="#RoundRobin" class="headerlink" title="RoundRobin"></a>RoundRobin</h4><ul>
<li><strong>轮询</strong>，按公约后的权重设置轮询比率。</li>
<li>存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</li>
</ul>
<h4 id="LeastActive"><a href="#LeastActive" class="headerlink" title="LeastActive"></a>LeastActive</h4><ul>
<li><strong>最少活跃调用数</strong>，相同活跃数的随机，活跃数指调用前后计数差。</li>
<li>使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</li>
</ul>
<h4 id="ConsistentHash"><a href="#ConsistentHash" class="headerlink" title="ConsistentHash"></a>ConsistentHash</h4><ul>
<li><strong>一致性 Hash</strong>，相同参数的请求总是发到同一提供者。</li>
<li>当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</li>
<li>算法参见：<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Consistent_hashing">http://en.wikipedia.org/wiki/Consistent_hashing</a></li>
<li>缺省只对第一个参数 Hash，如果要修改，请配置 <code>&lt;dubbo:parameter key=&quot;hash.arguments&quot; value=&quot;0,1&quot; /&gt;</code></li>
<li>缺省用 160 份虚拟节点，如果要修改，请配置 <code>&lt;dubbo:parameter key=&quot;hash.nodes&quot; value=&quot;320&quot; /&gt;</code></li>
</ul>
<h2 id="九、Dubbo-服务治理"><a href="#九、Dubbo-服务治理" class="headerlink" title="九、Dubbo 服务治理"></a>九、Dubbo 服务治理</h2><h3 id="服务治理简介"><a href="#服务治理简介" class="headerlink" title="服务治理简介"></a>服务治理简介</h3><ul>
<li>当服务越来越多时，服务 URL 配置管理变得非常困难，F5 硬件负载均衡器的单点压力也越来越大。</li>
<li>当进一步发展，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。</li>
<li>接着，服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？</li>
</ul>
<p>以上问题可以归纳为服务治理问题，这也是 Dubbo 的核心功能。</p>
<h4 id="调用链路"><a href="#调用链路" class="headerlink" title="调用链路"></a>调用链路</h4><p>一个微服务架构，往往由大量分布式服务组成。那么这些服务之间互相是如何调用的？调用链路是啥？说实话，几乎到后面没人搞的清楚了，因为服务实在太多了，可能几百个甚至几千个服务。</p>
<p>那就需要基于 dubbo 做的分布式系统中，对各个服务之间的调用自动记录下来，然后自动将<strong>各个服务之间的依赖关系和调用链路生成出来</strong>，做成一张图，显示出来，大家才可以看到对吧。</p>
<h4 id="服务访问压力以及时长统计"><a href="#服务访问压力以及时长统计" class="headerlink" title="服务访问压力以及时长统计"></a>服务访问压力以及时长统计</h4><p>需要自动统计<strong>各个接口和服务之间的调用次数以及访问延时</strong>，而且要分成两个级别。</p>
<ul>
<li>一个级别是接口粒度，就是每个服务的每个接口每天被调用多少次，TP50&#x2F;TP90&#x2F;TP99，三个档次的请求延时分别是多少；</li>
<li>第二个级别是从源头入口开始，一个完整的请求链路经过几十个服务之后，完成一次请求，每天全链路走多少次，全链路请求延时的 TP50&#x2F;TP90&#x2F;TP99，分别是多少。</li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li>服务分层（避免循环依赖）</li>
<li>调用链路失败监控和报警</li>
<li>服务鉴权</li>
<li>每个服务的可用性的监控（接口调用成功率？几个 9？99.99%，99.9%，99%）</li>
</ul>
<p>所谓失败重试，就是 consumer 调用 provider 要是失败了，比如抛异常了，此时应该是可以重试的，或者调用超时了也可以重试。配置如下：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:reference <span class="attribute">id</span>=<span class="string">&quot;xxxx&quot;</span> <span class="attribute">interface</span>=<span class="string">&quot;xx&quot;</span> <span class="attribute">check</span>=<span class="string">&quot;true&quot;</span> <span class="attribute">async</span>=<span class="string">&quot;false&quot;</span> <span class="attribute">retries</span>=<span class="string">&quot;3&quot;</span> <span class="attribute">timeout</span>=<span class="string">&quot;2000&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>举个栗子。</p>
<p>某个服务的接口，要耗费 5s，你这边不能干等着，你这边配置了 timeout 之后，我等待 2s，还没返回，我直接就撤了，不能干等你。</p>
<p>可以结合你们公司具体的场景来说说你是怎么设置这些参数的：</p>
<ul>
<li><code>timeout</code>：一般设置为 <code>200ms</code>，我们认为不能超过 <code>200ms</code> 还没返回。</li>
<li><code>retries</code>：设置 retries，一般是在读请求的时候，比如你要查询个数据，你可以设置个 retries，如果第一次没读到，报错，重试指定的次数，尝试再次读取。</li>
</ul>
<h3 id="路由规则"><a href="#路由规则" class="headerlink" title="路由规则"></a>路由规则</h3><p>路由规则决定一次 dubbo 服务调用的目标服务器，分为条件路由规则和脚本路由规则，并且支持可扩展。</p>
<p>向注册中心写入路由规则的操作通常由监控中心或治理中心的页面完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RegistryFactory</span> <span class="variable">registryFactory</span> <span class="operator">=</span> ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension();</span><br><span class="line"><span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> registryFactory.getRegistry(URL.valueOf(<span class="string">&quot;zookeeper://10.20.153.10:2181&quot;</span>));</span><br><span class="line">registry.register(URL.valueOf(<span class="string">&quot;condition://0.0.0.0/com.foo.BarService?category=routers&amp;dynamic=false&amp;rule=&quot;</span> + URL.encode(<span class="string">&quot;host = 10.20.153.10 =&gt; host = 10.20.153.11&quot;</span>) + <span class="string">&quot;));</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>condition:&#x2F;&#x2F;</strong> - 表示路由规则的类型，支持条件路由规则和脚本路由规则，可扩展，必填。</li>
<li><strong>0.0.0.0</strong> - 表示对所有 IP 地址生效，如果只想对某个 IP 的生效，请填入具体 IP，必填。</li>
<li><strong>com.foo.BarService</strong> - 表示只对指定服务生效，必填。</li>
<li><strong>category&#x3D;routers</strong> - 表示该数据为动态配置类型，必填。</li>
<li><strong>dynamic&#x3D;false</strong> - 表示该数据为持久数据，当注册方退出时，数据依然保存在注册中心，必填。</li>
<li><strong>enabled&#x3D;true</strong> - 覆盖规则是否生效，可不填，缺省生效。</li>
<li><strong>force&#x3D;false</strong> - 当路由结果为空时，是否强制执行，如果不强制执行，路由结果为空的路由规则将自动失效，可不填，缺省为 flase。</li>
<li><strong>runtime&#x3D;false</strong> - 是否在每次调用时执行路由规则，否则只在提供者地址列表变更时预先执行并缓存结果，调用时直接从缓存中获取路由结果。如果用了参数路由，必须设为 true，需要注意设置会影响调用的性能，可不填，缺省为 flase。</li>
<li><strong>priority&#x3D;1</strong> - 路由规则的优先级，用于排序，优先级越大越靠前执行，可不填，缺省为 0。</li>
<li><strong>rule&#x3D;URL.encode(“host &#x3D; 10.20.153.10 &#x3D;&gt; host &#x3D; 10.20.153.11”)</strong> - 表示路由规则的内容，必填。</li>
</ul>
<h3 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h3><p>可以通过服务降级功能临时屏蔽某个出错的非关键服务，并定义降级后的返回策略。</p>
<p>向注册中心写入动态配置覆盖规则：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RegistryFactory</span> <span class="variable">registryFactory</span> <span class="operator">=</span> ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension();</span><br><span class="line"><span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> registryFactory.getRegistry(URL.valueOf(<span class="string">&quot;zookeeper://10.20.153.10:2181&quot;</span>));</span><br><span class="line">registry.register(URL.valueOf(<span class="string">&quot;override://0.0.0.0/com.foo.BarService?category=configurators&amp;dynamic=false&amp;application=foo&amp;mock=force:return+null&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<p><strong><code>mock=force:return+null</code></strong> 表示消费方对该服务的方法调用都直接返回 null 值，不发起远程调用。用来屏蔽不重要服务不可用时对调用方的影响。<br>还可以改为 <strong><code>mock=fail:return+null</code></strong> 表示消费方对该服务的方法调用在失败后，再返回 null 值，不抛异常。用来容忍不重要服务不稳定时对调用方的影响。</p>
<p>比如说服务 A 调用服务 B，结果服务 B 挂掉了，服务 A 重试几次调用服务 B，还是不行，那么直接降级，走一个备用的逻辑，给用户返回响应。</p>
<p>举个例子，我们有接口 <code>HelloService</code>。<code>HelloServiceImpl</code> 有该接口的具体实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dubbo 配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- provider 配置 --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://code.alibabatech.com/schema/dubbo        http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;dubbo-provider&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;zookeeper://127.0.0.1:2181&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">port</span>=<span class="string">&quot;20880&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.zhss.service.HelloService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;helloServiceImpl&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;10000&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;helloServiceImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zhss.service.HelloServiceImpl&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- consumer 配置 --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://code.alibabatech.com/schema/dubbo        http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;dubbo-consumer&quot;</span>  /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;zookeeper://127.0.0.1:2181&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;fooService&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;com.test.service.FooService&quot;</span>  <span class="attr">timeout</span>=<span class="string">&quot;10000&quot;</span> <span class="attr">check</span>=<span class="string">&quot;false&quot;</span> <span class="attr">mock</span>=<span class="string">&quot;return null&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们调用接口失败的时候，可以通过 <code>mock</code> 统一返回 null。</p>
<p>mock 的值也可以修改为 true，然后再跟接口同一个路径下实现一个 Mock 类，命名规则是 “接口名称+<code>Mock</code>” 后缀。然后在 Mock 类里实现自己的降级逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServiceMock</span> <span class="keyword">implements</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 降级逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><h4 id="直连"><a href="#直连" class="headerlink" title="直连"></a>直连</h4><p>在开发及测试环境下，经常需要绕过注册中心，只测试指定服务提供者，这时候可能需要点对点直连，点对点直联方式，将以服务接口为单位，忽略注册中心的提供者列表，A 接口配置点对点，不影响 B 接口从注册中心获取列表。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/distributed/rpc/dubbo/dubbo访问控制-直连.jpg" />
</div>

<p>配置方式：</p>
<p>（1）通过 XML 配置</p>
<p>如果是线上需求需要点对点，可在 <a href="dubbo:reference">dubbo:reference</a> 中配置 url 指向提供者，将绕过注册中心，多个地址用分号隔开，配置如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;xxxService&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;com.alibaba.xxx.XxxService&quot;</span> <span class="attr">url</span>=<span class="string">&quot;dubbo://localhost:20890&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）通过 -D 参数指定</p>
<p>在 JVM 启动参数中加入-D 参数映射服务地址：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Dcom<span class="selector-class">.alibaba</span><span class="selector-class">.xxx</span>.XxxService=dubbo:<span class="comment">//localhost:20890</span></span><br></pre></td></tr></table></figure>

<p>（3）通过文件映射<br>如果服务比较多，也可以用文件映射，用 -Ddubbo.resolve.file 指定映射文件路径，此配置优先级高于 <a href="dubbo:reference">dubbo:reference</a> 中的配置：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Ddubbo.<span class="built_in">resolve</span>.<span class="built_in">file</span>=xxx.properties</span><br></pre></td></tr></table></figure>

<p>然后在映射文件 xxx.properties 中加入配置，其中 key 为服务名，value 为服务提供者 URL：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">com.alibaba.xxx.XxxService</span>=<span class="string">dubbo://localhost:20890</span></span><br></pre></td></tr></table></figure>

<h4 id="只订阅"><a href="#只订阅" class="headerlink" title="只订阅"></a>只订阅</h4><p>为方便开发测试，经常会在线下共用一个所有服务可用的注册中心，这时，如果一个正在开发中的服务提供者注册，可能会影响消费者不能正常运行。</p>
<p>可以让服务提供者开发方，只订阅服务(开发的服务可能依赖其它服务)，而不注册正在开发的服务，通过直连测试正在开发的服务。</p>
<p>禁用注册配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;10.20.153.10:9090&quot;</span> <span class="attr">register</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;10.20.153.10:9090?register=false&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="只注册"><a href="#只注册" class="headerlink" title="只注册"></a>只注册</h4><p>如果有两个镜像环境，两个注册中心，有一个服务只在其中一个注册中心有部署，另一个注册中心还没来得及部署，而两个注册中心的其它应用都需要依赖此服务。这个时候，可以让服务提供者方只注册服务到另一注册中心，而不从另一注册中心订阅服务。</p>
<p>禁用订阅配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">id</span>=<span class="string">&quot;hzRegistry&quot;</span> <span class="attr">address</span>=<span class="string">&quot;10.20.153.10:9090&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">id</span>=<span class="string">&quot;qdRegistry&quot;</span> <span class="attr">address</span>=<span class="string">&quot;10.20.141.150:9090&quot;</span> <span class="attr">subscribe</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">id</span>=<span class="string">&quot;hzRegistry&quot;</span> <span class="attr">address</span>=<span class="string">&quot;10.20.153.10:9090&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">id</span>=<span class="string">&quot;qdRegistry&quot;</span> <span class="attr">address</span>=<span class="string">&quot;10.20.141.150:9090?subscribe=false&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="静态服务"><a href="#静态服务" class="headerlink" title="静态服务"></a>静态服务</h4><p>有时候希望人工管理服务提供者的上线和下线，此时需将注册中心标识为非动态管理模式。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:registry <span class="attribute">address</span>=<span class="string">&quot;10.20.141.150:9090&quot;</span> <span class="attribute">dynamic</span>=<span class="string">&quot;false&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;10.20.141.150:9090?dynamic=false&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>服务提供者初次注册时为禁用状态，需人工启用。断线时，将不会被自动删除，需人工禁用。</p>
<h3 id="动态配置"><a href="#动态配置" class="headerlink" title="动态配置"></a>动态配置</h3><p>向注册中心写入动态配置覆盖规则。该功能通常由监控中心或治理中心的页面完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RegistryFactory</span> <span class="variable">registryFactory</span> <span class="operator">=</span> ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension();</span><br><span class="line"><span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> registryFactory.getRegistry(URL.valueOf(<span class="string">&quot;zookeeper://10.20.153.10:2181&quot;</span>));</span><br><span class="line">registry.register(URL.valueOf(<span class="string">&quot;override://0.0.0.0/com.foo.BarService?category=configurators&amp;dynamic=false&amp;application=foo&amp;timeout=1000&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><strong>override:&#x2F;&#x2F;</strong> - 表示数据采用覆盖方式，支持 override 和 absent，可扩展，必填。</li>
<li><strong>0.0.0.0</strong> - 表示对所有 IP 地址生效，如果只想覆盖某个 IP 的数据，请填入具体 IP，必填。</li>
<li><strong>com.foo.BarService</strong> - 表示只对指定服务生效，必填。</li>
<li><strong>category&#x3D;configurators</strong> - 表示该数据为动态配置类型，必填。</li>
<li><strong>dynamic&#x3D;false</strong> - 表示该数据为持久数据，当注册方退出时，数据依然保存在注册中心，必填。</li>
<li><strong>enabled&#x3D;true</strong> - 覆盖规则是否生效，可不填，缺省生效。</li>
<li><strong>application&#x3D;foo</strong> - 表示只对指定应用生效，可不填，表示对所有应用生效。</li>
<li><strong>timeout&#x3D;1000</strong> - 表示将满足以上条件的 timeout 参数的值覆盖为 1000。如果想覆盖其它参数，直接加在 override 的 URL 参数上。</li>
</ul>
<p>示例：</p>
<ul>
<li>禁用提供者：(通常用于临时踢除某台提供者机器，相似的，禁止消费者访问请使用路由规则)</li>
</ul>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span>:<span class="type"></span>//<span class="number">10.20</span><span class="number">.153</span><span class="number">.10</span>/com.foo.BarService?category=configurators&amp;<span class="keyword">dynamic</span>=<span class="literal">false</span>&amp;disbaled=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>调整权重：(通常用于容量评估，缺省权重为 100)</li>
</ul>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span>:<span class="type"></span>//<span class="number">10.20</span><span class="number">.153</span><span class="number">.10</span>/com.foo.BarService?category=configurators&amp;<span class="keyword">dynamic</span>=<span class="literal">false</span>&amp;weight=<span class="number">200</span></span><br></pre></td></tr></table></figure>

<ul>
<li>调整负载均衡策略：(缺省负载均衡策略为 random)</li>
</ul>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span>:<span class="type"></span>//<span class="number">10.20</span><span class="number">.153</span><span class="number">.10</span>/com.foo.BarService?category=configurators&amp;<span class="keyword">dynamic</span>=<span class="literal">false</span>&amp;loadbalance=leastactive</span><br></pre></td></tr></table></figure>

<ul>
<li>服务降级：(通常用于临时屏蔽某个出错的非关键服务)</li>
</ul>
<figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">override://0.0.0.0/com.foo.BarService?category=configurators<span class="variable">&amp;dynamic</span>=false<span class="variable">&amp;application</span>=foo<span class="variable">&amp;mock</span>=force:<span class="keyword">return</span>+<span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<h2 id="十、多版本"><a href="#十、多版本" class="headerlink" title="十、多版本"></a>十、多版本</h2><p>当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用。</p>
<p>可以按照以下的步骤进行版本迁移：</p>
<ol>
<li>在低压力时间段，先升级一半提供者为新版本</li>
<li>再将所有消费者升级为新版本</li>
<li>然后将剩下的一半提供者升级为新版本</li>
</ol>
<p>老版本服务提供者配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.foo.BarService&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.0.0&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>新版本服务提供者配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.foo.BarService&quot;</span> <span class="attr">version</span>=<span class="string">&quot;2.0.0&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>老版本服务消费者配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;barService&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;com.foo.BarService&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.0.0&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>新版本服务消费者配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;barService&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;com.foo.BarService&quot;</span> <span class="attr">version</span>=<span class="string">&quot;2.0.0&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果不需要区分版本，可以按照以下的方式配置 [<a target="_blank" rel="noopener" href="http://dubbo.apache.org/zh-cn/docs/user/demos/multi-versions.html#fn1">1]</a>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">&quot;barService&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;com.foo.BarService&quot;</span> <span class="attr">version</span>=<span class="string">&quot;*&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="十一、Dubbo-SPI"><a href="#十一、Dubbo-SPI" class="headerlink" title="十一、Dubbo SPI"></a>十一、Dubbo SPI</h2><p>SPI 全称为 Service Provider Interface，是一种服务发现机制。SPI 的本质是<strong>将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类</strong>。这样可以在运行时，动态为接口替换实现类。正因此特性，我们可以很容易的通过 SPI 机制为我们的程序提供拓展功能。SPI 机制在第三方框架中也有所应用，比如 Dubbo 就是通过 SPI 机制加载所有的组件。不过，Dubbo 并未使用 Java 原生的 SPI 机制，而是对其进行了增强，使其能够更好的满足需求。在 Dubbo 中，SPI 是一个非常重要的模块。基于 SPI，我们可以很容易的对 Dubbo 进行拓展。</p>
<p>Dubbo SPI 的相关逻辑被封装在了 <code>ExtensionLoader</code> 类中，通过 <code>ExtensionLoader</code>，我们可以加载指定的实现类。Dubbo SPI 所需的配置文件需放置在 <code>META-INF/dubbo</code> 路径下。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><strong>官方</strong><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/dubbo">Dubbo Github</a></li>
<li><a target="_blank" rel="noopener" href="https://dubbo.apache.org/zh-cn/">Dubbo 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://dubbo.gitbooks.io/dubbo-admin-book/content/">管理员手册</a></li>
</ul>
</li>
<li><strong>文章</strong><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/dubbo-service-management.md">如何基于 Dubbo 进行服务治理、服务降级、失败重试以及超时重试？</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/d848b7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/d848b7/" class="post-title-link" itemprop="url">Flink简介</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-17 22:28:55" itemprop="dateCreated datePublished" datetime="2022-02-17T22:28:55+08:00">2022-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:53" itemprop="dateModified" datetime="2024-12-12T10:02:53+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/" itemprop="url" rel="index"><span itemprop="name">大数据</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/flink/" itemprop="url" rel="index"><span itemprop="name">flink</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>11k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>10 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Flink-简介"><a href="#Flink-简介" class="headerlink" title="Flink 简介"></a>Flink 简介</h1><blockquote>
<p>关键概念：源源不断的流式数据处理、事件时间、有状态流处理和状态快照</p>
</blockquote>
<h2 id="流处理"><a href="#流处理" class="headerlink" title="流处理"></a>流处理</h2><p>任何类型的数据都可以形成一种事件流。信用卡交易、传感器测量、机器日志、网站或移动应用程序上的用户交互记录，所有这些数据都形成一种流。</p>
<p>数据可以被作为 <em>无界</em> 或者 <em>有界</em> 流来处理。</p>
<ol>
<li><strong>无界流</strong> 有定义流的开始，但没有定义流的结束。它们会无休止地产生数据。无界流的数据必须持续处理，即数据被摄取后需要立刻处理。我们不能等到所有数据都到达再处理，因为输入是无限的，在任何时候输入都不会完成。处理无界数据通常要求以特定顺序摄取事件，例如事件发生的顺序，以便能够推断结果的完整性。</li>
<li><strong>有界流</strong> 有定义流的开始，也有定义流的结束。有界流可以在摄取所有数据后再进行计算。有界流所有数据可以被排序，所以并不需要有序摄取。有界流处理通常被称为批处理。</li>
</ol>
<p><img src="https://nightlies.apache.org/flink/flink-docs-release-1.14/fig/bounded-unbounded.png" alt="Bounded and unbounded streams"></p>
<p><strong>Apache Flink 擅长处理无界和有界数据集</strong> 精确的时间控制和状态化使得 Flink 的运行时(runtime)能够运行任何处理无界流的应用。有界流则由一些专为固定大小数据集特殊设计的算法和数据结构进行内部处理，产生了出色的性能。</p>
<p><strong>批处理</strong>是有界数据流处理的范例。在这种模式下，你可以选择在计算结果输出之前输入整个数据集，这也就意味着你可以对整个数据集的数据进行排序、统计或汇总计算后再输出结果。</p>
<p><strong>流处理</strong>正相反，其涉及无界数据流。至少理论上来说，它的数据输入永远不会结束，因此程序必须持续不断地对到达的数据进行处理。</p>
<p>在 Flink 中，应用程序由用户自定义<strong>算子</strong>转换而来的<strong>流式 dataflows</strong> 所组成。这些流式 dataflows 形成了有向图，以一个或多个<strong>源</strong>（source）开始，并以一个或多个<strong>汇</strong>（sink）结束。</p>
<p><img src="https://nightlies.apache.org/flink/flink-docs-release-1.14/fig/program_dataflow.svg" alt="A DataStream program, and its dataflow."></p>
<p>通常，程序代码中的 transformation 和 dataflow 中的算子（operator）之间是一一对应的。但有时也会出现一个 transformation 包含多个算子的情况，如上图所示。</p>
<p>Flink 应用程序可以消费来自消息队列或分布式日志这类流式数据源（例如 Apache Kafka 或 Kinesis）的实时数据，也可以从各种的数据源中消费有界的历史数据。同样，Flink 应用程序生成的结果流也可以发送到各种数据汇中。</p>
<p><img src="https://nightlies.apache.org/flink/flink-docs-release-1.14/fig/flink-application-sources-sinks.png" alt="Flink application with sources and sinks"></p>
<h3 id="并行-Dataflows"><a href="#并行-Dataflows" class="headerlink" title="并行 Dataflows"></a>并行 Dataflows</h3><p>Flink 程序本质上是分布式并行程序。在程序执行期间，一个流有一个或多个<strong>流分区</strong>（Stream Partition），每个算子有一个或多个<strong>算子子任务</strong>（Operator Subtask）。每个子任务彼此独立，并在不同的线程中运行，或在不同的计算机或容器中运行。</p>
<p>算子子任务数就是其对应算子的<strong>并行度</strong>。在同一程序中，不同算子也可能具有不同的并行度。</p>
<p><img src="https://nightlies.apache.org/flink/flink-docs-release-1.14/fig/parallel_dataflow.svg" alt="A parallel dataflow"></p>
<p>Flink 算子之间可以通过<em>一对一</em>（_直传_）模式或<em>重新分发</em>模式传输数据：</p>
<ul>
<li><strong>一对一</strong>模式（例如上图中的 <em>Source</em> 和 <em>map()</em> 算子之间）可以保留元素的分区和顺序信息。这意味着 <em>map()</em> 算子的 subtask[1] 输入的数据以及其顺序与 <em>Source</em> 算子的 subtask[1] 输出的数据和顺序完全相同，即同一分区的数据只会进入到下游算子的同一分区。</li>
<li><strong>重新分发</strong>模式（例如上图中的 <em>map()</em> 和 <em>keyBy&#x2F;window</em> 之间，以及 <em>keyBy&#x2F;window</em> 和 <em>Sink</em> 之间）则会更改数据所在的流分区。当你在程序中选择使用不同的 _transformation_，每个<em>算子子任务</em>也会根据不同的 transformation 将数据发送到不同的目标子任务。例如以下这几种 transformation 和其对应分发数据的模式：_keyBy()_（通过散列键重新分区）、_broadcast()_（广播）或 _rebalance()<em>（随机重新分发）。在<em>重新分发</em>数据的过程中，元素只有在每对输出和输入子任务之间才能保留其之间的顺序信息（例如，_keyBy&#x2F;window</em> 的 subtask[2] 接收到的 <em>map()</em> 的 subtask[1] 中的元素都是有序的）。因此，上图所示的 <em>keyBy&#x2F;window</em> 和 <em>Sink</em> 算子之间数据的重新分发时，不同键（key）的聚合结果到达 Sink 的顺序是不确定的。</li>
</ul>
<h3 id="自定义时间流处理"><a href="#自定义时间流处理" class="headerlink" title="自定义时间流处理"></a>自定义时间流处理</h3><p>对于大多数流数据处理应用程序而言，能够使用处理实时数据的代码重新处理历史数据并产生确定并一致的结果非常有价值。</p>
<p>在处理流式数据时，我们通常更需要关注事件本身发生的顺序而不是事件被传输以及处理的顺序，因为这能够帮助我们推理出一组事件（事件集合）是何时发生以及结束的。例如电子商务交易或金融交易中涉及到的事件集合。</p>
<p>为了满足上述这类的实时流处理场景，我们通常会使用记录在数据流中的事件时间的时间戳，而不是处理数据的机器时钟的时间戳。</p>
<h3 id="有状态流处理"><a href="#有状态流处理" class="headerlink" title="有状态流处理"></a>有状态流处理</h3><p>Flink 中的算子可以是有状态的。这意味着如何处理一个事件可能取决于该事件之前所有事件数据的累积结果。Flink 中的状态不仅可以用于简单的场景（例如统计仪表板上每分钟显示的数据），也可以用于复杂的场景（例如训练作弊检测模型）。</p>
<p>Flink 应用程序可以在分布式集群上并行运行，其中每个算子的各个并行实例会在单独的线程中独立运行，并且通常情况下是会在不同的机器上运行。</p>
<p>有状态算子的并行实例组在存储其对应状态时通常是按照键（key）进行分片存储的。每个并行实例算子负责处理一组特定键的事件数据，并且这组键对应的状态会保存在本地。</p>
<p>如下图的 Flink 作业，其前三个算子的并行度为 2，最后一个 sink 算子的并行度为 1，其中第三个算子是有状态的，并且你可以看到第二个算子和第三个算子之间是全互联的（fully-connected），它们之间通过网络进行数据分发。通常情况下，实现这种类型的 Flink 程序是为了通过某些键对数据流进行分区，以便将需要一起处理的事件进行汇合，然后做统一计算处理。</p>
<p><img src="https://nightlies.apache.org/flink/flink-docs-release-1.14/fig/parallel-job.png" alt="State is sharded"></p>
<p>Flink 应用程序的状态访问都在本地进行，因为这有助于其提高吞吐量和降低延迟。通常情况下 Flink 应用程序都是将状态存储在 JVM 堆上，但如果状态太大，我们也可以选择将其以结构化数据格式存储在高速磁盘中。</p>
<p><img src="https://nightlies.apache.org/flink/flink-docs-release-1.14/fig/local-state.png" alt="State is local"></p>
<h3 id="通过状态快照实现的容错"><a href="#通过状态快照实现的容错" class="headerlink" title="通过状态快照实现的容错"></a>通过状态快照实现的容错</h3><p>通过状态快照和流重放两种方式的组合，Flink 能够提供可容错的，精确一次计算的语义。这些状态快照在执行时会获取并存储分布式 pipeline 中整体的状态，它会将数据源中消费数据的偏移量记录下来，并将整个 job graph 中算子获取到该数据（记录的偏移量对应的数据）时的状态记录并存储下来。当发生故障时，Flink 作业会恢复上次存储的状态，重置数据源从状态中记录的上次消费的偏移量开始重新进行消费处理。而且状态快照在执行时会异步获取状态并存储，并不会阻塞正在进行的数据处理逻辑。</p>
<h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>只有在每一个单独的事件上进行转换操作的应用才不需要状态，换言之，每一个具有一定复杂度的流处理应用都是有状态的。任何运行基本业务逻辑的流处理应用都需要在一定时间内存储所接收的事件或中间结果，以供后续的某个时间点（例如收到下一个事件或者经过一段特定时间）进行访问并进行后续处理。</p>
<p><img src="https://flink.apache.org/img/function-state.png" alt="img"></p>
<p>应用状态是 Flink 中的一等公民，Flink 提供了许多状态管理相关的特性支持，其中包括：</p>
<ul>
<li><strong>多种状态基础类型</strong>：Flink 为多种不同的数据结构提供了相对应的状态基础类型，例如原子值（value），列表（list）以及映射（map）。开发者可以基于处理函数对状态的访问方式，选择最高效、最适合的状态基础类型。</li>
<li><strong>插件化的 State Backend</strong>：State Backend 负责管理应用程序状态，并在需要的时候进行 checkpoint。Flink 支持多种 state backend，可以将状态存在内存或者 <a target="_blank" rel="noopener" href="https://rocksdb.org/">RocksDB</a>。RocksDB 是一种高效的嵌入式、持久化键值存储引擎。Flink 也支持插件式的自定义 state backend 进行状态存储。</li>
<li><strong>精确一次语义</strong>：Flink 的 checkpoint 和故障恢复算法保证了故障发生后应用状态的一致性。因此，Flink 能够在应用程序发生故障时，对应用程序透明，不造成正确性的影响。</li>
<li><strong>超大数据量状态</strong>：Flink 能够利用其异步以及增量式的 checkpoint 算法，存储数 TB 级别的应用状态。</li>
<li><strong>可弹性伸缩的应用</strong>：Flink 能够通过在更多或更少的工作节点上对状态进行重新分布，支持有状态应用的分布式的横向伸缩。</li>
</ul>
<h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><h3 id="时间语义"><a href="#时间语义" class="headerlink" title="时间语义"></a>时间语义</h3><p>Flink 支持以下三种时间语义:</p>
<ul>
<li>**事件时间(event time)**： 事件产生的时间，记录的是设备生产(或者存储)事件的时间</li>
<li>**摄取时间(ingestion time)**： Flink 读取事件时记录的时间</li>
<li>**处理时间(processing time)**： Flink pipeline 中具体算子处理事件的时间</li>
</ul>
<p>为了获得可重现的结果，例如在计算过去的特定一天里第一个小时股票的最高价格时，我们应该使用事件时间。这样的话，无论什么时间去计算都不会影响输出结果。然而如果使用处理时间的话，实时应用程序的结果是由程序运行的时间所决定。多次运行基于处理时间的实时程序，可能得到的结果都不相同，也可能会导致再次分析历史数据或者测试新代码变得异常困难。</p>
<h3 id="Event-Time"><a href="#Event-Time" class="headerlink" title="Event Time"></a>Event Time</h3><p>如果想要使用事件时间，需要额外给 Flink 提供一个时间戳提取器和 Watermark 生成器，Flink 将使用它们来跟踪事件时间的进度。</p>
<h3 id="Watermark"><a href="#Watermark" class="headerlink" title="Watermark"></a>Watermark</h3><p>让我们通过一个简单的示例来演示为什么需要 watermarks 及其工作方式。</p>
<p>在此示例中，我们将看到带有混乱时间戳的事件流，如下所示。显示的数字表达的是这些事件实际发生时间的时间戳。到达的第一个事件发生在时间 4，随后发生的事件发生在更早的时间 2，依此类推：</p>
<p>··· 23 19 22 24 21 14 17 13 12 15 9 11 7 2 4 →</p>
<p>假设我们要对数据流排序，我们想要达到的目的是：应用程序应该在数据流里的事件到达时就有一个算子（我们暂且称之为排序）开始处理事件，这个算子所输出的流是按照时间戳排序好的。</p>
<p>让我们重新审视这些数据:</p>
<p>(1) 我们的排序器看到的第一个事件的时间戳是 4，但是我们不能立即将其作为已排序的流释放。因为我们并不能确定它是有序的，并且较早的事件有可能并未到达。事实上，如果站在上帝视角，我们知道，必须要等到时间戳为 2 的元素到来时，排序器才可以有事件输出。</p>
<p><em>需要一些缓冲，需要一些时间，但这都是值得的</em></p>
<p>(2) 接下来的这一步，如果我们选择的是固执的等待，我们永远不会有结果。首先，我们看到了时间戳为 4 的事件，然后看到了时间戳为 2 的事件。可是，时间戳小于 2 的事件接下来会不会到来呢？可能会，也可能不会。再次站在上帝视角，我们知道，我们永远不会看到时间戳 1。</p>
<p><em>最终，我们必须勇于承担责任，并发出指令，把带有时间戳 2 的事件作为已排序的事件流的开始</em></p>
<p>(3) 然后，我们需要一种策略，该策略定义：对于任何给定时间戳的事件，Flink 何时停止等待较早事件的到来。</p>
<p><em>这正是 watermarks 的作用</em> — 它们定义何时停止等待较早的事件。</p>
<p>Flink 中事件时间的处理取决于 _watermark 生成器_，后者将带有时间戳的特殊元素插入流中形成 _watermarks_。事件时间 <em>t</em> 的 watermark 代表 <em>t</em> 之前（很可能）都已经到达。</p>
<p>当 watermark 以 2 或更大的时间戳到达时，事件流的排序器应停止等待，并输出 2 作为已经排序好的流。</p>
<p>(4) 我们可能会思考，如何决定 watermarks 的不同生成策略</p>
<p>每个事件都会延迟一段时间后到达，然而这些延迟有所不同，有些事件可能比其他事件延迟得更多。一种简单的方法是假定这些延迟受某个最大延迟的限制。Flink 将此策略称为 <em>最大无序边界 (bounded-out-of-orderness)</em> watermark。当然，我们可以想像出更好的生成 watermark 的方法，但是对于大多数应用而言，固定延迟策略已经足够了。</p>
<h3 id="延迟-VS-正确性"><a href="#延迟-VS-正确性" class="headerlink" title="延迟 VS 正确性"></a>延迟 VS 正确性</h3><p>watermarks 给了开发者流处理的一种选择，它们使开发人员在开发应用程序时可以控制延迟和完整性之间的权衡。与批处理不同，批处理中的奢侈之处在于可以在产生任何结果之前完全了解输入，而使用流式传输，我们不被允许等待所有的时间都产生了，才输出排序好的数据，这与流相违背。</p>
<p>我们可以把 watermarks 的边界时间配置的相对较短，从而冒着在输入了解不完全的情况下产生结果的风险-即可能会很快产生错误结果。或者，你可以等待更长的时间，并利用对输入流的更全面的了解来产生结果。</p>
<p>当然也可以实施混合解决方案，先快速产生初步结果，然后在处理其他（最新）数据时向这些结果提供更新。对于有一些对延迟的容忍程度很低，但是又对结果有很严格的要求的场景下，或许是一个福音。</p>
<h3 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h3><p>延迟是相对于 watermarks 定义的。<code>Watermark(t)</code> 表示事件流的时间已经到达了 <em>t</em>; watermark 之后的时间戳 ≤ <em>t</em> 的任何事件都被称之为延迟事件。</p>
<h3 id="使用-Watermarks"><a href="#使用-Watermarks" class="headerlink" title="使用 Watermarks"></a>使用 Watermarks</h3><p>如果想要使用基于带有事件时间戳的事件流，Flink 需要知道与每个事件相关的时间戳，而且流必须包含 watermark。</p>
<p>动手练习中使用的出租车数据源已经为我们处理了这些详细信息。但是，在您自己的应用程序中，您将必须自己进行处理，这通常是通过实现一个类来实现的，该类从事件中提取时间戳，并根据需要生成 watermarks。最简单的方法是使用 <code>WatermarkStrategy</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;Event&gt; stream = ...</span><br><span class="line"></span><br><span class="line">WatermarkStrategy&lt;Event&gt; strategy = WatermarkStrategy</span><br><span class="line">        .&lt;Event&gt;forBoundedOutOfOrderness(Duration.ofSeconds(<span class="number">20</span>))</span><br><span class="line">        .withTimestampAssigner((event, timestamp) -&gt; event.timestamp);</span><br><span class="line"></span><br><span class="line">DataStream&lt;Event&gt; withTimestampsAndWatermarks =</span><br><span class="line">    stream.assignTimestampsAndWatermarks(strategy);</span><br></pre></td></tr></table></figure>

<h2 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h2><p>我们在操作无界数据流时，经常需要应对以下问题，我们经常把无界数据流分解成有界数据流聚合分析：</p>
<ul>
<li>每分钟的浏览量</li>
<li>每位用户每周的会话数</li>
<li>每个传感器每分钟的最高温度</li>
</ul>
<p>用 Flink 计算窗口分析取决于两个主要的抽象操作：_Window Assigners_，将事件分配给窗口（根据需要创建新的窗口对象），以及 _Window Functions_，处理窗口内的数据。</p>
<p>Flink 的窗口 API 还具有 <em>Triggers</em> 和 <em>Evictors</em> 的概念，<em>Triggers</em> 确定何时调用窗口函数，而 <em>Evictors</em> 则可以删除在窗口中收集的元素。</p>
<p>举一个简单的例子，我们一般这样使用键控事件流（基于 key 分组的输入事件流）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stream.</span><br><span class="line">    .keyBy(&lt;key selector&gt;)</span><br><span class="line">    .window(&lt;window assigner&gt;)</span><br><span class="line">    .reduce|aggregate|process(&lt;window function&gt;)</span><br></pre></td></tr></table></figure>

<p>您不是必须使用键控事件流（keyed stream），但是值得注意的是，如果不使用键控事件流，我们的程序就不能 <em>并行</em> 处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stream.</span><br><span class="line">    .windowAll(&lt;window assigner&gt;)</span><br><span class="line">    .reduce|aggregate|process(&lt;window function&gt;)</span><br></pre></td></tr></table></figure>

<h3 id="窗口分配器"><a href="#窗口分配器" class="headerlink" title="窗口分配器"></a>窗口分配器</h3><p>Flink 有一些内置的窗口分配器，如下所示：</p>
<p><img src="https://nightlies.apache.org/flink/flink-docs-release-1.14/fig/window-assigners.svg" alt="Window assigners"></p>
<p>通过一些示例来展示关于这些窗口如何使用，或者如何区分它们：</p>
<ul>
<li>滚动时间窗口<ul>
<li><em>每分钟页面浏览量</em></li>
<li><code>TumblingEventTimeWindows.of(Time.minutes(1))</code></li>
</ul>
</li>
<li>滑动时间窗口<ul>
<li><em>每 10 秒钟计算前 1 分钟的页面浏览量</em></li>
<li><code>SlidingEventTimeWindows.of(Time.minutes(1), Time.seconds(10))</code></li>
</ul>
</li>
<li>会话窗口<ul>
<li><em>每个会话的网页浏览量，其中会话之间的间隔至少为 30 分钟</em></li>
<li><code>EventTimeSessionWindows.withGap(Time.minutes(30))</code></li>
</ul>
</li>
</ul>
<p>以下都是一些可以使用的间隔时间 <code>Time.milliseconds(n)</code>, <code>Time.seconds(n)</code>, <code>Time.minutes(n)</code>, <code>Time.hours(n)</code>, 和 <code>Time.days(n)</code>。</p>
<p>基于时间的窗口分配器（包括会话时间）既可以处理 <code>事件时间</code>，也可以处理 <code>处理时间</code>。这两种基于时间的处理没有哪一个更好，我们必须折衷。使用 <code>处理时间</code>，我们必须接受以下限制：</p>
<ul>
<li>无法正确处理历史数据,</li>
<li>无法正确处理超过最大无序边界的数据,</li>
<li>结果将是不确定的,</li>
</ul>
<p>但是有自己的优势，较低的延迟。</p>
<p>使用基于计数的窗口时，请记住，只有窗口内的事件数量到达窗口要求的数值时，这些窗口才会触发计算。尽管可以使用自定义触发器自己实现该行为，但无法应对超时和处理部分窗口。</p>
<p>我们可能在有些场景下，想使用全局 window assigner 将每个事件（相同的 key）都分配给某一个指定的全局窗口。 很多情况下，一个比较好的建议是使用 <code>ProcessFunction</code>，具体介绍在<a target="_blank" rel="noopener" href="https://nightlies.apache.org/flink/flink-docs-release-1.14/zh/docs/learn-flink/event_driven/#process-functions">这里</a>。</p>
<h3 id="窗口应用函数"><a href="#窗口应用函数" class="headerlink" title="窗口应用函数"></a>窗口应用函数</h3><p>我们有三种最基本的操作窗口内的事件的选项:</p>
<ol>
<li>像批量处理，<code>ProcessWindowFunction</code> 会缓存 <code>Iterable</code> 和窗口内容，供接下来全量计算；</li>
<li>或者像流处理，每一次有事件被分配到窗口时，都会调用 <code>ReduceFunction</code> 或者 <code>AggregateFunction</code> 来增量计算；</li>
<li>或者结合两者，通过 <code>ReduceFunction</code> 或者 <code>AggregateFunction</code> 预聚合的增量计算结果在触发窗口时， 提供给 <code>ProcessWindowFunction</code> 做全量计算。</li>
</ol>
<p>接下来展示一段 1 和 3 的示例，每一个实现都是计算传感器的最大值。在每一个一分钟大小的事件时间窗口内, 生成一个包含 <code>(key,end-of-window-timestamp, max_value)</code> 的一组结果。</p>
<h4 id="ProcessWindowFunction-示例"><a href="#ProcessWindowFunction-示例" class="headerlink" title="ProcessWindowFunction 示例"></a>ProcessWindowFunction 示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;SensorReading&gt; input = ...</span><br><span class="line"></span><br><span class="line">input</span><br><span class="line">    .keyBy(x -&gt; x.key)</span><br><span class="line">    .window(TumblingEventTimeWindows.of(Time.minutes(<span class="number">1</span>)))</span><br><span class="line">    .process(<span class="keyword">new</span> <span class="title class_">MyWastefulMax</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyWastefulMax</span> <span class="keyword">extends</span> <span class="title class_">ProcessWindowFunction</span>&lt;</span><br><span class="line">        SensorReading,                  <span class="comment">// 输入类型</span></span><br><span class="line">        Tuple3&lt;String, Long, Integer&gt;,  <span class="comment">// 输出类型</span></span><br><span class="line">        String,                         <span class="comment">// 键类型</span></span><br><span class="line">        TimeWindow&gt; &#123;                   <span class="comment">// 窗口类型</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(</span></span><br><span class="line"><span class="params">            String key,</span></span><br><span class="line"><span class="params">            Context context,</span></span><br><span class="line"><span class="params">            Iterable&lt;SensorReading&gt; events,</span></span><br><span class="line"><span class="params">            Collector&lt;Tuple3&lt;String, Long, Integer&gt;&gt; out)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (SensorReading event : events) &#123;</span><br><span class="line">            max = Math.max(event.value, max);</span><br><span class="line">        &#125;</span><br><span class="line">        out.collect(Tuple3.of(key, context.window().getEnd(), max));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在当前实现中有一些值得关注的地方：</p>
<ul>
<li>Flink 会缓存所有分配给窗口的事件流，直到触发窗口为止。这个操作可能是相当昂贵的。</li>
<li>Flink 会传递给 <code>ProcessWindowFunction</code> 一个 <code>Context</code> 对象，这个对象内包含了一些窗口信息。<code>Context</code> 接口 展示大致如下:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Context</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> W <span class="title function_">window</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">long</span> <span class="title function_">currentProcessingTime</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">long</span> <span class="title function_">currentWatermark</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> KeyedStateStore <span class="title function_">windowState</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> KeyedStateStore <span class="title function_">globalState</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>windowState</code> 和 <code>globalState</code> 可以用来存储当前的窗口的 key、窗口或者当前 key 的每一个窗口信息。这在一些场景下会很有用，试想，我们在处理当前窗口的时候，可能会用到上一个窗口的信息。</p>
<h4 id="增量聚合示例"><a href="#增量聚合示例" class="headerlink" title="增量聚合示例"></a>增量聚合示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;SensorReading&gt; input = ...</span><br><span class="line"></span><br><span class="line">input</span><br><span class="line">    .keyBy(x -&gt; x.key)</span><br><span class="line">    .window(TumblingEventTimeWindows.of(Time.minutes(<span class="number">1</span>)))</span><br><span class="line">    .reduce(<span class="keyword">new</span> <span class="title class_">MyReducingMax</span>(), <span class="keyword">new</span> <span class="title class_">MyWindowFunction</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyReducingMax</span> <span class="keyword">implements</span> <span class="title class_">ReduceFunction</span>&lt;SensorReading&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> SensorReading <span class="title function_">reduce</span><span class="params">(SensorReading r1, SensorReading r2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> r1.value() &gt; r2.value() ? r1 : r2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyWindowFunction</span> <span class="keyword">extends</span> <span class="title class_">ProcessWindowFunction</span>&lt;</span><br><span class="line">    SensorReading, Tuple3&lt;String, Long, SensorReading&gt;, String, TimeWindow&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(</span></span><br><span class="line"><span class="params">            String key,</span></span><br><span class="line"><span class="params">            Context context,</span></span><br><span class="line"><span class="params">            Iterable&lt;SensorReading&gt; maxReading,</span></span><br><span class="line"><span class="params">            Collector&lt;Tuple3&lt;String, Long, SensorReading&gt;&gt; out)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">SensorReading</span> <span class="variable">max</span> <span class="operator">=</span> maxReading.iterator().next();</span><br><span class="line">        out.collect(Tuple3.of(key, context.window().getEnd(), max));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意 <code>Iterable&lt;SensorReading&gt;</code> 将只包含一个读数 – <code>MyReducingMax</code> 计算出的预先汇总的最大值。</p>
<h3 id="晚到的事件"><a href="#晚到的事件" class="headerlink" title="晚到的事件"></a>晚到的事件</h3><p>默认场景下，超过最大无序边界的事件会被删除，但是 Flink 给了我们两个选择去控制这些事件。</p>
<p>您可以使用一种称为<a target="_blank" rel="noopener" href="https://nightlies.apache.org/flink/flink-docs-release-1.14/zh/docs/learn-flink/event_driven/#side-outputs">旁路输出</a> 的机制来安排将要删除的事件收集到侧输出流中，这里是一个示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">OutputTag&lt;Event&gt; lateTag = <span class="keyword">new</span> <span class="title class_">OutputTag</span>&lt;Event&gt;(<span class="string">&quot;late&quot;</span>)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">SingleOutputStreamOperator&lt;Event&gt; result = stream.</span><br><span class="line">    .keyBy(...)</span><br><span class="line">    .window(...)</span><br><span class="line">    .sideOutputLateData(lateTag)</span><br><span class="line">    .process(...);</span><br><span class="line"></span><br><span class="line">DataStream&lt;Event&gt; lateStream = result.getSideOutput(lateTag);</span><br></pre></td></tr></table></figure>

<p>我们还可以指定 <em>允许的延迟(allowed lateness)</em> 的间隔，在这个间隔时间内，延迟的事件将会继续分配给窗口（同时状态会被保留），默认状态下，每个延迟事件都会导致窗口函数被再次调用（有时也称之为 <em>late firing</em> ）。</p>
<p>默认情况下，允许的延迟为 0。换句话说，watermark 之后的元素将被丢弃（或发送到侧输出流）。</p>
<p>举例说明:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stream.</span><br><span class="line">    .keyBy(...)</span><br><span class="line">    .window(...)</span><br><span class="line">    .allowedLateness(Time.seconds(<span class="number">10</span>))</span><br><span class="line">    .process(...);</span><br></pre></td></tr></table></figure>

<p>当允许的延迟大于零时，只有那些超过最大无序边界以至于会被丢弃的事件才会被发送到侧输出流（如果已配置）。</p>
<h3 id="深入了解窗口操作"><a href="#深入了解窗口操作" class="headerlink" title="深入了解窗口操作"></a>深入了解窗口操作</h3><p>Flink 的窗口 API 某些方面有一些奇怪的行为，可能和我们预期的行为不一致。 根据 <a target="_blank" rel="noopener" href="https://flink.apache.org/community.html#mailing-lists">Flink 用户邮件列表</a> 和其他地方一些频繁被问起的问题, 以下是一些有关 Windows 的底层事实，这些信息可能会让您感到惊讶。</p>
<h4 id="滑动窗口是通过复制来实现的"><a href="#滑动窗口是通过复制来实现的" class="headerlink" title="滑动窗口是通过复制来实现的"></a>滑动窗口是通过复制来实现的</h4><p>滑动窗口分配器可以创建许多窗口对象，并将每个事件复制到每个相关的窗口中。例如，如果您每隔 15 分钟就有 24 小时的滑动窗口，则每个事件将被复制到 4 * 24 &#x3D; 96 个窗口中。</p>
<h4 id="时间窗口会和时间对齐"><a href="#时间窗口会和时间对齐" class="headerlink" title="时间窗口会和时间对齐"></a>时间窗口会和时间对齐</h4><p>仅仅因为我们使用的是一个小时的处理时间窗口并在 12:05 开始运行您的应用程序，并不意味着第一个窗口将在 1:05 关闭。第一个窗口将长 55 分钟，并在 1:00 关闭。</p>
<p>请注意，滑动窗口和滚动窗口分配器所采用的 offset 参数可用于改变窗口的对齐方式。有关详细的信息，请参见 <a target="_blank" rel="noopener" href="https://nightlies.apache.org/flink/flink-docs-release-1.14/zh/docs/dev/datastream/operators/windows/#tumbling-windows">滚动窗口</a> 和 <a target="_blank" rel="noopener" href="https://nightlies.apache.org/flink/flink-docs-release-1.14/zh/docs/dev/datastream/operators/windows/#sliding-windows">滑动窗口</a> 。</p>
<h4 id="window-后面可以接-window"><a href="#window-后面可以接-window" class="headerlink" title="window 后面可以接 window"></a>window 后面可以接 window</h4><p>比如说:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stream</span><br><span class="line">    .keyBy(t -&gt; t.key)</span><br><span class="line">    .window(&lt;window assigner&gt;)</span><br><span class="line">    .reduce(&lt;reduce function&gt;)</span><br><span class="line">    .windowAll(&lt;same window assigner&gt;)</span><br><span class="line">    .reduce(&lt;same reduce function&gt;)</span><br></pre></td></tr></table></figure>

<p>可能我们会猜测以 Flink 的能力，想要做到这样看起来是可行的（前提是你使用的是 ReduceFunction 或 AggregateFunction ），但不是。</p>
<p>之所以可行，是因为时间窗口产生的事件是根据窗口结束时的时间分配时间戳的。例如，一个小时小时的窗口所产生的所有事件都将带有标记一个小时结束的时间戳。后面的窗口内的数据消费和前面的流产生的数据是一致的。</p>
<h4 id="空的时间窗口不会输出结果"><a href="#空的时间窗口不会输出结果" class="headerlink" title="空的时间窗口不会输出结果"></a>空的时间窗口不会输出结果</h4><p>事件会触发窗口的创建。换句话说，如果在特定的窗口内没有事件，就不会有窗口，就不会有输出结果。</p>
<h4 id="延迟时间会导致延迟聚合"><a href="#延迟时间会导致延迟聚合" class="headerlink" title="延迟时间会导致延迟聚合"></a>延迟时间会导致延迟聚合</h4><p>会话窗口的实现是基于窗口的一个抽象能力，窗口可以 _聚合_。会话窗口中的每个数据在初始被消费时，都会被分配一个新的窗口，但是如果窗口之间的间隔足够小，多个窗口就会被聚合。延迟事件可以弥合两个先前分开的会话间隔，从而产生一个虽然有延迟但是更加准确地结果。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://nightlies.apache.org/flink/flink-docs-release-1.14/zh/">Flink 官方文档</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/6c8f32/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/6c8f32/" class="post-title-link" itemprop="url">Flink ETL</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-17 22:28:55" itemprop="dateCreated datePublished" datetime="2022-02-17T22:28:55+08:00">2022-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:53" itemprop="dateModified" datetime="2024-12-12T10:02:53+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/" itemprop="url" rel="index"><span itemprop="name">大数据</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/flink/" itemprop="url" rel="index"><span itemprop="name">flink</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Flink-ETL"><a href="#Flink-ETL" class="headerlink" title="Flink ETL"></a>Flink ETL</h1><p>Apache Flink 的一种常见应用场景是 ETL（抽取、转换、加载）管道任务。从一个或多个数据源获取数据，进行一些转换操作和信息补充，将结果存储起来。在这个教程中，我们将介绍如何使用 Flink 的 DataStream API 实现这类应用。</p>
<p>这里注意，Flink 的 <a target="_blank" rel="noopener" href="https://nightlies.apache.org/flink/flink-docs-release-1.14/zh/docs/dev/table/overview/">Table 和 SQL API</a> 完全可以满足很多 ETL 使用场景。但无论你最终是否直接使用 DataStream API，对这里介绍的基本知识有扎实的理解都是有价值的。</p>
<h2 id="无状态的转换"><a href="#无状态的转换" class="headerlink" title="无状态的转换"></a>无状态的转换</h2><p>本节涵盖了 <code>map()</code> 和 <code>flatmap()</code>，这两种算子可以用来实现无状态转换的基本操作。</p>
<h3 id="map"><a href="#map" class="headerlink" title="map()"></a><code>map()</code></h3><p>在第一个练习中，你将过滤出租车行程数据中的事件。在同一代码仓库中，有一个 <code>GeoUtils</code> 类，提供了一个静态方法 <code>GeoUtils.mapToGridCell(float lon, float lat)</code>，它可以将位置坐标（经度，维度）映射到 100x100 米的对应不同区域的网格单元。</p>
<p>现在让我们为每个出租车行程时间的数据对象增加 <code>startCell</code> 和 <code>endCell</code> 字段。你可以创建一个继承 <code>TaxiRide</code> 的 <code>EnrichedRide</code> 类，添加这些字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">EnrichedRide</span> <span class="keyword">extends</span> <span class="title class_">TaxiRide</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> startCell;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> endCell;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EnrichedRide</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EnrichedRide</span><span class="params">(TaxiRide ride)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rideId = ride.rideId;</span><br><span class="line">        <span class="built_in">this</span>.isStart = ride.isStart;</span><br><span class="line">        ...</span><br><span class="line">        <span class="built_in">this</span>.startCell = GeoUtils.mapToGridCell(ride.startLon, ride.startLat);</span><br><span class="line">        <span class="built_in">this</span>.endCell = GeoUtils.mapToGridCell(ride.endLon, ride.endLat);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.toString() + <span class="string">&quot;,&quot;</span> +</span><br><span class="line">            Integer.toString(<span class="built_in">this</span>.startCell) + <span class="string">&quot;,&quot;</span> +</span><br><span class="line">            Integer.toString(<span class="built_in">this</span>.endCell);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后你可以创建一个应用来转换这个流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;TaxiRide&gt; rides = env.addSource(<span class="keyword">new</span> <span class="title class_">TaxiRideSource</span>(...));</span><br><span class="line"></span><br><span class="line">DataStream&lt;EnrichedRide&gt; enrichedNYCRides = rides</span><br><span class="line">    .filter(<span class="keyword">new</span> <span class="title class_">RideCleansingSolution</span>.NYCFilter())</span><br><span class="line">    .map(<span class="keyword">new</span> <span class="title class_">Enrichment</span>());</span><br><span class="line"></span><br><span class="line">enrichedNYCRides.print();</span><br></pre></td></tr></table></figure>

<p>使用这个 <code>MapFunction</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Enrichment</span> <span class="keyword">implements</span> <span class="title class_">MapFunction</span>&lt;TaxiRide, EnrichedRide&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> EnrichedRide <span class="title function_">map</span><span class="params">(TaxiRide taxiRide)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EnrichedRide</span>(taxiRide);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="flatmap"><a href="#flatmap" class="headerlink" title="flatmap()"></a><code>flatmap()</code></h3><p><code>MapFunction</code> 只适用于一对一的转换：对每个进入算子的流元素，<code>map()</code> 将仅输出一个转换后的元素。对于除此以外的场景，你将要使用 <code>flatmap()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;TaxiRide&gt; rides = env.addSource(<span class="keyword">new</span> <span class="title class_">TaxiRideSource</span>(...));</span><br><span class="line"></span><br><span class="line">DataStream&lt;EnrichedRide&gt; enrichedNYCRides = rides</span><br><span class="line">    .flatMap(<span class="keyword">new</span> <span class="title class_">NYCEnrichment</span>());</span><br><span class="line"></span><br><span class="line">enrichedNYCRides.print();</span><br></pre></td></tr></table></figure>

<p>其中用到的 <code>FlatMapFunction</code> :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">NYCEnrichment</span> <span class="keyword">implements</span> <span class="title class_">FlatMapFunction</span>&lt;TaxiRide, EnrichedRide&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatMap</span><span class="params">(TaxiRide taxiRide, Collector&lt;EnrichedRide&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        FilterFunction&lt;TaxiRide&gt; valid = <span class="keyword">new</span> <span class="title class_">RideCleansing</span>.NYCFilter();</span><br><span class="line">        <span class="keyword">if</span> (valid.filter(taxiRide)) &#123;</span><br><span class="line">            out.collect(<span class="keyword">new</span> <span class="title class_">EnrichedRide</span>(taxiRide));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用接口中提供的 <code>Collector</code> ，<code>flatmap()</code> 可以输出你想要的任意数量的元素，也可以一个都不发。</p>
<h2 id="Keyed-Streams"><a href="#Keyed-Streams" class="headerlink" title="Keyed Streams"></a>Keyed Streams</h2><h3 id="keyBy"><a href="#keyBy" class="headerlink" title="keyBy()"></a><code>keyBy()</code></h3><p>将一个流根据其中的一些属性来进行分区是十分有用的，这样我们可以使所有具有相同属性的事件分到相同的组里。例如，如果你想找到从每个网格单元出发的最远的出租车行程。按 SQL 查询的方式来考虑，这意味着要对 <code>startCell</code> 进行 GROUP BY 再排序，在 Flink 中这部分可以用 <code>keyBy(KeySelector)</code> 实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rides</span><br><span class="line">    .flatMap(<span class="keyword">new</span> <span class="title class_">NYCEnrichment</span>())</span><br><span class="line">    .keyBy(enrichedRide -&gt; enrichedRide.startCell)</span><br></pre></td></tr></table></figure>

<p>每个 <code>keyBy</code> 会通过 shuffle 来为数据流进行重新分区。总体来说这个开销是很大的，它涉及网络通信、序列化和反序列化。</p>
<p><img src="https://nightlies.apache.org/flink/flink-docs-release-1.14/fig/keyBy.png" alt="keyBy and network shuffle"></p>
<h3 id="通过计算得到键"><a href="#通过计算得到键" class="headerlink" title="通过计算得到键"></a>通过计算得到键</h3><p>KeySelector 不仅限于从事件中抽取键。你也可以按想要的方式计算得到键值，只要最终结果是确定的，并且实现了 <code>hashCode()</code> 和 <code>equals()</code>。这些限制条件不包括产生随机数或者返回 Arrays 或 Enums 的 KeySelector，但你可以用元组和 POJO 来组成键，只要他们的元素遵循上述条件。</p>
<p>键必须按确定的方式产生，因为它们会在需要的时候被重新计算，而不是一直被带在流记录中。</p>
<p>例如，比起创建一个新的带有 <code>startCell</code> 字段的 <code>EnrichedRide</code> 类，用这个字段作为 key：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keyBy(enrichedRide -&gt; enrichedRide.startCell)</span><br></pre></td></tr></table></figure>

<p>我们更倾向于这样做：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keyBy(ride -&gt; GeoUtils.mapToGridCell(ride.startLon, ride.startLat))</span><br></pre></td></tr></table></figure>

<h3 id="Keyed-Stream-的聚合"><a href="#Keyed-Stream-的聚合" class="headerlink" title="Keyed Stream 的聚合"></a>Keyed Stream 的聚合</h3><p>以下代码为每个行程结束事件创建了一个新的包含 <code>startCell</code> 和时长（分钟）的元组流：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.joda.time.Interval;</span><br><span class="line"></span><br><span class="line">DataStream&lt;Tuple2&lt;Integer, Minutes&gt;&gt; minutesByStartCell = enrichedNYCRides</span><br><span class="line">    .flatMap(<span class="keyword">new</span> <span class="title class_">FlatMapFunction</span>&lt;EnrichedRide, Tuple2&lt;Integer, Minutes&gt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatMap</span><span class="params">(EnrichedRide ride,</span></span><br><span class="line"><span class="params">                            Collector&lt;Tuple2&lt;Integer, Minutes&gt;&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ride.isStart) &#123;</span><br><span class="line">                <span class="type">Interval</span> <span class="variable">rideInterval</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Interval</span>(ride.startTime, ride.endTime);</span><br><span class="line">                <span class="type">Minutes</span> <span class="variable">duration</span> <span class="operator">=</span> rideInterval.toDuration().toStandardMinutes();</span><br><span class="line">                out.collect(<span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;&gt;(ride.startCell, duration));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>现在就可以产生一个流，对每个 <code>startCell</code> 仅包含那些最长行程的数据。</p>
<p>有很多种方法表示使用哪个字段作为键。前面使用 <code>EnrichedRide</code> POJO 的例子，用字段名来指定键。而这个使用 <code>Tuple2</code> 对象的例子中，用字段在元组中的序号（从 0 开始）来指定键。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">minutesByStartCell</span><br><span class="line">  .keyBy(value -&gt; value.f0) <span class="comment">// .keyBy(value -&gt; value.startCell)</span></span><br><span class="line">  .maxBy(<span class="number">1</span>) <span class="comment">// duration</span></span><br><span class="line">  .print();</span><br></pre></td></tr></table></figure>

<p>现在每次行程时长达到新的最大值，都会输出一条新记录，例如下面这个对应 50797 网格单元的数据：</p>
<figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta prompt_">4&gt; </span>(<span class="number">64549</span>,<span class="number">5</span>M)</span><br><span class="line"><span class="meta prompt_">4&gt; </span>(<span class="number">46298</span>,<span class="number">18</span>M)</span><br><span class="line"><span class="meta prompt_">1&gt; </span>(<span class="number">51549</span>,<span class="number">14</span>M)</span><br><span class="line"><span class="meta prompt_">1&gt; </span>(<span class="number">53043</span>,<span class="number">13</span>M)</span><br><span class="line"><span class="meta prompt_">1&gt; </span>(<span class="number">56031</span>,<span class="number">22</span>M)</span><br><span class="line"><span class="meta prompt_">1&gt; </span>(<span class="number">50797</span>,<span class="number">6</span>M)</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_">1&gt; </span>(<span class="number">50797</span>,<span class="number">8</span>M)</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_">1&gt; </span>(<span class="number">50797</span>,<span class="number">11</span>M)</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_">1&gt; </span>(<span class="number">50797</span>,<span class="number">12</span>M)</span><br></pre></td></tr></table></figure>

<h3 id="（隐式的）状态"><a href="#（隐式的）状态" class="headerlink" title="（隐式的）状态"></a>（隐式的）状态</h3><p>这是培训中第一个涉及到有状态流的例子。尽管状态的处理是透明的，Flink 必须跟踪每个不同的键的最大时长。</p>
<p>只要应用中有状态，你就应该考虑状态的大小。如果键值的数量是无限的，那 Flink 的状态需要的空间也同样是无限的。</p>
<p>在流处理场景中，考虑有限窗口的聚合往往比整个流聚合更有意义。</p>
<h3 id="reduce-和其他聚合算子"><a href="#reduce-和其他聚合算子" class="headerlink" title="reduce() 和其他聚合算子"></a><code>reduce()</code> 和其他聚合算子</h3><p>上面用到的 <code>maxBy()</code> 只是 Flink 中 <code>KeyedStream</code> 上众多聚合函数中的一个。还有一个更通用的 <code>reduce()</code> 函数可以用来实现你的自定义聚合。</p>
<h2 id="有状态的转换"><a href="#有状态的转换" class="headerlink" title="有状态的转换"></a>有状态的转换</h2><h3 id="Flink-为什么要参与状态管理？"><a href="#Flink-为什么要参与状态管理？" class="headerlink" title="Flink 为什么要参与状态管理？"></a>Flink 为什么要参与状态管理？</h3><p>在 Flink 不参与管理状态的情况下，你的应用也可以使用状态，但 Flink 为其管理状态提供了一些引人注目的特性：</p>
<ul>
<li><strong>本地性</strong>: Flink 状态是存储在使用它的机器本地的，并且可以以内存访问速度来获取</li>
<li><strong>持久性</strong>: Flink 状态是容错的，例如，它可以自动按一定的时间间隔产生 checkpoint，并且在任务失败后进行恢复</li>
<li><strong>纵向可扩展性</strong>: Flink 状态可以存储在集成的 RocksDB 实例中，这种方式下可以通过增加本地磁盘来扩展空间</li>
<li><strong>横向可扩展性</strong>: Flink 状态可以随着集群的扩缩容重新分布</li>
<li><strong>可查询性</strong>: Flink 状态可以通过使用 <a target="_blank" rel="noopener" href="https://nightlies.apache.org/flink/flink-docs-release-1.14/zh/docs/dev/datastream/fault-tolerance/queryable_state/">状态查询 API</a> 从外部进行查询。</li>
</ul>
<p>在本节中你将学习如何使用 Flink 的 API 来管理 keyed state。</p>
<h3 id="Rich-Functions"><a href="#Rich-Functions" class="headerlink" title="Rich Functions"></a>Rich Functions</h3><p>至此，你已经看到了 Flink 的几种函数接口，包括 <code>FilterFunction</code>， <code>MapFunction</code>，和 <code>FlatMapFunction</code>。这些都是单一抽象方法模式。</p>
<p>对其中的每一个接口，Flink 同样提供了一个所谓 “rich” 的变体，如 <code>RichFlatMapFunction</code>，其中增加了以下方法，包括：</p>
<ul>
<li><code>open(Configuration c)</code></li>
<li><code>close()</code></li>
<li><code>getRuntimeContext()</code></li>
</ul>
<p><code>open()</code> 仅在算子初始化时调用一次。可以用来加载一些静态数据，或者建立外部服务的链接等。</p>
<p><code>getRuntimeContext()</code> 为整套潜在有趣的东西提供了一个访问途径，最明显的，它是你创建和访问 Flink 状态的途径。</p>
<h3 id="一个使用-Keyed-State-的例子"><a href="#一个使用-Keyed-State-的例子" class="headerlink" title="一个使用 Keyed State 的例子"></a>一个使用 Keyed State 的例子</h3><p>在这个例子里，想象你有一个要去重的事件数据流，对每个键只保留第一个事件。下面是完成这个功能的应用，使用一个名为 <code>Deduplicator</code> 的 <code>RichFlatMapFunction</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Event</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String key;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">long</span> timestamp;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">    env.addSource(<span class="keyword">new</span> <span class="title class_">EventSource</span>())</span><br><span class="line">        .keyBy(e -&gt; e.key)</span><br><span class="line">        .flatMap(<span class="keyword">new</span> <span class="title class_">Deduplicator</span>())</span><br><span class="line">        .print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了实现这个功能，<code>Deduplicator</code> 需要记录每个键是否已经有了相应的记录。它将通过使用 Flink 的 <em>keyed state</em> 接口来做这件事。</p>
<p>当你使用像这样的 keyed stream 的时候，Flink 会为每个状态中管理的条目维护一个键值存储。</p>
<p>Flink 支持几种不同方式的 keyed state，这个例子使用的是最简单的一个，叫做 <code>ValueState</code>。意思是对于 <em>每个键</em> ，Flink 将存储一个单一的对象 —— 在这个例子中，存储的是一个 <code>Boolean</code> 类型的对象。</p>
<p>我们的 <code>Deduplicator</code> 类有两个方法：<code>open()</code> 和 <code>flatMap()</code>。<code>open()</code> 方法通过定义 <code>ValueStateDescriptor&lt;Boolean&gt;</code> 建立了管理状态的使用。构造器的参数定义了这个状态的名字（“keyHasBeenSeen”），并且为如何序列化这些对象提供了信息（在这个例子中的 <code>Types.BOOLEAN</code>）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Deduplicator</span> <span class="keyword">extends</span> <span class="title class_">RichFlatMapFunction</span>&lt;Event, Event&gt; &#123;</span><br><span class="line">    ValueState&lt;Boolean&gt; keyHasBeenSeen;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">(Configuration conf)</span> &#123;</span><br><span class="line">        ValueStateDescriptor&lt;Boolean&gt; desc = <span class="keyword">new</span> <span class="title class_">ValueStateDescriptor</span>&lt;&gt;(<span class="string">&quot;keyHasBeenSeen&quot;</span>, Types.BOOLEAN);</span><br><span class="line">        keyHasBeenSeen = getRuntimeContext().getState(desc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatMap</span><span class="params">(Event event, Collector&lt;Event&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (keyHasBeenSeen.value() == <span class="literal">null</span>) &#123;</span><br><span class="line">            out.collect(event);</span><br><span class="line">            keyHasBeenSeen.update(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 flatMap 方法调用 <code>keyHasBeenSeen.value()</code> 时，Flink 会在 <em>当前键的上下文</em> 中检索状态值，只有当状态为 <code>null</code> 时，才会输出当前事件。这种情况下，它同时也将更新 <code>keyHasBeenSeen</code> 为 <code>true</code>。</p>
<p>这种访问和更新按键分区的状态的机制也许看上去很神奇，因为在 <code>Deduplicator</code> 的实现中，键不是明确可见的。当 Flink 运行时调用 <code>RichFlatMapFunction</code> 的 <code>open</code> 方法时， 是没有事件的，所以这个时候上下文中不含有任何键。但当它调用 <code>flatMap</code> 方法，被处理的事件的键在运行时中就是可用的了，并且被用来确定操作哪个 Flink 状态后端的入口。</p>
<p>部署在分布式集群时，将会有很多 <code>Deduplicator</code> 的实例，每一个实例将负责整个键空间的互斥子集中的一个。所以，当你看到一个单独的 <code>ValueState</code>，比如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ValueState&lt;Boolean&gt; keyHasBeenSeen;</span><br></pre></td></tr></table></figure>

<p>要理解这个代表的不仅仅是一个单独的布尔类型变量，而是一个分布式的共享键值存储。</p>
<h3 id="清理状态"><a href="#清理状态" class="headerlink" title="清理状态"></a>清理状态</h3><p>上面例子有一个潜在的问题：当键空间是无界的时候将发生什么？Flink 会对每个使用过的键都存储一个 <code>Boolean</code> 类型的实例。如果是键是有限的集合还好，但在键无限增长的应用中，清除再也不会使用的状态是很必要的。这通过在状态对象上调用 <code>clear()</code> 来实现，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keyHasBeenSeen.clear()</span><br></pre></td></tr></table></figure>

<p>对一个给定的键值，你也许想在它一段时间不使用后来做这件事。当学习 <code>ProcessFunction</code> 的相关章节时，你将看到在事件驱动的应用中怎么用定时器来做这个。</p>
<p>也可以选择使用 <a target="_blank" rel="noopener" href="https://nightlies.apache.org/flink/flink-docs-release-1.14/zh/docs/dev/datastream/fault-tolerance/state/#state-time-to-live-ttl">状态的过期时间（TTL）</a>，为状态描述符配置你想要旧状态自动被清除的时间。</p>
<h3 id="Non-keyed-State"><a href="#Non-keyed-State" class="headerlink" title="Non-keyed State"></a>Non-keyed State</h3><p>在没有键的上下文中我们也可以使用 Flink 管理的状态。这也被称作 <a target="_blank" rel="noopener" href="https://nightlies.apache.org/flink/flink-docs-release-1.14/zh/docs/dev/datastream/fault-tolerance/state/#operator-state">算子的状态</a>。它包含的接口是很不一样的，由于对用户定义的函数来说使用 non-keyed state 是不太常见的，所以这里就不多介绍了。这个特性最常用于 source 和 sink 的实现。</p>
<h2 id="Connected-Streams"><a href="#Connected-Streams" class="headerlink" title="Connected Streams"></a>Connected Streams</h2><p>相比于下面这种预先定义的转换：</p>
<p><img src="https://nightlies.apache.org/flink/flink-docs-release-1.14/fig/transformation.svg" alt="simple transformation"></p>
<p>有时你想要更灵活地调整转换的某些功能，比如数据流的阈值、规则或者其他参数。Flink 支持这种需求的模式称为 <em>connected streams</em> ，一个单独的算子有两个输入流。</p>
<p><img src="https://nightlies.apache.org/flink/flink-docs-release-1.14/fig/connected-streams.svg" alt="connected streams"></p>
<p>connected stream 也可以被用来实现流的关联。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>在这个例子中，一个控制流是用来指定哪些词需要从 <code>streamOfWords</code> 里过滤掉的。 一个称为 <code>ControlFunction</code> 的 <code>RichCoFlatMapFunction</code> 作用于连接的流来实现这个功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">    DataStream&lt;String&gt; control = env</span><br><span class="line">        .fromElements(<span class="string">&quot;DROP&quot;</span>, <span class="string">&quot;IGNORE&quot;</span>)</span><br><span class="line">        .keyBy(x -&gt; x);</span><br><span class="line"></span><br><span class="line">    DataStream&lt;String&gt; streamOfWords = env</span><br><span class="line">        .fromElements(<span class="string">&quot;Apache&quot;</span>, <span class="string">&quot;DROP&quot;</span>, <span class="string">&quot;Flink&quot;</span>, <span class="string">&quot;IGNORE&quot;</span>)</span><br><span class="line">        .keyBy(x -&gt; x);</span><br><span class="line"></span><br><span class="line">    control</span><br><span class="line">        .connect(streamOfWords)</span><br><span class="line">        .flatMap(<span class="keyword">new</span> <span class="title class_">ControlFunction</span>())</span><br><span class="line">        .print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里注意两个流只有键一致的时候才能连接。 <code>keyBy</code> 的作用是将流数据分区，当 keyed stream 被连接时，他们必须按相同的方式分区。这样保证了两个流中所有键相同的事件发到同一个实例上。这样也使按键关联两个流成为可能。</p>
<p>在这个例子中，两个流都是 <code>DataStream&lt;String&gt;</code> 类型的，并且都将字符串作为键。正如你将在下面看到的，<code>RichCoFlatMapFunction</code> 在状态中存了一个布尔类型的变量，这个变量被两个流共享。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ControlFunction</span> <span class="keyword">extends</span> <span class="title class_">RichCoFlatMapFunction</span>&lt;String, String, String&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> ValueState&lt;Boolean&gt; blocked;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">(Configuration config)</span> &#123;</span><br><span class="line">        blocked = getRuntimeContext()</span><br><span class="line">            .getState(<span class="keyword">new</span> <span class="title class_">ValueStateDescriptor</span>&lt;&gt;(<span class="string">&quot;blocked&quot;</span>, Boolean.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatMap1</span><span class="params">(String control_value, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        blocked.update(Boolean.TRUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatMap2</span><span class="params">(String data_value, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (blocked.value() == <span class="literal">null</span>) &#123;</span><br><span class="line">            out.collect(data_value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RichCoFlatMapFunction</code> 是一种可以被用于一对连接流的 <code>FlatMapFunction</code>，并且它可以调用 rich function 的接口。这意味着它可以是有状态的。</p>
<p>布尔变量 <code>blocked</code> 被用于记录在数据流 <code>control</code> 中出现过的键（在这个例子中是单词），并且这些单词从 <code>streamOfWords</code> 过滤掉。这是 <em>keyed</em> state，并且它是被两个流共享的，这也是为什么两个流必须有相同的键值空间。</p>
<p>在 Flink 运行时中，<code>flatMap1</code> 和 <code>flatMap2</code> 在连接流有新元素到来时被调用 —— 在我们的例子中，<code>control</code> 流中的元素会进入 <code>flatMap1</code>，<code>streamOfWords</code> 中的元素会进入 <code>flatMap2</code>。这是由两个流连接的顺序决定的，本例中为 <code>control.connect(streamOfWords)</code>。</p>
<p>认识到你没法控制 <code>flatMap1</code> 和 <code>flatMap2</code> 的调用顺序是很重要的。这两个输入流是相互竞争的关系，Flink 运行时将根据从一个流或另一个流中消费的事件做它要做的。对于需要保证时间和&#x2F;或顺序的场景，你会发现在 Flink 的管理状态中缓存事件一直到它们能够被处理是必须的。（注意：如果你真的感到绝望，可以使用自定义的算子实现 <code>InputSelectable</code> 接口，在两输入算子消费它的输入流时增加一些顺序上的限制。）</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://nightlies.apache.org/flink/flink-docs-release-1.14/zh/">Flink 官方文档</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/13/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><span class="space">&hellip;</span><a class="page-number" href="/page/47/">47</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/15/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备2021160229号 </a>
  </div>
  <div class="copyright">
    &copy; 2015 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">李狗蛋</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">3.5m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">53:28</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/yiyirushi/" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.1/dist/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  




<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>

</body>
</html>
