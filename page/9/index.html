<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/uploads/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/uploads/favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.ligoudan.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="天气不错哇，你看这大冰雹下得">
<meta property="og:type" content="website">
<meta property="og:title" content="LIGOUDAN">
<meta property="og:url" content="https://www.ligoudan.cn/page/9/index.html">
<meta property="og:site_name" content="LIGOUDAN">
<meta property="og:description" content="天气不错哇，你看这大冰雹下得">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="李狗蛋">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://www.ligoudan.cn/page/9/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/9/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>LIGOUDAN</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">LIGOUDAN</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">好好学习，天天向上</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">326</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">137</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">461</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="李狗蛋"
      src="/uploads/ligoudan.png">
  <p class="site-author-name" itemprop="name">李狗蛋</p>
  <div class="site-description" itemprop="description">天气不错哇，你看这大冰雹下得</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">461</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">137</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">326</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/yiyirushi" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yiyirushi" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yuanhaohoo@163.com" title="E-Mail → mailto:yuanhaohoo@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/a16273/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/a16273/" class="post-title-link" itemprop="url">《后端存储实战课》笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-08 17:00:00" itemprop="dateCreated datePublished" datetime="2022-04-08T17:00:00+08:00">2022-04-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:53" itemprop="dateModified" datetime="2024-12-12T10:02:53+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="《后端存储实战课》笔记"><a href="#《后端存储实战课》笔记" class="headerlink" title="《后端存储实战课》笔记"></a>《后端存储实战课》笔记</h1><h2 id="课前加餐丨电商系统是如何设计的？"><a href="#课前加餐丨电商系统是如何设计的？" class="headerlink" title="课前加餐丨电商系统是如何设计的？"></a>课前加餐丨电商系统是如何设计的？</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220407152237.png"></p>
<h2 id="创建和更新订单时，如何保证数据准确无误？"><a href="#创建和更新订单时，如何保证数据准确无误？" class="headerlink" title="创建和更新订单时，如何保证数据准确无误？"></a>创建和更新订单时，如何保证数据准确无误？</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220407162459.png"></p>
<h2 id="流量大、数据多的商品详情页系统该如何设计？"><a href="#流量大、数据多的商品详情页系统该如何设计？" class="headerlink" title="流量大、数据多的商品详情页系统该如何设计？"></a>流量大、数据多的商品详情页系统该如何设计？</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220407164745.png"></p>
<h2 id="复杂而又重要的购物车系统，应该如何设计？"><a href="#复杂而又重要的购物车系统，应该如何设计？" class="headerlink" title="复杂而又重要的购物车系统，应该如何设计？"></a>复杂而又重要的购物车系统，应该如何设计？</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220408142059.png"></p>
<h2 id="事务：账户余额总是对不上账，怎么办？"><a href="#事务：账户余额总是对不上账，怎么办？" class="headerlink" title="事务：账户余额总是对不上账，怎么办？"></a>事务：账户余额总是对不上账，怎么办？</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220408152524.png"></p>
<h2 id="分布式事务：如何保证多个系统间的数据是一致的？"><a href="#分布式事务：如何保证多个系统间的数据是一致的？" class="headerlink" title="分布式事务：如何保证多个系统间的数据是一致的？"></a>分布式事务：如何保证多个系统间的数据是一致的？</h2><p>分布式事务常见解决方案：</p>
<ul>
<li>2PC</li>
<li>3PC</li>
<li>TCC</li>
<li>Saga</li>
<li>本地消息表</li>
</ul>
<blockquote>
<p>个人以前总结：<a target="_blank" rel="noopener" href="https://dunwu.github.io/design/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1.html">分布式事务</a></p>
</blockquote>
<h2 id="如何用-Elasticsearch-构建商品搜索系统？"><a href="#如何用-Elasticsearch-构建商品搜索系统？" class="headerlink" title="如何用 Elasticsearch 构建商品搜索系统？"></a>如何用 Elasticsearch 构建商品搜索系统？</h2><p>搜索领域的核心问题是进行全文匹配。一般的关系型数据库，如 Mysql 的索引（InnoDB 为 B 树索引）不适用于全文检索，导致查询时只能全表扫描，性能很差。</p>
<p>搜索引擎（典型代表：Elasticsearch）通过倒排索引技术，很好的支持了全文检索。但是，倒排索引的写入和更新性能相较于 B 树索引较差，因此不适用于更新频繁的数据。</p>
<h2 id="MySQL-HA：如何将“删库跑路”的损失降到最低？"><a href="#MySQL-HA：如何将“删库跑路”的损失降到最低？" class="headerlink" title="MySQL HA：如何将“删库跑路”的损失降到最低？"></a>MySQL HA：如何将“删库跑路”的损失降到最低？</h2><p>Mysql 复制（略）</p>
<h2 id="一个几乎每个系统必踩的坑儿：访问数据库超时"><a href="#一个几乎每个系统必踩的坑儿：访问数据库超时" class="headerlink" title="一个几乎每个系统必踩的坑儿：访问数据库超时"></a>一个几乎每个系统必踩的坑儿：访问数据库超时</h2><p>数据库超时分析经验：</p>
<ul>
<li>根据故障时段在系统忙时，推断出故障是跟支持用户访问的功能有关。</li>
<li>根据系统能在流量峰值过后自动恢复这一现象，排除后台服务被大量请求打死的可能性。</li>
<li>根据 CPU 利用率的变化曲线，如果满足一定的周期性波动，可推断出大概率和定时任务有关。这些定时任务负责刷新数据缓存。如果确实是因为刷新缓存定时任务导致的，需要针对性优化。</li>
<li>如果 Mysql CPU 过高，大概率是慢 SQL 导致的，优先排查慢 SQL 日志，找出查询特别慢的表。看看该表是不是需要加缓存。</li>
</ul>
<p>避免访问数据库超时的注意点：</p>
<ul>
<li>开发时，考虑 SQL 相关表的数据规模，查询性能，是否匹配索引等等，避免出现慢 SQL</li>
<li>设计上，考虑减少查询次数，如使用缓存</li>
<li>系统支持自动杀慢 SQL</li>
<li>支持熔断、降级，减少故障影响范围</li>
</ul>
<h2 id="怎么能避免写出慢-SQL？"><a href="#怎么能避免写出慢-SQL？" class="headerlink" title="怎么能避免写出慢 SQL？"></a>怎么能避免写出慢 SQL？</h2><p>数据表不宜过大，一般不要超过千万条数据。</p>
<p>根据实际情况，尽量设计好索引，以提高查询、排序效率。</p>
<p>如果出现慢 SQL，需要改造索引时，可以通过执行计划进行分析。</p>
<h2 id="走进黑盒：SQL-是如何在数据库中执行的？"><a href="#走进黑盒：SQL-是如何在数据库中执行的？" class="headerlink" title="走进黑盒：SQL 是如何在数据库中执行的？"></a>走进黑盒：SQL 是如何在数据库中执行的？</h2><h2 id="MySQL-如何应对高并发（一）：使用缓存保护-MySQL"><a href="#MySQL-如何应对高并发（一）：使用缓存保护-MySQL" class="headerlink" title="MySQL 如何应对高并发（一）：使用缓存保护 MySQL"></a>MySQL 如何应对高并发（一）：使用缓存保护 MySQL</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220413101029.png"></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220413101039.png"></p>
<h2 id="MySQL-如何应对高并发（二）：读写分离"><a href="#MySQL-如何应对高并发（二）：读写分离" class="headerlink" title="MySQL 如何应对高并发（二）：读写分离"></a>MySQL 如何应对高并发（二）：读写分离</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220413160150.png"></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/database/mysql/master-slave-proxy.png" alt="img"></p>
<h2 id="MySQL-主从数据库同步是如何实现的？"><a href="#MySQL-主从数据库同步是如何实现的？" class="headerlink" title="MySQL 主从数据库同步是如何实现的？"></a>MySQL 主从数据库同步是如何实现的？</h2><p>基于 binlog 进行数据同步</p>
<h2 id="订单数据越来越多，数据库越来越慢该怎么办？"><a href="#订单数据越来越多，数据库越来越慢该怎么办？" class="headerlink" title="订单数据越来越多，数据库越来越慢该怎么办？"></a>订单数据越来越多，数据库越来越慢该怎么办？</h2><p>针对大表，为了优化其查询性能，可以将历史数据归档。一般可以考虑归档到列式数据库，如：Hive</p>
<h2 id="MySQL-存储海量数据的最后一招：分库分表"><a href="#MySQL-存储海量数据的最后一招：分库分表" class="headerlink" title="MySQL 存储海量数据的最后一招：分库分表"></a>MySQL 存储海量数据的最后一招：分库分表</h2><p>分库分表</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220413174922.png"></p>
<h2 id="用-Redis-构建缓存集群的最佳实践有哪些"><a href="#用-Redis-构建缓存集群的最佳实践有哪些" class="headerlink" title="用 Redis 构建缓存集群的最佳实践有哪些"></a>用 Redis 构建缓存集群的最佳实践有哪些</h2><p>Redis 3.0 后，官方提供 Redis Cluster 来解决数据量大、高可用和高并发问题。</p>
<blockquote>
<p>相关文章：<a target="_blank" rel="noopener" href="https://dunwu.github.io/waterdrop/%E6%95%B0%E6%8D%AE%E5%BA%93/05.KV%E6%95%B0%E6%8D%AE%E5%BA%93/01.Redis/07.Redis%E9%9B%86%E7%BE%A4/">Redis 集群</a></p>
</blockquote>
<h2 id="大厂都是怎么做-MySQL-to-Redis-同步的"><a href="#大厂都是怎么做-MySQL-to-Redis-同步的" class="headerlink" title="大厂都是怎么做 MySQL to Redis 同步的?"></a>大厂都是怎么做 MySQL to Redis 同步的?</h2><p>缓存穿透：把全量数据都放在 Redis 集群，服务通过接受 MQ 消息，去触发更新缓存数据。</p>
<p>使用 Binlog 实时更新 Redis 缓存，如 <a target="_blank" rel="noopener" href="https://github.com/alibaba/canal">Canal</a></p>
<h2 id="分布式存储：你知道对象存储是如何保存图片文件的吗？"><a href="#分布式存储：你知道对象存储是如何保存图片文件的吗？" class="headerlink" title="分布式存储：你知道对象存储是如何保存图片文件的吗？"></a>分布式存储：你知道对象存储是如何保存图片文件的吗？</h2><p>保存图片、音频、视频这种相对较大的文件，一般使用对象存储。如：HDFS 等。</p>
<p>元数据管理：ZooKeeper、etcd、Nacos</p>
<p>对象如何拆分和保存：将大文件分块（block），提升 IO 效率并方便维护。</p>
<h2 id="跨系统实时同步数据，分布式事务是唯一的解决方案吗？"><a href="#跨系统实时同步数据，分布式事务是唯一的解决方案吗？" class="headerlink" title="跨系统实时同步数据，分布式事务是唯一的解决方案吗？"></a>跨系统实时同步数据，分布式事务是唯一的解决方案吗？</h2><p>跨系统实时同步数据：</p>
<ul>
<li>早期方案：使用 ETL 定时同步数据，在 T+1 时刻去同步上一周期的数据，然后进行计算和分析。</li>
<li>使用 Binlog 和 MQ 构建实时数据同步系统</li>
</ul>
<p>如何保证数据同步的实时性</p>
<ul>
<li>为了能够支撑众多下游数据库实时同步的需求，可以通过 MQ 解耦上下游，Binlog 先发送到 MQ 中，下游各业务方可以消费 MQ 中的消息再写入各自的数据库。</li>
<li>如果下游处理能力不能满足要求，可以增加 MQ 中的分区数量实现并发同步，但需要结合同步的业务数据特点，把具有因果关系的数据哈希到相同分区上，才能避免因为并发乱序而出现数据同步错误的问题。</li>
</ul>
<h2 id="如何在不停机的情况下，安全地更换数据库？"><a href="#如何在不停机的情况下，安全地更换数据库？" class="headerlink" title="如何在不停机的情况下，安全地更换数据库？"></a>如何在不停机的情况下，安全地更换数据库？</h2><ul>
<li><strong>停机迁移&#x2F;扩容</strong><ul>
<li>优点：简单粗暴；没有数据一致性问题</li>
<li>缺点：需要停机</li>
</ul>
</li>
<li><strong>双写迁移</strong><ul>
<li>优点：不需要停机</li>
<li>缺点：方案较复杂</li>
</ul>
</li>
<li><strong>主从升级</strong><ul>
<li>优点：不需要停机；无需数据迁移</li>
<li>缺点：需要冗余的从库</li>
</ul>
</li>
</ul>
<h2 id="类似“点击流”这样的海量数据应该如何存储？"><a href="#类似“点击流”这样的海量数据应该如何存储？" class="headerlink" title="类似“点击流”这样的海量数据应该如何存储？"></a>类似“点击流”这样的海量数据应该如何存储？</h2><p>使用 Kafka 暂存海量原始数据，然后再使用大数据计算框架（Spark、Flink）进行计算。</p>
<p>其他方案：</p>
<p>分布式流数据存储，如：Pravega、Pulsar 的存储引擎 BookKeeper</p>
<p>时序数据库，如：InfluxDB、OpenTSDB 等。</p>
<h2 id="面对海量数据，如何才能查得更快"><a href="#面对海量数据，如何才能查得更快" class="headerlink" title="面对海量数据，如何才能查得更快"></a>面对海量数据，如何才能查得更快</h2><p>实时计算：Flink、Storm</p>
<p>批处理计算：Map-Reduce、Spark</p>
<p>海量数据存储：</p>
<ul>
<li>列式数据库（在正确使用的前提下，10GB 量级的数据查询基本上可以做到秒级返回）：HBase、Cassandra</li>
<li>搜索引擎（对于 TB 量级以下的数据，如果可以接受相对比较贵的硬件成本）：Elasticsearch</li>
</ul>
<h2 id="MySQL-经常遇到的高可用、分片问题，NewSQL-是如何解决的？"><a href="#MySQL-经常遇到的高可用、分片问题，NewSQL-是如何解决的？" class="headerlink" title="MySQL 经常遇到的高可用、分片问题，NewSQL 是如何解决的？"></a>MySQL 经常遇到的高可用、分片问题，NewSQL 是如何解决的？</h2><p>安利 CockroachDB、RocksDB、OceanBase</p>
<h2 id="RocksDB：不丢数据的高性能-KV-存储、"><a href="#RocksDB：不丢数据的高性能-KV-存储、" class="headerlink" title="RocksDB：不丢数据的高性能 KV 存储、"></a>RocksDB：不丢数据的高性能 KV 存储、</h2><p>越来越多的新生代数据库，都选择 RocksDB 作为它们的存储引擎。</p>
<p>Redis 是一个内存数据库，所以它很快。</p>
<p>RocksDB 是一个持久化的 KV 存储，它需要保证每条数据都要安全地写到磁盘上。磁盘的读写性能和内<br>存读写性能差着一两个数量级，读写磁盘的 RocksDB，能和读写内存的 Redis 做到相近的性能，这就是 RocksDB 的价值所在了。</p>
<p>RocksDB 性能好，是由于使用了 LSM 树结构。</p>
<p>LSM-Tree 的全称是：The Log-Structured Merge-Tree，是一种非常复杂的复合数据结构，它包含了 WAL（Write Ahead Log）、跳表（SkipList）和一个分层的有序表（SSTable，Sorted String Table）。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100046801">后端存储实战课</a> - 极客教程【入门】：讲解存储在电商领域的种种应用和一些基本特性</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/d7cd88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/d7cd88/" class="post-title-link" itemprop="url">数据结构与数据库索引</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-27 23:39:10" itemprop="dateCreated datePublished" datetime="2022-03-27T23:39:10+08:00">2022-03-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%BC%E5%90%88/" itemprop="url" rel="index"><span itemprop="name">数据库综合</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="数据结构与数据库索引"><a href="#数据结构与数据库索引" class="headerlink" title="数据结构与数据库索引"></a>数据结构与数据库索引</h1><blockquote>
<p>关键词：链表、数组、散列表、红黑树、B+ 树、LSM 树、跳表</p>
</blockquote>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><strong>数据库</strong>是“按照 <strong>数据结构</strong> 来组织、存储和管理数据的仓库”。是一个长期存储在计算机内的、有组织的、可共享的、统一管理的大量数据的集合。</p>
<p>——上面这句定义对数据库的定义来自百度百科。通过这个定义，我们也能明显看出数据结构是实现数据库的基石。</p>
<p>从本质来看，数据库只负责两件事：读数据、写数据；而数据结构研究的是如何合理组织数据，尽可能提升读、写数据的效率，这恰好是数据库的核心问题。因此，数据结构与数据库这两个领域有非常多的交集。其中，数据库索引最能体现二者的紧密关联。</p>
<p><strong>索引是数据库为了提高查找效率的一种数据结构</strong>。索引基于原始数据衍生而来，它的主要作用是缩小检索的数据范围，提升查询性能。通俗来说，索引在数据库中的作用就像是一本书的目录索引。索引对于良好的性能非常关键，在数据量小且负载较低时，不恰当的索引对于性能的影响可能还不明显；但随着数据量逐渐增大，性能则会急剧下降。因此，<strong>索引优化应该是查询性能优化的最有效手段</strong>。</p>
<p>很多数据库允许单独添加和删除索引，而不影响数据库的内容，它只会影响查询性能。维护额外的结构势必会引入开销，特别是在新数据写入时。对于写入，它很难超过简单地追加文件方式的性能，因为那已经是最简单的写操作了。由于每次写数据时，需要更新索引，因此任何类型的索引通常都会降低写的速度。</p>
<p>本文以一些常见的数据库为例，分析它们的索引采用了什么样的数据结构，有什么利弊，为何如此设计。</p>
<h2 id="数组和链表"><a href="#数组和链表" class="headerlink" title="数组和链表"></a>数组和链表</h2><p>数组和链表分别代表了连续空间和不连续空间的存储方式，它们是线性表（Linear List）的典型代表。其他所有的数据结构，比如栈、队列、二叉树、B+ 树等，实际上都是这两者的结合和变化。</p>
<p><strong>数组用连续的内存空间来存储数据</strong>。数组**支持随机访问，根据下标随机访问的时间复杂度为 <code>O(1)</code>**。但这并不代表数组的查找时间复杂度也是 <code>O(1)</code>。</p>
<ul>
<li>**对于无序数组，只能顺序查找，其时间复杂度为 <code>O(n)</code>**。</li>
<li>**对于有序数组，可以应用二分查找法，其时间复杂度为 <code>O(log n)</code>**。</li>
</ul>
<p>在有序数组上应用二分查找法如此高效，为什么几乎没有数据库直接使用数组作为索引？这是因为它的限制条件：<strong>数据有序</strong>——为了保证数据有序，每次添加、删除数组数据时，都必须要进行数据调整，来保证其有序，而 **数组的插入&#x2F;删除操作，时间复杂度为 <code>O(n)</code>**。此外，由于数组空间大小固定，每次扩容只能采用复制数组的方式。数组的这些特性，决定了它不适合用于数据频繁变化的应用场景。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220320115836.png" alt="img"></p>
<p><strong>链表用不连续的内存空间来存储数据；并通过一个指针按顺序将这些空间串起来，形成一条链</strong>。</p>
<p>区别于数组，链表中的元素不是存储在内存中连续的一片区域，链表中的数据存储在每一个称之为“结点”复合区域里，在每一个结点除了存储数据以外，还保存了到下一个节点的指针（Pointer）。由于不必按顺序存储，**链表的插入&#x2F;删除操作，时间复杂度为 <code>O(1)</code>**，但是，链表只支持顺序访问，其 **查找时间复杂度为 <code>O(n)</code>**。其低效的查找方式，决定了链表不适合作为索引。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220320174829.png" alt="img"></p>
<h2 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h2><p>哈希表是一种以键 - 值（key-value）对形式存储数据的结构，我们只要输入待查找的值即 key，就可以找到其对应的值即 Value。</p>
<p><strong>哈希表</strong> 使用 <strong>哈希函数</strong> 组织数据，以支持快速插入和搜索的数据结构。哈希表的本质是一个数组，其思路是：使用 Hash 函数将 Key 转换为数组下标，利用数组的随机访问特性，使得我们能在 <code>O(1)</code> 的时间代价内完成检索。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220320201844.png" alt="img"></p>
<p>有两种不同类型的哈希表：<strong>哈希集合</strong> 和 <strong>哈希映射</strong>。</p>
<ul>
<li><strong>哈希集合</strong> 是集合数据结构的实现之一，用于存储非重复值。</li>
<li><strong>哈希映射</strong> 是映射 数据结构的实现之一，用于存储键值对。</li>
</ul>
<p>哈希索引基于哈希表实现，<strong>只适用于等值查询</strong>。对于每一行数据，哈希索引都会将所有的索引列计算一个哈希码（<code>hashcode</code>），哈希码是一个较小的值。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。</p>
<p>✔️️️ 哈希索引的<strong>优点</strong>：</p>
<ul>
<li>因为索引数据结构紧凑，所以<strong>查询速度非常快</strong>。</li>
</ul>
<p>❌ 哈希索引的<strong>缺点</strong>：</p>
<ul>
<li>哈希索引值包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能影响不大。</li>
<li><strong>哈希索引数据不是按照索引值顺序存储的</strong>，所以<strong>无法用于排序</strong>。</li>
<li>哈希索引<strong>不支持部分索引匹配查找</strong>，因为哈希索引时使用索引列的全部内容来进行哈希计算的。如，在数据列 (A,B) 上建立哈希索引，如果查询只有数据列 A，无法使用该索引。</li>
<li>哈希索引<strong>只支持等值比较查询</strong>，包括 <code>=</code>、<code>IN()</code>、<code>&lt;=&gt;</code>；不支持任何范围查询，如 <code>WHERE price &gt; 100</code>。</li>
<li>哈希索引有<strong>可能出现哈希冲突</strong><ul>
<li>出现哈希冲突时，必须遍历链表中所有的行指针，逐行比较，直到找到符合条件的行。</li>
<li>如果哈希冲突多的话，维护索引的代价会很高。</li>
</ul>
</li>
</ul>
<blockquote>
<p>因为种种限制，所以哈希索引只适用于特定的场合。而一旦使用哈希索引，则它带来的性能提升会非常显著。例如，Mysql 中的 Memory 存储引擎就显示的支持哈希索引。</p>
</blockquote>
<h2 id="B-Tree-索引"><a href="#B-Tree-索引" class="headerlink" title="B-Tree 索引"></a>B-Tree 索引</h2><p>通常我们所说的 B 树索引是指 <code>B-Tree</code> 索引，它是目前关系型数据库中查找数据最为常用和有效的索引，大多数存储引擎都支持这种索引。使用 <code>B-Tree</code> 这个术语，是因为 MySQL 在 <code>CREATE TABLE</code> 或其它语句中使用了这个关键字，但实际上不同的存储引擎可能使用不同的数据结构，比如 InnoDB 使用的是 <code>B+Tree</code>索引；而 MyISAM 使用的是 <code>B-Tree</code>索引。</p>
<p><code>B-Tree</code> 索引中的 B 是指 <code>balance</code>，意为平衡。需要注意的是，<code>B-Tree</code> 索引并不能找到一个给定键值的具体行，它找到的只是被查找数据行所在的页，接着数据库会把页读入到内存，再在内存中进行查找，最后得到要查找的数据。</p>
<h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。其查询时间复杂度是 <code>O(log n)</code>。</p>
<p>当然为了维持 <code>O(log n)</code> 的查询复杂度，你就需要保持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是 <code>O(log n)</code>。</p>
<p>随着数据库中数据的增加，索引本身大小随之增加，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘 I&#x2F;O 消耗，相对于内存存取，I&#x2F;O 存取的消耗要高几个数量级。可以想象一下一棵几百万节点的二叉树的深度是多少？如果将这么大深度的一颗二叉树放磁盘上，每读取一个节点，需要一次磁盘的 I&#x2F;O 读取，整个查找的耗时显然是不能够接受的。那么如何减少查找过程中的 I&#x2F;O 存取次数？</p>
<p>一种行之有效的解决方法是减少树的深度，将<strong>二叉树变为 N 叉树</strong>（多路搜索树），而 <strong>B+ 树就是一种多路搜索树</strong>。</p>
<h3 id="B-Tree-索引-1"><a href="#B-Tree-索引-1" class="headerlink" title="B+Tree 索引"></a><code>B+Tree</code> 索引</h3><p>B+ 树索引适用于<strong>全键值查找</strong>、<strong>键值范围查找</strong>和<strong>键前缀查找</strong>，其中键前缀查找只适用于最左前缀查找。</p>
<p>理解 <code>B+Tree</code>，只需要理解其最重要的两个特征即可：</p>
<ul>
<li>第一，所有的关键字（可以理解为数据）都存储在叶子节点，非叶子节点并不存储真正的数据，所有记录节点都是按键值大小顺序存放在同一层叶子节点上。</li>
<li>其次，所有的叶子节点由指针连接。如下图为简化了的<code>B+Tree</code>。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200304235424.jpg" alt="img"></p>
<p>根据叶子节点的内容，索引类型分为主键索引和非主键索引。</p>
<ul>
<li><strong>聚簇索引（clustered）</strong>：又称为主键索引，其叶子节点存的是整行数据。因为无法同时把数据行存放在两个不同的地方，所以<strong>一个表只能有一个聚簇索引</strong>。<strong>InnoDB 的聚簇索引实际是在同一个结构中保存了 B 树的索引和数据行</strong>。</li>
<li>非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为<strong>二级索引（secondary）</strong>。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。可以有多个，小于 249 个。</li>
</ul>
<p><strong>聚簇表示数据行和相邻的键值紧凑地存储在一起，因为数据紧凑，所以访问快</strong>。因为无法同时把数据行存放在两个不同的地方，所以<strong>一个表只能有一个聚簇索引</strong>。</p>
<p><strong>聚簇索引和非聚簇索引的查询有什么区别</strong></p>
<ul>
<li>如果语句是 <code>select * from T where ID=500</code>，即聚簇索引查询方式，则只需要搜索 ID 这棵 B+ 树；</li>
<li>如果语句是 <code>select * from T where k=5</code>，即非聚簇索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为<strong>回表</strong>。</li>
</ul>
<p>也就是说，<strong>基于非聚簇索引的查询需要多扫描一棵索引树</strong>。因此，我们在应用中应该尽量使用主键查询。</p>
<p><strong>显然，主键长度越小，非聚簇索引的叶子节点就越小，非聚簇索引占用的空间也就越小。</strong></p>
<p>自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。从性能和存储空间方面考量，自增主键往往是更合理的选择。有没有什么场景适合用业务字段直接做主键的呢？还是有的。比如，有些业务的场景需求是这样的：</p>
<ul>
<li>只有一个索引；</li>
<li>该索引必须是唯一索引。</li>
</ul>
<p>由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。这时候我们就要优先考虑上一段提到的“尽量使用主键查询”原则，直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。</p>
<hr>
<p>内存是半导体元件。对于内存而言，只要给出了内存地址，我们就可以直接访问该地址取出数据。这个过程具有高效的随机访问特性，因此内存也叫随机访问存储器（Random Access Memory，即 RAM）。内存的访问速度很快，但是价格相对较昂贵，因此一般的计算机内存空间都相对较小。</p>
<p>而磁盘是机械器件。磁盘访问数据时，需要等磁盘盘片旋转到磁头下，才能读取相应的数据。尽管磁盘的旋转速度很快，但是和内存的随机访问相比，性能差距非常大。一般来说，如果是随机读写，会有 10 万到 100 万倍左右的差距。但如果是顺序访问大批量数据的话，磁盘的性能和内存就是一个数量级的。</p>
<p>磁盘的最小读写单位是扇区，较早期的磁盘一个扇区是 <strong><code>512</code></strong> 字节。随着磁盘技术的发展，目前常见的磁盘扇区是 <strong><code>4K</code></strong> 个字节。操作系统一次会读写多个扇区，所以操作系统的最小读写单位是块（Block），也叫作簇（Cluster）。当我们要从磁盘中读取一个数据时，操作系统会一次性将整个块都读出来。因此，对于大批量的顺序读写来说，磁盘的效率会比随机读写高许多。</p>
<p>假设有一个有序数组存储在硬盘中，如果它足够大，那么它会存储在多个块中。当我们要对这个数组使用二分查找时，需要先找到中间元素所在的块，将这个块从磁盘中读到内存里，然后在内存中进行二分查找。如果下一步要读的元素在其他块中，则需要再将相应块从磁盘中读入内存。直到查询结束，这个过程可能会多次访问磁盘。我们可以看到，这样的检索性能非常低。</p>
<p>由于磁盘相对于内存而言访问速度实在太慢，因此，对于磁盘上数据的高效检索，我们有一个极其重要的原则：对磁盘的访问次数要尽可能的少！</p>
<p>将索引和数据分离就是一种常见的设计思路。在数据频繁变化的场景中，有序数组并不是一个最好的选择，二叉检索树或者哈希表往往更有普适性。但是，哈希表由于缺乏范围检索的能力，在一些场合也不适用。因此，二叉检索树这种树形结构是许多常见检索系统的实施方案。</p>
<p>随着索引数据越来越大，直到无法完全加载到内存中，这是需要将索引数据也存入磁盘中。B+ 树给出了将树形索引的所有节点都存在磁盘上的高效检索方案。操作系统对磁盘数据的访问是以块为单位的。因此，如果我们想将树型索引的一个节点从磁盘中读出，即使该节点的数据量很小（比如说只有几个字节），但磁盘依然会将整个块的数据全部读出来，而不是只读这一小部分数据，这会让有效读取效率很低。B+ 树的一个关键设计，就是让一个节点的大小等于一个块的大小。节点内存储的数据，不是一个元素，而是一个可以装 m 个元素的有序数组。这样一来，我们就可以将磁盘一次读取的数据全部利用起来，使得读取效率最大化。</p>
<p>B+ 树还有另一个设计，就是将所有的节点分为内部节点和叶子节点。内部节点仅存储 key 和维持树形结构的指针，并不存储 key 对应的数据（无论是具体数据还是文件位置信息）。这样内部节点就能存储更多的索引数据，我们也就可以使用最少的内部节点，将所有数据组织起来了。而叶子节点仅存储 key 和对应数据，不存储维持树形结构的指针。通过这样的设计，B+ 树就能做到节点的空间利用率最大化。此外，B+ 树还将同一层的所有节点串成了有序的双向链表，这样一来，B+ 树就同时具备了良好的范围查询能力和灵活调整的能力了。</p>
<p>因此，B+ 树是一棵完全平衡的 m 阶多叉树。所谓的 m 阶，指的是每个节点最多有 m 个子节点，并且每个节点里都存了一个紧凑的可包含 m 个元素的数组。</p>
<p>即使是复杂的 B+ 树，我们将它拆解开来，其实也是由简单的数组、链表和树组成的，而且 B+ 树的检索过程其实也是二分查找。因此，如果 B+ 树完全加载在内存中的话，它的检索效率其实并不会比有序数组或者二叉检索树更<br>高，也还是二分查找的 log(n) 的效率。并且，它还比数组和二叉检索树更加复杂，还会带来额外的开销。</p>
<p>另外，这一节还有一个很重要的设计思想需要你掌握，那就是将索引和数据分离。通过这样的方式，我们能将索引的数组大小保持在一个较小的范围内，让它能加载在内存中。在许多大规模系统中，都是使用这个设计思想来精简索引的。而且，B+ 树的内部节点和叶子节点的区分，其实也是索引和数据分离的一次实践。</p>
<p>MySQL 中的 B+ 树实现其实有两种，一种是 MyISAM 引擎，另一种是 InnoDB 引擎。它们的核心区别就在于，数据和索引是否是分离的。</p>
<p>在 MyISAM 引擎中，B+ 树的叶子节点仅存储了数据的位置指针，这是一种索引和数据分离的设计方案，叫作非聚集索引。如果要保证 MyISAM 的数据一致性，那我们需要在表级别上进行加锁处理。</p>
<p>在 InnoDB 中，B+ 树的叶子节点直接存储了具体数据，这是一种索引和数据一体的方案。叫作聚集索引。由于数据直接就存在索引的叶子节点中，因此 InnoDB 不需要给全表加锁来保证一致性，它只需要支持行级的锁就可以了。</p>
<h2 id="LSM-树"><a href="#LSM-树" class="headerlink" title="LSM 树"></a>LSM 树</h2><p>B+ 树的数据都存储在叶子节点中，而叶子节点一般都存储在磁盘中。因此，每次插入的新数据都需要随机写入磁盘，而随机写入的性能非常慢。如果是一个日志系统，每秒钟要写入上千条甚至上万条数据，这样的磁盘操作代价会使得系统性能急剧下降，甚至无法使用。</p>
<p>操作系统对磁盘的读写是以块为单位的，我们能否以块为单位写入，而不是每次插入一个数据都要随机写入磁盘呢？这样是不是就可以大幅度减少写入操作了呢？解决方案就是：<strong>LSM 树</strong>（Log Structured Merge Trees）。</p>
<p>LSM 树就是根据这个思路设计了这样一个机制：当数据写入时，延迟写磁盘，将数据先存放在内存中的树里，进行常规的存储和查询。当内存中的树持续变大达到阈值时，再批量地以块为单位写入磁盘的树中。因此，LSM 树至少需要由两棵树组成，一棵是存储在内存中较小的 C0 树，另一棵是存储在磁盘中较大的 C1 树。</p>
<p>LSM 树具有以下 3 个特点：</p>
<ol>
<li>将索引分为内存和磁盘两部分，并在内存达到阈值时启动树合并（Merge Trees）；</li>
<li>用批量写入代替随机写入，并且用预写日志 WAL 技术（Write AheadLog，预写日志技术）保证内存数据，在系统崩溃后可以被恢复；</li>
<li>数据采取类似日志追加写的方式写入（Log Structured）磁盘，以顺序写的方式提高写<br>入效率。</li>
</ol>
<p>LSM 树的这些特点，使得它相对于 B+ 树，在写入性能上有大幅提升。所以，许多 NoSQL 系统都使用 LSM 树作为检索引擎，而且还对 LSM 树进行了优化以提升检索性能。</p>
<h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><p>倒排索引的核心其实并不复杂，它的具体实现其实是哈希表，只是它不是将文档 ID 或者题目作为 key，而是反过来，通过将内容或者属性作为 key 来存储对应的文档列表，使得我们能在 O(1) 的时间代价内完成查询。</p>
<p>尽管原理并不复杂，但是倒排索引是许多检索引擎的核心。比如说，数据库的全文索引功能、搜索引擎的索引、广告引擎和推荐引擎，都使用了倒排索引技术来实现检索功能。</p>
<h2 id="索引的维护"><a href="#索引的维护" class="headerlink" title="索引的维护"></a>索引的维护</h2><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><ul>
<li><strong>数据压缩</strong>：一个是尽可能地将数据加载到内存中，因为内存的检索效率大大高于磁盘。那为了将数据更多地加载到内存中，索引压缩是一个重要的研究方向。</li>
<li><strong>分支处理</strong>：另一个是将大数据集合拆成多个小数据集合来处理。这其实就是分布式系统的核心思想。</li>
</ul>
<h3 id="更新索引"><a href="#更新索引" class="headerlink" title="更新索引"></a>更新索引</h3><p>（1）Double Buffer（双缓冲）机制</p>
<p>就是在内存中同时保存两份一样的索引，一个是索引 A，一个是索引 B。两个索引保持一个读、一个写，并且来回切换，最终完成高性能的索引更新。</p>
<p>优点：简单高效</p>
<p>缺点：达到一定数据量级后，会带来翻倍的内存开销，甚至有些索引存储在磁盘上的情况下，更是无法使用此机制。</p>
<p>（2）全量索引和增量索引</p>
<p>将新接收到的数据单独建立一个可以存在内存中的倒排索引，也就是增量索引。当查询发生的时候，我们会同时查询全量索引和增量索引，将合并的结果作为总的结果输出。</p>
<p>因为增量索引相对全量索引而言会小很多，内存资源消耗在可承受范围，所以我们可以使用 Double Buffer 机制<br>对增量索引进行索引更新。这样一来，增量索引就可以做到无锁访问。而全量索引本身就是只读的，也不需要加锁。因此，整个检索过程都可以做到无锁访问，也就提高了系统的检索效率。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/30329536/">《数据密集型应用系统设计》</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100017301">数据结构与算法之美</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100048401">检索技术核心 20 讲</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cise.ufl.edu/~mschneid/Research/papers/HS05BoCh.pdf">Data Structures for Databases</a></li>
<li><a target="_blank" rel="noopener" href="https://people.csail.mit.edu/bradley/BenderKuszmaul-tutorial-xldb12.pdf">Data Structures and Algorithms for Big Databases</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/cba821/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/cba821/" class="post-title-link" itemprop="url">复杂度分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-20 23:25:17" itemprop="dateCreated datePublished" datetime="2022-03-20T23:25:17+08:00">2022-03-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构和算法</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%BB%BC%E5%90%88/" itemprop="url" rel="index"><span itemprop="name">综合</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h2 id="为什么需要复杂度分析"><a href="#为什么需要复杂度分析" class="headerlink" title="为什么需要复杂度分析"></a>为什么需要复杂度分析</h2><p>衡量算法的优劣，有两种评估方式：事前估计和后期测试。</p>
<p>后期测试有性能测试、基准测试（Benchmark）等手段。</p>
<p>但是，后期测试有以下限制：</p>
<ul>
<li><strong>测试结果非常依赖测试环境</strong>。如：不同机型、不同编译器版本、不同硬件配置等等，都会影响测试结果。</li>
<li><strong>测试结果受数据规模的影响很大</strong>。</li>
</ul>
<p>所以，需要一种方法，可以不受环境或数据规模的影响，粗略地估计算法的执行效率。这种方法就是复杂度分析。</p>
<h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><h3 id="大-O-表示法"><a href="#大-O-表示法" class="headerlink" title="大 O 表示法"></a>大 O 表示法</h3><p>假设问题的规模为 n，则程序的时间复杂度表示为 <code>T(n)</code>。<strong>代码的执行时间 T(n) 与每行代码的执行次数 n 成正比</strong>。</p>
<p>当 n 增大时，T(n) 也随之增大，想要准确估计其变化比较困难。所以，可以采用大 O 时间复杂度来粗略估计其复杂度，其表达式为：**<code>T(n) = O(f(n))</code>**。</p>
<p><strong>大 O 表示法</strong>实际上并不具体表示代码真正的执行时间，而是表示<strong>代码执行时间随数据规模增长的变化趋势</strong>，所以，也叫作<strong>渐进时间复杂度</strong>（asymptotic time complexity），简称<strong>时间复杂度</strong>。</p>
<h3 id="时间复杂度分析的要点"><a href="#时间复杂度分析的要点" class="headerlink" title="时间复杂度分析的要点"></a>时间复杂度分析的要点</h3><ul>
<li><strong>只关注循环执行次数最多的一段代码</strong></li>
<li><strong>加法法则：总复杂度等于量级最大的那段代码的复杂度</strong></li>
<li><strong>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</strong></li>
</ul>
<h3 id="最好、最坏和平均情况"><a href="#最好、最坏和平均情况" class="headerlink" title="最好、最坏和平均情况"></a>最好、最坏和平均情况</h3><ul>
<li><strong>最好情况时间复杂度</strong>（best case time complexity）：<strong>在最理想的情况下，执行代码的时间复杂度</strong>。例如：在最理想的情况下，要查找的变量 x 正好是数组的第一个元素，此时最好情况时间复杂度为 1。</li>
<li><strong>最坏情况时间复杂度</strong>（worst case time complexity）：<strong>在最糟糕的情况下，执行代码的时间复杂度</strong>。例如：在最理想的情况下，要查找的变量 x 正好是数组的最后个元素，此时最好情况时间复杂度为 n。</li>
<li><strong>平均情况时间复杂度</strong>（average case time complexity）：平均时间复杂度的全称应该叫<strong>加权平均时间复杂度</strong>或者<strong>期望时间复杂度</strong>。</li>
</ul>
<h3 id="时间复杂度分析示例"><a href="#时间复杂度分析示例" class="headerlink" title="时间复杂度分析示例"></a>时间复杂度分析示例</h3><p>【示例】从 1 累加到 100 的时间复杂度是多少？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    sum = sum + i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度计算：显然，这段代码执行了 100 次加法，其时间复杂度和 N 的大小完全一致</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">T</span><span class="params">(n)</span></span> = <span class="built_in">O</span>(n)</span><br></pre></td></tr></table></figure>

<p>【示例】嵌套循环的时间复杂度是多少？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; M; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;i = &quot;</span> + i + <span class="string">&quot;, j = &quot;</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度计算：</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">T</span>(<span class="built_in">n</span>) = (M-<span class="number">1</span>)(<span class="built_in">N</span>-<span class="number">1</span>) = O(M*<span class="built_in">N</span>) ≈ O(<span class="built_in">N</span>^<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>【示例】递归函数的时间复杂度是多少？思考一下斐波那契数列 <code>f(n) = f(n-1) + f(n-2)</code> 的时间复杂度是多少？</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220320110642.png" alt="img"></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">T</span><span class="params">(n)</span></span> = <span class="built_in">O</span>(<span class="number">2</span>^N)</span><br></pre></td></tr></table></figure>

<h2 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h2><p>时间复杂度的全称是<strong>渐进时间复杂度</strong>，<strong>表示算法的执行时间与数据规模之间的增长关系</strong>。</p>
<p>类比一下，空间复杂度全称就是<strong>渐进空间复杂度</strong>（asymptotic space complexity），<strong>表示算法的存储空间与数据规模之间的增长关系</strong>。</p>
<h2 id="复杂度量级"><a href="#复杂度量级" class="headerlink" title="复杂度量级"></a>复杂度量级</h2><p>复杂度有以下量级：</p>
<ul>
<li>**<code>O(1)</code>**：常数复杂度</li>
<li>**<code>O(log n)</code>**：对数复杂度</li>
<li>**<code>O(n)</code>**：线性复杂度</li>
<li>**<code>O(nlog n)</code>**：线性对数阶复杂度</li>
<li>**<code>O(n^2)</code>**：平方复杂度</li>
<li>**<code>O(n^3)</code>**：立方复杂度</li>
<li>**<code>O(n^k)</code>**：K 次方复杂度</li>
<li>**<code>O(2^n)</code>**：指数复杂度</li>
<li>**<code>O(n!)</code>**：阶乘复杂度</li>
</ul>
<p>在数据量比较小的时候，复杂度量级差异并不明显；但是，随着数据规模大小的变化，差异会逐渐突出。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220320160627.png" alt="img"></p>
<p><code>O(1)</code> 复杂度示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;num = &quot;</span> + num);</span><br></pre></td></tr></table></figure>

<p><code>O(log n)</code> 对数复杂度示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; max; i = i * <span class="number">2</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>O(n)</code> 复杂度示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; max; i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>O(n^2)</code> 复杂度示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; M; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;i = &quot;</span> + i + <span class="string">&quot;, j = &quot;</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>O(k^n)</code> 复杂度示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= Math.pow(<span class="number">2</span>, max); i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常见数据结构的复杂度"><a href="#常见数据结构的复杂度" class="headerlink" title="常见数据结构的复杂度"></a>常见数据结构的复杂度</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200702071922.png" alt="img"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100017301">数据结构与算法之美</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/2288d8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/2288d8/" class="post-title-link" itemprop="url">Flink Table API & SQL</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-18 14:33:03" itemprop="dateCreated datePublished" datetime="2022-03-18T14:33:03+08:00">2022-03-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:53" itemprop="dateModified" datetime="2024-12-12T10:02:53+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/" itemprop="url" rel="index"><span itemprop="name">大数据</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/flink/" itemprop="url" rel="index"><span itemprop="name">flink</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Flink-Table-API-SQL"><a href="#Flink-Table-API-SQL" class="headerlink" title="Flink Table API &amp; SQL"></a>Flink Table API &amp; SQL</h1><p>Apache Flink 有两种关系型 API 来做流批统一处理：Table API 和 SQL。Table API 是用于 Scala 和 Java 语言的查询 API，它可以用一种非常直观的方式来组合使用选取、过滤、join 等关系型算子。Flink SQL 是基于 <a target="_blank" rel="noopener" href="https://calcite.apache.org/">Apache Calcite</a> 来实现的标准 SQL。无论输入是连续的（流式）还是有界的（批处理），在两个接口中指定的查询都具有相同的语义，并指定相同的结果。</p>
<p>Table API 和 SQL 两种 API 是紧密集成的，以及 DataStream API。你可以在这些 API 之间，以及一些基于这些 API 的库之间轻松的切换。比如，你可以先用 <a target="_blank" rel="noopener" href="https://nightlies.apache.org/flink/flink-docs-release-1.14/zh/docs/libs/cep/">CEP</a> 从 DataStream 中做模式匹配，然后用 Table API 来分析匹配的结果；或者你可以用 SQL 来扫描、过滤、聚合一个批式的表，然后再跑一个 <a target="_blank" rel="noopener" href="https://nightlies.apache.org/flink/flink-docs-release-1.14/zh/docs/libs/gelly/overview/">Gelly 图算法</a> 来处理已经预处理好的数据。</p>
<h2 id="jar-依赖"><a href="#jar-依赖" class="headerlink" title="jar 依赖"></a>jar 依赖</h2><p>必要依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-table-api-java-bridge_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.14.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>除此之外，如果你想在 IDE 本地运行你的程序，你需要添加下面的模块，具体用哪个取决于你使用哪个 Planner：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-table-planner_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.14.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-streaming-scala_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.14.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果你想实现<a target="_blank" rel="noopener" href="https://nightlies.apache.org/flink/flink-docs-release-1.14/zh/docs/dev/table/sourcessinks/">自定义格式或连接器</a> 用于（反）序列化行或一组<a target="_blank" rel="noopener" href="https://nightlies.apache.org/flink/flink-docs-release-1.14/zh/docs/dev/table/functions/udfs/">用户定义的函数</a>，下面的依赖就足够了，编译出来的 jar 文件可以直接给 SQL Client 使用：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-table-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.14.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="概念与通用-API"><a href="#概念与通用-API" class="headerlink" title="概念与通用 API"></a>概念与通用 API</h2><p>Table API 和 SQL 集成在同一套 API 中。 这套 API 的核心概念是<code>Table</code>，用作查询的输入和输出。</p>
<h3 id="Table-API-和-SQL-程序的结构"><a href="#Table-API-和-SQL-程序的结构" class="headerlink" title="Table API 和 SQL 程序的结构"></a>Table API 和 SQL 程序的结构</h3><p>所有用于批处理和流处理的 Table API 和 SQL 程序都遵循相同的模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.table.api.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.connector.datagen.table.DataGenOptions;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a TableEnvironment for batch or streaming execution.</span></span><br><span class="line"><span class="comment">// See the &quot;Create a TableEnvironment&quot; section for details.</span></span><br><span class="line"><span class="type">TableEnvironment</span> <span class="variable">tableEnv</span> <span class="operator">=</span> TableEnvironment.create(<span class="comment">/*…*/</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a source table</span></span><br><span class="line">tableEnv.createTemporaryTable(<span class="string">&quot;SourceTable&quot;</span>, TableDescriptor.forConnector(<span class="string">&quot;datagen&quot;</span>)</span><br><span class="line">    .schema(Schema.newBuilder()</span><br><span class="line">      .column(<span class="string">&quot;f0&quot;</span>, DataTypes.STRING())</span><br><span class="line">      .build())</span><br><span class="line">    .option(DataGenOptions.ROWS_PER_SECOND, <span class="number">100</span>)</span><br><span class="line">    .build())</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a sink table (using SQL DDL)</span></span><br><span class="line">tableEnv.executeSql(<span class="string">&quot;CREATE TEMPORARY TABLE SinkTable WITH (&#x27;connector&#x27; = &#x27;blackhole&#x27;) LIKE SourceTable&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a Table object from a Table API query</span></span><br><span class="line"><span class="type">Table</span> <span class="variable">table2</span> <span class="operator">=</span> tableEnv.from(<span class="string">&quot;SourceTable&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a Table object from a SQL query</span></span><br><span class="line"><span class="type">Table</span> <span class="variable">table3</span> <span class="operator">=</span> tableEnv.sqlQuery(<span class="string">&quot;SELECT * FROM SourceTable&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Emit a Table API result Table to a TableSink, same for SQL result</span></span><br><span class="line"><span class="type">TableResult</span> <span class="variable">tableResult</span> <span class="operator">=</span> table2.executeInsert(<span class="string">&quot;SinkTable&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="创建-TableEnvironment"><a href="#创建-TableEnvironment" class="headerlink" title="创建 TableEnvironment"></a>创建 <code>TableEnvironment</code></h3><p><code>TableEnvironment</code> 是 Table API 和 SQL 的核心概念。它负责:</p>
<ul>
<li>在内部的 catalog 中注册 <code>Table</code></li>
<li>注册外部的 catalog</li>
<li>加载可插拔模块</li>
<li>执行 SQL 查询</li>
<li>注册自定义函数 （scalar、table 或 aggregation）</li>
<li><code>DataStream</code> 和 <code>Table</code> 之间的转换(面向 <code>StreamTableEnvironment</code> )</li>
</ul>
<h3 id="在-Catalog-中创建表"><a href="#在-Catalog-中创建表" class="headerlink" title="在 Catalog 中创建表"></a>在 Catalog 中创建表</h3><p><code>TableEnvironment</code> 维护着一个由标识符（identifier）创建的表 catalog 的映射。标识符由三个部分组成：catalog 名称、数据库名称以及对象名称。</p>
<p><code>Table</code> 可以是虚拟的（视图 <code>VIEWS</code>）也可以是常规的（表 <code>TABLES</code>）。视图 <code>VIEWS</code>可以从已经存在的<code>Table</code>中创建，一般是 Table API 或者 SQL 的查询结果。 表<code>TABLES</code>描述的是外部数据，例如文件、数据库表或者消息队列。</p>
<h3 id="查询表"><a href="#查询表" class="headerlink" title="查询表"></a>查询表</h3><p>Table API 示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get a TableEnvironment</span></span><br><span class="line"><span class="type">TableEnvironment</span> <span class="variable">tableEnv</span> <span class="operator">=</span> ...; <span class="comment">// see &quot;Create a TableEnvironment&quot; section</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// register Orders table</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// scan registered Orders table</span></span><br><span class="line"><span class="type">Table</span> <span class="variable">orders</span> <span class="operator">=</span> tableEnv.from(<span class="string">&quot;Orders&quot;</span>);</span><br><span class="line"><span class="comment">// compute revenue for all customers from France</span></span><br><span class="line"><span class="type">Table</span> <span class="variable">revenue</span> <span class="operator">=</span> orders</span><br><span class="line">  .filter($(<span class="string">&quot;cCountry&quot;</span>).isEqual(<span class="string">&quot;FRANCE&quot;</span>))</span><br><span class="line">  .groupBy($(<span class="string">&quot;cID&quot;</span>), $(<span class="string">&quot;cName&quot;</span>))</span><br><span class="line">  .select($(<span class="string">&quot;cID&quot;</span>), $(<span class="string">&quot;cName&quot;</span>), $(<span class="string">&quot;revenue&quot;</span>).sum().as(<span class="string">&quot;revSum&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// emit or convert Table</span></span><br><span class="line"><span class="comment">// execute query</span></span><br></pre></td></tr></table></figure>

<p>SQL 示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get a TableEnvironment</span></span><br><span class="line"><span class="type">TableEnvironment</span> <span class="variable">tableEnv</span> <span class="operator">=</span> ...; <span class="comment">// see &quot;Create a TableEnvironment&quot; section</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// register Orders table</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// compute revenue for all customers from France</span></span><br><span class="line"><span class="type">Table</span> <span class="variable">revenue</span> <span class="operator">=</span> tableEnv.sqlQuery(</span><br><span class="line">    <span class="string">&quot;SELECT cID, cName, SUM(revenue) AS revSum &quot;</span> +</span><br><span class="line">    <span class="string">&quot;FROM Orders &quot;</span> +</span><br><span class="line">    <span class="string">&quot;WHERE cCountry = &#x27;FRANCE&#x27; &quot;</span> +</span><br><span class="line">    <span class="string">&quot;GROUP BY cID, cName&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line"><span class="comment">// emit or convert Table</span></span><br><span class="line"><span class="comment">// execute query</span></span><br></pre></td></tr></table></figure>

<h3 id="输出表"><a href="#输出表" class="headerlink" title="输出表"></a>输出表</h3><p><code>Table</code> 通过写入 <code>TableSink</code> 输出。<code>TableSink</code> 是一个通用接口，用于支持多种文件格式（如 CSV、Apache Parquet、Apache Avro）、存储系统（如 JDBC、Apache HBase、Apache Cassandra、Elasticsearch）或消息队列系统（如 Apache Kafka、RabbitMQ）。</p>
<p>批处理 <code>Table</code> 只能写入 <code>BatchTableSink</code>，而流处理 <code>Table</code> 需要指定写入 <code>AppendStreamTableSink</code>，<code>RetractStreamTableSink</code> 或者 <code>UpsertStreamTableSink</code>。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>通用类型与（嵌套的）复合类型 （如：POJO、tuples、rows、Scala case 类) 都可以作为行的字段。</p>
<p>复合类型的字段任意的嵌套可被 <a target="_blank" rel="noopener" href="https://nightlies.apache.org/flink/flink-docs-release-1.14/zh/docs/dev/table/functions/systemfunctions/#value-access-functions">值访问函数</a> 访问。</p>
<p>通用类型将会被视为一个黑箱，且可以被 <a target="_blank" rel="noopener" href="https://nightlies.apache.org/flink/flink-docs-release-1.14/zh/docs/dev/table/functions/udfs/">用户自定义函数</a> 传递或引用。</p>
<h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><p>Flink 支持以下语句：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://nightlies.apache.org/flink/flink-docs-release-1.14/zh/docs/dev/table/sql/queries/overview/">SELECT (Queries)</a></li>
<li><a target="_blank" rel="noopener" href="https://nightlies.apache.org/flink/flink-docs-release-1.14/zh/docs/dev/table/sql/create/">CREATE TABLE, DATABASE, VIEW, FUNCTION</a></li>
<li><a target="_blank" rel="noopener" href="https://nightlies.apache.org/flink/flink-docs-release-1.14/zh/docs/dev/table/sql/drop/">DROP TABLE, DATABASE, VIEW, FUNCTION</a></li>
<li><a target="_blank" rel="noopener" href="https://nightlies.apache.org/flink/flink-docs-release-1.14/zh/docs/dev/table/sql/alter/">ALTER TABLE, DATABASE, FUNCTION</a></li>
<li><a target="_blank" rel="noopener" href="https://nightlies.apache.org/flink/flink-docs-release-1.14/zh/docs/dev/table/sql/insert/">INSERT</a></li>
<li><a target="_blank" rel="noopener" href="https://nightlies.apache.org/flink/flink-docs-release-1.14/zh/docs/dev/table/sql/queries/hints/">SQL HINTS</a></li>
<li><a target="_blank" rel="noopener" href="https://nightlies.apache.org/flink/flink-docs-release-1.14/zh/docs/dev/table/sql/describe/">DESCRIBE</a></li>
<li><a target="_blank" rel="noopener" href="https://nightlies.apache.org/flink/flink-docs-release-1.14/zh/docs/dev/table/sql/explain/">EXPLAIN</a></li>
<li><a target="_blank" rel="noopener" href="https://nightlies.apache.org/flink/flink-docs-release-1.14/zh/docs/dev/table/sql/use/">USE</a></li>
<li><a target="_blank" rel="noopener" href="https://nightlies.apache.org/flink/flink-docs-release-1.14/zh/docs/dev/table/sql/show/">SHOW</a></li>
<li><a target="_blank" rel="noopener" href="https://nightlies.apache.org/flink/flink-docs-release-1.14/zh/docs/dev/table/sql/load/">LOAD</a></li>
<li><a target="_blank" rel="noopener" href="https://nightlies.apache.org/flink/flink-docs-release-1.14/zh/docs/dev/table/sql/unload/">UNLOAD</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://nightlies.apache.org/flink/flink-docs-release-1.14/zh/docs/dev/table/common/">Flink 官方文档之 Flink Table API &amp; SQL</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/899690/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/899690/" class="post-title-link" itemprop="url">LSM树</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-16 09:27:21" itemprop="dateCreated datePublished" datetime="2022-03-16T09:27:21+08:00">2022-03-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构和算法</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%A0%91/" itemprop="url" rel="index"><span itemprop="name">树</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="LSM-树"><a href="#LSM-树" class="headerlink" title="LSM 树"></a>LSM 树</h1><h2 id="什么是-LSM-树"><a href="#什么是-LSM-树" class="headerlink" title="什么是 LSM 树"></a>什么是 LSM 树</h2><p>LSM 树具有以下 3 个特点：</p>
<ol>
<li>将索引分为内存和磁盘两部分，并在内存达到阈值时启动树合并（Merge Trees）；</li>
<li>用批量写入代替随机写入，并且用预写日志 WAL 技术（Write AheadLog，预写日志技术）保证内存数据，在系统崩溃后可以被恢复；</li>
<li>数据采取类似日志追加写的方式写入（Log Structured）磁盘，以顺序写的方式提高写<br>入效率。</li>
</ol>
<p>LSM 树的这些特点，使得它相对于 B+ 树，在写入性能上有大幅提升。所以，许多 NoSQL 系统都使用 LSM 树作为检索引擎，而且还对 LSM 树进行了优化以提升检索性能。</p>
<p>LSM 树就是根据这个思路设计了这样一个机制：当数据写入时，延迟写磁盘，将数据先存放在内存中的树里，进行常规的存储和查询。当内存中的树持续变大达到阈值时，再批量地以块为单位写入磁盘的树中。因此，LSM 树至少需要由两棵树组成，一棵是存储在内存中较小的 C0 树，另一棵是存储在磁盘中较大的 C1 树。</p>
<h3 id="如何将内存数据与磁盘数据合并"><a href="#如何将内存数据与磁盘数据合并" class="headerlink" title="如何将内存数据与磁盘数据合并"></a>如何将内存数据与磁盘数据合并</h3><p>可以参考两个有序链表归并排序的过程，将 C0 树和 C1 树的所有叶子节点中存储的数据，看作是两个有序链表，那滚动合并问题就变成了我们熟悉的两个有序链表的归并问题。不过由于涉及磁盘操作，那为了提高写入效率和检索效率，我们还需要针对磁盘的特性，在一些归并细节上进行优化。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220316105440.png" alt="img"></p>
<p>由于磁盘具有顺序读写效率高的特性，因此，为了提高 C1 树中节点的读写性能，除了根节点以外的节点都要尽可能地存放到连续的块中，让它们能作为一个整体单位来读写。这种包含多个节点的块就叫作多页块（Multi-Pages Block）。</p>
<p>第一步，以多页块为单位，将 C1 树的当前叶子节点从前往后读入内存。读入内存的多页块，叫作清空块（Emptying Block），意思是处理完以后会被清空。</p>
<p>第二步，将 C0 树的叶子节点和清空块中的数据进行归并排序，把归并的结果写入内存的一个新块中，叫作填充块（Filling Block）。</p>
<p>第三步，如果填充块写满了，我们就要将填充块作为新的叶节点集合顺序写入磁盘。这个时候，如果 C0 树的叶子节点和清空块都没有遍历完，我们就继续遍历归并，将数据写入新的填充块。如果清空块遍历完了，我们就去 C1 树中顺序读取新的多页块，加载到清空块中。</p>
<p>第四步，重复第三步，直到遍历完 C0 树和 C1 树的所有叶子节点，并将所有的归并结果写入到磁盘。这个时候，我们就可以同时删除 C0 树和 C1 树中被处理过的叶子节点。这样就完成了滚动归并的过程。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220316110736.png" alt="img"></p>
<h3 id="LSM-树是如何检索"><a href="#LSM-树是如何检索" class="headerlink" title="LSM 树是如何检索"></a>LSM 树是如何检索</h3><p>因为同时存在 C0 和 C1 树，所以要查询一个 key 时，我们会先到 C0 树中查询。如果查询到了则直接返回；如过没有查询到，则查询 C1 树。</p>
<p>需要注意一种特殊情况：删除操作。假设某数据在 C0 树中被删除了，但是在 C1 树中仍存在。这此时查询时，可以在 C1 树中查到这个 key，这其实是过期数据了，如何应对这种情况呢？对于被删除的数据，可以将这些数据的 key 插入到 C0 树中，并标记一个删除标志。如果查到了一个带着删除标志的 key，就直接返回查询失败。</p>
<h2 id="为什么需要-LSM-树"><a href="#为什么需要-LSM-树" class="headerlink" title="为什么需要 LSM 树"></a>为什么需要 LSM 树</h2><p>在关系型数据库中，通常使用 B+ 树作为索引。B+ 树的数据都存储在叶子节点中，而叶子节点一般都存储在磁盘中。因此，每次插入的新数据都需要随机写入磁盘，而随机写入的性能非常慢。如果是一个日志系统，每秒钟要写入上千条甚至上万条数据，这样的磁盘操作代价会使得系统性能急剧下降，甚至无法使用。</p>
<p>操作系统对磁盘的读写是以块为单位的，我们能否以块为单位写入，而不是每次插入一个数据都要随机写入磁盘呢？这样是不是就可以大幅度减少写入操作了呢？解决方案就是：<strong>LSM 树</strong>（Log Structured Merge Trees）。</p>
<h2 id="WAL-技术"><a href="#WAL-技术" class="headerlink" title="WAL 技术"></a>WAL 技术</h2><p>LSM 树至少需要由两棵树组成，一棵是存储在内存中较小的 C0 树，另一棵是存储在磁盘中较大的 C1 树。</p>
<p>如果机器断电或系统崩溃了，那内存中还未写入磁盘的数据岂不就永远丢失了？这种情况我们该如何解决呢？</p>
<p>为了保证内存中的数据在系统崩溃后能恢复，可以使用 WAL 技术（Write Ahead Log，预写日志技术）将数据第一时间高效写入磁盘进行备份。</p>
<p>WAL 技术保存和恢复数据的具体步骤如下：</p>
<ol>
<li>内存中的程序在处理数据时，会先将对数据的修改作为一条记录，顺序写入磁盘的 log 文件作为备份。由于磁盘文件的顺序追加写入效率很高，因此许多应用场景都可以接受这种备份处理。</li>
<li>在数据写入 log 文件后，备份就成功了。接下来，该数据就可以长期驻留在内存中了。</li>
<li>系统会周期性地检查内存中的数据是否都被处理完了（比如，被删除或者写入磁盘），并且生成对应的检查点（Check Point）记录在磁盘中。然后，我们就可以随时删除被处理完的数据了。这样一来，log 文件就不会无限增长了。</li>
<li>系统崩溃重启，我们只需要从磁盘中读取检查点，就能知道最后一次成功处理的数据在 log 文件中的位置。接下来，我们就可以把这个位置之后未被处理的数据，从 log 文件中读出，然后重新加载到内存中。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220316104837.png" alt="img"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100048401">检索技术核心 20 讲</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/2ba2ac/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/2ba2ac/" class="post-title-link" itemprop="url">B+树</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-13 22:37:27" itemprop="dateCreated datePublished" datetime="2022-03-13T22:37:27+08:00">2022-03-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构和算法</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%A0%91/" itemprop="url" rel="index"><span itemprop="name">树</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h1><h2 id="什么是-B-树"><a href="#什么是-B-树" class="headerlink" title="什么是 B+树"></a>什么是 B+树</h2><p>B+树是在二叉查找树的基础上进行了改造：树中的节点并不存储数据本身，而是只是作为索引。每个叶子节点串在一条链表上，链表中的数据是从小到大有序的。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220311092926.jpg" alt="img"></p>
<p>改造之后，如果我们要求某个区间的数据。我们只需要拿区间的起始值，在树中进行查找，当查找到某个叶子节点之后，我们再顺着链表往后遍历，直到链表中的结点数据值大于区间的终止值为止。所有遍历到的数据，就是符合区间值的所有数据。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220311092929.jpg" alt="img"></p>
<p>但是，我们要为几千万、上亿的数据构建索引，如果将索引存储在内存中，尽管内存访问的速度非常快，查询的效率非常高，但是，占用的内存会非常多。</p>
<p>比如，我们给一亿个数据构建二叉查找树索引，那索引中会包含大约 1 亿个节点，每个节点假设占用 16 个字节，那就需要大约 1GB 的内存空间。给一张表建立索引，我们需要 1GB 的内存空间。如果我们要给 10 张表建立索引，那对内存的需求是无法满足的。如何解决这个索引占用太多内存的问题呢？</p>
<p>我们可以借助时间换空间的思路，把索引存储在硬盘中，而非内存中。我们都知道，硬盘是一个非常慢速的存储设备。通常内存的访问速度是纳秒级别的，而磁盘访问的速度是毫秒级别的。读取同样大小的数据，从磁盘中读取花费的时间，是从内存中读取所花费时间的上万倍，甚至几十万倍。</p>
<p>这种将索引存储在硬盘中的方案，尽管减少了内存消耗，但是在数据查找的过程中，需要读取磁盘中的索引，因此数据查询效率就相应降低很多。</p>
<p>二叉查找树，经过改造之后，支持区间查找的功能就实现了。不过，为了节省内存，如果把树存储在硬盘中，那么每个节点的读取（或者访问），都对应一次磁盘 IO 操作。树的高度就等于每次查询数据时磁盘 IO 操作的次数。</p>
<p>我们前面讲到，比起内存读写操作，磁盘 IO 操作非常耗时，所以我们优化的重点就是尽量减少磁盘 IO 操作，也就是，尽量降低树的高度。那如何降低树的高度呢？</p>
<p>我们来看下，如果我们把索引构建成 m 叉树，高度是不是比二叉树要小呢？如图所示，给 16 个数据构建二叉树索引，树的高度是 4，查找一个数据，就需要 4 个磁盘 IO 操作（如果根节点存储在内存中，其他结点存储在磁盘中），如果对 16 个数据构建五叉树索引，那高度只有 2，查找一个数据，对应只需要 2 次磁盘操作。如果 m 叉树中的 m 是 100，那对一亿个数据构建索引，树的高度也只是 3，最多只要 3 次磁盘 IO 就能获取到数据。磁盘 IO 变少了，查找数据的效率也就提高了。</p>
<h2 id="为什么需要-B-树"><a href="#为什么需要-B-树" class="headerlink" title="为什么需要 B+树"></a>为什么需要 B+树</h2><p>关系型数据库中常用 B+ 树作为索引，这是为什么呢？</p>
<p>思考以下经典应用场景</p>
<ul>
<li>根据某个值查找数据，比如 <code>select * from user where id=1234</code>。</li>
<li>根据区间值来查找某些数据，比如 <code>select * from user where id &gt; 1234 and id &lt; 2345</code>。</li>
</ul>
<p>为了提高查询效率，需要使用索引。而对于索引的性能要求，主要考察<strong>执行效率和存储空间</strong>。如果让你选择一种数据结构去存储索引，你会如何考虑？</p>
<p>以一些常见数据结构为例：</p>
<ul>
<li><strong>哈希表</strong>：哈希表的查询性能很好，时间复杂度是 <code>O(1)</code>。但是，哈希表不能支持按照区间快速查找数据。所以，哈希表不能满足我们的需求。</li>
<li><strong>平衡二叉查找树</strong>：尽管平衡二叉查找树查询的性能也很高，时间复杂度是 <code>O(logn)</code>。而且，对树进行中序遍历，我们还可以得到一个从小到大有序的数据序列，但这仍然不足以支持按照区间快速查找数据。</li>
<li><strong>跳表</strong>：跳表是在链表之上加上多层索引构成的。它支持快速地插入、查找、删除数据，对应的时间复杂度是 <code>O(logn)</code>。并且，跳表也支持按照区间快速地查找数据。我们只需要定位到区间起点值对应在链表中的结点，然后从这个结点开始，顺序遍历链表，直到区间终点对应的结点为止，这期间遍历得到的数据就是满足区间值的数据。</li>
</ul>
<p>实际上，数据库索引所用到的数据结构跟跳表非常相似，叫作 B+ 树。不过，它是通过二叉查找树演化过来的，而非跳表。B+树的应用场景</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100017301">数据结构与算法之美</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/eec931/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/eec931/" class="post-title-link" itemprop="url">字典树</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-13 22:37:27" itemprop="dateCreated datePublished" datetime="2022-03-13T22:37:27+08:00">2022-03-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构和算法</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%A0%91/" itemprop="url" rel="index"><span itemprop="name">树</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h1><h2 id="什么是字典树"><a href="#什么是字典树" class="headerlink" title="什么是字典树"></a>什么是字典树</h2><p>Trie 树（又叫“前缀树”或“字典树”）是一种用于快速查询“某个字符串&#x2F;字符前缀”是否存在的数据结构。</p>
<ul>
<li>根节点（Root）不包含字符，除根节点外的每一个节点都仅包含一个字符；</li>
<li>从根节点到某一节点路径上所经过的字符连接起来，即为该节点对应的字符串；</li>
<li>任意节点的所有子节点所包含的字符都不相同；</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220313181057.jpg" alt="img"></p>
<h3 id="字典树的构造"><a href="#字典树的构造" class="headerlink" title="字典树的构造"></a>字典树的构造</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220313181243.jpg" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220313181425.jpg" alt="img"></p>
<p>构建 Trie 树的过程，需要扫描所有的字符串，时间复杂度是 O(n)（n 表示所有字符串的长度和）。</p>
<p><strong>字典树非常耗费内存</strong>。</p>
<p>用数组来存储一个节点的子节点的指针。如果字符串中包含从 a 到 z 这 26 个字符，那每个节点都要存储一个长度为 26 的数组，并且每个数组存储一个 8 字节指针（或者是 4 字节，这个大小跟 CPU、操作系统、编译器等有关）。而且，即便一个节点只有很少的子节点，远小于 26 个，比如 3、4 个，我们也要维护一个长度为 26 的数组。</p>
<p>用数组来存储一个节点的子节点的指针。如果字符串中包含从 a 到 z 这 26 个字符，那每个节点都要存储一个长度为 26 的数组，并且每个数组存储一个 8 字节指针（或者是 4 字节，这个大小跟 CPU、操作系统、编译器等有关）。而且，即便一个节点只有很少的子节点，远小于 26 个，比如 3、4 个，我们也要维护一个长度为 26 的数组。</p>
<p>用数组来存储一个节点的子节点的指针。如果字符串中包含从 a 到 z 这 26 个字符，那每个节点都要存储一个长度为 26 的数组，并且每个数组存储一个 8 字节指针（或者是 4 字节，这个大小跟 CPU、操作系统、编译器等有关）。而且，即便一个节点只有很少的子节点，远小于 26 个，比如 3、4 个，我们也要维护一个长度为 26 的数组。</p>
<h3 id="字典树的查找"><a href="#字典树的查找" class="headerlink" title="字典树的查找"></a>字典树的查找</h3><ol>
<li>每次从根结点开始搜索；</li>
<li>获取关键词的第一个字符，根据该字符选择对应的子节点，转到该子节点继续检索；</li>
<li>在相应的子节点上，获取关键词的第二个字符，进一步选择对应的子节点进行检索；</li>
<li>以此类推，进行迭代过程；</li>
<li>在某个节点处，关键词的所有字母已被取出，则读取附在该节点上的信息，查找完成。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220313181305.jpg" alt="img"></p>
<p>每次查询时，如果要查询的字符串长度是 k，那我们只需要比对大约 k 个节点，就能完成查询操作。跟原本那组字符串的长度和个数没有任何关系。所以说，构建好 Trie 树后，在其中查找字符串的时间复杂度是 O(k)，k 表示要查找的字符串的长度。</p>
<h2 id="字典树的应用场景"><a href="#字典树的应用场景" class="headerlink" title="字典树的应用场景"></a>字典树的应用场景</h2><p>在一组字符串中查找字符串，Trie 树实际上表现得并不好。它对要处理的字符串有及其严苛的要求。</p>
<p>第一，字符串中包含的字符集不能太大。我们前面讲到，如果字符集太大，那存储空间可能就会浪费很多。即便可以优化，但也要付出牺牲查询、插入效率的代价。</p>
<p>第二，要求字符串的前缀重合比较多，不然空间消耗会变大很多。</p>
<p>第三，如果要用 Trie 树解决问题，那我们就要自己从零开始实现一个 Trie 树，还要保证没有 bug，这个在工程上是将简单问题复杂化，除非必须，一般不建议这样做。</p>
<p>第四，我们知道，通过指针串起来的数据块是不连续的，而 Trie 树中用到了指针，所以，对缓存并不友好，性能上会打个折扣。</p>
<p>在一组字符串中查找字符串，Trie 树实际上表现得并不好。它对要处理的字符串有及其严苛的要求。</p>
<p>在一组字符串中查找字符串，Trie 树实际上表现得并不好。它对要处理的字符串有及其严苛的要求。</p>
<p>（1）自动补全</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200305095300.png" alt="img"></p>
<p>（2）拼写检查</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200305101637.png" alt="img"></p>
<p>（3）IP 路由 (最长前缀匹配)</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200305102959.gif" alt="img"></p>
<p>图 3. 使用 Trie 树的最长前缀匹配算法，Internet 协议（IP）路由中利用转发表选择路径。</p>
<p>（4）T9 (九宫格) 打字预测</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200305103047.jpg" alt="img"></p>
<p>（5）单词游戏</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200305103052.png" alt="img"></p>
<p>Trie 树可通过剪枝搜索空间来高效解决 Boggle 单词游戏</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100017301">数据结构与算法之美</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/shi-xian-trie-qian-zhui-shu-by-leetcode/">https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/shi-xian-trie-qian-zhui-shu-by-leetcode/</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/346350/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/346350/" class="post-title-link" itemprop="url">《检索技术核心 20 讲》笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-04 20:03:00" itemprop="dateCreated datePublished" datetime="2022-03-04T20:03:00+08:00">2022-03-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:53" itemprop="dateModified" datetime="2024-12-12T10:02:53+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="《检索技术核心-20-讲》笔记"><a href="#《检索技术核心-20-讲》笔记" class="headerlink" title="《检索技术核心 20 讲》笔记"></a>《检索技术核心 20 讲》笔记</h1><blockquote>
<p>伸缩性架构是指不需要改变系统的软硬件设计，仅通过改变部署服务器数量就可以扩大或缩小系统的服务处理能力。</p>
</blockquote>
<h2 id="线性结构检索"><a href="#线性结构检索" class="headerlink" title="线性结构检索"></a>线性结构检索</h2><p>检索的核心思想：合理组织数据，尽可能快速减少查询范围，可以提升检索效率。</p>
<p><strong><em>数组和链表的比较</em></strong></p>
<ul>
<li><strong>存储方式</strong><ul>
<li>数组用 <strong>连续</strong> 的内存空间来存储数据。</li>
<li>链表用 <strong>不连续</strong> 的内存空间来存储数据；并通过一个指针按顺序将这些空间串起来，形成一条链。</li>
</ul>
</li>
<li><strong>访问方式</strong><ul>
<li>数组<strong>支持随机访问</strong>。根据下标随机访问的时间复杂度为 <code>O(1)</code></li>
<li>链表<strong>不支持随机访问</strong>，只能顺序访问。</li>
</ul>
</li>
<li><strong>空间大小</strong><ul>
<li>数组空间<strong>大小固定</strong>，扩容只能采用复制数组的方式。</li>
<li>链表空间<strong>大小不固定</strong>，扩容灵活。</li>
</ul>
</li>
<li><strong>效率比较</strong><ul>
<li>数组的 <strong>查找</strong> 效率高于链表。</li>
<li>链表的 <strong>添加</strong>、<strong>删除</strong> 效率高于数组。</li>
</ul>
</li>
</ul>
<h2 id="非线性结构检索"><a href="#非线性结构检索" class="headerlink" title="非线性结构检索"></a>非线性结构检索</h2><ul>
<li>对于无序数组，只能顺序查找，其时间复杂度为 <code>O(n)</code>。</li>
<li>对于有序数组，可以应用二分查找法，其时间复杂度为 <code>O(log n)</code>。</li>
</ul>
<p>显然，二分查找法很高效，但是它有限制条件：数据有序。为了保证数据有序，添加、删除数组数据时，必须要进行数据调整，来保证其有序。</p>
<p>首先，对于数据频繁变化的应用场景，有序数组并不是最适合的解决方案。我们一般要考虑采用非连续存储的数据结构来灵活调整。同时，为了提高检索效率，我们还要采取合理的组织方式，让这些非连续存储的数据结构能够使用二分查找算法。</p>
<p>数据组织的方式有两种，一种是二叉检索树。一个平衡的二叉检索树使用二分查找的检索效率是 <code>O(log n)</code>，但如果我们不做额外的平衡控制的话，二叉检索树的检索性能最差会退化到 <code>O(n)</code>，也就和单链表一样了。所以，AVL 树和红黑树这样平衡性更强的二叉检索树，在实际工作中应用更多。</p>
<p>除了树结构以外，另一种数据组织方式是跳表。跳表也具备二分查找的能力，理想跳表的检索效率是 <code>O(log n)</code>。为了保证跳表的检索空间平衡，跳表为每个节点随机生成层级，这样的实现方式比 AVL 树和红黑树更简单。</p>
<p>无论是二叉检索树还是跳表，它们都是通过将数据进行合理组织，然后尽可能地平衡划分检索空间，使得我们能采用二分查找的思路快速地缩减查找范围，达到 <code>O(log n)</code> 的检索效率。</p>
<h2 id="哈希检索"><a href="#哈希检索" class="headerlink" title="哈希检索"></a>哈希检索</h2><p>散列表的思路是：使用 Hash 函数将 Key 转换为数组下标。</p>
<p>哈希表的本质是一个数组，它通过 Hash 函数将查询的 Key 转为数组下标，利用数组的随机访问特性，使得我们能在 O(1) 的时间代价内完成检索。</p>
<p>尽管哈希检索没有使用二分查找，但无论是设计理想的哈希函数，还是保证哈希表有足够的空闲位置，包括解决冲突的“二次探查”和“双散列”方案，本质上都是希望数据插入哈希表的时候，分布能均衡，这样检索才能更高效。从这个角度来看，其实哈希检索提高检索效率的原理，和二叉检索树需要平衡左右子树深度的原理是一样的，也就是说，高效的检索需要均匀划分检索空间。</p>
<h2 id="状态检索"><a href="#状态检索" class="headerlink" title="状态检索"></a>状态检索</h2><p>在海量数据中，快速判断一个对象是否存在。相比于有序数组、二叉检索树和哈希表这三种方案，位图和布隆过滤器其实更适合解决这类状态检索的问题。这是因为，在不要求 100% 判断正确的情况下，使用位图和布隆过滤器可以达到 <code>O(1)</code> 时间代价的检索效率，同时空间使用率也非常高效。</p>
<p>为了判断一个很大的数据范围中，某数值是否存在，可以将这个范围的数据存为数组，其数组值为布尔型（true 或 false）。由于很多语言中，布尔类型需要 1 个字节，而二进制位（bit）的值 0 或 1 也可以表示 true 或 false，并且占用空间更小，所以更加合适。而这种基于位运算的哈希结构，即为位图。</p>
<p>布隆过滤器最大的特点，就是对一个对象使用多个哈希函数。如果我们使用了 k 个哈希函数，就会得到 k 个哈希值，也就是 k 个下标，我们会把数组中对应下标位置的值都置为 1。布隆过滤器和位图最大的区别就在于，我们不再使用一位来表示一个对象，而是使用 k 位来表示一个对象。这样两个对象的 k 位都相同的概率就会大大降低，从而能够解决哈希冲突的问题了。</p>
<p>布隆过滤器的误判有一个特点，那就是，它只会对存在的情况有误判。如果某个数字经过布隆过滤器判断不存在，那说明这个数字真的不存在，不会发生误判；如果某个数字经过布隆过滤器判断存在，这个时候才会有可能误判，有可能并不存在。不过，只要我们调整哈希函数的个数、位图大小跟要存储数字的个数之间的比例，那就可以将这种误判的概率降到非常低。</p>
<p>布隆过滤器过滤器适用于对误判有一定容忍度的场景。</p>
<h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><p>倒排索引的核心其实并不复杂，它的具体实现其实是哈希表，只是它不是将文档 ID 或者题目作为 key，而是反过来，通过将内容或者属性作为 key 来存储对应的文档列表，使得我们能在 O(1) 的时间代价内完成查询。</p>
<p>尽管原理并不复杂，但是倒排索引是许多检索引擎的核心。比如说，数据库的全文索引功能、搜索引擎的索引、广告引擎和推荐引擎，都使用了倒排索引技术来实现检索功能。</p>
<h2 id="B-树检索"><a href="#B-树检索" class="headerlink" title="B+ 树检索"></a>B+ 树检索</h2><p>内存是半导体元件。对于内存而言，只要给出了内存地址，我们就可以直接访问该地址取出数据。这个过程具有高效的随机访问特性，因此内存也叫随机访问存储器（Random Access Memory，即 RAM）。内存的访问速度很快，但是价格相对较昂贵，因此一般的计算机内存空间都相对较小。</p>
<p>而磁盘是机械器件。磁盘访问数据时，需要等磁盘盘片旋转到磁头下，才能读取相应的数据。尽管磁盘的旋转速度很快，但是和内存的随机访问相比，性能差距非常大。一般来说，如果是随机读写，会有 10 万到 100 万倍左右的差距。但如果是顺序访问大批量数据的话，磁盘的性能和内存就是一个数量级的。</p>
<p>磁盘的最小读写单位是扇区，较早期的磁盘一个扇区是 <strong><code>512</code></strong> 字节。随着磁盘技术的发展，目前常见的磁盘扇区是 <strong><code>4K</code></strong> 个字节。操作系统一次会读写多个扇区，所以操作系统的最小读写单位是块（Block），也叫作簇（Cluster）。当我们要从磁盘中读取一个数据时，操作系统会一次性将整个块都读出来。因此，对于大批量的顺序读写来说，磁盘的效率会比随机读写高许多。</p>
<p>假设有一个有序数组存储在硬盘中，如果它足够大，那么它会存储在多个块中。当我们要对这个数组使用二分查找时，需要先找到中间元素所在的块，将这个块从磁盘中读到内存里，然后在内存中进行二分查找。如果下一步要读的元素在其他块中，则需要再将相应块从磁盘中读入内存。直到查询结束，这个过程可能会多次访问磁盘。我们可以看到，这样的检索性能非常低。</p>
<p>由于磁盘相对于内存而言访问速度实在太慢，因此，对于磁盘上数据的高效检索，我们有一个极其重要的原则：对磁盘的访问次数要尽可能的少！</p>
<p>将索引和数据分离就是一种常见的设计思路。在数据频繁变化的场景中，有序数组并不是一个最好的选择，二叉检索树或者哈希表往往更有普适性。但是，哈希表由于缺乏范围检索的能力，在一些场合也不适用。因此，二叉检索树这种树形结构是许多常见检索系统的实施方案。</p>
<p>随着索引数据越来越大，直到无法完全加载到内存中，这是需要将索引数据也存入磁盘中。B+ 树给出了将树形索引的所有节点都存在磁盘上的高效检索方案。操作系统对磁盘数据的访问是以块为单位的。因此，如果我们想将树型索引的一个节点从磁盘中读出，即使该节点的数据量很小（比如说只有几个字节），但磁盘依然会将整个块的数据全部读出来，而不是只读这一小部分数据，这会让有效读取效率很低。B+ 树的一个关键设计，就是让一个节点的大小等于一个块的大小。节点内存储的数据，不是一个元素，而是一个可以装 m 个元素的有序数组。这样一来，我们就可以将磁盘一次读取的数据全部利用起来，使得读取效率最大化。</p>
<p>B+ 树还有另一个设计，就是将所有的节点分为内部节点和叶子节点。内部节点仅存储 key 和维持树形结构的指针，并不存储 key 对应的数据（无论是具体数据还是文件位置信息）。这样内部节点就能存储更多的索引数据，我们也就可以使用最少的内部节点，将所有数据组织起来了。而叶子节点仅存储 key 和对应数据，不存储维持树形结构的指针。通过这样的设计，B+ 树就能做到节点的空间利用率最大化。此外，B+ 树还将同一层的所有节点串成了有序的双向链表，这样一来，B+ 树就同时具备了良好的范围查询能力和灵活调整的能力了。</p>
<p>因此，B+ 树是一棵完全平衡的 m 阶多叉树。所谓的 m 阶，指的是每个节点最多有 m 个子节点，并且每个节点里都存了一个紧凑的可包含 m 个元素的数组。</p>
<p>即使是复杂的 B+ 树，我们将它拆解开来，其实也是由简单的数组、链表和树组成的，而且 B+ 树的检索过程其实也是二分查找。因此，如果 B+ 树完全加载在内存中的话，它的检索效率其实并不会比有序数组或者二叉检索树更<br>高，也还是二分查找的 log(n) 的效率。并且，它还比数组和二叉检索树更加复杂，还会带来额外的开销。</p>
<p>另外，这一节还有一个很重要的设计思想需要你掌握，那就是将索引和数据分离。通过这样的方式，我们能将索引的数组大小保持在一个较小的范围内，让它能加载在内存中。在许多大规模系统中，都是使用这个设计思想来精简索引的。而且，B+ 树的内部节点和叶子节点的区分，其实也是索引和数据分离的一次实践。</p>
<p>MySQL 中的 B+ 树实现其实有两种，一种是 MyISAM 引擎，另一种是 InnoDB 引擎。它们的核心区别就在于，数据和索引是否是分离的。</p>
<p>在 MyISAM 引擎中，B+ 树的叶子节点仅存储了数据的位置指针，这是一种索引和数据分离的设计方案，叫作非聚集索引。如果要保证 MyISAM 的数据一致性，那我们需要在表级别上进行加锁处理。</p>
<p>在 InnoDB 中，B+ 树的叶子节点直接存储了具体数据，这是一种索引和数据一体的方案。叫作聚集索引。由于数据直接就存在索引的叶子节点中，因此 InnoDB 不需要给全表加锁来保证一致性，它只需要支持行级的锁就可以了。</p>
<h2 id="LSM-树检索"><a href="#LSM-树检索" class="headerlink" title="LSM 树检索"></a>LSM 树检索</h2><p>B+ 树的数据都存储在叶子节点中，而叶子节点一般都存储在磁盘中。因此，每次插入的新数据都需要随机写入磁盘，而随机写入的性能非常慢。如果是一个日志系统，每秒钟要写入上千条甚至上万条数据，这样的磁盘操作代价会使得系统性能急剧下降，甚至无法使用。</p>
<p>操作系统对磁盘的读写是以块为单位的，我们能否以块为单位写入，而不是每次插入一个数据都要随机写入磁盘呢？这样是不是就可以大幅度减少写入操作了呢？解决方案就是：<strong>LSM 树</strong>（Log Structured Merge Trees）。</p>
<p>LSM 树就是根据这个思路设计了这样一个机制：当数据写入时，延迟写磁盘，将数据先存放在内存中的树里，进行常规的存储和查询。当内存中的树持续变大达到阈值时，再批量地以块为单位写入磁盘的树中。因此，LSM 树至少需要由两棵树组成，一棵是存储在内存中较小的 C0 树，另一棵是存储在磁盘中较大的 C1 树。</p>
<p>LSM 树具有以下 3 个特点：</p>
<ol>
<li>将索引分为内存和磁盘两部分，并在内存达到阈值时启动树合并（Merge Trees）；</li>
<li>用批量写入代替随机写入，并且用预写日志 WAL 技术（Write AheadLog，预写日志技术）保证内存数据，在系统崩溃后可以被恢复；</li>
<li>数据采取类似日志追加写的方式写入（Log Structured）磁盘，以顺序写的方式提高写<br>入效率。</li>
</ol>
<p>LSM 树的这些特点，使得它相对于 B+ 树，在写入性能上有大幅提升。所以，许多 NoSQL 系统都使用 LSM 树作为检索引擎，而且还对 LSM 树进行了优化以提升检索性能。</p>
<h2 id="索引构建"><a href="#索引构建" class="headerlink" title="索引构建"></a>索引构建</h2><ul>
<li><strong>数据压缩</strong>：一个是尽可能地将数据加载到内存中，因为内存的检索效率大大高于磁盘。那为了将数据更多地加载到内存中，索引压缩是一个重要的研究方向。</li>
<li><strong>分支处理</strong>：另一个是将大数据集合拆成多个小数据集合来处理。这其实就是分布式系统的核心思想。</li>
</ul>
<h2 id="索引更新"><a href="#索引更新" class="headerlink" title="索引更新"></a>索引更新</h2><h3 id="Double-Buffer（双缓冲）机制"><a href="#Double-Buffer（双缓冲）机制" class="headerlink" title="Double Buffer（双缓冲）机制"></a>Double Buffer（双缓冲）机制</h3><p>就是在内存中同时保存两份一样的索引，一个是索引 A，一个是索引 B。两个索引保持一个读、一个写，并且来回切换，最终完成高性能的索引更新。</p>
<p>优点：简单高效</p>
<p>缺点：达到一定数据量级后，会带来翻倍的内存开销，甚至有些索引存储在磁盘上的情况下，更是无法使用此机制。</p>
<h3 id="全量索引和增量索引"><a href="#全量索引和增量索引" class="headerlink" title="全量索引和增量索引"></a>全量索引和增量索引</h3><p>将新接收到的数据单独建立一个可以存在内存中的倒排索引，也就是增量索引。当查询发生的时候，我们会同时查询全量索引和增量索引，将合并的结果作为总的结果输出。</p>
<p>因为增量索引相对全量索引而言会小很多，内存资源消耗在可承受范围，所以我们可以使用 Double Buffer 机制<br>对增量索引进行索引更新。这样一来，增量索引就可以做到无锁访问。而全量索引本身就是只读的，也不需要加锁。因此，整个检索过程都可以做到无锁访问，也就提高了系统的检索效率。</p>
<h3 id="如何处理增量索引空间的持续增长"><a href="#如何处理增量索引空间的持续增长" class="headerlink" title="如何处理增量索引空间的持续增长"></a>如何处理增量索引空间的持续增长</h3><h4 id="完全重建法"><a href="#完全重建法" class="headerlink" title="完全重建法"></a>完全重建法</h4><p>如果增量索引的增长速度不算很快，或者全量索引重建的代价不大，那么我们完全可以在增量索引写满内存空间之前，完全重建一次全量索引，然后将系统查询切换到新的全量索引上。</p>
<h4 id="再合并法"><a href="#再合并法" class="headerlink" title="再合并法"></a>再合并法</h4><p>直接归并全量索引和增量索引，生成一个新的全量索引，这也就避免了从头处理所有文档的重复开销。</p>
<h4 id="滚动合并法"><a href="#滚动合并法" class="headerlink" title="滚动合并法"></a>滚动合并法</h4><p>先生成多个不同层级的索引，然后逐层合并。</p>
<p>比如说，一个检索系统在磁盘中保存了全量索引、周级索引和天级索引。所谓周级索引，就<br>是根据本周的新数据生成的一份索引，那天级索引就是根据每天的新数据生成的一份索引。<br>在滚动合并法中，当内存中的增量索引增长到一定体量时，我们会用再合并法将它合并到磁<br>盘上当天的天级索引文件中。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220316134834.png" alt="img"></p>
<h2 id="索引拆分"><a href="#索引拆分" class="headerlink" title="索引拆分"></a>索引拆分</h2><p>水平拆分和垂直拆分</p>
<h2 id="TOP-K-检索"><a href="#TOP-K-检索" class="headerlink" title="TOP K 检索"></a>TOP K 检索</h2><h3 id="TF-IDF-算法"><a href="#TF-IDF-算法" class="headerlink" title="TF-IDF 算法"></a>TF-IDF 算法</h3><p>TF-IDF 算法的公式是：相关性 &#x3D; TF*IDF。其中，TF 是词频（Term Frequency），IDF 是逆文档频率（Inverse Document Frequency）。</p>
<ul>
<li><strong>词频</strong>定义的就是一个词项在文档中出现的次数。换一句话说就是，如果一个词项出现了越多次，那这个词在文档中就越重要。</li>
<li><strong>文档频率</strong>（Document Frequency），指的是这个词项出现在了多少个文档中。你也可以理解为，如果一个词出现在越多的文档中，那这个词就越普遍，越没有区分度。一个极端的例子，比如“的”字，它基本上在每个文档中都会出现，所以它的区分度就非常低。</li>
<li>逆文档频率是对文档频率取倒数，它的值越大，这个词的的区分度就越大。</li>
</ul>
<h3 id="BM25-算法"><a href="#BM25-算法" class="headerlink" title="BM25 算法"></a>BM25 算法</h3><p>BM25 算法的一个重要的设计思想是，它认为词频和相关性的关系并不是线性的。也就是说，随着词频的增加，相关性的增加会越来越不明显，并且还会有一个阈值上限。当词频达到阈值以后，那相关性就不会再增长了。</p>
<p>总结来说，BM25 算法就是一个对查询词和文档的相关性进行打分的概率模型算法。BM25 算法考虑了四个因子，分别为 IDF、文档长度、文档中的词频以及查询词中的词频。并且，公式中还加入了 3 个可以人工调整大小的参数，分别是 ：k1、k2 和 b。</p>
<h3 id="机器学习打分"><a href="#机器学习打分" class="headerlink" title="机器学习打分"></a>机器学习打分</h3><p>机器学习可以更大规模地引入更多的打分因子，并且可以自动学习出各个打分因子的权重。所以，利用机器学习进行相关性打分，已经成了目前大规模检索引擎的标配。</p>
<h3 id="根据打分结果快速-TOP-K-检索"><a href="#根据打分结果快速-TOP-K-检索" class="headerlink" title="根据打分结果快速 TOP K 检索"></a>根据打分结果快速 TOP K 检索</h3><p>完成打分阶段之后，排序阶段我们要重视排序的效率。对于精准 Top K 检索，我们可以使用堆排序来代替全排序，只返回我们认为最重要的 k 个结果。这样，时间代价就是 O(n) + O(k log n) ，在数据量级非常大的情况下，它比 O(n log n) 的检索性能会高得多。</p>
<h2 id="非精准-TOP-K-检索"><a href="#非精准-TOP-K-检索" class="headerlink" title="非精准 TOP K 检索"></a>非精准 TOP K 检索</h2><p>高质量的检索结果并不一定要非常精准，我们只需要保证质量足够高的结果，被包含在最终的 Top K 个结果中就够了。这就是非精准 Top K 检索的思路。</p>
<h2 id="空间检索"><a href="#空间检索" class="headerlink" title="空间检索"></a>空间检索</h2><p>通过将二维空间在水平和垂直方向上不停二分，可以生成一维的区域编码，然后我们可以使用一维空间的检索技术对区域编码做好索引。</p>
<p>在需要动态调整查询范围的场景下，对于二进制编码的二维空间的最近邻检索问题，我们可以通过四叉树来完成。四叉树可以很好地快速划分查询空间，并通过递归的方式高效地扩大查询范围。但是满四叉树经常会造成无谓的空间浪费，为了避免这个问题，在实际应用的时候，我们会选择使用非满四叉树来存储和索引编码。对于 GeoHash 编码的二维空间最近邻检索问题，我们也能通过类似的前缀树来提高检索效率。</p>
<h2 id="最近邻检索"><a href="#最近邻检索" class="headerlink" title="最近邻检索"></a>最近邻检索</h2><p>如何计算两篇文章的相似性</p>
<p>最常见的方式就是使用向量空间模型（Vector Space Model）。所谓向量空间模型，就是将所有文档中出现过的所有关键词都提取出来。如果一共有 n 个关键词，那每个关键词就是一个维度，这就组成了一个 n 维的向量空间。</p>
<h2 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h2><p>LevelDB 是由 Google 开源的存储系统。</p>
<p>LevelDB 是基于 LSM 树优化而来的存储系统。LSM 树会将索引分为内存和磁盘两部分，并在内存达到阈值时启动树合并。但是，这里面存在着大量的细节问题。</p>
<h3 id="数据在内存中如何高效检索？"><a href="#数据在内存中如何高效检索？" class="headerlink" title="数据在内存中如何高效检索？"></a>数据在内存中如何高效检索？</h3><p>首先，对内存中索引的高效检索，我们可以用很多检索技术，如红黑树、跳表等，这些数据结构会比 B+ 树更高效。LevelDB 对于 LSM 树的第一个改进，就是使用跳表代替 B+ 树来实现内存中的 C0 树。</p>
<h3 id="数据是如何高效地从内存转移到磁盘的？"><a href="#数据是如何高效地从内存转移到磁盘的？" class="headerlink" title="数据是如何高效地从内存转移到磁盘的？"></a>数据是如何高效地从内存转移到磁盘的？</h3><p>LevelDB 做了读写分离的设计。它将内存中的数据分为两块，一块叫作 MemTable，它是可读可写的。另一块叫作 Immutable MemTable，它是只读的。这两块数据的数据结构完全一样，都是跳表。</p>
<p>当 MemTable 的存储数据达到上限时，我们直接将它切换为只读的 Immutable MemTable，然后重新生成一个新的 MemTable，来支持新数据的写入和查询。这时，将内存索引存储到磁盘的问题，就变成了将 Immutable MemTable 写入磁盘的问题。而且，由于 Immutable MemTable 是只读的，因此，它不需要加锁就可以高效<br>地写入磁盘中。</p>
<h3 id="数据如何合并"><a href="#数据如何合并" class="headerlink" title="数据如何合并"></a>数据如何合并</h3><p>在原始 LSM 树的设计中，内存索引写入磁盘时是直接和磁盘中的 C1 树进行归并的。但如果工程中也这么<br>实现的话，会有两个很严重的问题：</p>
<ul>
<li>合并代价很高，因为 C1 树很大，而 C0 树很小，这会导致它们在合并时产生大量的磁盘 IO；</li>
<li>合并频率会很频繁，由于 C0 树很小，很容易被写满，因此系统会频繁进行 C0 树和 C1 树的合并，这样频繁合并会带来的大量磁盘 IO，这更是系统无法承受的。</li>
</ul>
<p>LevelDB 采用了延迟合并的设计来优化。具体来说就是，先将 Immutable MemTable 顺序快速写入磁盘，直接变成一个个 SSTable（Sorted String Table）文件，之后再对这些 SSTable 文件进行合并。这样就避免了 C0 树和 C1 树昂贵的 合并代价。</p>
<p>而在管理多个 SSTable 文件的环节，LevelDB 使用分层和滚动合并的设计来组织多个 SSTable 文件，避免了 C0 树和 C1 树的合并带来的大量数据被复制的问题。</p>
<h3 id="数据如何检索"><a href="#数据如何检索" class="headerlink" title="数据如何检索"></a>数据如何检索</h3><p>先在 MemTable 中查找，如果查找不到再去 Immutable MemTable 中查找。如果 Immutable MemTable 也查询不到，才会到磁盘中去查找。</p>
<p>在磁盘中检索数据的环节，因为 SSTable 文件是有序的，所以我们通过多层二分查找的方式，就能快速定位到需要查询的 SSTable 文件。接着，在 SSTable 文件内查找元素时，LevelDB 先是使用索引与数据分离的设计，减少磁盘 IO，又使用 BloomFilter 和二分查找来完成检索加速。加速检索的过程中，LevelDB 又使用缓存技术，将会被反复读取的数据缓存在内存中，从而避免了磁盘开销。</p>
<h2 id="搜索系统"><a href="#搜索系统" class="headerlink" title="搜索系统"></a>搜索系统</h2><p>搜索流程：</p>
<ul>
<li>先对查询内容分词，搜索引擎还会纠错和相似推荐，得到检索词</li>
<li>根据检索词在倒排索引中进行短语检索。然后，根据相关性打分，将得分高的结果保留。</li>
</ul>
<h2 id="广告系统"><a href="#广告系统" class="headerlink" title="广告系统"></a>广告系统</h2><p>广告引擎处理一个广告请求的过程，本质上就是根据用户的广告请求信息，找出标签匹配的广告设置，并将广告进行排序返回的过程。</p>
<ul>
<li>在标签检索引擎中，我们通过合理地将标签使用在树形检索 + 倒排索引 + 结果过滤这三个环节，来提高检索效率。</li>
<li>在向量检索引擎中，我们可以使用聚类 + 倒排索引 + 乘积量化的技术来加速检索。</li>
<li>在打分排序环节，增加一个非精准打分环节，这样我们就可以大幅降低使用深度学习模型带来的开销。</li>
<li>在索引构建环节，我们还可以将一些过滤条件前置，仅将当前有效的广告设置加入索引，然后通过全量索引 + 增量索引的更新方式，来保证过滤逻辑的有效。</li>
</ul>
<h2 id="推荐引擎"><a href="#推荐引擎" class="headerlink" title="推荐引擎"></a>推荐引擎</h2><p>相比于搜索引擎和广告引擎，推荐引擎具有更灵活的检索能力，也就是可以使用更灵活的检索技术，来进行文章的召回服务。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100048401">检索技术核心 20 讲</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/9a2546/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/9a2546/" class="post-title-link" itemprop="url">Elasticsearch 集群和分片</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-01 20:52:25" itemprop="dateCreated datePublished" datetime="2022-03-01T20:52:25+08:00">2022-03-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">搜索引擎数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/Elasticsearch/" itemprop="url" rel="index"><span itemprop="name">Elasticsearch</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>13k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>12 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Elasticsearch-集群和分片"><a href="#Elasticsearch-集群和分片" class="headerlink" title="Elasticsearch 集群和分片"></a>Elasticsearch 集群和分片</h1><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><h3 id="空集群"><a href="#空集群" class="headerlink" title="空集群"></a>空集群</h3><p>如果我们启动了一个单独的节点，里面不包含任何的数据和索引，那我们的集群看起来就是一个包含空内容节点的集群。</p>
<p><strong>Figure 1. 包含空内容节点的集群</strong></p>
<p><img src="https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_0201.png" alt="包含空内容节点的集群"></p>
<p>图 1：只有一个空节点的集群</p>
<p>一个运行中的 Elasticsearch 实例称为一个<strong>节点</strong>，而<strong>集群</strong>是由一个或者多个拥有相同 <code>cluster.name</code> 配置的节点组成， 它们共同承担数据和负载的压力。当有节点加入集群中或者从集群中移除节点时，集群将会重新平均分布所有的数据。</p>
<p>当一个节点被选举成为<strong>主节点</strong>时， 它将负责管理集群范围内的<strong>所有变更</strong>，例如增加、删除索引，或者增加、删除节点等。 而主节点并不需要涉及到文档级别的变更和搜索等操作，所以当集群只拥有一个主节点的情况下，即使流量的增加它也不会成为瓶颈。 任何节点都可以成为主节点。我们的示例集群就只有一个节点，所以它同时也成为了主节点。</p>
<p>作为用户，我们可以将请求发送到集群中的任何节点，包括主节点。 每个节点都知道任意文档所处的位置，并且能够将我们的请求直接转发到存储我们所需文档的节点。 无论我们将请求发送到哪个节点，它都能负责从各个包含我们所需文档的节点收集回数据，并将最终结果返回給客户端。 Elasticsearch 对这一切的管理都是透明的。</p>
<h3 id="集群健康"><a href="#集群健康" class="headerlink" title="集群健康"></a>集群健康</h3><p>Elasticsearch 的集群监控信息中包含了许多的统计数据，其中最为重要的一项就是 <em>集群健康</em> ， 它在 <code>status</code> 字段中展示为 <code>green</code> 、 <code>yellow</code> 或者 <code>red</code> 。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /_cluster/health</span><br></pre></td></tr></table></figure>

<p>在一个不包含任何索引的空集群中，它将会有一个类似于如下所示的返回内容：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;cluster_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;elasticsearch&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;green&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;number_of_nodes&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;number_of_data_nodes&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;active_primary_shards&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;active_shards&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;relocating_shards&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;initializing_shards&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;unassigned_shards&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>status</code> 字段指示着当前集群在总体上是否工作正常。它的三种颜色含义如下：</p>
<ul>
<li>**<code>green</code>**：所有的主分片和副本分片都正常运行。</li>
<li>**<code>yellow</code>**：所有的主分片都正常运行，但不是所有的副本分片都正常运行。</li>
<li>**<code>red</code>**：有主分片没能正常运行。</li>
</ul>
<h3 id="添加索引"><a href="#添加索引" class="headerlink" title="添加索引"></a>添加索引</h3><p>我们往 Elasticsearch 添加数据时需要用到 <em>索引</em> —— 保存相关数据的地方。索引实际上是指向一个或者多个物理分片的逻辑命名空间 。</p>
<p>一个 <em>分片</em> 是一个底层的 <em>工作单元</em> ，它仅保存了全部数据中的一部分。现在我们只需知道一个分片是一个 Lucene 的实例，以及它本身就是一个完整的搜索引擎。 我们的文档被存储和索引到分片内，但是应用程序是直接与索引而不是与分片进行交互。</p>
<p>Elasticsearch 是利用分片将数据分发到集群内各处的。分片是数据的容器，文档保存在分片内，分片又被分配到集群内的各个节点里。 当你的集群规模扩大或者缩小时， Elasticsearch 会自动的在各节点中迁移分片，使得数据仍然均匀分布在集群里。</p>
<p>一个分片可以是 <em>主</em> 分片或者 <em>副本</em> 分片。 索引内任意一个文档都归属于一个主分片，所以主分片的数目决定着索引能够保存的最大数据量。</p>
<blockquote>
<p>技术上来说，一个主分片最大能够存储 <code>Integer.MAX_VALUE - 128</code> 个文档，但是实际最大值还需要参考你的使用场景：包括你使用的硬件， 文档的大小和复杂程度，索引和查询文档的方式以及你期望的响应时长。</p>
</blockquote>
<p>一个副本分片只是一个主分片的拷贝。副本分片作为硬件故障时保护数据不丢失的冗余备份，并为搜索和返回文档等读操作提供服务。</p>
<p>在索引建立的时候就已经确定了主分片数，但是副本分片数可以随时修改。</p>
<p>让我们在包含一个空节点的集群内创建名为 <code>blogs</code> 的索引。 索引在默认情况下会被分配 5 个主分片， 但是为了演示目的，我们将分配 3 个主分片和一份副本（每个主分片拥有一个副本分片）：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PUT /blogs</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">   <span class="attr">&quot;settings&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;number_of_shards&quot;</span> <span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;number_of_replicas&quot;</span> <span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">   <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>我们的集群现在是 _拥有一个索引的单节点集群_。所有 3 个主分片都被分配在 <code>Node 1</code> 。</p>
<p><strong>Figure 2. 拥有一个索引的单节点集群</strong></p>
<p><img src="https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_0202.png" alt="拥有一个索引的单节点集群"></p>
<p>如果我们现在查看集群健康，我们将看到如下内容：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;cluster_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;elasticsearch&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;yellow&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;number_of_nodes&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;number_of_data_nodes&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;active_primary_shards&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;active_shards&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;relocating_shards&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;initializing_shards&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;unassigned_shards&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;delayed_unassigned_shards&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;number_of_pending_tasks&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;number_of_in_flight_fetch&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;task_max_waiting_in_queue_millis&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;active_shards_percent_as_number&quot;</span><span class="punctuation">:</span> <span class="number">50</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>集群 status 值为 yellow</li>
<li>没有被分配到任何节点的副本数</li>
</ul>
<p>集群的健康状况为 <code>yellow</code> 则表示全部 <em>主</em> 分片都正常运行（集群可以正常服务所有请求），但是 <em>副本</em> 分片没有全部处在正常状态。 实际上，所有 3 个副本分片都是 <code>unassigned</code> —— 它们都没有被分配到任何节点。 在同一个节点上既保存原始数据又保存副本是没有意义的，因为一旦失去了那个节点，我们也将丢失该节点上的所有副本数据。</p>
<p>当前我们的集群是正常运行的，但是在硬件故障时有丢失数据的风险。</p>
<h3 id="添加故障转移"><a href="#添加故障转移" class="headerlink" title="添加故障转移"></a>添加故障转移</h3><p>当集群中只有一个节点在运行时，意味着会有一个单点故障问题——没有冗余。 幸运的是，我们只需再启动一个节点即可防止数据丢失。</p>
<blockquote>
<p>为了测试第二个节点启动后的情况，你可以在同一个目录内，完全依照启动第一个节点的方式来启动一个新节点（参考安装并运行 Elasticsearch）。多个节点可以共享同一个目录。</p>
<p>当你在同一台机器上启动了第二个节点时，只要它和第一个节点有同样的 cluster.name 配置，它就会自动发现集群并加入到其中。 但是在不同机器上启动节点的时候，为了加入到同一集群，你需要配置一个可连接到的单播主机列表。</p>
</blockquote>
<p>如果启动了第二个节点，我们的集群将会拥有两个节点的集群——所有主分片和副本分片都已被分配。</p>
<p><strong>Figure 3. 拥有两个节点的集群——所有主分片和副本分片都已被分配</strong></p>
<p><img src="https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_0203.png" alt="拥有两个节点的集群"></p>
<p>当第二个节点加入到集群后，3 个 <em>副本分片</em> 将会分配到这个节点上——每个主分片对应一个副本分片。 这意味着当集群内任何一个节点出现问题时，我们的数据都完好无损。</p>
<p>所有新近被索引的文档都将会保存在主分片上，然后被并行的复制到对应的副本分片上。这就保证了我们既可以从主分片又可以从副本分片上获得文档。</p>
<p><code>cluster-health</code> 现在展示的状态为 <code>green</code> ，这表示所有 6 个分片（包括 3 个主分片和 3 个副本分片）都在正常运行。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;cluster_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;elasticsearch&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;green&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;number_of_nodes&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;number_of_data_nodes&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;active_primary_shards&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;active_shards&quot;</span><span class="punctuation">:</span> <span class="number">6</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;relocating_shards&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;initializing_shards&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;unassigned_shards&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;delayed_unassigned_shards&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;number_of_pending_tasks&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;number_of_in_flight_fetch&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;task_max_waiting_in_queue_millis&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;active_shards_percent_as_number&quot;</span><span class="punctuation">:</span> <span class="number">100</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>集群 <code>status</code> 值为 <code>green</code></li>
</ul>
<p>我们的集群现在不仅仅是正常运行的，并且还处于 <em>始终可用</em> 的状态。</p>
<h3 id="水平扩容"><a href="#水平扩容" class="headerlink" title="水平扩容"></a>水平扩容</h3><p>怎样为我们的正在增长中的应用程序按需扩容呢？ 当启动了第三个节点，我们的集群将拥有三个节点的集群——为了分散负载而对分片进行重新分配。</p>
<p><strong>Figure 4. 拥有三个节点的集群——为了分散负载而对分片进行重新分配</strong></p>
<p><img src="https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_0204.png" alt="拥有三个节点的集群"></p>
<p><code>Node 1</code> 和 <code>Node 2</code> 上各有一个分片被迁移到了新的 <code>Node 3</code> 节点，现在每个节点上都拥有 2 个分片，而不是之前的 3 个。 这表示每个节点的硬件资源（CPU, RAM, I&#x2F;O）将被更少的分片所共享，每个分片的性能将会得到提升。</p>
<p>分片是一个功能完整的搜索引擎，它拥有使用一个节点上的所有资源的能力。 我们这个拥有 6 个分片（3 个主分片和 3 个副本分片）的索引可以最大扩容到 6 个节点，每个节点上存在一个分片，并且每个分片拥有所在节点的全部资源。</p>
<h3 id="更多的扩容"><a href="#更多的扩容" class="headerlink" title="更多的扩容"></a>更多的扩容</h3><p>但是如果我们想要扩容超过 6 个节点怎么办呢？</p>
<p>主分片的数目在索引创建时就已经确定了下来。实际上，这个数目定义了这个索引能够 <em>存储</em> 的最大数据量。（实际大小取决于你的数据、硬件和使用场景。） 但是，读操作——搜索和返回数据——可以同时被主分片 <em>或</em> 副本分片所处理，所以当你拥有越多的副本分片时，也将拥有越高的吞吐量。</p>
<p>在运行中的集群上是可以动态调整副本分片数目的，我们可以按需伸缩集群。让我们把副本数从默认的 <code>1</code> 增加到 <code>2</code> ：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUT /blogs/_settings</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">   <span class="attr">&quot;number_of_replicas&quot;</span> <span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>blogs</code> 索引现在拥有 9 个分片：3 个主分片和 6 个副本分片。 这意味着我们可以将集群扩容到 9 个节点，每个节点上一个分片。相比原来 3 个节点时，集群搜索性能可以提升 <em>3</em> 倍。</p>
<p><strong>Figure 5. 将参数 <code>number_of_replicas</code> 调大到 2</strong></p>
<p><img src="https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_0205.png" alt="拥有2份副本分片3个节点的集群"></p>
<blockquote>
<p>当然，如果只是在相同节点数目的集群上增加更多的副本分片并不能提高性能，因为每个分片从节点上获得的资源会变少。 你需要增加更多的硬件资源来提升吞吐量。</p>
<p>但是更多的副本分片数提高了数据冗余量：按照上面的节点配置，我们可以在失去 2 个节点的情况下不丢失任何数据。</p>
</blockquote>
<h3 id="应对故障"><a href="#应对故障" class="headerlink" title="应对故障"></a>应对故障</h3><p>我们之前说过 Elasticsearch 可以应对节点故障，接下来让我们尝试下这个功能。 如果我们关闭第一个节点，这时集群的状态为关闭了一个节点后的集群。</p>
<p><strong>Figure 6. 关闭了一个节点后的集群</strong></p>
<p><img src="https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_0206.png" alt="关闭了一个节点后的集群"></p>
<p>我们关闭的节点是一个主节点。而集群必须拥有一个主节点来保证正常工作，所以发生的第一件事情就是选举一个新的主节点： <code>Node 2</code> 。</p>
<p>在我们关闭 <code>Node 1</code> 的同时也失去了主分片 <code>1</code> 和 <code>2</code> ，并且在缺失主分片的时候索引也不能正常工作。 如果此时来检查集群的状况，我们看到的状态将会为 <code>red</code> ：不是所有主分片都在正常工作。</p>
<p>幸运的是，在其它节点上存在着这两个主分片的完整副本， 所以新的主节点立即将这些分片在 <code>Node 2</code> 和 <code>Node 3</code> 上对应的副本分片提升为主分片， 此时集群的状态将会为 <code>yellow</code> 。 这个提升主分片的过程是瞬间发生的，如同按下一个开关一般。</p>
<p>为什么我们集群状态是 <code>yellow</code> 而不是 <code>green</code> 呢？ 虽然我们拥有所有的三个主分片，但是同时设置了每个主分片需要对应 2 份副本分片，而此时只存在一份副本分片。 所以集群不能为 <code>green</code> 的状态，不过我们不必过于担心：如果我们同样关闭了 <code>Node 2</code> ，我们的程序 <em>依然</em> 可以保持在不丢任何数据的情况下运行，因为 <code>Node 3</code> 为每一个分片都保留着一份副本。</p>
<p>如果我们重新启动 <code>Node 1</code> ，集群可以将缺失的副本分片再次进行分配，那么集群的状态也将如 Figure 5. 将参数 <code>number_of_replicas</code> 调大到 2 所示。 如果 <code>Node 1</code> 依然拥有着之前的分片，它将尝试去重用它们，同时仅从主分片复制发生了修改的数据文件。</p>
<p>到目前为止，你应该对分片如何使得 Elasticsearch 进行水平扩容以及数据保障等知识有了一定了解。 接下来我们将讲述关于分片生命周期的更多细节。</p>
<h2 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h2><blockquote>
<ul>
<li>为什么搜索是 <em>近</em> 实时的？</li>
<li>为什么文档的 CRUD (创建-读取-更新-删除) 操作是 <em>实时</em> 的?</li>
<li>Elasticsearch 是怎样保证更新被持久化在断电时也不丢失数据?</li>
<li>为什么删除文档不会立刻释放空间？</li>
<li><code>refresh</code>, <code>flush</code>, 和 <code>optimize</code> API 都做了什么, 你什么情况下应该使用他们？</li>
</ul>
</blockquote>
<h3 id="使文本可被搜索"><a href="#使文本可被搜索" class="headerlink" title="使文本可被搜索"></a>使文本可被搜索</h3><p>必须解决的第一个挑战是如何使文本可被搜索。 传统的数据库每个字段存储单个值，但这对全文检索并不够。文本字段中的每个单词需要被搜索，对数据库意味着需要单个字段有索引多值(这里指单词)的能力。</p>
<p>最好的支持 <em>一个字段多个值</em> 需求的数据结构是我们在 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/inverted-index.html">倒排索引</a> 章节中介绍过的 <em>倒排索引</em> 。 倒排索引包含一个有序列表，列表包含所有文档出现过的不重复个体，或称为 <em>词项</em> ，对于每一个词项，包含了它所有曾出现过文档的列表。</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Term  |<span class="string"> Doc 1 </span>|<span class="string"> Doc 2 </span>|<span class="string"> Doc 3 </span>|<span class="string"> ...</span></span><br><span class="line"><span class="string">------------------------------------</span></span><br><span class="line"><span class="string">brown </span>|<span class="string">   X   </span>|<span class="string">       </span>|<span class="string">  X    </span>|<span class="string"> ...</span></span><br><span class="line"><span class="string">fox   </span>|<span class="string">   X   </span>|<span class="string">   X   </span>|<span class="string">  X    </span>|<span class="string"> ...</span></span><br><span class="line"><span class="string">quick </span>|<span class="string">   X   </span>|<span class="string">   X   </span>|<span class="string">       </span>|<span class="string"> ...</span></span><br><span class="line"><span class="string">the   </span>|<span class="string">   X   </span>|<span class="string">       </span>|<span class="string">  X    </span>|<span class="string"> ...</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>当讨论倒排索引时，我们会谈到 <em>文档</em> 标引，因为历史原因，倒排索引被用来对整个非结构化文本文档进行标引。 Elasticsearch 中的 <em>文档</em> 是有字段和值的结构化 JSON 文档。事实上，在 JSON 文档中， 每个被索引的字段都有自己的倒排索引。</p>
</blockquote>
<p>这个倒排索引相比特定词项出现过的文档列表，会包含更多其它信息。它会保存每一个词项出现过的文档总数， 在对应的文档中一个具体词项出现的总次数，词项在文档中的顺序，每个文档的长度，所有文档的平均长度，等等。这些统计信息允许 Elasticsearch 决定哪些词比其它词更重要，哪些文档比其它文档更重要，这些内容在 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/relevance-intro.html">什么是相关性?</a> 中有描述。</p>
<p>为了能够实现预期功能，倒排索引需要知道集合中的 <em>所有</em> 文档，这是需要认识到的关键问题。</p>
<p>早期的全文检索会为整个文档集合建立一个很大的倒排索引并将其写入到磁盘。 一旦新的索引就绪，旧的就会被其替换，这样最近的变化便可以被检索到。</p>
<h3 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h3><p>倒排索引被写入磁盘后是 <em>不可改变</em> 的:它永远不会修改。 不变性有重要的价值：</p>
<ul>
<li>不需要锁。如果你从来不更新索引，你就不需要担心多进程同时修改数据的问题。</li>
<li>一旦索引被读入内核的文件系统缓存，便会留在哪里，由于其不变性。只要文件系统缓存中还有足够的空间，那么大部分读请求会直接请求内存，而不会命中磁盘。这提供了很大的性能提升。</li>
<li>其它缓存(像 filter 缓存)，在索引的生命周期内始终有效。它们不需要在每次数据改变时被重建，因为数据不会变化。</li>
<li>写入单个大的倒排索引允许数据被压缩，减少磁盘 I&#x2F;O 和 需要被缓存到内存的索引的使用量。</li>
</ul>
<p>当然，一个不变的索引也有不好的地方。主要事实是它是不可变的! 你不能修改它。如果你需要让一个新的文档 可被搜索，你需要重建整个索引。这要么对一个索引所能包含的数据量造成了很大的限制，要么对索引可被更新的频率造成了很大的限制。</p>
<h3 id="动态更新索引"><a href="#动态更新索引" class="headerlink" title="动态更新索引"></a>动态更新索引</h3><p>下一个需要被解决的问题是怎样在保留不变性的前提下实现倒排索引的更新？答案是: 用更多的索引。</p>
<p>通过增加新的补充索引来反映新近的修改，而不是直接重写整个倒排索引。每一个倒排索引都会被轮流查询到—从最早的开始—查询完后再对结果进行合并。</p>
<p>Elasticsearch 基于 Lucene, 这个 java 库引入了 按段搜索 的概念。 每一 段 本身都是一个倒排索引， 但 索引 在 Lucene 中除表示所有 段 的集合外， 还增加了 提交点 的概念 — 一个列出了所有已知段的文件，就像在 Figure 16, “一个 Lucene 索引包含一个提交点和三个段” 中描绘的那样。 如 Figure 17, “一个在内存缓存中包含新文档的 Lucene 索引” 所示，新的文档首先被添加到内存索引缓存中，然后写入到一个基于磁盘的段，如 Figure 18, “在一次提交后，一个新的段被添加到提交点而且缓存被清空。” 所示。</p>
<p><strong>Figure 16. 一个 Lucene 索引包含一个提交点和三个段</strong></p>
<p><img src="https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_1101.png" alt="A Lucene index with a commit point and three segments"></p>
<blockquote>
<p>被混淆的概念是，一个 <em>Lucene 索引</em> 我们在 Elasticsearch 称作 <em>分片</em> 。 一个 Elasticsearch <em>索引</em> 是分片的集合。 当 Elasticsearch 在索引中搜索的时候， 他发送查询到每一个属于索引的分片(Lucene 索引)，然后像 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/distributed-search.html"><em>执行分布式检索</em></a> 提到的那样，合并每个分片的结果到一个全局的结果集。</p>
</blockquote>
<p>逐段搜索会以如下流程进行工作：</p>
<ol>
<li>新文档被收集到内存索引缓存， 见 Figure 17, “一个在内存缓存中包含新文档的 Lucene 索引” 。</li>
<li>不时地, 缓存被 <em>提交</em> ：<ul>
<li>一个新的段—一个追加的倒排索引—被写入磁盘。</li>
<li>一个新的包含新段名字的 <em>提交点</em> 被写入磁盘。</li>
<li>磁盘进行 <em>同步</em> — 所有在文件系统缓存中等待的写入都刷新到磁盘，以确保它们被写入物理文件。</li>
</ul>
</li>
<li>新的段被开启，让它包含的文档可见以被搜索。</li>
<li>内存缓存被清空，等待接收新的文档。</li>
</ol>
<p><strong>Figure 17. 一个在内存缓存中包含新文档的 Lucene 索引</strong></p>
<p><img src="https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_1102.png" alt="A Lucene index with new documents in the in-memory buffer, ready to commit"></p>
<p><strong>Figure 18. 在一次提交后，一个新的段被添加到提交点而且缓存被清空。</strong></p>
<p><img src="https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_1103.png" alt="After a commit, a new segment is added to the index and the buffer is cleared"></p>
<p>当一个查询被触发，所有已知的段按顺序被查询。词项统计会对所有段的结果进行聚合，以保证每个词和每个文档的关联都被准确计算。 这种方式可以用相对较低的成本将新文档添加到索引。</p>
<h3 id="删除和更新"><a href="#删除和更新" class="headerlink" title="删除和更新"></a>删除和更新</h3><p>段是不可改变的，所以既不能从把文档从旧的段中移除，也不能修改旧的段来进行反映文档的更新。 取而代之的是，每个提交点会包含一个 <code>.del</code> 文件，文件中会列出这些被删除文档的段信息。</p>
<p>当一个文档被 “删除” 时，它实际上只是在 <code>.del</code> 文件中被 <em>标记</em> 删除。一个被标记删除的文档仍然可以被查询匹配到， 但它会在最终结果被返回前从结果集中移除。</p>
<p>文档更新也是类似的操作方式：当一个文档被更新时，旧版本文档被标记删除，文档的新版本被索引到一个新的段中。 可能两个版本的文档都会被一个查询匹配到，但被删除的那个旧版本文档在结果集返回前就已经被移除。</p>
<p>在 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/merge-process.html">段合并</a> , 我们展示了一个被删除的文档是怎样被文件系统移除的。</p>
<h3 id="近实时搜索"><a href="#近实时搜索" class="headerlink" title="近实时搜索"></a>近实时搜索</h3><p>随着按段（per-segment）搜索的发展，一个新的文档从索引到可被搜索的延迟显著降低了。新文档在几分钟之内即可被检索，但这样还是不够快。</p>
<p>磁盘在这里成为了瓶颈。提交（Commiting）一个新的段到磁盘需要一个 <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Fsync"><code>fsync</code></a> 来确保段被物理性地写入磁盘，这样在断电的时候就不会丢失数据。 但是 <code>fsync</code> 操作代价很大; 如果每次索引一个文档都去执行一次的话会造成很大的性能问题。</p>
<p>我们需要的是一个更轻量的方式来使一个文档可被搜索，这意味着 <code>fsync</code> 要从整个过程中被移除。</p>
<p>在 Elasticsearch 和磁盘之间是文件系统缓存。 像之前描述的一样， 在内存索引缓冲区（ <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/near-real-time.html#img-pre-refresh">Figure 19, “在内存缓冲区中包含了新文档的 Lucene 索引”</a> ）中的文档会被写入到一个新的段中（ <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/near-real-time.html#img-post-refresh">Figure 20, “缓冲区的内容已经被写入一个可被搜索的段中，但还没有进行提交”</a> ）。 但是这里新段会被先写入到文件系统缓存—这一步代价会比较低，稍后再被刷新到磁盘—这一步代价比较高。不过只要文件已经在缓存中， 就可以像其它文件一样被打开和读取了。</p>
<p><strong>Figure 19. 在内存缓冲区中包含了新文档的 Lucene 索引</strong></p>
<p><img src="https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_1104.png" alt="A Lucene index with new documents in the in-memory buffer"></p>
<p>Lucene 允许新段被写入和打开—使其包含的文档在未进行一次完整提交时便对搜索可见。 这种方式比进行一次提交代价要小得多，并且在不影响性能的前提下可以被频繁地执行。</p>
<p><strong>Figure 20. 缓冲区的内容已经被写入一个可被搜索的段中，但还没有进行提交</strong></p>
<p><img src="https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_1105.png" alt="The buffer contents have been written to a segment, which is searchable, but is not yet commited"></p>
<h3 id="refresh-API"><a href="#refresh-API" class="headerlink" title="refresh API"></a>refresh API</h3><p>在 Elasticsearch 中，写入和打开一个新段的轻量的过程叫做 <em>refresh</em> 。 默认情况下每个分片会每秒自动刷新一次。这就是为什么我们说 Elasticsearch 是 <em>近</em> 实时搜索: 文档的变化并不是立即对搜索可见，但会在一秒之内变为可见。</p>
<p>这些行为可能会对新用户造成困惑: 他们索引了一个文档然后尝试搜索它，但却没有搜到。这个问题的解决办法是用 <code>refresh</code> API 执行一次手动刷新:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST /_refresh</span><br><span class="line">POST /blogs/_refresh</span><br></pre></td></tr></table></figure>

<p>刷新（Refresh）所有的索引</p>
<p>只刷新（Refresh） blogs 索引</p>
<blockquote>
<p>尽管刷新是比提交轻量很多的操作，它还是会有性能开销。当写测试的时候， 手动刷新很有用，但是不要在生产环境下每次索引一个文档都去手动刷新。 相反，你的应用需要意识到 Elasticsearch 的近实时的性质，并接受它的不足。</p>
</blockquote>
<p>并不是所有的情况都需要每秒刷新。可能你正在使用 Elasticsearch 索引大量的日志文件， 你可能想优化索引速度而不是近实时搜索， 可以通过设置 <code>refresh_interval</code> ， 降低每个索引的刷新频率：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_logs</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;refresh_interval&quot;</span><span class="punctuation">:</span> <span class="string">&quot;30s&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>每 30 秒刷新 <code>my_logs</code> 索引。</p>
</blockquote>
<p><code>refresh_interval</code> 可以在既存索引上进行动态更新。 在生产环境中，当你正在建立一个大的新索引时，可以先关闭自动刷新，待开始使用该索引时，再把它们调回来：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT <span class="regexp">/my_logs/</span>_settings</span><br><span class="line">&#123; <span class="string">&quot;refresh_interval&quot;</span>: -<span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line">PUT <span class="regexp">/my_logs/</span>_settings</span><br><span class="line">&#123; <span class="string">&quot;refresh_interval&quot;</span>: <span class="string">&quot;1s&quot;</span> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>关闭自动刷新。</p>
</li>
<li><p>每秒自动刷新。</p>
</li>
</ul>
<blockquote>
<p><code>refresh_interval</code> 需要一个 <em>持续时间</em> 值， 例如 <code>1s</code> （1 秒） 或 <code>2m</code> （2 分钟）。 一个绝对值 <em>1</em> 表示的是 <em>1 毫秒</em> –无疑会使你的集群陷入瘫痪。</p>
</blockquote>
<h3 id="持久化变更"><a href="#持久化变更" class="headerlink" title="持久化变更"></a>持久化变更</h3><p>如果没有用 <code>fsync</code> 把数据从文件系统缓存刷（flush）到硬盘，我们不能保证数据在断电甚至是程序正常退出之后依然存在。为了保证 Elasticsearch 的可靠性，需要确保数据变化被持久化到磁盘。</p>
<p>在 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/dynamic-indices.html">动态更新索引</a>，我们说一次完整的提交会将段刷到磁盘，并写入一个包含所有段列表的提交点。Elasticsearch 在启动或重新打开一个索引的过程中使用这个提交点来判断哪些段隶属于当前分片。</p>
<p>即使通过每秒刷新（refresh）实现了近实时搜索，我们仍然需要经常进行完整提交来确保能从失败中恢复。但在两次提交之间发生变化的文档怎么办？我们也不希望丢失掉这些数据。</p>
<p>Elasticsearch 增加了一个 <em>translog</em> ，或者叫事务日志，在每一次对 Elasticsearch 进行操作时均进行了日志记录。通过 translog ，整个流程看起来是下面这样：</p>
<p>一个文档被索引之后，就会被添加到内存缓冲区，<em>并且</em> 追加到了 translog ，正如 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/translog.html#img-xlog-pre-refresh">Figure 21, “新的文档被添加到内存缓冲区并且被追加到了事务日志”</a> 描述的一样。</p>
<p><strong>Figure 21. 新的文档被添加到内存缓冲区并且被追加到了事务日志</strong></p>
<p><img src="https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_1106.png" alt="New documents are added to the in-memory buffer and appended to the transaction log"></p>
<p>刷新（refresh）使分片处于 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/translog.html#img-xlog-post-refresh">Figure 22, “刷新（refresh）完成后, 缓存被清空但是事务日志不会”</a> 描述的状态，分片每秒被刷新（refresh）一次：</p>
<ul>
<li>这些在内存缓冲区的文档被写入到一个新的段中，且没有进行 <code>fsync</code> 操作。</li>
<li>这个段被打开，使其可被搜索。</li>
<li>内存缓冲区被清空。</li>
</ul>
<p><strong>Figure 22. 刷新（refresh）完成后, 缓存被清空但是事务日志不会</strong></p>
<p><img src="https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_1107.png" alt="After a refresh, the buffer is cleared but the transaction log is not"></p>
<p>这个进程继续工作，更多的文档被添加到内存缓冲区和追加到事务日志（见 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/translog.html#img-xlog-pre-flush">Figure 23, “事务日志不断积累文档”</a> ）。</p>
<p><strong>Figure 23. 事务日志不断积累文档</strong></p>
<p><img src="https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_1108.png" alt="The transaction log keeps accumulating documents"></p>
<ol>
<li>每隔一段时间—例如 translog 变得越来越大—索引被刷新（flush）；一个新的 translog 被创建，并且一个全量提交被执行（见 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/translog.html#img-xlog-post-flush">Figure 24, “在刷新（flush）之后，段被全量提交，并且事务日志被清空”</a> ）：<ul>
<li>所有在内存缓冲区的文档都被写入一个新的段。</li>
<li>缓冲区被清空。</li>
<li>一个提交点被写入硬盘。</li>
<li>文件系统缓存通过 <code>fsync</code> 被刷新（flush）。</li>
<li>老的 translog 被删除。</li>
</ul>
</li>
</ol>
<p>translog 提供所有还没有被刷到磁盘的操作的一个持久化纪录。当 Elasticsearch 启动的时候， 它会从磁盘中使用最后一个提交点去恢复已知的段，并且会重放 translog 中所有在最后一次提交后发生的变更操作。</p>
<p>translog 也被用来提供实时 CRUD 。当你试着通过 ID 查询、更新、删除一个文档，它会在尝试从相应的段中检索之前， 首先检查 translog 任何最近的变更。这意味着它总是能够实时地获取到文档的最新版本。</p>
<p><strong>Figure 24. 在刷新（flush）之后，段被全量提交，并且事务日志被清空</strong></p>
<p><img src="https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_1109.png" alt="After a flush, the segments are fully commited and the transaction log is cleared"></p>
<h3 id="flush-API"><a href="#flush-API" class="headerlink" title="flush API"></a>flush API</h3><p>这个执行一个提交并且截断 translog 的行为在 Elasticsearch 被称作一次 <em>flush</em> 。 分片每 30 分钟被自动刷新（flush），或者在 translog 太大的时候也会刷新。请查看 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/2.4/index-modules-translog.html#_translog_settings"><code>translog</code> 文档</a> 来设置，它可以用来 控制这些阈值：</p>
<p><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/indices-flush.html"><code>flush</code> API</a> 可以被用来执行一个手工的刷新（flush）:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST /blogs/_flush</span><br><span class="line">POST /_flush?wait_for_ongoing</span><br></pre></td></tr></table></figure>

<ul>
<li>刷新（flush） blogs 索引。</li>
<li>刷新（flush）所有的索引并且并且等待所有刷新在返回前完成。</li>
</ul>
<p>你很少需要自己手动执行 <code>flush</code> 操作；通常情况下，自动刷新就足够了。</p>
<p>这就是说，在重启节点或关闭索引之前执行 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/translog.html#flush-api">flush</a> 有益于你的索引。当 Elasticsearch 尝试恢复或重新打开一个索引， 它需要重放 translog 中所有的操作，所以如果日志越短，恢复越快。</p>
<blockquote>
<p>translog 的目的是保证操作不会丢失。这引出了这个问题： Translog 有多安全？</p>
<p>在文件被 <code>fsync</code> 到磁盘前，被写入的文件在重启之后就会丢失。默认 translog 是每 5 秒被 <code>fsync</code> 刷新到硬盘， 或者在每次写请求完成之后执行(e.g. index, delete, update, bulk)。这个过程在主分片和复制分片都会发生。最终， 基本上，这意味着在整个请求被 <code>fsync</code> 到主分片和复制分片的 translog 之前，你的客户端不会得到一个 200 OK 响应。</p>
<p>在每次请求后都执行一个 fsync 会带来一些性能损失，尽管实践表明这种损失相对较小（特别是 bulk 导入，它在一次请求中平摊了大量文档的开销）。</p>
<p>但是对于一些大容量的偶尔丢失几秒数据问题也并不严重的集群，使用异步的 fsync 还是比较有益的。比如，写入的数据被缓存到内存中，再每 5 秒执行一次 <code>fsync</code> 。</p>
<p>这个行为可以通过设置 <code>durability</code> 参数为 <code>async</code> 来启用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">PUT</span> /my_index/_settings</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;index.translog.durability&quot;</span>: <span class="string">&quot;async&quot;</span>,</span><br><span class="line">    <span class="string">&quot;index.translog.sync_interval&quot;</span>: <span class="string">&quot;5s&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个选项可以针对索引单独设置，并且可以动态进行修改。如果你决定使用异步 translog 的话，你需要 <em>保证</em> 在发生 crash 时，丢失掉 <code>sync_interval</code> 时间段的数据也无所谓。请在决定前知晓这个特性。</p>
<p>如果你不确定这个行为的后果，最好是使用默认的参数（ <code>&quot;index.translog.durability&quot;: &quot;request&quot;</code> ）来避免数据丢失。</p>
</blockquote>
<h3 id="段合并"><a href="#段合并" class="headerlink" title="段合并"></a>段合并</h3><p>由于自动刷新流程每秒会创建一个新的段 ，这样会导致短时间内的段数量暴增。而段数目太多会带来较大的麻烦。 每一个段都会消耗文件句柄、内存和 cpu 运行周期。更重要的是，每个搜索请求都必须轮流检查每个段；所以段越多，搜索也就越慢。</p>
<p>Elasticsearch 通过在后台进行段合并来解决这个问题。小的段被合并到大的段，然后这些大的段再被合并到更大的段。</p>
<p>段合并的时候会将那些旧的已删除文档从文件系统中清除。被删除的文档（或被更新文档的旧版本）不会被拷贝到新的大段中。</p>
<p>启动段合并不需要你做任何事。进行索引和搜索时会自动进行。这个流程像在 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/merge-process.html#img-merge">Figure 25, “两个提交了的段和一个未提交的段正在被合并到一个更大的段”</a> 中提到的一样工作：</p>
<p>1、 当索引的时候，刷新（refresh）操作会创建新的段并将段打开以供搜索使用。</p>
<p>2、 合并进程选择一小部分大小相似的段，并且在后台将它们合并到更大的段中。这并不会中断索引和搜索。</p>
<p><strong>Figure 25. 两个提交了的段和一个未提交的段正在被合并到一个更大的段</strong></p>
<p><img src="https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_1110.png" alt="Two commited segments and one uncommited segment in the process of being merged into a bigger segment"></p>
<p><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/merge-process.html#img-post-merge">Figure 26, “一旦合并结束，老的段被删除”</a> 说明合并完成时的活动：</p>
<ul>
<li>新的段被刷新（flush）到了磁盘。 ** 写入一个包含新段且排除旧的和较小的段的新提交点。</li>
<li>新的段被打开用来搜索。</li>
<li>老的段被删除。</li>
</ul>
<p><strong>Figure 26. 一旦合并结束，老的段被删除</strong></p>
<p><img src="https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_1111.png" alt="一旦合并结束，老的段被删除"></p>
<p>合并大的段需要消耗大量的 I&#x2F;O 和 CPU 资源，如果任其发展会影响搜索性能。Elasticsearch 在默认情况下会对合并流程进行资源限制，所以搜索仍然 有足够的资源很好地执行。</p>
<h3 id="optimize-API"><a href="#optimize-API" class="headerlink" title="optimize API"></a>optimize API</h3><p><code>optimize</code> API 大可看做是 <em>强制合并</em> API。它会将一个分片强制合并到 <code>max_num_segments</code> 参数指定大小的段数目。 这样做的意图是减少段的数量（通常减少到一个），来提升搜索性能。</p>
<blockquote>
<p><code>optimize</code> API <em>不应该</em> 被用在一个活跃的索引————一个正积极更新的索引。后台合并流程已经可以很好地完成工作。 optimizing 会阻碍这个进程。不要干扰它！</p>
</blockquote>
<p>在特定情况下，使用 <code>optimize</code> API 颇有益处。例如在日志这种用例下，每天、每周、每月的日志被存储在一个索引中。 老的索引实质上是只读的；它们也并不太可能会发生变化。</p>
<p>在这种情况下，使用 optimize 优化老的索引，将每一个分片合并为一个单独的段就很有用了；这样既可以节省资源，也可以使搜索更加快速：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST /logstash-2014-10/_optimize?max_num_segments=1</span><br></pre></td></tr></table></figure>

<p>合并索引中的每个分片为一个单独的段</p>
<blockquote>
<p>请注意，使用 <code>optimize</code> API 触发段合并的操作不会受到任何资源上的限制。这可能会消耗掉你节点上全部的 I&#x2F;O 资源, 使其没有余裕来处理搜索请求，从而有可能使集群失去响应。 如果你想要对索引执行 <code>optimize</code>，你需要先使用分片分配（查看 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/retiring-data.html#migrate-indices">迁移旧索引</a>）把索引移到一个安全的节点，再执行。</p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/distributed-cluster.html">Elasticsearch 官方文档之 集群内的原理</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/201e43/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/201e43/" class="post-title-link" itemprop="url">ElasticSearch Java API 之 High Level REST Client</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-01 18:55:46" itemprop="dateCreated datePublished" datetime="2022-03-01T18:55:46+08:00">2022-03-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">搜索引擎数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/Elasticsearch/" itemprop="url" rel="index"><span itemprop="name">Elasticsearch</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="ElasticSearch-Java-API-之-High-Level-REST-Client"><a href="#ElasticSearch-Java-API-之-High-Level-REST-Client" class="headerlink" title="ElasticSearch Java API 之 High Level REST Client"></a>ElasticSearch Java API 之 High Level REST Client</h1><blockquote>
<p>Elasticsearch 官方的 High Level REST Client 在 7.1.5.0 版本废弃。所以本文中的 API 不推荐使用。</p>
</blockquote>
<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><p>在 pom.xml 中引入以下依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.17.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="创建连接和关闭"><a href="#创建连接和关闭" class="headerlink" title="创建连接和关闭"></a>创建连接和关闭</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建连接</span></span><br><span class="line"><span class="type">RestHighLevelClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(</span><br><span class="line">        RestClient.builder(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">HttpHost</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">9200</span>, <span class="string">&quot;http&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">HttpHost</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">9201</span>, <span class="string">&quot;http&quot;</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭</span></span><br><span class="line">client.close();</span><br></pre></td></tr></table></figure>

<h2 id="索引-API"><a href="#索引-API" class="headerlink" title="索引 API"></a>索引 API</h2><h3 id="测试准备"><a href="#测试准备" class="headerlink" title="测试准备"></a>测试准备</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">INDEX</span> <span class="operator">=</span> <span class="string">&quot;mytest&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">INDEX_ALIAS</span> <span class="operator">=</span> <span class="string">&quot;mytest_alias&quot;</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> User&#125; 的 mapping 结构（json形式）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MAPPING_JSON</span> <span class="operator">=</span></span><br><span class="line">  <span class="string">&quot;&#123;\n&quot;</span> + <span class="string">&quot;  \&quot;properties\&quot;: &#123;\n&quot;</span> + <span class="string">&quot;    \&quot;_class\&quot;: &#123;\n&quot;</span> + <span class="string">&quot;      \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot;</span></span><br><span class="line">  + <span class="string">&quot;      \&quot;index\&quot;: false,\n&quot;</span> + <span class="string">&quot;      \&quot;doc_values\&quot;: false\n&quot;</span> + <span class="string">&quot;    &#125;,\n&quot;</span> + <span class="string">&quot;    \&quot;description\&quot;: &#123;\n&quot;</span></span><br><span class="line">  + <span class="string">&quot;      \&quot;type\&quot;: \&quot;text\&quot;,\n&quot;</span> + <span class="string">&quot;      \&quot;fielddata\&quot;: true\n&quot;</span> + <span class="string">&quot;    &#125;,\n&quot;</span> + <span class="string">&quot;    \&quot;enabled\&quot;: &#123;\n&quot;</span></span><br><span class="line">  + <span class="string">&quot;      \&quot;type\&quot;: \&quot;boolean\&quot;\n&quot;</span> + <span class="string">&quot;    &#125;,\n&quot;</span> + <span class="string">&quot;    \&quot;name\&quot;: &#123;\n&quot;</span> + <span class="string">&quot;      \&quot;type\&quot;: \&quot;text\&quot;,\n&quot;</span></span><br><span class="line">  + <span class="string">&quot;      \&quot;fielddata\&quot;: true\n&quot;</span> + <span class="string">&quot;    &#125;\n&quot;</span> + <span class="string">&quot;  &#125;\n&quot;</span> + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RestHighLevelClient client;</span><br></pre></td></tr></table></figure>

<h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建索引</span></span><br><span class="line"><span class="type">CreateIndexRequest</span> <span class="variable">createIndexRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreateIndexRequest</span>(INDEX);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置索引的 settings</span></span><br><span class="line">  createIndexRequest.settings(</span><br><span class="line">  Settings.builder().put(<span class="string">&quot;index.number_of_shards&quot;</span>, <span class="number">3</span>).put(<span class="string">&quot;index.number_of_replicas&quot;</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置索引的 mapping</span></span><br><span class="line">  createIndexRequest.mapping(MAPPING_JSON, XContentType.JSON);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置索引的别名</span></span><br><span class="line">  createIndexRequest.alias(<span class="keyword">new</span> <span class="title class_">Alias</span>(INDEX_ALIAS));</span><br><span class="line"></span><br><span class="line">  <span class="type">AcknowledgedResponse</span> <span class="variable">createIndexResponse</span> <span class="operator">=</span> client.indices().create(createIndexRequest, RequestOptions.DEFAULT);</span><br><span class="line">  Assertions.assertTrue(createIndexResponse.isAcknowledged());</span><br></pre></td></tr></table></figure>

<h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除索引</span></span><br><span class="line"><span class="type">DeleteIndexRequest</span> <span class="variable">deleteIndexRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteIndexRequest</span>(INDEX);</span><br><span class="line">  <span class="type">AcknowledgedResponse</span> <span class="variable">deleteResponse</span> <span class="operator">=</span> client.indices().delete(deleteIndexRequest, RequestOptions.DEFAULT);</span><br><span class="line">  Assertions.assertTrue(deleteResponse.isAcknowledged());</span><br></pre></td></tr></table></figure>

<h3 id="判断索引是否存在"><a href="#判断索引是否存在" class="headerlink" title="判断索引是否存在"></a>判断索引是否存在</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">GetIndexRequest</span> <span class="variable">getIndexRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetIndexRequest</span>(INDEX);</span><br><span class="line">  Assertions.assertTrue(client.indices().exists(getIndexRequest, RequestOptions.DEFAULT));</span><br><span class="line">  <span class="type">GetIndexRequest</span> <span class="variable">getIndexAliasRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetIndexRequest</span>(INDEX_ALIAS);</span><br><span class="line">  Assertions.assertTrue(client.indices().exists(getIndexAliasRequest, RequestOptions.DEFAULT));</span><br></pre></td></tr></table></figure>

<h2 id="文档-API"><a href="#文档-API" class="headerlink" title="文档 API"></a>文档 API</h2><h3 id="文档测试准备"><a href="#文档测试准备" class="headerlink" title="文档测试准备"></a>文档测试准备</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">INDEX</span> <span class="operator">=</span> <span class="string">&quot;mytest&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">INDEX_ALIAS</span> <span class="operator">=</span> <span class="string">&quot;mytest_alias&quot;</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> User&#125; 的 mapping 结构（json形式）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MAPPING_JSON</span> <span class="operator">=</span></span><br><span class="line">  <span class="string">&quot;&#123;\n&quot;</span> + <span class="string">&quot;  \&quot;properties\&quot;: &#123;\n&quot;</span> + <span class="string">&quot;    \&quot;_class\&quot;: &#123;\n&quot;</span> + <span class="string">&quot;      \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot;</span></span><br><span class="line">  + <span class="string">&quot;      \&quot;index\&quot;: false,\n&quot;</span> + <span class="string">&quot;      \&quot;doc_values\&quot;: false\n&quot;</span> + <span class="string">&quot;    &#125;,\n&quot;</span> + <span class="string">&quot;    \&quot;description\&quot;: &#123;\n&quot;</span></span><br><span class="line">  + <span class="string">&quot;      \&quot;type\&quot;: \&quot;text\&quot;,\n&quot;</span> + <span class="string">&quot;      \&quot;fielddata\&quot;: true\n&quot;</span> + <span class="string">&quot;    &#125;,\n&quot;</span> + <span class="string">&quot;    \&quot;enabled\&quot;: &#123;\n&quot;</span></span><br><span class="line">  + <span class="string">&quot;      \&quot;type\&quot;: \&quot;boolean\&quot;\n&quot;</span> + <span class="string">&quot;    &#125;,\n&quot;</span> + <span class="string">&quot;    \&quot;name\&quot;: &#123;\n&quot;</span> + <span class="string">&quot;      \&quot;type\&quot;: \&quot;text\&quot;,\n&quot;</span></span><br><span class="line">  + <span class="string">&quot;      \&quot;fielddata\&quot;: true\n&quot;</span> + <span class="string">&quot;    &#125;\n&quot;</span> + <span class="string">&quot;  &#125;\n&quot;</span> + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RestHighLevelClient client;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建索引</span></span><br><span class="line">  <span class="type">CreateIndexRequest</span> <span class="variable">createIndexRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreateIndexRequest</span>(INDEX);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置索引的 settings</span></span><br><span class="line">  createIndexRequest.settings(</span><br><span class="line">  Settings.builder().put(<span class="string">&quot;index.number_of_shards&quot;</span>, <span class="number">3</span>).put(<span class="string">&quot;index.number_of_replicas&quot;</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置索引的 mapping</span></span><br><span class="line">  createIndexRequest.mapping(MAPPING_JSON, XContentType.JSON);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置索引的别名</span></span><br><span class="line">  createIndexRequest.alias(<span class="keyword">new</span> <span class="title class_">Alias</span>(INDEX_ALIAS));</span><br><span class="line"></span><br><span class="line">  <span class="type">AcknowledgedResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.indices().create(createIndexRequest, RequestOptions.DEFAULT);</span><br><span class="line">  Assertions.assertTrue(response.isAcknowledged());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断索引是否存在</span></span><br><span class="line">  <span class="type">GetIndexRequest</span> <span class="variable">getIndexRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetIndexRequest</span>(INDEX_ALIAS);</span><br><span class="line">  Assertions.assertTrue(client.indices().exists(getIndexRequest, RequestOptions.DEFAULT));</span><br><span class="line">  <span class="type">GetIndexRequest</span> <span class="variable">getIndexAliasRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetIndexRequest</span>(INDEX_ALIAS);</span><br><span class="line">  Assertions.assertTrue(client.indices().exists(getIndexAliasRequest, RequestOptions.DEFAULT));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AfterEach</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="comment">// 删除索引</span></span><br><span class="line">  <span class="type">DeleteIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteIndexRequest</span>(INDEX);</span><br><span class="line">  <span class="type">AcknowledgedResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.indices().delete(request, RequestOptions.DEFAULT);</span><br><span class="line">  Assertions.assertTrue(response.isAcknowledged());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建文档"><a href="#创建文档" class="headerlink" title="创建文档"></a>创建文档</h3><p>RestHighLevelClient Api 使用 <code>IndexRequest</code> 来构建创建文档的请求参数。</p>
<p>【示例】创建 id 为 1 的文档</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;product&quot;</span>);</span><br><span class="line">  request.id(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">  <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Product</span>();</span><br><span class="line">  product.setName(<span class="string">&quot;机器人&quot;</span>);</span><br><span class="line">  product.setDescription(<span class="string">&quot;人工智能机器人&quot;</span>);</span><br><span class="line">  product.setEnabled(<span class="literal">true</span>);</span><br><span class="line">  <span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> JSONUtil.toJsonStr(product);</span><br><span class="line">  request.source(jsonString, XContentType.JSON);</span><br></pre></td></tr></table></figure>

<p>同步执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IndexResponse</span> <span class="variable">indexResponse</span> <span class="operator">=</span> client.index(request, RequestOptions.DEFAULT);</span><br></pre></td></tr></table></figure>

<p>异步执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步执行</span></span><br><span class="line">client.indexAsync(request, RequestOptions.DEFAULT, <span class="keyword">new</span> <span class="title class_">ActionListener</span>&lt;IndexResponse&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(IndexResponse indexResponse)</span> &#123;</span><br><span class="line">  System.out.println(indexResponse);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;执行失败&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><p>RestHighLevelClient Api 使用 <code>DeleteRequest</code> 来构建删除文档的请求参数。</p>
<p>【示例】删除 id 为 1 的文档</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DeleteRequest</span> <span class="variable">deleteRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteRequest</span>(INDEX_ALIAS, <span class="string">&quot;1&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>同步执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DeleteResponse</span> <span class="variable">deleteResponse</span> <span class="operator">=</span> client.delete(deleteRequest, RequestOptions.DEFAULT);</span><br><span class="line">  System.out.println(deleteResponse);</span><br></pre></td></tr></table></figure>

<p>异步执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">client.deleteAsync(deleteRequest, RequestOptions.DEFAULT, <span class="keyword">new</span> <span class="title class_">ActionListener</span>&lt;DeleteResponse&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(DeleteResponse deleteResponse)</span> &#123;</span><br><span class="line">  System.out.println(deleteResponse);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;执行失败&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h3><p>RestHighLevelClient Api 使用 <code>UpdateRequest</code> 来构建更新文档的请求参数。</p>
<p>【示例】更新 id 为 1 的文档</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UpdateRequest</span> <span class="variable">updateRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UpdateRequest</span>(INDEX_ALIAS, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">  <span class="type">Product</span> <span class="variable">product3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Product</span>();</span><br><span class="line">  product3.setName(<span class="string">&quot;扫地机器人&quot;</span>);</span><br><span class="line">  product3.setDescription(<span class="string">&quot;人工智能扫地机器人&quot;</span>);</span><br><span class="line">  product3.setEnabled(<span class="literal">true</span>);</span><br><span class="line">  <span class="type">String</span> <span class="variable">jsonString2</span> <span class="operator">=</span> JSONUtil.toJsonStr(product3);</span><br><span class="line">  updateRequest.doc(jsonString2, XContentType.JSON);</span><br></pre></td></tr></table></figure>

<p>同步执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UpdateResponse</span> <span class="variable">updateResponse</span> <span class="operator">=</span> client.update(updateRequest, RequestOptions.DEFAULT);</span><br><span class="line">  System.out.println(updateResponse);</span><br></pre></td></tr></table></figure>

<p>异步执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">client.updateAsync(updateRequest, RequestOptions.DEFAULT, <span class="keyword">new</span> <span class="title class_">ActionListener</span>&lt;UpdateResponse&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(UpdateResponse updateResponse)</span> &#123;</span><br><span class="line">  System.out.println(updateResponse);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;执行失败&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="查看文档"><a href="#查看文档" class="headerlink" title="查看文档"></a>查看文档</h3><p>RestHighLevelClient Api 使用 <code>GetRequest</code> 来构建查看文档的请求参数。</p>
<p>【示例】查看 id 为 1 的文档</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">GetRequest</span> <span class="variable">getRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetRequest</span>(INDEX_ALIAS, <span class="string">&quot;1&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>同步执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">GetResponse</span> <span class="variable">getResponse</span> <span class="operator">=</span> client.get(getRequest, RequestOptions.DEFAULT);</span><br></pre></td></tr></table></figure>

<p>异步执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">client.getAsync(getRequest, RequestOptions.DEFAULT, <span class="keyword">new</span> <span class="title class_">ActionListener</span>&lt;GetResponse&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(GetResponse getResponse)</span> &#123;</span><br><span class="line">  System.out.println(getResponse);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;执行失败&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="获取匹配条件的记录总数"><a href="#获取匹配条件的记录总数" class="headerlink" title="获取匹配条件的记录总数"></a>获取匹配条件的记录总数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;获取匹配条件的记录总数&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">count</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">SearchSourceBuilder</span> <span class="variable">sourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line">    sourceBuilder.query(QueryBuilders.matchPhraseQuery(<span class="string">&quot;customer_gender&quot;</span>, <span class="string">&quot;MALE&quot;</span>));</span><br><span class="line">    sourceBuilder.trackTotalHits(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">CountRequest</span> <span class="variable">countRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountRequest</span>(INDEX);</span><br><span class="line">    countRequest.source(sourceBuilder);</span><br><span class="line"></span><br><span class="line">    <span class="type">CountResponse</span> <span class="variable">countResponse</span> <span class="operator">=</span> client.count(countRequest, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> countResponse.getCount();</span><br><span class="line">    System.out.println(<span class="string">&quot;命中记录数：&quot;</span> + count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@ValueSource(ints = &#123;0, 1, 2, 3&#125;)</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;分页查询测试&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pageTest</span><span class="params">(<span class="type">int</span> page)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> page * size;</span><br><span class="line">    <span class="type">SearchSourceBuilder</span> <span class="variable">sourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line">    sourceBuilder.query(QueryBuilders.matchPhraseQuery(<span class="string">&quot;customer_gender&quot;</span>, <span class="string">&quot;MALE&quot;</span>));</span><br><span class="line">    sourceBuilder.from(offset);</span><br><span class="line">    sourceBuilder.size(size);</span><br><span class="line">    sourceBuilder.trackTotalHits(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">searchRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(INDEX);</span><br><span class="line">    searchRequest.source(sourceBuilder);</span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line">    SearchHit[] hits = response.getHits().getHits();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        <span class="type">KibanaSampleDataEcommerceBean</span> <span class="variable">bean</span> <span class="operator">=</span></span><br><span class="line">            BeanUtil.mapToBean(hit.getSourceAsMap(), KibanaSampleDataEcommerceBean.class, <span class="literal">true</span>,</span><br><span class="line">                               CopyOptions.create());</span><br><span class="line">        System.out.println(bean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;条件查询&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchPhraseQuery</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">searchRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(INDEX);</span><br><span class="line">    <span class="type">SearchSourceBuilder</span> <span class="variable">sourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">boolQueryBuilder</span> <span class="operator">=</span> QueryBuilders.boolQuery();</span><br><span class="line">    boolQueryBuilder.must(QueryBuilders.matchPhraseQuery(<span class="string">&quot;customer_last_name&quot;</span>, <span class="string">&quot;Jensen&quot;</span>));</span><br><span class="line">    sourceBuilder.query(boolQueryBuilder);</span><br><span class="line">    sourceBuilder.trackTotalHits(<span class="literal">true</span>);</span><br><span class="line">    searchRequest.source(sourceBuilder);</span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line">    SearchHit[] hits = response.getHits().getHits();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        <span class="type">KibanaSampleDataEcommerceBean</span> <span class="variable">bean</span> <span class="operator">=</span></span><br><span class="line">            BeanUtil.mapToBean(hit.getSourceAsMap(), KibanaSampleDataEcommerceBean.class, <span class="literal">true</span>,</span><br><span class="line">                               CopyOptions.create());</span><br><span class="line">        System.out.println(bean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><strong>官方</strong><ul>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/java-rest-high.html">Java High Level REST Client</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/8/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/47/">47</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/10/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2015 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">李狗蛋</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">3.5m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">53:28</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/yiyirushi/" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.1/dist/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  




<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>

</body>
</html>
