<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/uploads/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/uploads/favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.ligoudan.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="天气不错哇，你看这大冰雹下得">
<meta property="og:type" content="website">
<meta property="og:title" content="LIGOUDAN">
<meta property="og:url" content="https://www.ligoudan.cn/page/3/index.html">
<meta property="og:site_name" content="LIGOUDAN">
<meta property="og:description" content="天气不错哇，你看这大冰雹下得">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="李狗蛋">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://www.ligoudan.cn/page/3/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>LIGOUDAN</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">LIGOUDAN</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">好好学习，天天向上</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">326</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">137</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">461</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="李狗蛋"
      src="/uploads/ligoudan.png">
  <p class="site-author-name" itemprop="name">李狗蛋</p>
  <div class="site-description" itemprop="description">天气不错哇，你看这大冰雹下得</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">461</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">137</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">326</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/yiyirushi" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yiyirushi" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yuanhaohoo@163.com" title="E-Mail → mailto:yuanhaohoo@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/a3347e/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/a3347e/" class="post-title-link" itemprop="url">HBase Java API 高级特性之过滤器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-16 09:45:10" itemprop="dateCreated datePublished" datetime="2023-03-16T09:45:10+08:00">2023-03-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%88%97%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">列式数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%88%97%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/HBase/" itemprop="url" rel="index"><span itemprop="name">HBase</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="HBase-Java-API-高级特性之过滤器"><a href="#HBase-Java-API-高级特性之过滤器" class="headerlink" title="HBase Java API 高级特性之过滤器"></a>HBase Java API 高级特性之过滤器</h1><p>HBase 中两种主要的数据读取方法是 <code>get()</code> 和 <code>scan()</code>，它们都支持直接访问数据和通过指定起止 row key 访问数据。此外，可以指定列族、列、时间戳和版本号来进行条件查询。它们的缺点是不支持细粒度的筛选功能。为了弥补这种不足，<code>Get</code> 和 <code>Scan</code> 支持通过过滤器（<code>Filter</code>）对 row key、列或列值进行过滤。</p>
<p>HBase 提供了一些内置过滤器，也允许用户通过继承 <code>Filter</code> 类来自定义过滤器。所有的过滤器都在服务端生效，称为 <strong>谓词下推</strong>。这样可以保证被过滤掉的数据不会被传到客户端。</p>
<p><img src="https://www.oreilly.com/api/v2/epubs/9781449314682/files/httpatomoreillycomsourceoreillyimages889252.png"></p>
<p><em>图片来自 HBase 权威指南</em></p>
<p>HBase 过滤器层次结构的最底层是 <code>Filter</code> 接口和 <code>FilterBase</code> 抽象类。大部分过滤器都直接继承自 <code>FilterBase</code>。</p>
<h2 id="比较过滤器"><a href="#比较过滤器" class="headerlink" title="比较过滤器"></a>比较过滤器</h2><p>所有比较过滤器均继承自 <code>CompareFilter</code>。<code>CompareFilter</code> 比 <code>FilterBase</code> 多了一个 <code>compare()</code> 方法，它需要传入参数定义比较操作的过程：比较运算符和比较器。</p>
<p>创建一个比较过滤器需要两个参数，分别是<strong>比较运算符</strong>和<strong>比较器实例</strong>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CompareFilter(<span class="keyword">final</span> CompareOp compareOp,<span class="keyword">final</span> ByteArrayComparable comparator) &#123;</span><br><span class="line">   <span class="keyword">this</span>.compareOp = compareOp;</span><br><span class="line">   <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><ul>
<li>LESS (&lt;)</li>
<li>LESS_OR_EQUAL (&lt;&#x3D;)</li>
<li>EQUAL (&#x3D;)</li>
<li>NOT_EQUAL (!&#x3D;)</li>
<li>GREATER_OR_EQUAL (&gt;&#x3D;)</li>
<li>GREATER (&gt;)</li>
<li>NO_OP (排除所有符合条件的值)</li>
</ul>
<p>比较运算符均定义在枚举类 <code>CompareOperator</code> 中</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@InterfaceAudience.Public</span><br><span class="line">public enum CompareOperator &#123;</span><br><span class="line"><span class="built_in">  LESS,</span></span><br><span class="line"><span class="built_in">  LESS_OR_EQUAL,</span></span><br><span class="line"><span class="built_in">  EQUAL,</span></span><br><span class="line"><span class="built_in">  NOT_EQUAL,</span></span><br><span class="line"><span class="built_in">  GREATER_OR_EQUAL,</span></span><br><span class="line"><span class="built_in">  GREATER,</span></span><br><span class="line"><span class="built_in">  NO_OP,</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：在 1.x 版本的 HBase 中，比较运算符定义在 <code>CompareFilter.CompareOp</code> 枚举类中，但在 2.0 之后这个类就被标识为 @deprecated ，并会在 3.0 移除。所以 2.0 之后版本的 HBase 需要使用 <code>CompareOperator</code> 这个枚举类。</p>
</blockquote>
<h3 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h3><p>所有比较器均继承自 <code>ByteArrayComparable</code> 抽象类，常用的有以下几种：</p>
<ul>
<li><strong>BinaryComparator</strong> : 使用 <code>Bytes.compareTo(byte []，byte [])</code> 按字典序比较指定的字节数组。</li>
<li><strong>BinaryPrefixComparator</strong> : 按字典序与指定的字节数组进行比较，但只比较到这个字节数组的长度。</li>
<li><strong>RegexStringComparator</strong> : 使用给定的正则表达式与指定的字节数组进行比较。仅支持 <code>EQUAL</code> 和 <code>NOT_EQUAL</code> 操作。</li>
<li><strong>SubStringComparator</strong> : 测试给定的子字符串是否出现在指定的字节数组中，比较不区分大小写。仅支持 <code>EQUAL</code> 和 <code>NOT_EQUAL</code> 操作。</li>
<li><strong>NullComparator</strong> ：判断给定的值是否为空。</li>
<li><strong>BitComparator</strong> ：按位进行比较。</li>
</ul>
<p><code>BinaryPrefixComparator</code> 和 <code>BinaryComparator</code> 的区别不是很好理解，这里举例说明一下：</p>
<p>在进行 <code>EQUAL</code> 的比较时，如果比较器传入的是 <code>abcd</code> 的字节数组，但是待比较数据是 <code>abcdefgh</code>：</p>
<ul>
<li>如果使用的是 <code>BinaryPrefixComparator</code> 比较器，则比较以 <code>abcd</code> 字节数组的长度为准，即 <code>efgh</code> 不会参与比较，这时候认为 <code>abcd</code> 与 <code>abcdefgh</code> 是满足 <code>EQUAL</code> 条件的；</li>
<li>如果使用的是 <code>BinaryComparator</code> 比较器，则认为其是不相等的。</li>
</ul>
<h3 id="比较过滤器种类"><a href="#比较过滤器种类" class="headerlink" title="比较过滤器种类"></a>比较过滤器种类</h3><p>比较过滤器共有五个（Hbase 1.x 版本和 2.x 版本相同）：</p>
<ul>
<li><strong>RowFilter</strong> ：基于行键来过滤数据；</li>
<li><strong>FamilyFilterr</strong> ：基于列族来过滤数据；</li>
<li><strong>QualifierFilterr</strong> ：基于列限定符（列名）来过滤数据；</li>
<li><strong>ValueFilterr</strong> ：基于单元格 (cell) 的值来过滤数据；</li>
<li><strong>DependentColumnFilter</strong> ：指定一个参考列来过滤其他列的过滤器，过滤的原则是基于参考列的时间戳来进行筛选 。</li>
</ul>
<p>前四种过滤器的使用方法相同，均只要传递比较运算符和运算器实例即可构建，然后通过 <code>setFilter</code> 方法传递给 <code>scan</code>：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Filter</span> <span class="built_in">filter</span>  = <span class="keyword">new</span> RowFilter(CompareOperator.LESS_OR_EQUAL,</span><br><span class="line">                               <span class="keyword">new</span> BinaryComparator(Bytes.toBytes(<span class="string">&quot;xxx&quot;</span>)));</span><br><span class="line"> scan.setFilter(<span class="built_in">filter</span>);</span><br></pre></td></tr></table></figure>

<p><code>DependentColumnFilter</code> 的使用稍微复杂一点，这里单独做下说明。</p>
<h3 id="DependentColumnFilter"><a href="#DependentColumnFilter" class="headerlink" title="DependentColumnFilter"></a>DependentColumnFilter</h3><p>可以把 <code>DependentColumnFilter</code> 理解为<strong>一个 valueFilter 和一个时间戳过滤器的组合</strong>。<code>DependentColumnFilter</code> 有三个带参构造器，这里选择一个参数最全的进行说明：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DependentColumnFilter</span>(<span class="keyword">final</span> <span class="type">byte</span> [] family, <span class="keyword">final</span> <span class="type">byte</span>[] qualifier,</span><br><span class="line">                               <span class="keyword">final</span> <span class="type">boolean</span> dropDependentColumn, <span class="keyword">final</span> CompareOperator op,</span><br><span class="line">                               <span class="keyword">final</span> ByteArrayComparable valueComparator)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>family</strong> ：列族</li>
<li><strong>qualifier</strong> ：列限定符（列名）</li>
<li><strong>dropDependentColumn</strong> ：决定参考列是否被包含在返回结果内，为 true 时表示参考列被返回，为 false 时表示被丢弃</li>
<li><strong>op</strong> ：比较运算符</li>
<li><strong>valueComparator</strong> ：比较器</li>
</ul>
<p>这里举例进行说明：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DependentColumnFilter dependentColumnFilter = <span class="literal">new</span> DependentColumnFilter(</span><br><span class="line">    <span class="built_in">Bytes</span>.toBytes(<span class="string">&quot;student&quot;</span>),</span><br><span class="line">    <span class="built_in">Bytes</span>.toBytes(<span class="string">&quot;name&quot;</span>),</span><br><span class="line">    <span class="literal">false</span>,</span><br><span class="line">    CompareOperator.EQUAL,</span><br><span class="line">    <span class="literal">new</span> BinaryPrefixComparator(<span class="built_in">Bytes</span>.toBytes(<span class="string">&quot;xiaolan&quot;</span>)));</span><br></pre></td></tr></table></figure>

<ul>
<li>首先会去查找 <code>student:name</code> 中值以 <code>xiaolan</code> 开头的所有数据获得 <code>参考数据集</code>，这一步等同于 valueFilter 过滤器；</li>
<li>其次再用参考数据集中所有数据的时间戳去检索其他列，获得时间戳相同的其他列的数据作为 <code>结果数据集</code>，这一步等同于时间戳过滤器；</li>
<li>最后如果 <code>dropDependentColumn</code> 为 true，则返回 <code>参考数据集</code>+<code>结果数据集</code>，若为 false，则抛弃参考数据集，只返回 <code>结果数据集</code>。</li>
</ul>
<h2 id="专用过滤器"><a href="#专用过滤器" class="headerlink" title="专用过滤器"></a>专用过滤器</h2><p>专用过滤器通常直接继承自 <code>FilterBase</code>，用于更特定的场景。</p>
<h3 id="单列列值过滤器-SingleColumnValueFilter"><a href="#单列列值过滤器-SingleColumnValueFilter" class="headerlink" title="单列列值过滤器 (SingleColumnValueFilter)"></a>单列列值过滤器 (SingleColumnValueFilter)</h3><p>基于某列（参考列）的值决定某行数据是否被过滤。其实例有以下方法：</p>
<ul>
<li><strong>setFilterIfMissing(boolean filterIfMissing)</strong> ：默认值为 false，即如果该行数据不包含参考列，其依然被包含在最后的结果中；设置为 true 时，则不包含；</li>
<li><strong>setLatestVersionOnly(boolean latestVersionOnly)</strong> ：默认为 true，即只检索参考列的最新版本数据；设置为 false，则检索所有版本数据。</li>
</ul>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SingleColumnValueFilter singleColumnValueFilter = <span class="keyword">new</span> SingleColumnValue<span class="built_in">Filter</span>(</span><br><span class="line">                <span class="string">&quot;student&quot;</span>.getBytes(),</span><br><span class="line">                <span class="string">&quot;name&quot;</span>.getBytes(),</span><br><span class="line">                CompareOperator.EQUAL,</span><br><span class="line">                <span class="keyword">new</span> SubstringComparator(<span class="string">&quot;xiaolan&quot;</span>));</span><br><span class="line">singleColumnValueFilter.setFilterIfMissing(<span class="literal">true</span>);</span><br><span class="line">scan.<span class="keyword">set</span><span class="built_in">Filter</span>(singleColumnValueFilter);</span><br></pre></td></tr></table></figure>

<h3 id="单列列值排除器-SingleColumnValueExcludeFilter"><a href="#单列列值排除器-SingleColumnValueExcludeFilter" class="headerlink" title="单列列值排除器 (SingleColumnValueExcludeFilter)"></a>单列列值排除器 (SingleColumnValueExcludeFilter)</h3><p><code>SingleColumnValueExcludeFilter</code> 继承自上面的 <code>SingleColumnValueFilter</code>，过滤行为与其相反。</p>
<h3 id="行键前缀过滤器-PrefixFilter"><a href="#行键前缀过滤器-PrefixFilter" class="headerlink" title="行键前缀过滤器 (PrefixFilter)"></a>行键前缀过滤器 (PrefixFilter)</h3><p>基于 RowKey 值决定某行数据是否被过滤。</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PrefixFilter prefixFilter = <span class="keyword">new</span> Prefix<span class="built_in">Filter</span>(Bytes.toBytes(<span class="string">&quot;xxx&quot;</span>));</span><br><span class="line">scan.<span class="keyword">set</span><span class="built_in">Filter</span>(prefixFilter);</span><br></pre></td></tr></table></figure>

<h3 id="列名前缀过滤器-ColumnPrefixFilter"><a href="#列名前缀过滤器-ColumnPrefixFilter" class="headerlink" title="列名前缀过滤器 (ColumnPrefixFilter)"></a>列名前缀过滤器 (ColumnPrefixFilter)</h3><p>基于列限定符（列名）决定某行数据是否被过滤。</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ColumnPrefixFilter columnPrefixFilter = <span class="keyword">new</span> ColumnPrefix<span class="built_in">Filter</span>(Bytes.toBytes(<span class="string">&quot;xxx&quot;</span>));</span><br><span class="line"> scan.<span class="keyword">set</span><span class="built_in">Filter</span>(columnPrefixFilter);</span><br></pre></td></tr></table></figure>

<h3 id="分页过滤器-PageFilter"><a href="#分页过滤器-PageFilter" class="headerlink" title="分页过滤器 (PageFilter)"></a>分页过滤器 (PageFilter)</h3><p>可以使用这个过滤器实现对结果按行进行分页，创建 PageFilter 实例的时候需要传入每页的行数。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PageFilter</span><span class="params">(<span class="keyword">final</span> <span class="type">long</span> pageSize)</span> </span>&#123;</span><br><span class="line">    Preconditions.<span class="built_in">checkArgument</span>(pageSize &gt;= <span class="number">0</span>, <span class="string">&quot;must be positive %s&quot;</span>, pageSize);</span><br><span class="line">    <span class="keyword">this</span>.pageSize = pageSize;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>下面的代码体现了客户端实现分页查询的主要逻辑，这里对其进行一下解释说明：</p>
<p>客户端进行分页查询，需要传递 <code>startRow</code>(起始 RowKey)，知道起始 <code>startRow</code> 后，就可以返回对应的 pageSize 行数据。这里唯一的问题就是，对于第一次查询，显然 <code>startRow</code> 就是表格的第一行数据，但是之后第二次、第三次查询我们并不知道 <code>startRow</code>，只能知道上一次查询的最后一条数据的 RowKey（简单称之为 <code>lastRow</code>）。</p>
<p>我们不能将 <code>lastRow</code> 作为新一次查询的 <code>startRow</code> 传入，因为 scan 的查询区间是[startRow，endRow) ，即前开后闭区间，这样 <code>startRow</code> 在新的查询也会被返回，这条数据就重复了。</p>
<p>同时在不使用第三方数据库存储 RowKey 的情况下，我们是无法通过知道 <code>lastRow</code> 的下一个 RowKey 的，因为 RowKey 的设计可能是连续的也有可能是不连续的。</p>
<p>由于 Hbase 的 RowKey 是按照字典序进行排序的。这种情况下，就可以在 <code>lastRow</code> 后面加上 <code>0</code> ，作为 <code>startRow</code> 传入，因为按照字典序的规则，某个值加上 <code>0</code> 后的新值，在字典序上一定是这个值的下一个值，对于 HBase 来说下一个 RowKey 在字典序上一定也是等于或者大于这个新值的。</p>
<p>所以最后传入 <code>lastRow</code>+<code>0</code>，如果等于这个值的 RowKey 存在就从这个值开始 scan,否则从字典序的下一个 RowKey 开始 scan。</p>
<blockquote>
<p>25 个字母以及数字字符，字典排序如下:</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;0&#x27;</span> &lt; <span class="string">&#x27;1&#x27;</span> &lt; <span class="string">&#x27;2&#x27;</span> &lt; <span class="params">...</span> &lt; <span class="string">&#x27;9&#x27;</span> &lt; <span class="string">&#x27;a&#x27;</span> &lt; <span class="string">&#x27;b&#x27;</span> &lt; <span class="params">...</span> &lt; <span class="string">&#x27;z&#x27;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>分页查询主要实现逻辑：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">byte[] POSTFIX = <span class="built_in">new</span> byte[] &#123; <span class="number">0x00</span> &#125;;</span><br><span class="line"><span class="keyword">Filter</span> <span class="keyword">filter</span> = <span class="built_in">new</span> PageFilter(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> totalRows = <span class="number">0</span>;</span><br><span class="line">byte[] lastRow = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    Scan scan = <span class="built_in">new</span> Scan();</span><br><span class="line">    scan.setFilter(<span class="keyword">filter</span>);</span><br><span class="line">    <span class="keyword">if</span> (lastRow != <span class="keyword">null</span>) &#123;</span><br><span class="line">        // 如果不是首行 则 lastRow + <span class="number">0</span></span><br><span class="line">        byte[] startRow = Bytes.<span class="keyword">add</span>(lastRow, POSTFIX);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;start row: &quot; +</span><br><span class="line">                           Bytes.toStringBinary(startRow));</span><br><span class="line">        scan.withStartRow(startRow);</span><br><span class="line">    &#125;</span><br><span class="line">    ResultScanner scanner = <span class="keyword">table</span>.getScanner(scan);</span><br><span class="line">    <span class="type">int</span> localRows = <span class="number">0</span>;</span><br><span class="line">    Result result;</span><br><span class="line">    <span class="keyword">while</span> ((result = scanner.next()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(localRows++ + &quot;: &quot; + result);</span><br><span class="line">        totalRows++;</span><br><span class="line">        lastRow = result.getRow();</span><br><span class="line">    &#125;</span><br><span class="line">    scanner.<span class="keyword">close</span>();</span><br><span class="line">    //最后一页，查询结束</span><br><span class="line">    <span class="keyword">if</span> (localRows == <span class="number">0</span>) break;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;total rows: &quot; + totalRows);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是在多台 Regin Services 上执行分页过滤的时候，由于并行执行的过滤器不能共享它们的状态和边界，所以有可能每个过滤器都会在完成扫描前获取了 PageCount 行的结果，这种情况下会返回比分页条数更多的数据，分页过滤器就有失效的可能。</p>
</blockquote>
<h3 id="时间戳过滤器-TimestampsFilter"><a href="#时间戳过滤器-TimestampsFilter" class="headerlink" title="时间戳过滤器 (TimestampsFilter)"></a>时间戳过滤器 (TimestampsFilter)</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Long&gt; list <span class="operator">=</span> new ArrayList&lt;&gt;()<span class="comment">;</span></span><br><span class="line">list.add(<span class="number">1554975573000</span>L)<span class="comment">;</span></span><br><span class="line">TimestampsFilter timestampsFilter <span class="operator">=</span> new TimestampsFilter(list)<span class="comment">;</span></span><br><span class="line">scan.setFilter(timestampsFilter)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<h3 id="首次行键过滤器-FirstKeyOnlyFilter"><a href="#首次行键过滤器-FirstKeyOnlyFilter" class="headerlink" title="首次行键过滤器 (FirstKeyOnlyFilter)"></a>首次行键过滤器 (FirstKeyOnlyFilter)</h3><p><code>FirstKeyOnlyFilter</code> 只扫描每行的第一列，扫描完第一列后就结束对当前行的扫描，并跳转到下一行。相比于全表扫描，其性能更好，通常用于行数统计的场景，因为如果某一行存在，则行中必然至少有一列。</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FirstKeyOnlyFilter firstKeyOnlyFilter <span class="operator">=</span> new FirstKeyOnlyFilter()<span class="comment">;</span></span><br><span class="line">scan.set(firstKeyOnlyFilter)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<h2 id="包装过滤器"><a href="#包装过滤器" class="headerlink" title="包装过滤器"></a>包装过滤器</h2><p>包装过滤器就是通过包装其他过滤器以实现某些拓展的功能。</p>
<h3 id="SkipFilter-过滤器"><a href="#SkipFilter-过滤器" class="headerlink" title="SkipFilter 过滤器"></a>SkipFilter 过滤器</h3><p><code>SkipFilter</code> 包装一个过滤器，当被包装的过滤器遇到一个需要过滤的 KeyValue 实例时，则拓展过滤整行数据。下面是一个使用示例：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 ValueFilter 过滤器</span></span><br><span class="line"><span class="built_in">Filter</span> filter1 = <span class="keyword">new</span> ValueFilter(CompareOperator.NOT_EQUAL,</span><br><span class="line">      <span class="keyword">new</span> BinaryComparator(Bytes.toBytes(<span class="string">&quot;xxx&quot;</span>)));</span><br><span class="line"><span class="comment">// 使用 SkipFilter 进行包装</span></span><br><span class="line"><span class="built_in">Filter</span> filter2 = <span class="keyword">new</span> SkipFilter(filter1);</span><br></pre></td></tr></table></figure>

<h3 id="WhileMatchFilter-过滤器"><a href="#WhileMatchFilter-过滤器" class="headerlink" title="WhileMatchFilter 过滤器"></a>WhileMatchFilter 过滤器</h3><p><code>WhileMatchFilter</code> 包装一个过滤器，当被包装的过滤器遇到一个需要过滤的 KeyValue 实例时，<code>WhileMatchFilter</code> 则结束本次扫描，返回已经扫描到的结果。下面是其使用示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Filter filter1 = new RowFilter(CompareOperator.NOT_EQUAL,</span><br><span class="line">                               new BinaryComparator(Bytes.toBytes(<span class="string">&quot;rowKey4&quot;</span>)));</span><br><span class="line"></span><br><span class="line">Scan scan = new Scan();</span><br><span class="line">scan.setFilter(filter1);</span><br><span class="line">ResultScanner scanner1 = table.getScanner(scan);</span><br><span class="line"><span class="keyword">for</span> (Result result : scanner1) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Cell cell : result.listCells()) &#123;</span><br><span class="line">        System.out.println(cell);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">scanner1.close();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;--------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">// 使用 WhileMatchFilter 进行包装</span><br><span class="line">Filter filter2 = new WhileMatchFilter(filter1);</span><br><span class="line"></span><br><span class="line">scan.setFilter(filter2);</span><br><span class="line">ResultScanner scanner2 = table.getScanner(scan);</span><br><span class="line"><span class="keyword">for</span> (Result result : scanner1) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Cell cell : result.listCells()) &#123;</span><br><span class="line">        System.out.println(cell);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">scanner2.close();</span><br><span class="line">rowKey0/student:name/1555035006994/Put/vlen=8/seqid=0</span><br><span class="line">rowKey1/student:name/1555035007019/Put/vlen=8/seqid=0</span><br><span class="line">rowKey2/student:name/1555035007025/Put/vlen=8/seqid=0</span><br><span class="line">rowKey3/student:name/1555035007037/Put/vlen=8/seqid=0</span><br><span class="line">rowKey5/student:name/1555035007051/Put/vlen=8/seqid=0</span><br><span class="line">rowKey6/student:name/1555035007057/Put/vlen=8/seqid=0</span><br><span class="line">rowKey7/student:name/1555035007062/Put/vlen=8/seqid=0</span><br><span class="line">rowKey8/student:name/1555035007068/Put/vlen=8/seqid=0</span><br><span class="line">rowKey9/student:name/1555035007073/Put/vlen=8/seqid=0</span><br><span class="line">--------------------</span><br><span class="line">rowKey0/student:name/1555035006994/Put/vlen=8/seqid=0</span><br><span class="line">rowKey1/student:name/1555035007019/Put/vlen=8/seqid=0</span><br><span class="line">rowKey2/student:name/1555035007025/Put/vlen=8/seqid=0</span><br><span class="line">rowKey3/student:name/1555035007037/Put/vlen=8/seqid=0</span><br></pre></td></tr></table></figure>

<p>可以看到被包装后，只返回了 <code>rowKey4</code> 之前的数据。</p>
<h2 id="FilterList"><a href="#FilterList" class="headerlink" title="FilterList"></a>FilterList</h2><p>以上都是讲解单个过滤器的作用，当需要多个过滤器共同作用于一次查询的时候，就需要使用 <code>FilterList</code>。<code>FilterList</code> 支持通过构造器或者 <code>addFilter</code> 方法传入多个过滤器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造器传入</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FilterList</span><span class="params">(<span class="keyword">final</span> Operator operator, <span class="keyword">final</span> List&lt;Filter&gt; filters)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FilterList</span><span class="params">(<span class="keyword">final</span> List&lt;Filter&gt; filters)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FilterList</span><span class="params">(<span class="keyword">final</span> Filter... filters)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法传入</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFilter</span><span class="params">(List&lt;Filter&gt; filters)</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFilter</span><span class="params">(Filter filter)</span></span><br></pre></td></tr></table></figure>

<p>多个过滤器组合的结果由 <code>operator</code> 参数定义 ，其可选参数定义在 <code>Operator</code> 枚举类中。只有 <code>MUST_PASS_ALL</code> 和 <code>MUST_PASS_ONE</code> 两个可选的值：</p>
<ul>
<li><strong>MUST_PASS_ALL</strong> ：相当于 AND，必须所有的过滤器都通过才认为通过；</li>
<li><strong>MUST_PASS_ONE</strong> ：相当于 OR，只有要一个过滤器通过则认为通过。</li>
</ul>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@InterfaceAudience</span>.Public</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">enum</span> Operator &#123;</span><br><span class="line">    <span class="comment">/** !AND */</span></span><br><span class="line">    MUST_PASS_ALL,</span><br><span class="line">    <span class="comment">/** !OR */</span></span><br><span class="line">    MUST_PASS_ONE</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>使用示例如下：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="keyword">Filter</span>&gt; filters = <span class="built_in">new</span> ArrayList&lt;<span class="keyword">Filter</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">Filter</span> filter1 = <span class="built_in">new</span> RowFilter(CompareOperator.GREATER_OR_EQUAL,</span><br><span class="line">                               <span class="built_in">new</span> BinaryComparator(Bytes.toBytes(&quot;XXX&quot;)));</span><br><span class="line">filters.<span class="keyword">add</span>(filter1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">Filter</span> filter2 = <span class="built_in">new</span> RowFilter(CompareOperator.LESS_OR_EQUAL,</span><br><span class="line">                               <span class="built_in">new</span> BinaryComparator(Bytes.toBytes(&quot;YYY&quot;)));</span><br><span class="line">filters.<span class="keyword">add</span>(filter2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">Filter</span> filter3 = <span class="built_in">new</span> QualifierFilter(CompareOperator.EQUAL,</span><br><span class="line">                                     <span class="built_in">new</span> RegexStringComparator(&quot;ZZZ&quot;));</span><br><span class="line">filters.<span class="keyword">add</span>(filter3);</span><br><span class="line"></span><br><span class="line">FilterList filterList = <span class="built_in">new</span> FilterList(filters);</span><br><span class="line"></span><br><span class="line">Scan scan = <span class="built_in">new</span> Scan();</span><br><span class="line">scan.setFilter(filterList);</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://item.jd.com/11321037.html">《HBase 权威指南》</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/larsgeorge/hbase-book">《HBase 权威指南》官方源码</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/a69528/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/a69528/" class="post-title-link" itemprop="url">HBase Schema 设计</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-15 20:28:32" itemprop="dateCreated datePublished" datetime="2023-03-15T20:28:32+08:00">2023-03-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%88%97%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">列式数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%88%97%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/HBase/" itemprop="url" rel="index"><span itemprop="name">HBase</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="HBase-Schema-设计"><a href="#HBase-Schema-设计" class="headerlink" title="HBase Schema 设计"></a>HBase Schema 设计</h1><h2 id="HBase-Schema-设计要素"><a href="#HBase-Schema-设计要素" class="headerlink" title="HBase Schema 设计要素"></a>HBase Schema 设计要素</h2><ul>
<li>这个表应该有多少 Column Family</li>
<li>Column Family 使用什么数据</li>
<li>每个 Column Family 有有多少列</li>
<li>列名是什么，尽管列名不必在建表时定义，但读写数据是要知道的</li>
<li>单元应该存放什么数据</li>
<li>每个单元存储多少时间版本</li>
<li>行健(rowKey)结构是什么，应该包含什么信息</li>
</ul>
<h2 id="Row-Key-设计"><a href="#Row-Key-设计" class="headerlink" title="Row Key 设计"></a>Row Key 设计</h2><h3 id="Row-Key-的作用"><a href="#Row-Key-的作用" class="headerlink" title="Row Key 的作用"></a>Row Key 的作用</h3><p>在 HBase 中，所有对表的访问都要通过 Row Key，有三种访问方式：</p>
<ul>
<li>使用 <code>get</code> 命令，查询指定的 Row Key，即精确查找。</li>
<li>使用 scan 命令，根据 Row Key 进行范围查找。</li>
<li>全表扫描，即直接扫描表中所有行记录。</li>
</ul>
<p>此外，在 HBase 中，表中的行，是按照 Row Key 的字典序进行排序的。</p>
<p>由此，可见，Row Key 的良好设计对于 HBase CRUD 的性能至关重要。</p>
<h3 id="Row-Key-的设计原则"><a href="#Row-Key-的设计原则" class="headerlink" title="Row Key 的设计原则"></a>Row Key 的设计原则</h3><p><strong>长度原则</strong></p>
<p>RowKey 是一个二进制码流，可以是任意字符串，最大长度为 64kb，实际应用中一般为 10-100byte，以 byte[]形式保存，一般设计成定长。建议越短越好，不要超过 16 个字节，原因如下：</p>
<ol>
<li>数据的持久化文件 HFile 中时按照 Key-Value 存储的，如果 RowKey 过长，例如超过 100byte，那么 1000w 行的记录，仅 RowKey 就需占用近 1GB 的空间。这样会极大影响 HFile 的存储效率。</li>
<li>MemStore 会缓存部分数据到内存中，若 RowKey 字段过长，内存的有效利用率就会降低，就不能缓存更多的数据，从而降低检索效率。</li>
<li>目前操作系统都是 64 位系统，内存 8 字节对齐，控制在 16 字节，8 字节的整数倍利用了操作系统的最佳特性。</li>
</ol>
<p><strong>唯一原则</strong></p>
<p>必须在设计上保证 RowKey 的唯一性。由于在 HBase 中数据存储是 Key-Value 形式，若向 HBase 中同一张表插入相同 RowKey 的数据，则原先存在的数据会被新的数据覆盖。</p>
<p><strong>排序原则</strong></p>
<p>HBase 的 RowKey 是按照 ASCII 有序排序的，因此我们在设计 RowKey 的时候要充分利用这点。</p>
<p><strong>散列原则</strong></p>
<p>设计的 RowKey 应均匀的分布在各个 HBase 节点上。</p>
<h3 id="热点问题"><a href="#热点问题" class="headerlink" title="热点问题"></a>热点问题</h3><p>Region 是在 HBase 集群上分布数据的最小单位。每个 Region 由它所属的表的起始范围来表示（即起始 Row Key 和结束 Row Key）。</p>
<p>如果，Row Key 使用单调递增的整数或时间戳，就会产生一个问题：因为 Hbase 的 Row Key 是就近存储的，这会导致一段时间内大部分读写集中在某一个 Region 或少数 Region 上（根据二八原则，最近产生的数据，往往是读写频率最高的数据），即所谓 <strong>热点问题</strong>。</p>
<h4 id="反转（Reversing）"><a href="#反转（Reversing）" class="headerlink" title="反转（Reversing）"></a>反转（Reversing）</h4><p>第一种咱们要分析的方法是反转，顾名思义它就是把固定长度或者数字格式的 RowKey 进行反转，反转分为一般数据反转和时间戳反转，其中以时间戳反转较常见。</p>
<ul>
<li><strong>反转固定格式的数值</strong> - 以手机号为例，手机号的前缀变化比较少（如 <code>152、185</code> 等），但后半部分变化很多。如果将它反转过来，可以有效地避免热点。不过其缺点就是失去了有序性。</li>
<li><strong>反转时间</strong> - 如果数据访问以查找最近的数据为主，可以将时间戳存储为反向时间戳（例如： <code>timestamp = Long.MAX_VALUE – timestamp</code>），这样有利于扫描最近的数据。</li>
</ul>
<h4 id="加盐（Salting）"><a href="#加盐（Salting）" class="headerlink" title="加盐（Salting）"></a>加盐（Salting）</h4><p>这里的“加盐”与密码学中的“加盐”不是一回事。它是指在 RowKey 的前面增加一些前缀，加盐的前缀种类越多，RowKey 就被打得越散。</p>
<p>需要注意的是分配的随机前缀的种类数量应该和我们想把数据分散到的那些 region 的数量一致。只有这样，加盐之后的 rowkey 才会根据随机生成的前缀分散到各个 region 中，避免了热点现象。</p>
<h4 id="哈希（Hashing）"><a href="#哈希（Hashing）" class="headerlink" title="哈希（Hashing）"></a>哈希（Hashing）</h4><p>其实哈希和加盐的适用场景类似，但我们前缀不可以是随机的，因为必须要让客户端能够完整地重构 RowKey。所以一般会拿原 RowKey 或其一部分计算 Hash 值，然后再对 Hash 值做运算作为前缀。</p>
<h2 id="HBase-Schema-设计规则"><a href="#HBase-Schema-设计规则" class="headerlink" title="HBase Schema 设计规则"></a>HBase Schema 设计规则</h2><h3 id="Column-Family-设计"><a href="#Column-Family-设计" class="headerlink" title="Column Family 设计"></a>Column Family 设计</h3><p>HBase 不能很好处理 2 ~ 3 个以上的 Column Family，所以 <strong>HBase 表应尽可能减少 Column Family 数</strong>。如果可以，请只使用一个列族，只有需要经常执行 Column 范围查询时，才引入多列族。也就是说，尽量避免同时查询多个列族。</p>
<ul>
<li><strong>Column Family 数量多，会影响数据刷新</strong>。HBase 的数据刷新是在每个 Region 的基础上完成的。因此，如果一个 Column Family 携带大量导致刷新的数据，那么相邻的列族即使携带的数据量很小，也会被刷新。当存在许多 Column Family 时，刷新交互会导致一堆不必要的 IO。 此外，在表&#x2F;区域级别的压缩操作也会在每个存储中发生。</li>
<li><strong>Column Family 数量多，会影响查找效率</strong>。如：Column Family A 有 100 万行，Column Family B 有 10 亿行，那么 Column Family A 的数据可能会分布在很多很多区域（和 RegionServers）。 这会降低 Column Family A 的批量扫描效率。</li>
</ul>
<p>Column Family 名尽量简短，最好是一个字符。Column Family 会在列限定符中被频繁使用，缩短长度有利于节省空间并提升效率。</p>
<h3 id="Row-设计"><a href="#Row-设计" class="headerlink" title="Row 设计"></a>Row 设计</h3><p><strong>HBase 中的 Row 按 Row Key 的字典顺序排序</strong>。</p>
<ul>
<li><p><strong>不要将 Row Key 设计为单调递增的</strong>，例如：递增的整数或时间戳</p>
<ul>
<li><p>问题：因为 Hbase 的 Row Key 是就近存储的，这样会导致一段时间内大部分写入集中在某一个 Region 上，即所谓热点问题。</p>
</li>
<li><p>解决方法一、加盐：这里的不是指密码学的加盐，而是指将随机分配的前缀添加到行键的开头。这么做是为了避免相同前缀的 Row Key 数据被存储在相邻位置，从而导致热点问题。示例如下：</p>
<ul>
<li><pre><code>foo0001
foo0002
foo0003
foo0004

改为

a-foo0003
b-foo0001
c-foo0003
c-foo0004
d-foo0002
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 解决方法二、Hash：<span class="keyword">Row</span> Key 的前缀使用 Hash</span><br><span class="line"></span><br><span class="line">- **尽量减少行和列的长度**</span><br><span class="line"></span><br><span class="line">- **反向时间戳**：反向时间戳可以极大地帮助快速找到值的最新版本。</span><br><span class="line"></span><br><span class="line">- **行健不能改变**：唯一可以改变的方式是先删除后插入。</span><br><span class="line"></span><br><span class="line">- **<span class="keyword">Row</span> Key 和 <span class="keyword">Column</span> <span class="keyword">Family</span>**：<span class="keyword">Row</span> Key 从属于 <span class="keyword">Column</span> <span class="keyword">Family</span>，因此，相同的 <span class="keyword">Row</span> Key 可以存在每一个 <span class="keyword">Column</span> <span class="keyword">Family</span> 中而不会出现冲突。</span><br><span class="line"></span><br><span class="line">### <span class="keyword">Version</span> 设计</span><br><span class="line"></span><br><span class="line">最大、最小 <span class="keyword">Row</span> 版本号：表示 HBase 会保留的版本号数的上下限。均可以通过 HColumnDescriptor 对每个列族进行配置</span><br><span class="line"></span><br><span class="line"><span class="keyword">Row</span> 版本号过大，会大大增加 StoreFile 的大小；所以，最大 <span class="keyword">Row</span> 版本号应按需设置。HBase 会在主要压缩时，删除多余的版本。</span><br><span class="line"></span><br><span class="line">### TTL 设计</span><br><span class="line"></span><br><span class="line"><span class="keyword">Column</span> <span class="keyword">Family</span> 会设置一个以秒为单位的 TTL，一旦达到 TTL 时，HBase 会自动删除行记录。</span><br><span class="line"></span><br><span class="line">仅包含过期行的存储文件在次要压缩时被删除。 将 hbase.store.<span class="keyword">delete</span>.expired.storefile 设置为 <span class="keyword">false</span> 会禁用此功能。将最小版本数设置为 <span class="number">0</span> 以外的值也会禁用此功能。</span><br><span class="line"></span><br><span class="line">在较新版本的 HBase 上，还支持在 Cell 上设置 TTL，与 <span class="keyword">Column</span> <span class="keyword">Family</span> 的 TTL 不同的是，单位是毫秒。</span><br><span class="line"></span><br><span class="line">### <span class="keyword">Column</span> <span class="keyword">Family</span> 属性配置</span><br><span class="line"></span><br><span class="line">- HFile 数据块，默认是 <span class="number">64</span>KB，数据库的大小影响数据块索引的大小。数据块大的话一次加载进内存的数据越多，扫描查询效果越好。但是数据块小的话，随机查询性能更好</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>create ‘mytable’,{NAME &#x3D;&gt; ‘cf1’, BLOCKSIZE &#x3D;&gt; ‘65536’}<br>复制代码</p>
</blockquote>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">- </span>数据块缓存，数据块缓存默认是打开的，如果一些比较少访问的数据可以选择关闭缓存</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>create ‘mytable’,{NAME &#x3D;&gt; ‘cf1’, BLOCKCACHE &#x3D;&gt; ‘FALSE’}<br>复制代码</p>
</blockquote>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">- </span>数据压缩，压缩会提高磁盘利用率，但是会增加 CPU 的负载，看情况进行控制</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>create ‘mytable’,{NAME &#x3D;&gt; ‘cf1’, COMPRESSION &#x3D;&gt; ‘SNAPPY’}<br>复制代码</p>
</blockquote>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Hbase 表设计是和需求相关的，但是遵守表设计的一些硬性指标对性能的提升还是很有帮助的，这里整理了一些设计时用到的要点。</span><br><span class="line"></span><br><span class="line">## <span class="keyword">Schema</span> 设计案例</span><br><span class="line"></span><br><span class="line">### 案例：日志数据和时序数据</span><br><span class="line"></span><br><span class="line">假设采集以下数据</span><br><span class="line"></span><br><span class="line">- Hostname</span><br><span class="line">- <span class="type">Timestamp</span></span><br><span class="line">- <span class="keyword">Log</span> event</span><br><span class="line">- <span class="keyword">Value</span>/message</span><br><span class="line"></span><br><span class="line">应该如何设计 <span class="keyword">Row</span> Key？</span><br><span class="line"></span><br><span class="line">（<span class="number">1</span>）<span class="type">Timestamp</span> 在 <span class="keyword">Row</span> Key 头部</span><br><span class="line"></span><br><span class="line">如果 <span class="keyword">Row</span> Key 设计为 `[<span class="type">timestamp</span>][hostname][<span class="keyword">log</span>-event]` 形式，会出现热点问题。</span><br><span class="line"></span><br><span class="line">如果针对时间的扫描很重要，可以采用时间戳分桶策略，即</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>bucket &#x3D; timestamp % bucketNum</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">计算出桶号后，将 <span class="keyword">Row</span> Key 指定为：`[bucket][<span class="type">timestamp</span>][hostname][<span class="keyword">log</span>-event]`</span><br><span class="line"></span><br><span class="line">如上所述，要为特定时间范围选择数据，需要对每个桶执行扫描。 例如，<span class="number">100</span> 个桶将在键空间中提供广泛的分布，但需要 <span class="number">100</span> 次扫描才能获取单个时间戳的数据，因此需要权衡取舍。</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）Hostname 在 <span class="keyword">Row</span> Key 头部</span><br><span class="line"></span><br><span class="line">如果主机样本量很大，将 <span class="keyword">Row</span> Key 设计为 `[hostname][<span class="keyword">log</span>-event][<span class="type">timestamp</span>]`，这样有利于扫描 hostname。</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>）<span class="type">Timestamp</span> 还是反向 <span class="type">Timestamp</span></span><br><span class="line"></span><br><span class="line">如果数据访问以查找最近的数据为主，可以将时间戳存储为反向时间戳（例如： `<span class="type">timestamp</span> = Long.MAX_VALUE – <span class="type">timestamp</span>`），这样有利于扫描最近的数据。</span><br><span class="line"></span><br><span class="line">（<span class="number">4</span>）<span class="keyword">Row</span> Key 是可变长度还是固定长度</span><br><span class="line"></span><br><span class="line">拼接 <span class="keyword">Row</span> Key 的关键字长度不一定是固定的，例如 hostname 有可能很长，也有可能很短。如果想要统一长度，可以参考以下做法：</span><br><span class="line"></span><br><span class="line">- 将关键字 Hash 编码：使用某种 Hash 算法计算关键字，并取固定长度的值（例如：<span class="number">8</span> 位或 <span class="number">16</span> 位）。</span><br><span class="line">- 使用数字替代关键字：例如：使用事件类型 Code 替换事件类型；hostname 如果是 IP，可以转换为 long</span><br><span class="line">- 截取关键字：截取后的关键字需要有足够的辨识度，长度大小根据具体情况权衡。</span><br><span class="line"></span><br><span class="line">（<span class="number">5</span>）时间分片</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>[hostname][log-event][timestamp1]<br>[hostname][log-event][timestamp2]<br>[hostname][log-event][timestamp3]</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">上面的例子中，每个详细事件都有单独的行键，可以重写如下，即每个时间段存储一次：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>[hostname][log-event][timerange]</p>
<pre><code>
## 参考资料

- [HBase 官方文档之 HBase and Schema Design](https://hbase.apache.org/book.html#schema)
</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/a8cad3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/a8cad3/" class="post-title-link" itemprop="url">HBase Java API 基础特性</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-15 20:28:32" itemprop="dateCreated datePublished" datetime="2023-03-15T20:28:32+08:00">2023-03-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%88%97%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">列式数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%88%97%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/HBase/" itemprop="url" rel="index"><span itemprop="name">HBase</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>11 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="HBase-Java-API-基础特性"><a href="#HBase-Java-API-基础特性" class="headerlink" title="HBase Java API 基础特性"></a>HBase Java API 基础特性</h1><h2 id="HBase-Client-API"><a href="#HBase-Client-API" class="headerlink" title="HBase Client API"></a>HBase Client API</h2><h3 id="HBase-Java-API-示例"><a href="#HBase-Java-API-示例" class="headerlink" title="HBase Java API 示例"></a>HBase Java API 示例</h3><p>引入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hbase<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hbase-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HBaseUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Connection connection;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> HBaseConfiguration.create();</span><br><span class="line">        configuration.set(<span class="string">&quot;hbase.zookeeper.property.clientPort&quot;</span>, <span class="string">&quot;2181&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果是集群 则主机名用逗号分隔</span></span><br><span class="line">        configuration.set(<span class="string">&quot;hbase.zookeeper.quorum&quot;</span>, <span class="string">&quot;hadoop001&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = ConnectionFactory.createConnection(configuration);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 HBase 表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName      表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> columnFamilies 列族的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">createTable</span><span class="params">(String tableName, List&lt;String&gt; columnFamilies)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">HBaseAdmin</span> <span class="variable">admin</span> <span class="operator">=</span> (HBaseAdmin) connection.getAdmin();</span><br><span class="line">            <span class="keyword">if</span> (admin.tableExists(TableName.valueOf(tableName))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">TableDescriptorBuilder</span> <span class="variable">tableDescriptor</span> <span class="operator">=</span> TableDescriptorBuilder.newBuilder(TableName.valueOf(tableName));</span><br><span class="line">            columnFamilies.forEach(columnFamily -&gt; &#123;</span><br><span class="line">                <span class="type">ColumnFamilyDescriptorBuilder</span> <span class="variable">cfDescriptorBuilder</span> <span class="operator">=</span> ColumnFamilyDescriptorBuilder.newBuilder(Bytes.toBytes(columnFamily));</span><br><span class="line">                cfDescriptorBuilder.setMaxVersions(<span class="number">1</span>);</span><br><span class="line">                <span class="type">ColumnFamilyDescriptor</span> <span class="variable">familyDescriptor</span> <span class="operator">=</span> cfDescriptorBuilder.build();</span><br><span class="line">                tableDescriptor.setColumnFamily(familyDescriptor);</span><br><span class="line">            &#125;);</span><br><span class="line">            admin.createTable(tableDescriptor.build());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除 hBase 表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName 表名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">deleteTable</span><span class="params">(String tableName)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">HBaseAdmin</span> <span class="variable">admin</span> <span class="operator">=</span> (HBaseAdmin) connection.getAdmin();</span><br><span class="line">            <span class="comment">// 删除表前需要先禁用表</span></span><br><span class="line">            admin.disableTable(TableName.valueOf(tableName));</span><br><span class="line">            admin.deleteTable(TableName.valueOf(tableName));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName        表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rowKey           唯一标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> columnFamilyName 列族名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> qualifier        列标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value            数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">putRow</span><span class="params">(String tableName, String rowKey, String columnFamilyName, String qualifier,</span></span><br><span class="line"><span class="params">                                 String value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">            <span class="type">Put</span> <span class="variable">put</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Put</span>(Bytes.toBytes(rowKey));</span><br><span class="line">            put.addColumn(Bytes.toBytes(columnFamilyName), Bytes.toBytes(qualifier), Bytes.toBytes(value));</span><br><span class="line">            table.put(put);</span><br><span class="line">            table.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName        表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rowKey           唯一标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> columnFamilyName 列族名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pairList         列标识和值的集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">putRow</span><span class="params">(String tableName, String rowKey, String columnFamilyName, List&lt;Pair&lt;String, String&gt;&gt; pairList)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">            <span class="type">Put</span> <span class="variable">put</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Put</span>(Bytes.toBytes(rowKey));</span><br><span class="line">            pairList.forEach(pair -&gt; put.addColumn(Bytes.toBytes(columnFamilyName), Bytes.toBytes(pair.getKey()), Bytes.toBytes(pair.getValue())));</span><br><span class="line">            table.put(put);</span><br><span class="line">            table.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 rowKey 获取指定行的数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName 表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rowKey    唯一标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">getRow</span><span class="params">(String tableName, String rowKey)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">            <span class="type">Get</span> <span class="variable">get</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Get</span>(Bytes.toBytes(rowKey));</span><br><span class="line">            <span class="keyword">return</span> table.get(get);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定行指定列 (cell) 的最新版本的数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName    表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rowKey       唯一标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> columnFamily 列族</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> qualifier    列标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getCell</span><span class="params">(String tableName, String rowKey, String columnFamily, String qualifier)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">            <span class="type">Get</span> <span class="variable">get</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Get</span>(Bytes.toBytes(rowKey));</span><br><span class="line">            <span class="keyword">if</span> (!get.isCheckExistenceOnly()) &#123;</span><br><span class="line">                get.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(qualifier));</span><br><span class="line">                <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> table.get(get);</span><br><span class="line">                <span class="type">byte</span>[] resultValue = result.getValue(Bytes.toBytes(columnFamily), Bytes.toBytes(qualifier));</span><br><span class="line">                <span class="keyword">return</span> Bytes.toString(resultValue);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检索全表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName 表名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ResultScanner <span class="title function_">getScanner</span><span class="params">(String tableName)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">            <span class="type">Scan</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scan</span>();</span><br><span class="line">            <span class="keyword">return</span> table.getScanner(scan);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检索表中指定数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName  表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filterList 过滤器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ResultScanner <span class="title function_">getScanner</span><span class="params">(String tableName, FilterList filterList)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">            <span class="type">Scan</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scan</span>();</span><br><span class="line">            scan.setFilter(filterList);</span><br><span class="line">            <span class="keyword">return</span> table.getScanner(scan);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检索表中指定数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName   表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startRowKey 起始 RowKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> endRowKey   终止 RowKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filterList  过滤器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ResultScanner <span class="title function_">getScanner</span><span class="params">(String tableName, String startRowKey, String endRowKey,</span></span><br><span class="line"><span class="params">                                           FilterList filterList)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">            <span class="type">Scan</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scan</span>();</span><br><span class="line">            scan.withStartRow(Bytes.toBytes(startRowKey));</span><br><span class="line">            scan.withStopRow(Bytes.toBytes(endRowKey));</span><br><span class="line">            scan.setFilter(filterList);</span><br><span class="line">            <span class="keyword">return</span> table.getScanner(scan);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除指定行记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName 表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rowKey    唯一标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">deleteRow</span><span class="params">(String tableName, String rowKey)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">            <span class="type">Delete</span> <span class="variable">delete</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Delete</span>(Bytes.toBytes(rowKey));</span><br><span class="line">            table.delete(delete);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除指定行指定列</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName  表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rowKey     唯一标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> familyName 列族</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> qualifier  列标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">deleteColumn</span><span class="params">(String tableName, String rowKey, String familyName,</span></span><br><span class="line"><span class="params">                                          String qualifier)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">            <span class="type">Delete</span> <span class="variable">delete</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Delete</span>(Bytes.toBytes(rowKey));</span><br><span class="line">            delete.addColumn(Bytes.toBytes(familyName), Bytes.toBytes(qualifier));</span><br><span class="line">            table.delete(delete);</span><br><span class="line">            table.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据库连接"><a href="#数据库连接" class="headerlink" title="数据库连接"></a>数据库连接</h2><p>在上面的代码中，在类加载时就初始化了 Connection 连接，并且之后的方法都是复用这个 Connection，这时我们可能会考虑是否可以使用自定义连接池来获取更好的性能表现？实际上这是没有必要的。</p>
<p>首先官方对于 <code>Connection</code> 的使用说明如下：</p>
<figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Connection Pooling For applications which require high-<span class="keyword">end</span> multithreaded</span><br><span class="line">access (e.g., web-servers <span class="keyword">or</span>  application servers  that may serve many</span><br><span class="line">application threads <span class="keyword">in</span> a single JVM), you can pre-<span class="keyword">create</span> a Connection,</span><br><span class="line"><span class="keyword">as</span> shown <span class="keyword">in</span> the following example:</span><br><span class="line"></span><br><span class="line">对于高并发多线程访问的应用程序（例如，在单个 JVM 中存在的为多个线程服务的 Web 服务器或应用程序服务器），</span><br><span class="line">您只需要预先创建一个 Connection。例子如下：</span><br><span class="line"></span><br><span class="line">// <span class="keyword">Create</span> a connection to the cluster.</span><br><span class="line">Configuration conf = HBaseConfiguration.<span class="keyword">create</span>();</span><br><span class="line">try (Connection connection = ConnectionFactory.createConnectio<span class="meta">n</span>(conf);</span><br><span class="line">     <span class="keyword">Table</span> <span class="keyword">table</span> = connection.getTable(TableName.valueOf(tablename))) &#123;</span><br><span class="line">  // use <span class="keyword">table</span> <span class="keyword">as</span> needed, the <span class="keyword">table</span> returned is lightweight</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之所以能这样使用，这是因为 Connection 并不是一个简单的 socket 连接，<a target="_blank" rel="noopener" href="https://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Connection.html">接口文档</a> 中对 Connection 的表述是：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A <span class="keyword">cluster</span> <span class="keyword">connection</span> encapsulating lower <span class="keyword">level</span> individual connections <span class="keyword">to</span> actual servers <span class="keyword">and</span> a</span><br><span class="line"><span class="keyword">connection</span> <span class="keyword">to</span> zookeeper.  Connections are instantiated through the ConnectionFactory <span class="keyword">class</span>.</span><br><span class="line">The lifecycle <span class="keyword">of</span> the <span class="keyword">connection</span> <span class="keyword">is</span> managed <span class="keyword">by</span> the caller,  who has <span class="keyword">to</span> <span class="keyword">close</span>() the <span class="keyword">connection</span></span><br><span class="line"><span class="keyword">to</span> <span class="keyword">release</span> the resources.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Connection</span> 是一个集群连接，封装了与多台服务器（Matser/Region <span class="keyword">Server</span>）的底层连接以及与 zookeeper 的连接。</span><br><span class="line">连接通过 ConnectionFactory  类实例化。连接的生命周期由调用者管理，调用者必须使用 <span class="keyword">close</span>() 关闭连接以释放资源。</span><br></pre></td></tr></table></figure>

<p>之所以封装这些连接，是因为 HBase 客户端需要连接三个不同的服务角色：</p>
<ul>
<li><strong>Zookeeper</strong> ：主要用于获取 <code>meta</code> 表的位置信息，Master 的信息；</li>
<li><strong>HBase Master</strong> ：主要用于执行 HBaseAdmin 接口的一些操作，例如建表等；</li>
<li><strong>HBase RegionServer</strong> ：用于读、写数据。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20230315202403.png"></p>
<p>Connection 对象和实际的 Socket 连接之间的对应关系如下图：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20230315202426.png"></p>
<p>在 HBase 客户端代码中，真正对应 Socket 连接的是 <code>RpcConnection</code> 对象。HBase 使用 <code>PoolMap</code> 这种数据结构来存储客户端到 HBase 服务器之间的连接。<code>PoolMap</code> 的内部有一个 <code>ConcurrentHashMap</code> 实例，其 key 是 <code>ConnectionId</code>(封装了服务器地址和用户 ticket)，value 是一个 <code>RpcConnection</code> 对象的资源池。当 HBase 需要连接一个服务器时，首先会根据 <code>ConnectionId</code> 找到对应的连接池，然后从连接池中取出一个连接对象。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@InterfaceAudience.Private</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">PoolMap</span>&lt;<span class="symbol">K, <span class="symbol">V</span></span>&gt; <span class="symbol">implements</span> <span class="symbol">Map</span>&lt;<span class="symbol">K, <span class="symbol">V</span></span>&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> PoolType poolType;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="built_in">int</span> poolMaxSize;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Map&lt;K, Pool&lt;V&gt;&gt; pools = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> PoolMap(PoolType poolType) &#123;</span><br><span class="line">    <span class="keyword">this</span>.poolType = poolType;</span><br><span class="line">  &#125;</span><br><span class="line">  .....</span><br></pre></td></tr></table></figure>

<p>HBase 中提供了三种资源池的实现，分别是 <code>Reusable</code>，<code>RoundRobin</code> 和 <code>ThreadLocal</code>。具体实现可以通 <code>hbase.client.ipc.pool.type</code> 配置项指定，默认为 <code>Reusable</code>。连接池的大小也可以通过 <code>hbase.client.ipc.pool.size</code> 配置项指定，默认为 1，即每个 Server 1 个连接。也可以通过修改配置实现：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">config</span><span class="meta">.set</span>(<span class="string">&quot;hbase.client.ipc.pool.type&quot;</span>,...);</span><br><span class="line"><span class="built_in">config</span><span class="meta">.set</span>(<span class="string">&quot;hbase.client.ipc.pool.size&quot;</span>,...);</span><br><span class="line">connection = ConnectionFactory.createConnection(<span class="built_in">config</span>);</span><br></pre></td></tr></table></figure>

<p>由此可以看出 HBase 中 Connection 类已经实现了对连接的管理功能，所以我们不必在 Connection 上在做额外的管理。</p>
<p>另外，Connection 是线程安全的，但 Table 和 Admin 却不是线程安全的，因此正确的做法是一个进程共用一个 Connection 对象，而在不同的线程中使用单独的 Table 和 Admin 对象。Table 和 Admin 的获取操作 <code>getTable()</code> 和 <code>getAdmin()</code> 都是轻量级，所以不必担心性能的消耗，同时建议在使用完成后显示的调用 <code>close()</code> 方法来关闭它们。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>HBase 的主要客户端操作是由 <code>org.apache.hadoop.hbase.client.HTable</code> 提供的。创建 HTable 实例非常耗时，所以，建议每个线程只创建一次 HTable 实例。</p>
<p>HBase 所有修改数据的操作都保证了行级别的原子性。要么读到最新的修改，要么等待系统允许写入改行修改</p>
<p>用户要尽量使用批处理(batch)更新来减少单独操作同一行数据的次数</p>
<p>写操作中设计的列的数目并不会影响该行数据的原子性，行原子性会同时保护到所有列</p>
<p>创建 HTable 实例（指的是在 java 中新建该类），每个实例都要扫描.META. 表，以检查该表是否存在，推荐用户只创建一次 HTable 实例，而且是每个线程创建一个</p>
<p>如果用户需要多个 HTable 实例，建议使用 HTablePool 类（类似连接池）</p>
<h2 id="CRUD-操作"><a href="#CRUD-操作" class="headerlink" title="CRUD 操作"></a>CRUD 操作</h2><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p><code>Table</code> 接口提供了两个 <code>put</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写入单行 put</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Put put)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="comment">// 批量写入 put</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">put</span><span class="params">(List&lt;Put&gt; puts)</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<p>Put 类提供了多种构造器方法用来初始化实例。</p>
<p>Put 类还提供了一系列有用的方法：</p>
<p>多个 <code>add</code> 方法：用于添加指定的列数据。</p>
<p><code>has</code> 方法：用于检查是否存在特定的单元格，而不需要遍历整个集合</p>
<p><code>getFamilyMap</code> 方法：可以遍历 Put 实例中每一个可用的 KeyValue 实例</p>
<p>getRow 方法：用于获取 rowkey<br>Put.heapSize() 可以计算当前 Put 实例所需的堆大小，既包含其中的数据，也包含内部数据结构所需的空间</p>
<h4 id="KeyValue-类"><a href="#KeyValue-类" class="headerlink" title="KeyValue 类"></a>KeyValue 类</h4><p>特定单元格的数据以及坐标，坐标包括行键、列族名、列限定符以及时间戳<br><code>KeyValue(byte[] row, int roffset, int rlength, byte[] family, int foffoset, int flength, byte[] qualifier, int qoffset, int qlength, long timestamp, Type type, byte[] value, int voffset, int vlength)</code><br>每一个字节数组都有一个 offset 参数和一个 length 参数，允许用户提交一个已经存在的字节数组进行字节级别操作。<br>行目前来说指的是行键，即 Put 构造器里的 row 参数。</p>
<h4 id="客户端的写缓冲区"><a href="#客户端的写缓冲区" class="headerlink" title="客户端的写缓冲区"></a>客户端的写缓冲区</h4><p>每一个 put 操作实际上都是一个 RPC 操作，它将客户端数据传送到服务器然后返回。</p>
<p>HBase 的 API 配备了一个客户端的写缓冲区，缓冲区负责收集 put 操作，然后调用 RPC 操作一次性将 put 送往服务器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">setAutoFlush</span><span class="params">(<span class="type">boolean</span> autoFlush)</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isAutoFlush</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，客户端缓冲区是禁用的。可以通过 <code>table.setAutoFlush(false)</code> 来激活缓冲区。</p>
<h4 id="Put-列表"><a href="#Put-列表" class="headerlink" title="Put 列表"></a>Put 列表</h4><p>批量提交 <code>put</code> 列表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">put</span><span class="params">(List&lt;Put&gt; puts)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>

<p>注意：批量提交可能会有部分修改失败。</p>
<h4 id="原子性操作-compare-and-set"><a href="#原子性操作-compare-and-set" class="headerlink" title="原子性操作 compare-and-set"></a>原子性操作 compare-and-set</h4><p><code>checkAndPut</code> 方法提供了 CAS 机制来保证 put 操作的原子性。</p>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Result <span class="built_in">get</span>(<span class="built_in">Get</span> get) throws IOException</span><br></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Get(<span class="built_in">byte</span>[] row)</span><br><span class="line">Get(<span class="built_in">byte</span>[] row, RowLock rowLock)</span><br><span class="line"><span class="function">Get <span class="title">addColumn</span>(<span class="params"><span class="built_in">byte</span>[] family, <span class="built_in">byte</span>[] qualifier</span>)</span></span><br><span class="line"><span class="function">Get <span class="title">addFamily</span>(<span class="params"><span class="built_in">byte</span>[] family</span>)</span></span><br></pre></td></tr></table></figure>

<h4 id="Result-类"><a href="#Result-类" class="headerlink" title="Result 类"></a>Result 类</h4><p>当用户使用 <code>get()</code> 方法获取数据，HBase 返回的结果包含所有匹配的单元格数据，这些数据被封装在一个 <code>Result</code> 实例中返回给用户。</p>
<p>Result 类提供的方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] getValue(<span class="type">byte</span>[] family, <span class="type">byte</span>[] qualifier)</span><br><span class="line"><span class="type">byte</span>[] value()</span><br><span class="line"><span class="type">byte</span>[] getRow()</span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span></span><br><span class="line">KeyValue[] raw()</span><br><span class="line">List&lt;KeyValue&gt; <span class="title function_">list</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<h2 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="keyword">delete</span>(<span class="keyword">Delete</span> <span class="keyword">delete</span>) <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Delte(<span class="built_in">byte</span>[] row)</span><br><span class="line">Delete(<span class="built_in">byte</span>[] row, <span class="built_in">long</span> timestamp, RowLock rowLock)</span><br></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Delete <span class="title">deleteFamily</span>(<span class="params"><span class="built_in">byte</span>[] family</span>)</span></span><br><span class="line"><span class="function">Delete <span class="title">deleteFamily</span>(<span class="params"><span class="built_in">byte</span>[] family, <span class="built_in">long</span> timestamp</span>)</span></span><br><span class="line"><span class="function">Delete <span class="title">deleteColumns</span>(<span class="params"><span class="built_in">byte</span>[] family, <span class="built_in">byte</span>[] qualifier</span>)</span></span><br><span class="line"><span class="function">Delete <span class="title">deleteColumn</span>(<span class="params"><span class="built_in">byte</span>[] family, <span class="built_in">byte</span>[] qualifier</span>) <span class="comment">// 只删除最新版本</span></span></span><br></pre></td></tr></table></figure>

<h2 id="批处理操作"><a href="#批处理操作" class="headerlink" title="批处理操作"></a>批处理操作</h2><p>Row 是 Put、Get、Delete 的父类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">batch</span><span class="params">(List&lt;Row&gt; actions, Object[] results)</span> <span class="keyword">throws</span> IOException, InterruptedException</span><br><span class="line">Object <span class="title function_">batch</span><span class="params">(List&lt;Row&gt; actions)</span> <span class="keyword">throws</span> IOException, InterruptedException</span><br></pre></td></tr></table></figure>

<h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><p>region 服务器提供了行锁特性，这个特性保证了只有一个客户端能获取一行数据相应的锁，同时对该行进行修改。</p>
<p>如果不显示指定锁，服务器会隐式加锁。</p>
<h2 id="扫描"><a href="#扫描" class="headerlink" title="扫描"></a>扫描</h2><p>scan，类似数据库系统中的 cursor，利用了 HBase 提供的底层顺序存储的数据结构。</p>
<p>调用 HTable 的 getScanner 就可以返回扫描器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ResultScanner <span class="title function_">getScanner</span><span class="params">(Scan scan)</span> <span class="keyword">throws</span> IOException</span><br><span class="line">ResultScanner <span class="title function_">getScanner</span><span class="params">(<span class="type">byte</span>[] family)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>

<p>Scan 类构造器可以有 startRow，区间一般为 [startRow, stopRow)</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Scan(<span class="built_in">byte</span>[] startRow, Filter filter)</span><br><span class="line">Scan(<span class="built_in">byte</span>[] startRow)</span><br></pre></td></tr></table></figure>

<h3 id="ResultScanner"><a href="#ResultScanner" class="headerlink" title="ResultScanner"></a>ResultScanner</h3><p>以行为单位进行返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Result <span class="title function_">next</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br><span class="line">Result[] next(<span class="type">int</span> nbRows) <span class="keyword">throws</span> IOException</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<h3 id="缓存与批量处理"><a href="#缓存与批量处理" class="headerlink" title="缓存与批量处理"></a>缓存与批量处理</h3><p>每一个 next()调用都会为每行数据生成一个单独的 RPC 请求</p>
<p>可以设置扫描器缓存</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setScannerCaching</span><span class="params">(itn scannerCaching)</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getScannerCaching</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>缓存是面向行一级操作，批量是面向列一级操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setBatch</span><span class="params">(<span class="type">int</span> batch)</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> getBatch</span></span><br></pre></td></tr></table></figure>

<p>RPC 请求的次数&#x3D;(行数*每行列数)&#x2F;Min(每行的列数，批量大小)&#x2F;扫描器缓存</p>
<h2 id="各种特性"><a href="#各种特性" class="headerlink" title="各种特性"></a>各种特性</h2><p><code>Bytes</code> 类提供了一系列将原生 Java 类型和字节数组互转的方法。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://item.jd.com/11321037.html">《HBase 权威指南》</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/larsgeorge/hbase-book">《HBase 权威指南》官方源码</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/0493ff/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/0493ff/" class="post-title-link" itemprop="url">《大规模数据处理实战》笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-15 15:15:07" itemprop="dateCreated datePublished" datetime="2023-03-15T15:15:07+08:00">2023-03-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:53" itemprop="dateModified" datetime="2024-12-12T10:02:53+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AC%94%E8%AE%B0/%E5%A4%A7%E6%95%B0%E6%8D%AE/" itemprop="url" rel="index"><span itemprop="name">大数据</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="《大规模数据处理实战》笔记"><a href="#《大规模数据处理实战》笔记" class="headerlink" title="《大规模数据处理实战》笔记"></a>《大规模数据处理实战》笔记</h1><h2 id="00-丨开篇词丨从这里开始，带你走上硅谷一线系统架构师之路"><a href="#00-丨开篇词丨从这里开始，带你走上硅谷一线系统架构师之路" class="headerlink" title="00 丨开篇词丨从这里开始，带你走上硅谷一线系统架构师之路"></a>00 丨开篇词丨从这里开始，带你走上硅谷一线系统架构师之路</h2><h2 id="01-丨为什么-MapReduce-会被硅谷一线公司淘汰？"><a href="#01-丨为什么-MapReduce-会被硅谷一线公司淘汰？" class="headerlink" title="01 丨为什么 MapReduce 会被硅谷一线公司淘汰？"></a>01 丨为什么 MapReduce 会被硅谷一线公司淘汰？</h2><p>高昂的维护成本</p>
<p>时间性能“达不到”用户的期待</p>
<h2 id="02-MapReduce-后谁主沉浮：怎样设计下一代数据处理技术？"><a href="#02-MapReduce-后谁主沉浮：怎样设计下一代数据处理技术？" class="headerlink" title="02 | MapReduce 后谁主沉浮：怎样设计下一代数据处理技术？"></a>02 | MapReduce 后谁主沉浮：怎样设计下一代数据处理技术？</h2><h2 id="03-大规模数据处理初体验：怎样实现大型电商热销榜？"><a href="#03-大规模数据处理初体验：怎样实现大型电商热销榜？" class="headerlink" title="03 | 大规模数据处理初体验：怎样实现大型电商热销榜？"></a>03 | 大规模数据处理初体验：怎样实现大型电商热销榜？</h2><p>不同量级 TOP K 算法的解决方案不同：</p>
<p>小规模：Hash 即可</p>
<p>大规模：由于单机的处理量不足以处理全量数据，势必分而治之：分片统计，然后聚合（即先 map 后 reduce）</p>
<h2 id="04-丨分布式系统（上）：学会用服务等级协议-SLA-来评估你的系统"><a href="#04-丨分布式系统（上）：学会用服务等级协议-SLA-来评估你的系统" class="headerlink" title="04 丨分布式系统（上）：学会用服务等级协议 SLA 来评估你的系统"></a>04 丨分布式系统（上）：学会用服务等级协议 SLA 来评估你的系统</h2><p>SLA（Service-Level Agreement），也就是服务等级协议，指的是系统服务提供者（Provider）对客户（Customer）的一个服务承诺。</p>
<p>可用性：大厂一般要求可用性至少达到四个 9（即 99.99%）</p>
<p>准确性：准确率&#x3D; 正确的有效请求数 &#x2F; 有效的总请求数</p>
<p>系统容量：通常通过 QPS （Queries Per Second）来衡量</p>
<p>延迟：请求和响应的时间间隔</p>
<h2 id="05-丨分布式系统（下）：架构师不得不知的三大指标"><a href="#05-丨分布式系统（下）：架构师不得不知的三大指标" class="headerlink" title="05 丨分布式系统（下）：架构师不得不知的三大指标"></a>05 丨分布式系统（下）：架构师不得不知的三大指标</h2><ul>
<li>可扩展性（Scalability）<ul>
<li>水平扩展（Horizontal Scaling）</li>
<li>垂直扩展（Vertical Scaling）</li>
</ul>
</li>
<li>一致性（Consistency）<ul>
<li>强一致性（Strong Consistency）：系统中的某个数据被成功更新后，后续任何对该数据的读取操作都将得到更新<br>后的值。所以在任意时刻，同一系统所有节点中的数据是一样的。</li>
<li>弱一致性（Weak Consistency）：系统中的某个数据被更新后，后续对该数据的读取操作可能得到更新后的值，<br>也可能是更改前的值。但经过“不一致时间窗口”这段时间后，后续对该数据的读取都是更新后的值。</li>
<li>最终一致性（Eventual Consistency）：是弱一致性的特殊形式。存储系统保证，在没有新的更新的条件下，最终所有的访问都是最后更新的值。</li>
</ul>
</li>
<li>持久性（Data Durability）：意味着数据一旦被成功存储就可以一直继续使用，即使系统中的节点下线、宕机或数据损坏也是如。</li>
</ul>
<h2 id="06-如何区分批处理还是流处理？"><a href="#06-如何区分批处理还是流处理？" class="headerlink" title="06 | 如何区分批处理还是流处理？"></a>06 | 如何区分批处理还是流处理？</h2><ul>
<li>无边界数据（Unbounded Data）：是一种不断增长，可以说是无限的数据集。</li>
<li>有边界数据（Bounded Data）：是一种有限的数据集。</li>
<li>事件时间（Event Time）：指的是一个数据实际产生的时间点。</li>
<li>处理时间（Precessing Time）：指的是处理数据的系统架构实际接收到这个数据的时间点。</li>
<li>批处理：绝大部分情况下，批处理的输入数据都是有边界数据，同样的，输出结果也一样是有边界数据。所以在批处理中，我们所关心的更多会是数据的事件时间。<ul>
<li>应用场景：<ul>
<li>日志分析：日志系统是在一定时间段（日，周或年）内收集的，而日志的数据处理分析是在不同的时间内执行，以得出有关系统的一些关键性能指标。</li>
<li>计费应用程序：计费应用程序会计算出一段时间内一项服务的使用程度，并生成计费信息，例如银行在每个月末生成的信用卡还款单。</li>
<li>数据仓库：数据仓库的主要目标是根据收集好的数据事件时间，将数据信息合并为静态快照 （static snapshot），并将它们聚合为每周、每月、每季度的报告等。</li>
</ul>
</li>
</ul>
</li>
<li>流处理：流处理的输入数据基本上都是无边界数据。<ul>
<li>应用场景<ul>
<li>实时监控：捕获和分析各种来源发布的数据，如传感器，新闻源，点击网页等。</li>
<li>实时商业智能：智能汽车，智能家居，智能病人护理等。</li>
<li>销售终端（POS）系统：像是股票价格的更新，允许用户实时完成付款的系统等。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="07-Workflow-设计模式：让你在大规模数据世界中君临天下"><a href="#07-Workflow-设计模式：让你在大规模数据世界中君临天下" class="headerlink" title="07 | Workflow 设计模式：让你在大规模数据世界中君临天下"></a>07 | Workflow 设计模式：让你在大规模数据世界中君临天下</h2><p>略</p>
<h2 id="08-发布-订阅模式：流处理架构中的瑞士军刀"><a href="#08-发布-订阅模式：流处理架构中的瑞士军刀" class="headerlink" title="08 | 发布&#x2F;订阅模式：流处理架构中的瑞士军刀"></a>08 | 发布&#x2F;订阅模式：流处理架构中的瑞士军刀</h2><p>略</p>
<h2 id="09-丨-CAP-定理：三选二，架构师必须学会的取舍"><a href="#09-丨-CAP-定理：三选二，架构师必须学会的取舍" class="headerlink" title="09 丨 CAP 定理：三选二，架构师必须学会的取舍"></a>09 丨 CAP 定理：三选二，架构师必须学会的取舍</h2><p>略</p>
<h2 id="10-丨-Lambda-架构：Twitter-亿级实时数据分析架构背后的倚天剑"><a href="#10-丨-Lambda-架构：Twitter-亿级实时数据分析架构背后的倚天剑" class="headerlink" title="10 丨 Lambda 架构：Twitter 亿级实时数据分析架构背后的倚天剑"></a>10 丨 Lambda 架构：Twitter 亿级实时数据分析架构背后的倚天剑</h2><p>Lambda 架构总共由三层系统组成：批处理层（Batch Layer），速度处理层（Speed Layer），以及用于响应查询的服务层（Serving Layer）。</p>
<h2 id="11-丨-Kappa-架构：利用-Kafka-锻造的屠龙刀"><a href="#11-丨-Kappa-架构：利用-Kafka-锻造的屠龙刀" class="headerlink" title="11 丨 Kappa 架构：利用 Kafka 锻造的屠龙刀"></a>11 丨 Kappa 架构：利用 Kafka 锻造的屠龙刀</h2><p>略</p>
<h2 id="12-我们为什么需要-Spark？"><a href="#12-我们为什么需要-Spark？" class="headerlink" title="12 | 我们为什么需要 Spark？"></a>12 | 我们为什么需要 Spark？</h2><p>MapReduce 的缺点：</p>
<ul>
<li>高昂的维护成本</li>
<li>时间性能“达不到”用户的期待</li>
<li>MapReduce 模型的抽象层次低</li>
<li>只提供 Map 和 Reduce 两个操作</li>
<li>在 Hadoop 中，每一个 Job 的计算结果都会存储在 HDFS 文件存储系统中，所以每一步计算都要进行硬盘的读取和写入，大大增加了系统的延迟。</li>
<li>只支持批处理</li>
</ul>
<p>Spark 的优点</p>
<ul>
<li>性能比 MapReduce 高很多</li>
<li>Spark 提供了很多对 RDD 的操作，如 Map、Filter、flatMap、groupByKey 和 Union 等等，极大地提升了对各种复杂场景的支持</li>
</ul>
<h2 id="13-丨弹性分布式数据集：Spark-大厦的地基（上）"><a href="#13-丨弹性分布式数据集：Spark-大厦的地基（上）" class="headerlink" title="13 丨弹性分布式数据集：Spark 大厦的地基（上）"></a>13 丨弹性分布式数据集：Spark 大厦的地基（上）</h2><p>Spark 最基本的数据抽象是弹性分布式数据集（Resilient Distributed Dataset）</p>
<p>RDD 表示已被分区、不可变的，并能够被并行操作的数据集合。</p>
<h2 id="14-丨弹性分布式数据集：Spark-大厦的地基（下）"><a href="#14-丨弹性分布式数据集：Spark-大厦的地基（下）" class="headerlink" title="14 丨弹性分布式数据集：Spark 大厦的地基（下）"></a>14 丨弹性分布式数据集：Spark 大厦的地基（下）</h2><h2 id="15-丨-SparkSQL：Spark-数据查询的利器"><a href="#15-丨-SparkSQL：Spark-数据查询的利器" class="headerlink" title="15 丨 SparkSQL：Spark 数据查询的利器"></a>15 丨 SparkSQL：Spark 数据查询的利器</h2><h2 id="16-Spark-Streaming：Spark-的实时流计算-API"><a href="#16-Spark-Streaming：Spark-的实时流计算-API" class="headerlink" title="16 | Spark Streaming：Spark 的实时流计算 API"></a>16 | Spark Streaming：Spark 的实时流计算 API</h2><p>Spark Streaming 用时间片拆分了无限的数据流，然后对每一个数据片用类似于批处理的方法进行处理，输出的数据也是一块一块的</p>
<h2 id="17-Structured-Streaming：如何用-DataFrame-API-进行实时数据分析"><a href="#17-Structured-Streaming：如何用-DataFrame-API-进行实时数据分析" class="headerlink" title="17 | Structured Streaming：如何用 DataFrame API 进行实时数据分析?"></a>17 | Structured Streaming：如何用 DataFrame API 进行实时数据分析?</h2><h2 id="18-丨-WordCount：从零开始运行你的第一个-Spark-应用"><a href="#18-丨-WordCount：从零开始运行你的第一个-Spark-应用" class="headerlink" title="18 丨 WordCount：从零开始运行你的第一个 Spark 应用"></a>18 丨 WordCount：从零开始运行你的第一个 Spark 应用</h2><h2 id="19-丨综合案例实战：处理加州房屋信息，构建线性回归模型"><a href="#19-丨综合案例实战：处理加州房屋信息，构建线性回归模型" class="headerlink" title="19 丨综合案例实战：处理加州房屋信息，构建线性回归模型"></a>19 丨综合案例实战：处理加州房屋信息，构建线性回归模型</h2><h2 id="20-丨流处理案例实战：分析纽约市出租车载客信息"><a href="#20-丨流处理案例实战：分析纽约市出租车载客信息" class="headerlink" title="20 丨流处理案例实战：分析纽约市出租车载客信息"></a>20 丨流处理案例实战：分析纽约市出租车载客信息</h2><hr>
<p>读到此处，感觉收获甚少，暂时搁置阅读。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100025301">大规模数据处理实战</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/fa4495/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/fa4495/" class="post-title-link" itemprop="url">《从 0 开始学大数据》笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-13 17:01:51" itemprop="dateCreated datePublished" datetime="2023-03-13T17:01:51+08:00">2023-03-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:53" itemprop="dateModified" datetime="2024-12-12T10:02:53+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AC%94%E8%AE%B0/%E5%A4%A7%E6%95%B0%E6%8D%AE/" itemprop="url" rel="index"><span itemprop="name">大数据</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>11 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="《从-0-开始学大数据》笔记"><a href="#《从-0-开始学大数据》笔记" class="headerlink" title="《从 0 开始学大数据》笔记"></a>《从 0 开始学大数据》笔记</h1><h2 id="预习模块"><a href="#预习模块" class="headerlink" title="预习模块"></a>预习模块</h2><h3 id="01-丨预习-01-丨大数据技术发展史：大数据的前世今生"><a href="#01-丨预习-01-丨大数据技术发展史：大数据的前世今生" class="headerlink" title="01 丨预习 01 丨大数据技术发展史：大数据的前世今生"></a>01 丨预习 01 丨大数据技术发展史：大数据的前世今生</h3><p>大数据技术，起源于 Google 在 2004 年前后发表的三篇论文：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/gfs-sosp2003.pdf">The Google File System</a></li>
<li><a target="_blank" rel="noopener" href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/bigtable-osdi06.pdf">Bigtable: A Distributed Storage System for Structured Data</a></li>
<li><a target="_blank" rel="noopener" href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/mapreduce-osdi04.pdf">MapReduce: Simplified Data Processing on Large Clusters</a></li>
</ul>
<p>Doug Cutting 根据 Google 论文开发了 Hadoop。</p>
<p>大数据处理的主要应用场景包括数据分析、数据挖掘与机器学习。</p>
<p>数据分析主要使用 Hive、Spark SQL 等 SQL 引擎完成；</p>
<p>数据挖掘与机器学习则有专门的机器学习框架 TensorFlow、Mahout 以及 MLlib 等，内置了主要的机器学习和数据挖掘算法。</p>
<p>大数据要存入分布式文件系统（HDFS），要有序调度 MapReduce 和 Spark 作业执行，并能把执行结果写入到各个应用系统的数据库中，还需要有一个大数据平台整合所有这些大数据组件和企业应用系统。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20230223134708.png"></p>
<h3 id="02-丨预习-02-丨大数据应用发展史：从搜索引擎到人工智能"><a href="#02-丨预习-02-丨大数据应用发展史：从搜索引擎到人工智能" class="headerlink" title="02 丨预习 02 丨大数据应用发展史：从搜索引擎到人工智能"></a>02 丨预习 02 丨大数据应用发展史：从搜索引擎到人工智能</h3><p>大数据的应用领域：</p>
<ul>
<li><strong>搜索引擎</strong>：GFS 和 MapReduce 开启了超大规模的分布式存储和分布式计算应用。</li>
<li><strong>数据仓库</strong>：Hive 实现了用更低廉的价格获得比以往多得多的数据存储与计算能力。</li>
<li><strong>数据挖掘</strong>：基于海量数据进行关联分析。应用有：关联推荐、用户画像、关系图谱</li>
<li><strong>机器学习</strong>：有了大数据，可以把全部的历史数据都收集起来，统计其规律，进而预测正在发生的事情。</li>
</ul>
<h3 id="03-丨预习-03-丨大数据应用领域：数据驱动一切"><a href="#03-丨预习-03-丨大数据应用领域：数据驱动一切" class="headerlink" title="03 丨预习 03 丨大数据应用领域：数据驱动一切"></a>03 丨预习 03 丨大数据应用领域：数据驱动一切</h3><p>大数据的行业应用：</p>
<ul>
<li>医疗健康领域<ul>
<li>医学影像智能识别</li>
<li>病历大数据智能诊疗</li>
</ul>
</li>
<li>教育领域<ul>
<li>AI 外语老师</li>
<li>智能解题</li>
</ul>
</li>
<li>社交媒体领域：舆情监控与分析</li>
<li>金融领域：大数据风控</li>
<li>新零售领域：全链路管理</li>
<li>交通领域<ul>
<li>实时采集监控数据</li>
<li>判断道路拥堵状态</li>
<li>无人驾驶技术</li>
</ul>
</li>
</ul>
<h2 id="模块一、Hadoop-大数据原理与架构"><a href="#模块一、Hadoop-大数据原理与架构" class="headerlink" title="模块一、Hadoop 大数据原理与架构"></a>模块一、Hadoop 大数据原理与架构</h2><h3 id="04-移动计算比移动数据更划算"><a href="#04-移动计算比移动数据更划算" class="headerlink" title="04 | 移动计算比移动数据更划算"></a>04 | 移动计算比移动数据更划算</h3><p>传统计算模型：输入 -&gt; 计算 -&gt; 输出，面对海量数据（TB 级甚至 PB 级），无法应对。</p>
<p>移动计算将程序分发到数据所在的地方进行计算，也就是所谓的移动计算比移动数据更划算。</p>
<p>移动计算步骤：</p>
<ol>
<li>将待处理的大规模数据存储在服务器集群的所有服务器上，主要使用 HDFS 分布式文件存储系统，将文件分成很多块（Block），以块为单位存储在集群的服务器上。</li>
<li>大数据引擎根据集群里不同服务器的计算能力，在每台服务器上启动若干分布式任务执行进程，这些进程会等待给它们分配执行任务。</li>
<li>使用大数据计算框架支持的编程模型进行编程，比如 Hadoop 的 MapReduce 编程模型，或者 Spark 的 RDD 编程模型。应用程序编写好以后，将其打包，MapReduce 和 Spark 都是在 JVM 环境中运行，所以打包出来的是一个 Java 的 JAR 包。</li>
<li>用 Hadoop 或者 Spark 的启动命令执行这个应用程序的 JAR 包，首先执行引擎会解析程序要处理的数据输入路径，根据输入数据量的大小，将数据分成若干片（Split），每一个数据片都分配给一个任务执行进程去处理。</li>
<li>任务执行进程收到分配的任务后，检查自己是否有任务对应的程序包，如果没有就去下载程序包，下载以后通过反射的方式加载程序。走到这里，最重要的一步，也就是移动计算就完成了。</li>
<li>加载程序后，任务执行进程根据分配的数据片的文件地址和数据在文件内的偏移量读取数据，并把数据输入给应用程序相应的方法</li>
</ol>
<h3 id="05-从-RAID-看垂直伸缩到水平伸缩的演化"><a href="#05-从-RAID-看垂直伸缩到水平伸缩的演化" class="headerlink" title="05 | 从 RAID 看垂直伸缩到水平伸缩的演化"></a>05 | 从 RAID 看垂直伸缩到水平伸缩的演化</h3><p>海量数据存储核心问题</p>
<ul>
<li>数据存储容量的问题。既然大数据要解决的是数以 PB 计的数据计算问题，而一般的服务器磁盘容量通常 1 ～ 2TB，那么如何存储这么大规模的数据呢？</li>
<li>数据读写速度的问题。一般磁盘的连续读写速度为几十 MB，以这样的速度，几十 PB 的数据恐怕要读写到天荒地老。</li>
<li>数据可靠性的问题。磁盘大约是计算机设备中最易损坏的硬件了，通常情况一块磁盘使用寿命大概是一年，如果磁盘损坏了，数据怎么办？</li>
</ul>
<p>解决方式是 RAID 技术：</p>
<ul>
<li>数据存储容量的问题。RAID 使用了 N 块磁盘构成一个存储阵列，如果使用 RAID 5，数据就可以存储在 N-1 块磁盘上，这样将存储空间扩大了 N-1 倍。</li>
<li>数据读写速度的问题。RAID 根据可以使用的磁盘数量，将待写入的数据分成多片，并发同时向多块磁盘进行写入，显然写入的速度可以得到明显提高；同理，读取速度也可以得到明显提高。不过，需要注意的是，由于传统机械磁盘的访问延迟主要来自于寻址时间，数据真正进行读写的时间可能只占据整个数据访问时间的一小部分，所以数据分片后对 N 块磁盘进行并发读写操作并不能将访问速度提高 N 倍。</li>
<li>数据可靠性的问题。使用 RAID 10、RAID 5 或者 RAID 6 方案的时候，由于数据有冗余存储，或者存储校验信息，所以当某块磁盘损坏的时候，可以通过其他磁盘上的数据和校验数据将丢失磁盘上的数据还原。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20230224131454.png"></p>
<p>实现更强的计算能力和更大规模的数据存储有两种思路</p>
<ul>
<li>垂直伸缩（scaling up），即硬件升级</li>
<li>水平伸缩（scaling out），即分布式系统</li>
</ul>
<p>注：RAID 技术就是采用了垂直伸缩的方式。</p>
<h3 id="06-新技术层出不穷，HDFS-依然是存储的王者"><a href="#06-新技术层出不穷，HDFS-依然是存储的王者" class="headerlink" title="06 | 新技术层出不穷，HDFS 依然是存储的王者"></a>06 | 新技术层出不穷，HDFS 依然是存储的王者</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/bigdata/hdfs/hdfs-architecture.png" alt="img"></p>
<p>HDFS 有两个关键组件：DataNode 和 NameNode：</p>
<ul>
<li>DataNode 负责文件数据的存储和读写操作，HDFS 将文件数据分割成若干数据块（Block），每个 DataNode 存储一部分数据块，这样文件就分布存储在整个 HDFS 服务器集群中。应用程序客户端（Client）可以并行对这些数据块进行访问，从而使得 HDFS 可以在服务器集群规模上实现数据并行访问，极大地提高了访问速度。</li>
<li>NameNode 负责整个分布式文件系统的元数据（MetaData）管理，也就是文件路径名、数据块的 ID 以及存储位置等信息，相当于操作系统中文件分配表（FAT）的角色。</li>
</ul>
<p>为保证高可用，HDFS 会，会将一个数据块复制为多份（默认为 3 份），并将多份相同的数据块存储在不同的服务器上，甚至不同的机架上。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200224203958.png" alt="img"></p>
<p>HDFS 故障容错：</p>
<ul>
<li><strong>数据存储故障容错</strong><ul>
<li>对于 DataNode 上的数据块进行计算并存储校验和（CheckSum）</li>
<li>读取数据的时候，重新计算读取出来的数据的校验和，校验和不正确，则抛出异常</li>
<li>发现异常后，从其他 DataNode 读取备份</li>
</ul>
</li>
<li><strong>磁盘故障容错</strong><ul>
<li>如果 DataNode 监测到本机磁盘损坏，将该磁盘的所有数据块 ID 报告给 NameNode</li>
<li>NameNode 检查这些数据块在哪些 DataNode 上有备份，复制一份到其他 DataNode 上</li>
</ul>
</li>
<li><strong>DataNode 故障容错</strong><ul>
<li>DataNode 会通过心跳和 NameNode 保持通信</li>
<li>如果 DataNode 超时未发送心跳，NameNode 视其为宕机</li>
<li>NameNode 查找这个 DataNode 存储的所有数据块，复制一份到其他 DataNode 上</li>
</ul>
</li>
<li><strong>NameNode 故障容错</strong><ul>
<li>基于 ZooKeeper 实现主从备份</li>
<li>争夺 znode 锁</li>
</ul>
</li>
</ul>
<h3 id="07-为什么说-MapReduce-既是编程模型又是计算框架？"><a href="#07-为什么说-MapReduce-既是编程模型又是计算框架？" class="headerlink" title="07 | 为什么说 MapReduce 既是编程模型又是计算框架？"></a>07 | 为什么说 MapReduce 既是编程模型又是计算框架？</h3><p><strong>MapReduce 既是编程模型，又是计算框架</strong>。</p>
<p>MapReduce 编程模型只包含 Map 和 Reduce 两个过程，map 的主要输入是一对 <code>&lt;Key, Value&gt;</code> 值，经过 map 计算后输出一对 <code>&lt;Key, Value&gt;</code> 值；然后将相同 Key 合并，形成 <code>&lt;Key, Value 集合&gt;</code>；再将这个 <code>&lt;Key, Value 集合&gt;</code> 输入 reduce，经过计算输出零个或多个 <code>&lt;Key, Value&gt;</code> 对。</p>
<h3 id="08-MapReduce-如何让数据完成一次旅行？"><a href="#08-MapReduce-如何让数据完成一次旅行？" class="headerlink" title="08 | MapReduce 如何让数据完成一次旅行？"></a>08 | MapReduce 如何让数据完成一次旅行？</h3><h4 id="MapReduce-作业启动和运行机制"><a href="#MapReduce-作业启动和运行机制" class="headerlink" title="MapReduce 作业启动和运行机制"></a>MapReduce 作业启动和运行机制</h4><p>大数据应用进程。这类进程是启动 MapReduce 程序的主入口，主要是指定 Map 和 Reduce 类、输入输出文件路径等，并提交作业给 Hadoop 集群，也就是下面提到的 JobTracker 进程。这是由用户启动的 MapReduce 程序进程，比如我们上期提到的 WordCount 程序。</p>
<p>JobTracker 进程。这类进程根据要处理的输入数据量，命令下面提到的 TaskTracker 进程启动相应数量的 Map 和 Reduce 进程任务，并管理整个作业生命周期的任务调度和监控。这是 Hadoop 集群的常驻进程，需要注意的是，JobTracker 进程在整个 Hadoop 集群全局唯一。</p>
<p>TaskTracker 进程。这个进程负责启动和管理 Map 进程以及 Reduce 进程。因为需要每个数据块都有对应的 map 函数，TaskTracker 进程通常和 HDFS 的 DataNode 进程启动在同一个服务器。也就是说，Hadoop 集群中绝大多数服务器同时运行 DataNode 进程和 TaskTracker 进程。</p>
<h4 id="MapReduce-数据合并与连接机制"><a href="#MapReduce-数据合并与连接机制" class="headerlink" title="MapReduce 数据合并与连接机制"></a>MapReduce 数据合并与连接机制</h4><p>在 map 输出与 reduce 输入之间，MapReduce 计算框架处理数据合并与连接操作，这个操作有个专门的词汇叫 shuffle。分布式计算需要将不同服务器上的相关数据合并到一起进行下一步计算，这就是 shuffle。</p>
<h3 id="09-为什么我们管-Yarn-叫作资源调度框架？"><a href="#09-为什么我们管-Yarn-叫作资源调度框架？" class="headerlink" title="09 | 为什么我们管 Yarn 叫作资源调度框架？"></a>09 | 为什么我们管 Yarn 叫作资源调度框架？</h3><p>服务器集群资源调度管理和 MapReduce 执行过程耦合在一起，如果想在当前集群中运行其他计算任务，比如 Spark 或者 Storm，就无法统一使用集群中的资源了。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20230227195344.png"></p>
<p>Yarn 包括两个部分：</p>
<p>ResourceManager 进程负责整个集群的资源调度管理，通常部署在独立的服务器上；</p>
<p>NodeManager 进程负责具体服务器上的资源和任务管理，在集群的每一台计算服务器上都会启动，基本上跟 HDFS 的 DataNode 进程一起出现。</p>
<p>Yarn 的工作流程</p>
<ol>
<li>我们向 Yarn 提交应用程序，包括 MapReduce ApplicationMaster、我们的 MapReduce 程序，以及 MapReduce Application 启动命令。</li>
<li>ResourceManager 进程和 NodeManager 进程通信，根据集群资源，为用户程序分配第一个容器，并将 MapReduce ApplicationMaster 分发到这个容器上面，并在容器里面启动 MapReduce ApplicationMaster。</li>
<li>MapReduce ApplicationMaster 启动后立即向 ResourceManager 进程注册，并为自己的应用程序申请容器资源。</li>
<li>MapReduce ApplicationMaster 申请到需要的容器后，立即和相应的 NodeManager 进程通信，将用户 MapReduce 程序分发到 NodeManager 进程所在服务器，并在容器中运行，运行的就是 Map 或者 Reduce 任务。</li>
<li>Map 或者 Reduce 任务在运行期和 MapReduce ApplicationMaster 通信，汇报自己的运行状态，如果运行结束，MapReduce ApplicationMaster 向 ResourceManager 进程注销并释放所有的容器资源。</li>
</ol>
<h3 id="10-模块答疑：我们能从-Hadoop-学到什么？"><a href="#10-模块答疑：我们能从-Hadoop-学到什么？" class="headerlink" title="10 | 模块答疑：我们能从 Hadoop 学到什么？"></a>10 | 模块答疑：我们能从 Hadoop 学到什么？</h3><p>Hadoop 几个主要产品的架构设计，就会发现它们都有相似性，都是一主多从的架构方案。</p>
<ul>
<li>HDFS，一个 NameNode，多个 DataNode；</li>
<li>MapReduce，一个 JobTracker，多个 TaskTracker；</li>
<li>Yarn，一个 ResourceManager，多个 NodeManager。</li>
</ul>
<p>事实上，很多大数据产品都是这样的架构方案：</p>
<p>Storm，一个 Nimbus，多个 Supervisor；</p>
<p>Spark，一个 Master，多个 Slave。</p>
<p>大数据因为要对数据和计算任务进行统一管理，所以和互联网在线应用不同，需要一个全局管理者。一言以蔽之：<strong>集中管理，分布存储与计算</strong></p>
<h2 id="模块二、大数据生态体系主要产品原理与架构"><a href="#模块二、大数据生态体系主要产品原理与架构" class="headerlink" title="模块二、大数据生态体系主要产品原理与架构"></a>模块二、大数据生态体系主要产品原理与架构</h2><h3 id="11-Hive-是如何让-MapReduce-实现-SQL-操作的？"><a href="#11-Hive-是如何让-MapReduce-实现-SQL-操作的？" class="headerlink" title="11 | Hive 是如何让 MapReduce 实现 SQL 操作的？"></a>11 | Hive 是如何让 MapReduce 实现 SQL 操作的？</h3><p>Hive 能够直接处理我们输入的 SQL 语句（Hive 的 SQL 语法和数据库标准 SQL 略有不同），调用 MapReduce 计算框架完成数据分析操作。</p>
<p>我们通过 Hive 的 Client（Hive 的命令行工具，JDBC 等）向 Hive 提交 SQL 命令。如果是创建数据表的 DDL（数据定义语言），Hive 就会通过执行引擎 Driver 将数据表的信息记录在 Metastore 元数据组件中，这个组件通常用一个关系数据库实现，记录表名、字段名、字段类型、关联 HDFS 文件路径等这些数据库的 Meta 信息（元信息）。</p>
<p>如果我们提交的是查询分析数据的 DQL（数据查询语句），Driver 就会将该语句提交给自己的编译器 Compiler 进行语法分析、语法解析、语法优化等一系列操作，最后生成一个 MapReduce 执行计划。然后根据执行计划生成一个 MapReduce 的作业，提交给 Hadoop MapReduce 计算框架处理。</p>
<h3 id="12-我们并没有觉得-MapReduce-速度慢，直到-Spark-出现"><a href="#12-我们并没有觉得-MapReduce-速度慢，直到-Spark-出现" class="headerlink" title="12 | 我们并没有觉得 MapReduce 速度慢，直到 Spark 出现"></a>12 | 我们并没有觉得 MapReduce 速度慢，直到 Spark 出现</h3><p>RDD 是 Spark 的核心概念，是弹性数据集（Resilient Distributed Datasets）的缩写。RDD 既是 Spark 面向开发者的编程模型，又是 Spark 自身架构的核心元素。</p>
<p>Spark 上编写 WordCount 程序，主要代码只需要三行</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> textFile = sc.textFile(<span class="string">&quot;hdfs://...&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> counts = textFile.flatMap(line =&gt; line.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">.map(word =&gt; (word, <span class="number">1</span>))</span><br><span class="line">.reduceByKey(_ + _)</span><br><span class="line">counts.saveAsTextFile(<span class="string">&quot;hdfs://...&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>MapReduce 针对输入数据，将计算过程分为两个阶段，一个 Map 阶段，一个 Reduce 阶段，可以理解成是面向过程的大数据计算。</p>
<p>而 Spark 则直接针对数据进行编程，将大规模数据集合抽象成一个 RDD 对象，然后在这个 RDD 上进行各种计算处理，得到一个新的 RDD，继续计算处理，直到得到最后的结果数据。所以 Spark 可以理解成是面向对象的大数据计算。</p>
<p>RDD 上定义的函数分两种，一种是转换（transformation）函数，这种函数的返回值还是 RDD；另一种是执行（action）函数，这种函数不再返回 RDD。</p>
<p>RDD 定义了很多转换操作函数，比如有计算 map(func)、过滤 filter(func)、合并数据集 union(otherDataset)、根据 Key 聚合 reduceByKey(func, [numPartitions])、连接数据集 join(otherDataset, [numPartitions])、分组 groupByKey([numPartitions]) 等十几个函数。</p>
<h3 id="13-同样的本质，为何-Spark-可以更高效？"><a href="#13-同样的本质，为何-Spark-可以更高效？" class="headerlink" title="13 | 同样的本质，为何 Spark 可以更高效？"></a>13 | 同样的本质，为何 Spark 可以更高效？</h3><p>Spark 有三个主要特性：RDD 的编程模型更简单，DAG 切分的多阶段计算过程更快速，使用内存存储中间计算结果更高效。这三个特性使得 Spark 相对 Hadoop MapReduce 可以有更快的执行速度，以及更简单的编程实现。</p>
<h3 id="14-BigTable-的开源实现：HBase"><a href="#14-BigTable-的开源实现：HBase" class="headerlink" title="14 | BigTable 的开源实现：HBase"></a>14 | BigTable 的开源实现：HBase</h3><h4 id="HBase-可伸缩架构"><a href="#HBase-可伸缩架构" class="headerlink" title="HBase 可伸缩架构"></a>HBase 可伸缩架构</h4><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20230303145832.png"></p>
<p>HBase 的伸缩性主要依赖其可分裂的 HRegion 及可伸缩的分布式文件系统 HDFS 实现。</p>
<p>HRegion 是 HBase 负责数据存储的主要进程，应用程序对数据的读写操作都是通过和 HRegion 通信完成。上面是 HBase 架构图，我们可以看到在 HBase 中，数据以 HRegion 为单位进行管理，也就是说应用程序如果想要访问一个数据，必须先找到 HRegion，然后将数据读写操作提交给 HRegion，由 HRegion 完成存储层面的数据操作。</p>
<p>HRegionServer 是物理服务器，每个 HRegionServer 上可以启动多个 HRegion 实例。当一个 HRegion 中写入的数据太多，达到配置的阈值时，一个 HRegion 会分裂成两个 HRegion，并将 HRegion 在整个集群中进行迁移，以使 HRegionServer 的负载均衡。</p>
<p>每个 HRegion 中存储一段 Key 值区间 [key1, key2) 的数据，所有 HRegion 的信息，包括存储的 Key 值区间、所在 HRegionServer 地址、访问端口号等，都记录在 HMaster 服务器上。为了保证 HMaster 的高可用，HBase 会启动多个 HMaster，并通过 ZooKeeper 选举出一个主服务器。</p>
<p>应用程序通过 ZooKeeper 获得主 HMaster 的地址，输入 Key 值获得这个 Key 所在的 HRegionServer 地址，然后请求 HRegionServer 上的 HRegion，获得所需要的数据。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20230303150211.png"></p>
<p>HRegion 会把数据存储在若干个 HFile 格式的文件中，这些文件使用 HDFS 分布式文件系统存储，在整个集群内分布并高可用。当一个 HRegion 中数据量太多时，这个 HRegion 连同 HFile 会分裂成两个 HRegion，并根据集群中服务器负载进行迁移。如果集群中有新加入的服务器，也就是说有了新的 HRegionServer，由于其负载较低，也会把 HRegion 迁移过去并记录到 HMaster，从而实现 HBase 的线性伸缩。</p>
<h4 id="HBase-可扩展数据模型"><a href="#HBase-可扩展数据模型" class="headerlink" title="HBase 可扩展数据模型"></a>HBase 可扩展数据模型</h4><p>支持列族结构的 NoSQL 数据库，在创建表的时候，只需要指定列族的名字，无需指定字段（Column）。那什么时候指定字段呢？可以在数据写入时再指定。通过这种方式， 数据表可以包含数百万的字段，这样就可以随意扩展应用程序的数据结构了。并且这种数据库在查询时也很方便，可以通过指定任意字段名称和值进行查询。</p>
<p>HBase 这种列族的数据结构设计，实际上是把字段的名称和字段的值，以 Key-Value 的方式一起存储在 HBase 中。实际写入的时候，可以随意指定字段名称，即使有几百万个字段也能轻松应对。</p>
<h4 id="HBase-的高性能存储"><a href="#HBase-的高性能存储" class="headerlink" title="HBase 的高性能存储"></a>HBase 的高性能存储</h4><p>HBase 使用了一种叫作 LSM 树（Log 结构合并树）的数据结构进行数据存储。数据写入的时候以 Log 方式连续写入，然后异步对磁盘上的多个 LSM 树进行合并。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20230303154832.png"></p>
<p>LSM 树可以看作是一个 N 阶合并树。数据写操作（包括插入、修改、删除）都在内存中进行，并且都会创建一个新记录（修改会记录新的数据值，而删除会记录一个删除标志）。这些数据在内存中仍然还是一棵排序树，当数据量超过设定的内存阈值后，会将这棵排序树和磁盘上最新的排序树合并。当这棵排序树的数据量也超过设定阈值后，会和磁盘上下一级的排序树合并。合并过程中，会用最新更新的数据覆盖旧的数据（或者记录为不同版本）。</p>
<h3 id="15-流式计算的代表：Storm、Flink、Spark-Streaming"><a href="#15-流式计算的代表：Storm、Flink、Spark-Streaming" class="headerlink" title="15 | 流式计算的代表：Storm、Flink、Spark Streaming"></a>15 | 流式计算的代表：Storm、Flink、Spark Streaming</h3><h3 id="16-ZooKeeper-是如何保证数据一致性的？"><a href="#16-ZooKeeper-是如何保证数据一致性的？" class="headerlink" title="16 | ZooKeeper 是如何保证数据一致性的？"></a>16 | ZooKeeper 是如何保证数据一致性的？</h3><p>分布式系统中的“脑裂”是指一个系统中的节点被分隔成两个或多个独立的部分，这些部分无法互相通信，导致系统出现不一致性和数据丢失的问题。通常情况下，“脑裂”是由于网络故障、硬件故障或者软件故障等因素导致的。</p>
<p>包括 HDFS 在内的很多大数据技术都选择了使用 ZooKeeper 来解决多台服务器的状态一致性问题。</p>
<p>ZooKeeper 使用了一种叫 ZAB 算法来解决一致性问题。ZAB 可视为 Paxos 算法的一种简化方案。</p>
<h3 id="17-丨模块答疑：这么多技术，到底都能用在什么场景里？"><a href="#17-丨模块答疑：这么多技术，到底都能用在什么场景里？" class="headerlink" title="17 丨模块答疑：这么多技术，到底都能用在什么场景里？"></a>17 丨模块答疑：这么多技术，到底都能用在什么场景里？</h3><p>大数据技术在实际部署的时候，通常会部署在同一个集群中，也就是说，在由很多台服务器组成的服务器集群中，某台服务器可能运行着 HDFS 的 DataNode 进程，负责 HDFS 的数据存储；同时也运行着 Yarn 的 NodeManager，负责计算资源的调度管理；而 MapReduce、Spark、Storm、Flink 这些批处理或者流处理大数据计算引擎则通过 Yarn 的调度，运行在 NodeManager 的容器（container）里面。至于 Hive、Spark SQL 这些运行在 MapReduce 或者 Spark 基础上的大数据仓库引擎，在经过自身的执行引擎将 SQL 语句解析成 MapReduce 或者 Spark 的执行计划以后，一样提交给 Yarn 去调度执行。</p>
<h2 id="模块三、大数据开发实践"><a href="#模块三、大数据开发实践" class="headerlink" title="模块三、大数据开发实践"></a>模块三、大数据开发实践</h2><h3 id="18-如何自己开发一个大数据-SQL-引擎？"><a href="#18-如何自己开发一个大数据-SQL-引擎？" class="headerlink" title="18 | 如何自己开发一个大数据 SQL 引擎？"></a>18 | 如何自己开发一个大数据 SQL 引擎？</h3><h3 id="19-Spark-的性能优化案例分析（上）"><a href="#19-Spark-的性能优化案例分析（上）" class="headerlink" title="19 | Spark 的性能优化案例分析（上）"></a>19 | Spark 的性能优化案例分析（上）</h3><p>性能指标：</p>
<ul>
<li>响应时间：完成一次任务（请求）花费的时间。</li>
<li>并发数：同时处理的任务数（请求数）。</li>
<li>吞吐量：单位时间完成的任务数（请求数、事务数、查询数……）。</li>
<li>性能计数器：System Load，线程数，进程数，CPU、内存、磁盘、网络使用率等。</li>
</ul>
<p>Spark 性能优化可以分解为下面几步。</p>
<ol>
<li>性能测试，观察 Spark 性能特性和资源（CPU、Memory、Disk、Net）利用情况。</li>
<li>分析、寻找资源瓶颈。</li>
<li>分析系统架构、代码，发现资源利用关键所在，思考优化策略。</li>
<li>代码、架构、基础设施调优，优化、平衡资源利用。</li>
<li>性能测试，观察系统性能特性，是否达到优化目的，以及寻找下一个瓶颈点。</li>
</ol>
<h3 id="20-Spark-的性能优化案例分析（下）"><a href="#20-Spark-的性能优化案例分析（下）" class="headerlink" title="20 | Spark 的性能优化案例分析（下）"></a>20 | Spark 的性能优化案例分析（下）</h3><h3 id="21-从阿里内部产品看海量数据处理系统的设计（上）：Doris-的立项"><a href="#21-从阿里内部产品看海量数据处理系统的设计（上）：Doris-的立项" class="headerlink" title="21 | 从阿里内部产品看海量数据处理系统的设计（上）：Doris 的立项"></a>21 | 从阿里内部产品看海量数据处理系统的设计（上）：Doris 的立项</h3><h3 id="22-从阿里内部产品看海量数据处理系统的设计（下）：架构与创新"><a href="#22-从阿里内部产品看海量数据处理系统的设计（下）：架构与创新" class="headerlink" title="22 | 从阿里内部产品看海量数据处理系统的设计（下）：架构与创新"></a>22 | 从阿里内部产品看海量数据处理系统的设计（下）：架构与创新</h3><h3 id="23-大数据基准测试可以带来什么好处？"><a href="#23-大数据基准测试可以带来什么好处？" class="headerlink" title="23 | 大数据基准测试可以带来什么好处？"></a>23 | 大数据基准测试可以带来什么好处？</h3><p>大数据基准测试工具：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Intel-bigdata/HiBench">HiBench</a></p>
<h3 id="24-丨从大数据性能测试工具-Dew-看如何快速开发大数据系统"><a href="#24-丨从大数据性能测试工具-Dew-看如何快速开发大数据系统" class="headerlink" title="24 丨从大数据性能测试工具 Dew 看如何快速开发大数据系统"></a>24 丨从大数据性能测试工具 Dew 看如何快速开发大数据系统</h3><h3 id="25-模块答疑：我能从大厂的大数据开发实践中学到什么？"><a href="#25-模块答疑：我能从大厂的大数据开发实践中学到什么？" class="headerlink" title="25 | 模块答疑：我能从大厂的大数据开发实践中学到什么？"></a>25 | 模块答疑：我能从大厂的大数据开发实践中学到什么？</h3><p>学习层次</p>
<ol>
<li>练习</li>
<li>应用</li>
<li>开发</li>
</ol>
<h2 id="模块四、大数据平台与系统集成"><a href="#模块四、大数据平台与系统集成" class="headerlink" title="模块四、大数据平台与系统集成"></a>模块四、大数据平台与系统集成</h2><h3 id="26-互联网产品-大数据产品-大数据平台"><a href="#26-互联网产品-大数据产品-大数据平台" class="headerlink" title="26 | 互联网产品 + 大数据产品 &#x3D; 大数据平台"></a>26 | 互联网产品 + 大数据产品 &#x3D; 大数据平台</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20230313105947.png"></p>
<ul>
<li>数据采集：数据库同步通常用 Sqoop，日志同步可以选择 Flume，打点采集的数据经过格式化转换后通过 Kafka 等消息队列进行传递</li>
<li>数据处理：离线计算：MapReduce、Hive、Spark；实时计算：Storm、Spark Streaming、Flink</li>
<li>数据展示：Lambda 架构</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20230313111021.png"></p>
<h3 id="27-大数据从哪里来？"><a href="#27-大数据从哪里来？" class="headerlink" title="27 | 大数据从哪里来？"></a>27 | 大数据从哪里来？</h3><p>大数据平台的数据来源主要有数据库、日志、前端程序埋点、爬虫系统。</p>
<ul>
<li>数据库导入<ul>
<li>Sqoop：Sqoop 是一个数据库批量导入导出工具，可以将关系数据库的数据批量导入到 Hadoop，也可以将 Hadoop 的数据导出到关系数据库。</li>
<li>Canal：Canal 是阿里巴巴开源的一个 MySQL binlog 获取工具，binlog 是 MySQL 的事务日志，可用于 MySQL 数据库主从复制，Canal 将自己伪装成 MySQL 从库，从 MySQL 获取 binlog。</li>
</ul>
</li>
<li>日志文件导入<ul>
<li>Flume：Flume 是大数据日志收集常用的工具。</li>
</ul>
</li>
<li>前端程序埋点<ul>
<li>手动埋点</li>
<li>自动埋点</li>
</ul>
</li>
<li>爬虫</li>
</ul>
<h3 id="28-知名大厂如何搭建大数据平台？"><a href="#28-知名大厂如何搭建大数据平台？" class="headerlink" title="28 | 知名大厂如何搭建大数据平台？"></a>28 | 知名大厂如何搭建大数据平台？</h3><p>淘宝大数据平台</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20230313113641.png"></p>
<p>美团大数据平台</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20230313113700.png"></p>
<p>滴滴大数据平台</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20230313113720.png"></p>
<h3 id="29-盘点可供中小企业参考的商业大数据平台"><a href="#29-盘点可供中小企业参考的商业大数据平台" class="headerlink" title="29 | 盘点可供中小企业参考的商业大数据平台"></a>29 | 盘点可供中小企业参考的商业大数据平台</h3><h4 id="大数据解决方案提供商"><a href="#大数据解决方案提供商" class="headerlink" title="大数据解决方案提供商"></a>大数据解决方案提供商</h4><p>CDH、TDH</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20230313114058.png"></p>
<p>CDH 是一个大数据集成平台，将主流大数据产品都集成到这个平台中，企业可以使用 CDH 一站式部署整个大数据技术栈。从架构分层角度，CDH 可以分为 4 层：系统集成，大数据存储，统一服务，过程、分析与计算。</p>
<ol>
<li>系统集成：数据库导入导出用 Sqoop，日志导入导出用 Flume，其他实时数据导入导出用 Kafka。</li>
<li>大数据存储：文件系统用 HDFS，结构化数据用 Kudu，NoSQL 存储用 HBase，其他还有对象存储。</li>
<li>统一服务：资源管理用 Yarn，安全管理用 Sentry 和 RecordService 细粒度地管理不同用户数据的访问权限。</li>
<li>过程、分析与计算：批处理计算用 MapReduce、Spark、Hive、Pig，流计算用 SparkStreaming，快速 SQL 分析用 Impala，搜索服务用 Solr。</li>
</ol>
<h4 id="大数据云计算服务商"><a href="#大数据云计算服务商" class="headerlink" title="大数据云计算服务商"></a>大数据云计算服务商</h4><p>阿里云、亚马逊</p>
<h4 id="大数据-SaaS-服务商"><a href="#大数据-SaaS-服务商" class="headerlink" title="大数据 SaaS 服务商"></a>大数据 SaaS 服务商</h4><p>友盟、神策、百度统计</p>
<h4 id="大数据开放平台"><a href="#大数据开放平台" class="headerlink" title="大数据开放平台"></a>大数据开放平台</h4><h3 id="30-当大数据遇上物联网"><a href="#30-当大数据遇上物联网" class="headerlink" title="30 | 当大数据遇上物联网"></a>30 | 当大数据遇上物联网</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20230313144317.png"></p>
<ol>
<li>智能网关通过消息队列将数据上传到物联网大数据平台，Storm 等流式计算引擎从消息队列获取数据，对数据的处理分三个方面。数据进行清理转换后写入到大数据存储系统。调用规则和机器学习模型，对上传数据进行计算，如果触发了某种执行规则，就将控制信息通过设备管理服务器下发给智能网关，并进一步控制终端智能设备。</li>
<li>Spark 等离线计算引擎定时对写入存储系统的数据进行批量计算处理，进行全量统计分析和机器学习，并更新机器学习模型。</li>
<li>应用程序也可以通过设备管理服务器直接发送控制指令给智能网关，控制终端智能设备。</li>
</ol>
<h3 id="31-模块答疑：为什么大数据平台至关重要？"><a href="#31-模块答疑：为什么大数据平台至关重要？" class="headerlink" title="31 | 模块答疑：为什么大数据平台至关重要？"></a>31 | 模块答疑：为什么大数据平台至关重要？</h3><h2 id="模块五、大数据分析与运营"><a href="#模块五、大数据分析与运营" class="headerlink" title="模块五、大数据分析与运营"></a>模块五、大数据分析与运营</h2><h3 id="32-互联网运营数据指标与可视化监控"><a href="#32-互联网运营数据指标与可视化监控" class="headerlink" title="32 | 互联网运营数据指标与可视化监控"></a>32 | 互联网运营数据指标与可视化监控</h3><p>运营常用数据指标</p>
<ul>
<li>新增用户数</li>
<li>用户留存率</li>
<li>活跃用户数</li>
<li>PV（Page View）</li>
<li>GMV（Gross Merchandise Volume），即成交总金额</li>
<li>转化率 &#x3D; 付费用户数 &#x2F; 总用户数</li>
</ul>
<h3 id="33-丨一个电商网站订单下降的数据分析案例"><a href="#33-丨一个电商网站订单下降的数据分析案例" class="headerlink" title="33 丨一个电商网站订单下降的数据分析案例"></a>33 丨一个电商网站订单下降的数据分析案例</h3><h3 id="34-丨-A-B-测试与灰度发布必知必会"><a href="#34-丨-A-B-测试与灰度发布必知必会" class="headerlink" title="34 丨 A-B 测试与灰度发布必知必会"></a>34 丨 A-B 测试与灰度发布必知必会</h3><h4 id="A-B-测试的过程"><a href="#A-B-测试的过程" class="headerlink" title="A&#x2F;B 测试的过程"></a>A&#x2F;B 测试的过程</h4><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20230313151335.png"></p>
<h4 id="A-B-测试的系统架构"><a href="#A-B-测试的系统架构" class="headerlink" title="A&#x2F;B 测试的系统架构"></a>A&#x2F;B 测试的系统架构</h4><p>A&#x2F;B 测试系统最重要的是能够根据用户 ID（或者设备 ID）将实验配置参数分发给应用程序，应用程序根据配置参数决定给用户展示的界面和执行的业务逻辑</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20230313151508.png"></p>
<h4 id="灰度发布"><a href="#灰度发布" class="headerlink" title="灰度发布"></a>灰度发布</h4><h3 id="35-丨如何利用大数据成为“增长黑客”？"><a href="#35-丨如何利用大数据成为“增长黑客”？" class="headerlink" title="35 丨如何利用大数据成为“增长黑客”？"></a>35 丨如何利用大数据成为“增长黑客”？</h3><p>AARRR 用户增长模型：它描述了用户增长的 5 个关键环节，分别是：获取用户（Acquisition）、提高活跃度（Activation）、提高留存率（Retention）、获取收入（Revenue）和自传播（Refer）。</p>
<ul>
<li>获取用户：通过各种推广手段，使产品触达用户并吸引用户，让用户访问我们的产品。</li>
<li>提高活跃度：用户访问我们的产品后，如果发现没意思、体验差，就很难再次打开，产品的价值也就无法实现。因此需要结合产品内容、运营活动各种手段吸引用户，提升产品的活跃度。</li>
<li>提高留存率：留住一个老用户的成本远低于获取一个新用户，而真正为产品带来营收利润的通常是老用户，因此需要提高留存率。提高留存率的常用手段有：针对老用户推出各种优惠和活动；建立会员等级体系，注册时间越长等级越高；对于一段时间没有访问的疑似流失用户进行消息短信推送以实现用户挽回等。</li>
<li>获取收入：做企业不是做慈善，开发、运营互联网产品的最终目的还是为了赚钱，即获取收入。互联网产品收入主要有用户付费和广告收入，有些互联网产品看起来是用户付费，但其实主要营收是广告收入，比如淘宝。</li>
<li>自传播：让用户利用利用自己的社交网络进行产品推广就是自传播，几乎所有的互联网产品都有“分享到”这样一个功能按钮，促进用户社交传播。有些产品还会利用“帮我砍价”“帮我抢票”等产品功能推动用户进行分享，实现产品的裂变式传播、病毒式营销。</li>
</ul>
<p>增长用户的手段主要有：</p>
<p>利用用户画像定位用户群体</p>
<ul>
<li>通过用户分析挽回用户</li>
<li>A&#x2F;B 测试决定产品功能</li>
<li>大数据反欺诈、反羊毛</li>
<li>用户生命周期管理</li>
</ul>
<h3 id="36-丨模块答疑：为什么说数据驱动运营？"><a href="#36-丨模块答疑：为什么说数据驱动运营？" class="headerlink" title="36 丨模块答疑：为什么说数据驱动运营？"></a>36 丨模块答疑：为什么说数据驱动运营？</h3><p>略</p>
<h2 id="模块六、大数据算法"><a href="#模块六、大数据算法" class="headerlink" title="模块六、大数据算法"></a>模块六、大数据算法</h2><h3 id="37-丨如何对数据进行分类和预测？"><a href="#37-丨如何对数据进行分类和预测？" class="headerlink" title="37 丨如何对数据进行分类和预测？"></a>37 丨如何对数据进行分类和预测？</h3><p>KNN 算法：KNN 算法，即 K 近邻（K Nearest Neighbour）算法，是一种基本的分类算法。其主要原理是：对于一个需要分类的数据，将其和一组已经分类标注好的样本集合进行比较，得到距离最近的 K 个样本，K 个样本最多归属的类别，就是这个需要分类数据的类别。</p>
<p>数据的距离：</p>
<ul>
<li>欧氏距离：计算空间距离</li>
<li>余弦相似度：计算向量的夹角。更关注数据的相似性</li>
</ul>
<p>文本的特征值：</p>
<ul>
<li>TF-IDF 算法：TF 与 IDF 的乘积就是 TF-IDF。<ul>
<li>TF 是词频（Term Frequency），表示某个单词在文档中出现的频率，一个单词在一个文档中出现的越频繁，TF 值越高。</li>
<li>IDF 是逆文档频率（Inverse Document Frequency），表示这个单词在所有文档中的稀缺程度，越少文档出现这个词，IDF 值越高。</li>
</ul>
</li>
</ul>
<p>贝叶斯分类：贝叶斯公式是一种基于条件概率的分类算法，如果我们已经知道 A 和 B 的发生概率，并且知道了 B 发生情况下 A 发生的概率，可以用贝叶斯公式计算 A 发生的情况下 B 发生的概率。</p>
<h3 id="38-丨如何发掘数据之间的关系？"><a href="#38-丨如何发掘数据之间的关系？" class="headerlink" title="38 丨如何发掘数据之间的关系？"></a>38 丨如何发掘数据之间的关系？</h3><p>搜索排序：Google PageRank 算法</p>
<p>关联分析：</p>
<ul>
<li>Apriori 算法：Apriori 算法极大地降低了需要计算的商品组合数目，这个算法的原理是，如果一个商品组合不满足最小支持度，那么所有包含这个商品组合的其他商品组合也不满足最小支持度。所以从最小商品组合，也就是一件商品开始计算最小支持度，逐渐迭代，进而筛选出所有满足最小支持度的频繁模式。其步骤如下：<ol>
<li>设置最小支持度阈值。</li>
<li>寻找满足最小支持度的单件商品，也就是单件商品出现在所有订单中的概率不低于最小支持度。</li>
<li>从第 2 步找到的所有满足最小支持度的单件商品中，进行两两组合，寻找满足最小支持度的两件商品组合，也就是两件商品出现在同一个订单中概率不低于最小支持度。</li>
<li>从第 3 步找到的所有满足最小支持度的两件商品，以及第 2 步找到的满足最小支持度的单件商品进行组合，寻找满足最小支持度的三件商品组合。</li>
<li>以此类推，找到所有满足最小支持度的商品组合。</li>
</ol>
</li>
</ul>
<p>聚类：聚类就是对一批数据进行自动归类。</p>
<p>K-means 算法</p>
<h3 id="39-丨如何预测用户的喜好？"><a href="#39-丨如何预测用户的喜好？" class="headerlink" title="39 丨如何预测用户的喜好？"></a>39 丨如何预测用户的喜好？</h3><p>基于人口统计的推荐：基于人口统计的推荐是相对比较简单的一种推荐算法，根据用户的基本信息进行分类，然后将商品推荐给同类用户。</p>
<p>基于产品属性的推荐：基于用户的属性进行分类，然后根据同类用户的行为进行推荐。而基于商品属性的推荐则是将商品的属性进行分类，然后根据用户的历史行为进行推荐。</p>
<p>基于用户的协同过滤推荐：基于用户的协同过滤推荐是根据用户的喜好进行用户分类，常用的就是 KNN 算法，寻找和当前用户喜好最相近的 K 个用户，然后根据这些用户的喜好为当前用户进行推荐。</p>
<p>基于商品的协同过滤推荐：根据用户的喜好对商品进行分类，如果两个商品，喜欢它们的用户具有较高的重叠性，就认为它们的距离相近，划分为同类商品，然后进行推荐</p>
<h3 id="40-丨机器学习的数学原理是什么？"><a href="#40-丨机器学习的数学原理是什么？" class="headerlink" title="40 丨机器学习的数学原理是什么？"></a>40 丨机器学习的数学原理是什么？</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20230313161656.png"></p>
<p>样本：样本就是通常我们常说的“训练数据”，包括输入和结果两部分。</p>
<p>模型：模型就是映射样本输入与样本结果的函数，可能是一个条件概率分布，也可能是一个决策函数。</p>
<p>算法：算法就是要从模型的假设空间中寻找一个最优的函数，使得样本空间的输入 X 经过该函数的映射得到的 f(X)，和真实的 Y 值之间的距离最小。这个最优的函数通常没办法直接计算得到，即没有解析解，需要用数值计算的方法不断迭代求解。因此如何寻找到 f 函数的全局最优解，以及使寻找过程尽量高效，就构成了机器学习的算法。</p>
<h3 id="41-丨从感知机到神经网络算法"><a href="#41-丨从感知机到神经网络算法" class="headerlink" title="41 丨从感知机到神经网络算法"></a>41 丨从感知机到神经网络算法</h3><h3 id="42-丨模块答疑：软件工程师如何进入人工智能领域？"><a href="#42-丨模块答疑：软件工程师如何进入人工智能领域？" class="headerlink" title="42 丨模块答疑：软件工程师如何进入人工智能领域？"></a>42 丨模块答疑：软件工程师如何进入人工智能领域？</h3><p>斯坦福大学的机器学习公开课</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100020201">从 0 开始学大数据</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/c3ab9e/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/c3ab9e/" class="post-title-link" itemprop="url">《机器学习 40 讲》笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-02-09 21:08:48" itemprop="dateCreated datePublished" datetime="2023-02-09T21:08:48+08:00">2023-02-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:53" itemprop="dateModified" datetime="2024-12-12T10:02:53+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AC%94%E8%AE%B0/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">人工智能</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>957</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="《机器学习-40-讲》笔记"><a href="#《机器学习-40-讲》笔记" class="headerlink" title="《机器学习 40 讲》笔记"></a>《机器学习 40 讲》笔记</h1><h2 id="开篇词-打通修炼机器学习的任督二脉"><a href="#开篇词-打通修炼机器学习的任督二脉" class="headerlink" title="开篇词 | 打通修炼机器学习的任督二脉"></a>开篇词 | 打通修炼机器学习的任督二脉</h2><p>“机器学习”分为 3 个模块</p>
<ul>
<li><strong>机器学习概观</strong>：介绍机器学习中超脱于具体模型和方法之上的一些共性问题</li>
<li><strong>统计学习（频率学派）</strong>：利用不同的模型去拟合数据背后的规律；用拟合出的规律去推断和预测未知的结果</li>
<li><strong>符号学习（贝叶斯学派）</strong>：即概率图模型，它计算的是变量间的相关关系，每个遍历的先验分布和大量复杂的积分技巧。</li>
</ul>
<h2 id="01-丨频率视角下的机器学习"><a href="#01-丨频率视角下的机器学习" class="headerlink" title="01 丨频率视角下的机器学习"></a>01 丨频率视角下的机器学习</h2><p>频率学派认为概率是随机事件发生频率的极限值；</p>
<p>频率学派执行参数估计时，视参数为确定取值，视数据为随机变量；</p>
<p>频率学派主要使用最大似然估计法，让数据在给定参数下的似然概率最大化；</p>
<p>频率学派对应机器学习中的统计学习，以经验风险最小化作为模型选择的准则。</p>
<h2 id="02-贝叶斯视角下的机器学习"><a href="#02-贝叶斯视角下的机器学习" class="headerlink" title="02 | 贝叶斯视角下的机器学习"></a>02 | 贝叶斯视角下的机器学习</h2><p>贝叶斯学派认为概率是事件的可信程度或主体对事件的信任程度；</p>
<p>贝叶斯学派执行参数估计时，视参数为随机变量，视数据为确定取值；</p>
<p>贝叶斯学派主要使用最大后验概率法，让参数在先验信息和给定数据下的后验概率最大化；</p>
<p>贝叶斯学派对应机器学习中的概率图模型，可以在模型预测和选择中提供更加完整的信息。</p>
<h2 id="03-丨学什么与怎么学"><a href="#03-丨学什么与怎么学" class="headerlink" title="03 丨学什么与怎么学"></a>03 丨学什么与怎么学</h2><p>什么样的问题才能通过机器学习来解决呢？</p>
<p>首先，问题不能是完全随机的，需要具备一定的模式；</p>
<p>其次，问题本身不能通过纯计算的方法解决；</p>
<p>再次，有大量的数据可供使用。</p>
<p>机器学习的任务，就是使用数据计算出与目标函数最接近的假设，或者说拟合出最精确的模型 。</p>
<p>输入特征类型</p>
<ul>
<li>具体特征（concrete feature）</li>
<li>原始特征（raw feature）</li>
<li>抽象特征（abstract feature）</li>
</ul>
<p>机器学习方法类型</p>
<ul>
<li>分类算法（classification）</li>
<li>回归算法（regression）</li>
<li>标注算法（tagging）</li>
</ul>
<p>如果训练数据中的每组输入都有其对应的输出结果，这类学习任务就是<strong>监督学习（supervised learning）</strong>，对没有输出的数据进行学习则是<strong>无监督学习（unsupervised learning）</strong>。监督学习具有更好的预测精度，无监督学习则可以发现数据中隐含的结构特性，起到的也是分类的作用，只不过没有给每个类别赋予标签而已。无监督学习可以用于对数据进行聚类或者密度估计，也可以完成异常检测这类监督学习中的预处理操作。直观地看，监督学习适用于预测任务，无监督学习适用于描述任务。</p>
<h2 id="04-丨计算学习理论"><a href="#04-丨计算学习理论" class="headerlink" title="04 丨计算学习理论"></a>04 丨计算学习理论</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/191cdb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/191cdb/" class="post-title-link" itemprop="url">Spring Data 综合</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-02-08 09:10:35" itemprop="dateCreated datePublished" datetime="2023-02-08T09:10:35+08:00">2023-02-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E6%A1%86%E6%9E%B6/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E6%A1%86%E6%9E%B6/Spring/Spring%E6%95%B0%E6%8D%AE/" itemprop="url" rel="index"><span itemprop="name">Spring数据</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Spring-Data-综合"><a href="#Spring-Data-综合" class="headerlink" title="Spring Data 综合"></a>Spring Data 综合</h1><p>Spring Data Repository 抽象的目标是显著减少各种访问持久化存储的样板式代码。</p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>Repository 是 Spring Data 的核心接口。此接口主要用作标记接口，以捕获要使用的类型并帮助您发现扩展此接口的接口。<code>CrudRepository</code> 和 <code>ListCrudRepository</code> 接口为被管理的实体类提供复杂的 CRUD 功能。<code>ListCrudRepository</code> 提供等效方法，但它们返回 <code>List</code>，而 <code>CrudRepository</code> 方法返回 <code>Iterable</code>。</p>
<p><code>CrudRepository</code> 接口定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CrudRepository</span>&lt;T, ID&gt; <span class="keyword">extends</span> <span class="title class_">Repository</span>&lt;T, ID&gt; &#123;</span><br><span class="line"></span><br><span class="line">  &lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; S <span class="title function_">save</span><span class="params">(S entity)</span>;</span><br><span class="line"></span><br><span class="line">  Optional&lt;T&gt; <span class="title function_">findById</span><span class="params">(ID primaryKey)</span>;</span><br><span class="line"></span><br><span class="line">  Iterable&lt;T&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> <span class="title function_">count</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(T entity)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">existsById</span><span class="params">(ID primaryKey)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// … more functionality omitted.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Spring Data 项目也提供了一些特定持久化技术的抽象接口，如：JpaRepository 或 MongoRepository。这些接口扩展了 CrudRepository 并暴露了一些持久化技术的底层功能。</p>
</blockquote>
<p>除了 <code>CrudRepository</code> 之外，还有一个 <code>PagingAndSortingRepository</code> 接口，它添加了额外的方法来简化对实体的分页访问：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PagingAndSortingRepository</span>&lt;T, ID&gt;  &#123;</span><br><span class="line"></span><br><span class="line">  Iterable&lt;T&gt; <span class="title function_">findAll</span><span class="params">(Sort sort)</span>;</span><br><span class="line"></span><br><span class="line">  Page&lt;T&gt; <span class="title function_">findAll</span><span class="params">(Pageable pageable)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【示例】要按页面大小 20 访问 User 的第二页，可以执行如下操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PagingAndSortingRepository&lt;User, Long&gt; repository = <span class="comment">// … get access to a bean</span></span><br><span class="line">Page&lt;User&gt; users = repository.findAll(PageRequest.of(<span class="number">1</span>, <span class="number">20</span>));</span><br></pre></td></tr></table></figure>

<p>除了查询方法之外，计数和删除时的查询也是可用的。</p>
<p>【示例】根据姓氏计数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">CrudRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line">  <span class="type">long</span> <span class="title function_">countByLastname</span><span class="params">(String lastname)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【示例】根据姓氏删除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">CrudRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> <span class="title function_">deleteByLastname</span><span class="params">(String lastname)</span>;</span><br><span class="line"></span><br><span class="line">  List&lt;User&gt; <span class="title function_">removeByLastname</span><span class="params">(String lastname)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查询方法"><a href="#查询方法" class="headerlink" title="查询方法"></a>查询方法</h2><p>使用 Spring Data 对数据库进行查询有以下四步：</p>
<ol>
<li><p>声明一个扩展 <code>Repository</code> 或其子接口的接口，并指定泛型类型（实体类和 ID 类型），如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">PersonRepository</span> <span class="keyword">extends</span> <span class="title class_">Repository</span>&lt;Person, Long&gt; &#123; … &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在接口中声明查询方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">PersonRepository</span> <span class="keyword">extends</span> <span class="title class_">Repository</span>&lt;Person, Long&gt; &#123;</span><br><span class="line">  List&lt;Person&gt; <span class="title function_">findByLastname</span><span class="params">(String lastname)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/current/reference/html/#repositories.create-instances.java-config">JavaConfig</a> 或 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/current/reference/html/#repositories.create-instances">XML 配置</a>为这些接口创建代理实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableJpaRepositories</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Config</span> &#123; … &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注入 <code>Repository</code> 实例并使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClient</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> PersonRepository repository;</span><br><span class="line"></span><br><span class="line">  SomeClient(PersonRepository repository) &#123;</span><br><span class="line">    <span class="built_in">this</span>.repository = repository;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Person&gt; persons = repository.findByLastname(<span class="string">&quot;Matthews&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="定义-Repository"><a href="#定义-Repository" class="headerlink" title="定义 Repository"></a>定义 Repository</h2><p>首先需要定义一个 Repository 接口，该接口必须扩展 Repository 并且指定泛型类型（实体类和 ID 类型）。如果想为该实体暴露 CRUD 方法，可以扩展 CrudRepository 接口。</p>
<h3 id="微调-Repository-定义"><a href="#微调-Repository-定义" class="headerlink" title="微调 Repository 定义"></a>微调 Repository 定义</h3><p>Spring Data 提供了很多种 Repository 以应对不同的需求场景。</p>
<p><code>CrudRepository</code> 提供了 CRUD 功能。</p>
<p><code>ListCrudRepository</code> 和 <code>CrudRepository</code> 类似，但对于那些返回多个实体的方法，它返回一个 <code>List</code> 而不是 <code>Iterable</code>，这样使用可能更方便。</p>
<p>如果使用响应式框架，可以使用 <code>ReactiveCrudRepository</code> 或 <code>RxJava3CrudRepository</code>。</p>
<p><code>CoroutineCrudRepository</code> 支持 Kotlin 的协程特性。</p>
<p><code>PagingAndSortingRepository</code> 提供了分页、排序功能。</p>
<p>如果不想扩展 Spring Data 接口，还可以使用 <code>@RepositoryDefinition</code> 注释您的 <code>Repository</code> 接口。 扩展一个 CRUD Repository 接口，需要暴露一组完整的方法来操作实体。如果希望对暴露的方法有选择性，可以将要暴露的方法从 CRUD Repository 复制到自定义的 Repository 中。 这样做时，可以更改方法的返回类型。 如果可能，Spring Data 将遵循返回类型。 例如，对于返回多个实体的方法，可以选择 <code>Iterable&lt;T&gt;</code>、<code>List&lt;T&gt;</code>、<code>Collection&lt;T&gt;</code> 或 <code>VAVR</code> 列表。</p>
<p>自定义基础 <code>Repository</code> 接口，必须用 <code>@NoRepositoryBean</code> 标记。 这可以防止 Spring Data 尝试直接创建它的实例并失败，因为它无法确定该 Repository 的实体，因为它仍然包含一个通用类型变量。</p>
<p>以下示例显示了如何有选择地暴露 CRUD 方法（在本例中为 findById 和 save）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoRepositoryBean</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyBaseRepository</span>&lt;T, ID&gt; <span class="keyword">extends</span> <span class="title class_">Repository</span>&lt;T, ID&gt; &#123;</span><br><span class="line"></span><br><span class="line">  Optional&lt;T&gt; <span class="title function_">findById</span><span class="params">(ID id)</span>;</span><br><span class="line"></span><br><span class="line">  &lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; S <span class="title function_">save</span><span class="params">(S entity)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">MyBaseRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line">  User <span class="title function_">findByEmailAddress</span><span class="params">(EmailAddress emailAddress)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用多个-Spring-数据模块"><a href="#使用多个-Spring-数据模块" class="headerlink" title="使用多个 Spring 数据模块"></a>使用多个 Spring 数据模块</h3><p>有时，程序中需要使用多个 Spring Data 模块。在这种情况下，必须区分持久化技术。当检测到类路径上有多个 Repository 工厂时，Spring Data 进入严格的配置模式。</p>
<p>如果定义的 Repository 扩展了特定模块中的 Repository，则它是特定 Spring Data 模块的有效候选者。</p>
<p>如果实体类使用了特定模块的类型注解，则它是特定 Spring Data 模块的有效候选者。 Spring Data 模块接受第三方注解（例如 JPA 的 <code>@Entity</code>）或提供自己的注解（例如用于 Spring Data MongoDB 和 Spring Data Elasticsearch 的 <code>@Document</code>）。</p>
<p>以下示例显示了一个使用模块特定接口（在本例中为 JPA）的 Repository：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NoRepositoryBean</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyBaseRepository</span>&lt;T, ID&gt; <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;T, ID&gt; &#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">MyBaseRepository</span>&lt;User, Long&gt; &#123; … &#125;</span><br></pre></td></tr></table></figure>

<p>MyRepository 和 UserRepository 扩展了 JpaRepository。它们是 Spring Data JPA 模块的有效候选者。</p>
<p>以下示例显示了一个使用通用接口的 Repository</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">AmbiguousRepository</span> <span class="keyword">extends</span> <span class="title class_">Repository</span>&lt;User, Long&gt; &#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NoRepositoryBean</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyBaseRepository</span>&lt;T, ID&gt; <span class="keyword">extends</span> <span class="title class_">CrudRepository</span>&lt;T, ID&gt; &#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AmbiguousUserRepository</span> <span class="keyword">extends</span> <span class="title class_">MyBaseRepository</span>&lt;User, Long&gt; &#123; … &#125;</span><br></pre></td></tr></table></figure>

<p>AmbiguousRepository 和 AmbiguousUserRepository 仅扩展了 Repository 和 CrudRepository。 虽然这在使用唯一的 Spring Data 模块时很好，但是存在多个模块时，无法区分这些 Repository 应该绑定到哪个特定的 Spring Data。</p>
<p>以下示例显示了一个使用带注解的实体类的 Repository</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">PersonRepository</span> <span class="keyword">extends</span> <span class="title class_">Repository</span>&lt;Person, Long&gt; &#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">Repository</span>&lt;User, Long&gt; &#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Document</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123; … &#125;</span><br></pre></td></tr></table></figure>

<p>PersonRepository 引用 Person，它使用 JPA @Entity 注解进行标记，因此这个 Repository 显然属于 Spring Data JPA。 UserRepository 引用 User，它使用 Spring Data MongoDB 的 @Document 注解进行标记。</p>
<p>以下错误示例显示了一个使用带有混合注解的实体类的 Repository</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">JpaPersonRepository</span> <span class="keyword">extends</span> <span class="title class_">Repository</span>&lt;Person, Long&gt; &#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MongoDBPersonRepository</span> <span class="keyword">extends</span> <span class="title class_">Repository</span>&lt;Person, Long&gt; &#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Document</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123; … &#125;</span><br></pre></td></tr></table></figure>

<p>此示例中的实体类同时使用了 JPA 和 Spring Data MongoDB 的注解。示例中定义了两个 Repository：JpaPersonRepository 和 MongoDBPersonRepository。 一个用于 JPA，另一个用于 MongoDB。 Spring Data 不再能够区分 Repository，这会导致未定义的行为。</p>
<p>区分 Repository 的最后一种方法是确定 Repository 扫描 package 的范围。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableJpaRepositories(basePackages = &quot;com.acme.repositories.jpa&quot;)</span></span><br><span class="line"><span class="meta">@EnableMongoRepositories(basePackages = &quot;com.acme.repositories.mongo&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Configuration</span> &#123; … &#125;</span><br></pre></td></tr></table></figure>

<h2 id="定义查询方法"><a href="#定义查询方法" class="headerlink" title="定义查询方法"></a>定义查询方法</h2><p>Repository 代理有两种方法可以从方法名称派生特定于存储的查询：</p>
<ul>
<li>通过直接从方法名称派生查询。</li>
<li>通过使用手动定义的查询。</li>
</ul>
<p>可用选项取决于实际存储。但是，必须有一个策略来决定创建什么实际查询。</p>
<h3 id="查询策略"><a href="#查询策略" class="headerlink" title="查询策略"></a>查询策略</h3><p>以下策略可用于Repository 基础结构来解析查询。 对于 Java 配置，您可以使用 EnableJpaRepositories 注释的 queryLookupStrategy 属性。 特定数据存储可能不支持某些策略。</p>
<ul>
<li><code>CREATE</code> 尝试从查询方法名称构造特定存储的查询。</li>
<li><code>USE_DECLARED_QUERY</code> 尝试查找已声明的查询，如果找不到则抛出异常。</li>
<li><code>CREATE_IF_NOT_FOUND</code> （默认）结合了 <code>CREATE</code> 和 <code>USE_DECLARED_QUERY</code>。</li>
</ul>
<h3 id="查询创建"><a href="#查询创建" class="headerlink" title="查询创建"></a>查询创建</h3><p>Spring Data 中有一套内置的查询构建器机制，可以自动映射符合命名和参数规则的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">PersonRepository</span> <span class="keyword">extends</span> <span class="title class_">Repository</span>&lt;Person, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">  List&lt;Person&gt; <span class="title function_">findByEmailAddressAndLastname</span><span class="params">(EmailAddress emailAddress, String lastname)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Enables the distinct flag for the query</span></span><br><span class="line">  List&lt;Person&gt; <span class="title function_">findDistinctPeopleByLastnameOrFirstname</span><span class="params">(String lastname, String firstname)</span>;</span><br><span class="line">  List&lt;Person&gt; <span class="title function_">findPeopleDistinctByLastnameOrFirstname</span><span class="params">(String lastname, String firstname)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Enabling ignoring case for an individual property</span></span><br><span class="line">  List&lt;Person&gt; <span class="title function_">findByLastnameIgnoreCase</span><span class="params">(String lastname)</span>;</span><br><span class="line">  <span class="comment">// Enabling ignoring case for all suitable properties</span></span><br><span class="line">  List&lt;Person&gt; <span class="title function_">findByLastnameAndFirstnameAllIgnoreCase</span><span class="params">(String lastname, String firstname)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Enabling static ORDER BY for a query</span></span><br><span class="line">  List&lt;Person&gt; <span class="title function_">findByLastnameOrderByFirstnameAsc</span><span class="params">(String lastname)</span>;</span><br><span class="line">  List&lt;Person&gt; <span class="title function_">findByLastnameOrderByFirstnameDesc</span><span class="params">(String lastname)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析查询方法名称分为主语和谓语。第一部分 (find…By, exists…By) 定义查询的主语，第二部分构成谓词。 主语可以包含更多的表达。 <code>find</code>（或其他引入关键字）和 <code>By</code> 之间的任何文本都被认为是描述性的，除非使用其中一个结果限制关键字，例如 <code>Distinct</code> 在要创建的查询上设置不同的标志或 <code>Top</code>&#x2F;<code>First</code> 限制查询结果。</p>
<blockquote>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/current/reference/html/#appendix.query.method.subject">Spring Data 支持的查询主语关键词</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jdbc/docs/current/reference/html/#appendix.query.method.predicate">Spring Data 支持的查询谓语关键词</a></p>
</blockquote>
<h2 id="创建-Repository-实例"><a href="#创建-Repository-实例" class="headerlink" title="创建 Repository 实例"></a>创建 Repository 实例</h2><h2 id="自定义-Repository-实现"><a href="#自定义-Repository-实现" class="headerlink" title="自定义 Repository 实现"></a>自定义 Repository 实现</h2><h2 id="Spring-Data-扩展"><a href="#Spring-Data-扩展" class="headerlink" title="Spring Data 扩展"></a>Spring Data 扩展</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://redis.io/">Redis 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/redis/redis">Redis Github</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-data-redis">spring-data-redis Github</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/redis/docs/current/reference/html/">Spring Data Redis 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-data-examples/">Spring Data 官方示例</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/65e4a2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/65e4a2/" class="post-title-link" itemprop="url">Spring 访问 Redis</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-01-31 20:54:42" itemprop="dateCreated datePublished" datetime="2023-01-31T20:54:42+08:00">2023-01-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E6%A1%86%E6%9E%B6/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E6%A1%86%E6%9E%B6/Spring/Spring%E6%95%B0%E6%8D%AE/" itemprop="url" rel="index"><span itemprop="name">Spring数据</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Spring-访问-Redis"><a href="#Spring-访问-Redis" class="headerlink" title="Spring 访问 Redis"></a>Spring 访问 Redis</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a target="_blank" rel="noopener" href="https://redis.io/">Redis</a> 是一个被数百万开发人员用作数据库、缓存、流引擎和消息代理的开源内存数据库。</p>
<p>在 Spring 中，<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-data-redis">spring-data-redis</a> 项目对访问 <a target="_blank" rel="noopener" href="https://redis.io/">Redis</a> 进行了 API 封装，提供了便捷的访问方式。 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-data-redis">spring-data-redis</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot">spring-boot</a> 项目中的子模块 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/main/spring-boot-project/spring-boot-starters/spring-boot-starter-data-redis">spring-boot-starter-data-redis</a> 基于 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-data-redis">spring-data-redis</a> 项目，做了二次封装，大大简化了 Redis 的相关配置。</p>
<h2 id="Spring-Boot-快速入门"><a href="#Spring-Boot-快速入门" class="headerlink" title="Spring Boot 快速入门"></a>Spring Boot 快速入门</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><p>在 pom.xml 中引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="数据源配置"><a href="#数据源配置" class="headerlink" title="数据源配置"></a>数据源配置</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.redis.database</span> = <span class="string">0</span></span><br><span class="line"><span class="attr">spring.redis.host</span> = <span class="string">localhost</span></span><br><span class="line"><span class="attr">spring.redis.port</span> = <span class="string">6379</span></span><br><span class="line"><span class="attr">spring.redis.password</span> =<span class="string"></span></span><br></pre></td></tr></table></figure>

<h3 id="定义实体"><a href="#定义实体" class="headerlink" title="定义实体"></a>定义实体</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">4142994984277644695L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义-CRUD-接口"><a href="#定义-CRUD-接口" class="headerlink" title="定义 CRUD 接口"></a>定义 CRUD 接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">batchSetUsers</span><span class="params">(Map&lt;String, User&gt; users)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="title function_">count</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    User <span class="title function_">getUser</span><span class="params">(Long id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setUser</span><span class="params">(User user)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建-CRUD-接口实现"><a href="#创建-CRUD-接口实现" class="headerlink" title="创建 CRUD 接口实现"></a>创建 CRUD 接口实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.bean.BeanUtil;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_KEY</span> <span class="operator">=</span> <span class="string">&quot;spring:tutorial:user&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceImpl</span><span class="params">(RedisTemplate&lt;String, Object&gt; redisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">batchSetUsers</span><span class="params">(Map&lt;String, User&gt; users)</span> &#123;</span><br><span class="line">        redisTemplate.opsForHash().putAll(DEFAULT_KEY, users);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">count</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().size(DEFAULT_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> redisTemplate.opsForHash().get(DEFAULT_KEY, id.toString());</span><br><span class="line">        <span class="keyword">return</span> BeanUtil.toBean(obj, User.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        redisTemplate.opsForHash().put(DEFAULT_KEY, user.getId().toString(), user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建-Application"><a href="#创建-Application" class="headerlink" title="创建 Application"></a>创建 Application</h3><p>创建 Application，实例化一个 <code>RedisTemplate</code> 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonAutoDetect;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.PropertyAccessor;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Primary;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisQuickstartApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定要序列化的域，field,get和set,以及修饰符范围，ANY是都有包括private和public</span></span><br><span class="line">        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        <span class="comment">// // 指定序列化输入的类型，类必须是非final修饰的，final修饰的类，比如String,Integer等会跑出异常</span></span><br><span class="line">        <span class="comment">// objectMapper.activateDefaultTyping(new DefaultBaseTypeLimitingValidator(),</span></span><br><span class="line">        <span class="comment">//     ObjectMapper.DefaultTyping.NON_FINAL);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值（默认使用JDK的序列化方式）</span></span><br><span class="line">        Jackson2JsonRedisSerializer&lt;Object&gt; serializer = <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>&lt;&gt;(Object.class);</span><br><span class="line">        serializer.setObjectMapper(objectMapper);</span><br><span class="line"></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 配置连接工厂</span></span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line">        <span class="comment">// 值采用json序列化</span></span><br><span class="line">        template.setValueSerializer(serializer);</span><br><span class="line">        <span class="comment">// 使用StringRedisSerializer来序列化和反序列化redis的key值</span></span><br><span class="line">        template.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        <span class="comment">// 设置hash key 和value序列化模式</span></span><br><span class="line">        template.setHashKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        template.setHashValueSerializer(serializer);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(RedisQuickstartApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SpringBootTest(classes = &#123; RedisQuickstartApplication.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisQuickstartTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">SIZE</span> <span class="operator">=</span> <span class="number">1000L</span>;</span><br><span class="line">        Map&lt;String, User&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; SIZE; i++) &#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(i, RandomUtil.randomChineseName(),</span><br><span class="line">                RandomUtil.randomInt(<span class="number">1</span>, <span class="number">100</span>),</span><br><span class="line">                RandomUtil.randomEnum(Location.class).name(),</span><br><span class="line">                RandomUtil.randomEmail());</span><br><span class="line">            map.put(String.valueOf(i), user);</span><br><span class="line">        &#125;</span><br><span class="line">        userService.batchSetUsers(map);</span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> userService.count();</span><br><span class="line">        Assertions.assertThat(count).isEqualTo(SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> RandomUtil.randomLong(<span class="number">0</span>, <span class="number">1000</span>);</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getUser(id);</span><br><span class="line">            log.info(<span class="string">&quot;user-&#123;&#125;: &#123;&#125;&quot;</span>, id, user.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="示例源码"><a href="#示例源码" class="headerlink" title="示例源码"></a>示例源码</h2><p>更多 Spring 访问 Redis 示例请参考：<a target="_blank" rel="noopener" href="https://github.com/dunwu/spring-tutorial/tree/master/codes/data/nosql/redis">Redis 示例源码</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://redis.io/">Redis 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/redis/redis">Redis Github</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-data-redis">spring-data-redis Github</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/redis/docs/current/reference/html/">Spring Data Redis 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-data-examples/">Spring Data 官方示例</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/1f743f/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/1f743f/" class="post-title-link" itemprop="url">Spring EL 表达式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-01-12 20:26:46" itemprop="dateCreated datePublished" datetime="2023-01-12T20:26:46+08:00">2023-01-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E6%A1%86%E6%9E%B6/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E6%A1%86%E6%9E%B6/Spring/Spring%E6%A0%B8%E5%BF%83/" itemprop="url" rel="index"><span itemprop="name">Spring核心</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>60</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Spring-EL-表达式"><a href="#Spring-EL-表达式" class="headerlink" title="Spring EL 表达式"></a>Spring EL 表达式</h1><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans">Spring 官方文档之 Core Technologies</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/course/intro/265">《小马哥讲 Spring 核心编程思想》</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/ad472e/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/ad472e/" class="post-title-link" itemprop="url">Spring 应用上下文生命周期</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-12-23 09:58:09" itemprop="dateCreated datePublished" datetime="2022-12-23T09:58:09+08:00">2022-12-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E6%A1%86%E6%9E%B6/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E6%A1%86%E6%9E%B6/Spring/Spring%E6%A0%B8%E5%BF%83/" itemprop="url" rel="index"><span itemprop="name">Spring核心</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Spring-应用上下文生命周期"><a href="#Spring-应用上下文生命周期" class="headerlink" title="Spring 应用上下文生命周期"></a>Spring 应用上下文生命周期</h1><h2 id="Spring-应用上下文启动准备阶段"><a href="#Spring-应用上下文启动准备阶段" class="headerlink" title="Spring 应用上下文启动准备阶段"></a>Spring 应用上下文启动准备阶段</h2><p>AbstractApplicationContext#prepareRefresh() 方法</p>
<ul>
<li>启动时间 - startupDate</li>
<li>状态标识 - closed(false)、active(true)</li>
<li>初始化 PropertySources - initPropertySources()</li>
<li>检验 Environment 中必须属性</li>
<li>初始化事件监听器集合</li>
<li>初始化早期 Spring 事件集合</li>
</ul>
<h2 id="BeanFactory-创建阶段"><a href="#BeanFactory-创建阶段" class="headerlink" title="BeanFactory 创建阶段"></a>BeanFactory 创建阶段</h2><p>AbstractApplicationContext#obtainFreshBeanFactory() 方法</p>
<ul>
<li>刷新 Spring 应用上下文底层 BeanFactory - refreshBeanFactory()<ul>
<li>销毁或关闭 BeanFactory，如果已存在的话</li>
<li>创建 BeanFactory - createBeanFactory()</li>
<li>设置 BeanFactory Id</li>
<li>设置“是否允许 BeanDefinition 重复定义” - customizeBeanFactory(DefaultListableBeanFactory)</li>
<li>设置“是否允许循环引用（依赖）” - customizeBeanFactory(DefaultListableBeanFactory)</li>
<li>加载 BeanDefinition - loadBeanDefinitions(DefaultListableBeanFactory) 方法</li>
<li>关联新建 BeanFactory 到 Spring 应用上下文</li>
</ul>
</li>
<li>返回 Spring 应用上下文底层 BeanFactory - getBeanFactory()</li>
</ul>
<h2 id="BeanFactory-准备阶段"><a href="#BeanFactory-准备阶段" class="headerlink" title="BeanFactory 准备阶段"></a>BeanFactory 准备阶段</h2><p>AbstractApplicationContext#prepareBeanFactory(ConfigurableListableBeanFactory) 方法</p>
<ul>
<li>关联 ClassLoader</li>
<li>设置 Bean 表达式处理器</li>
<li>添加 PropertyEditorRegistrar 实现 - ResourceEditorRegistrar</li>
<li>添加 Aware 回调接口 BeanPostProcessor 实现 - ApplicationContextAwareProcessor</li>
<li>忽略 Aware 回调接口作为依赖注入接口</li>
<li>注册 ResolvableDependency 对象 - BeanFactory、ResourceLoader、ApplicationEventPublisher 以及 ApplicationContext</li>
<li>注册 ApplicationListenerDetector 对象</li>
<li>注册 LoadTimeWeaverAwareProcessor 对象</li>
<li>注册单例对象 - Environment、Java System Properties 以及 OS 环境变量</li>
</ul>
<h2 id="BeanFactory-后置处理阶段"><a href="#BeanFactory-后置处理阶段" class="headerlink" title="BeanFactory 后置处理阶段"></a>BeanFactory 后置处理阶段</h2><ul>
<li>AbstractApplicationContext#postProcessBeanFactory(ConfigurableListableBeanFactory) 方法<ul>
<li>由子类覆盖该方法</li>
</ul>
</li>
<li>AbstractApplicationContext#invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory 方法<ul>
<li>调用 BeanFactoryPostProcessor 或 BeanDefinitionRegistry 后置处理方法</li>
<li>注册 LoadTimeWeaverAwareProcessor 对象</li>
</ul>
</li>
</ul>
<h2 id="BeanFactory-注册-BeanPostProcessor-阶段"><a href="#BeanFactory-注册-BeanPostProcessor-阶段" class="headerlink" title="BeanFactory 注册 BeanPostProcessor 阶段"></a>BeanFactory 注册 BeanPostProcessor 阶段</h2><p>AbstractApplicationContext#registerBeanPostProcessors(ConfigurableListableBeanFactory) 方法</p>
<ul>
<li>注册 PriorityOrdered 类型的 BeanPostProcessor Beans</li>
<li>注册 Ordered 类型的 BeanPostProcessor Beans</li>
<li>注册普通 BeanPostProcessor Beans</li>
<li>注册 MergedBeanDefinitionPostProcessor Beans</li>
<li>注册 ApplicationListenerDetector 对象</li>
</ul>
<h2 id="初始化內建-Bean：MessageSource"><a href="#初始化內建-Bean：MessageSource" class="headerlink" title="初始化內建 Bean：MessageSource"></a>初始化內建 Bean：MessageSource</h2><p>AbstractApplicationContext#initMessageSource() 方法</p>
<h2 id="初始化內建-Bean：Spring-事件广播器"><a href="#初始化內建-Bean：Spring-事件广播器" class="headerlink" title="初始化內建 Bean：Spring 事件广播器"></a>初始化內建 Bean：Spring 事件广播器</h2><p>AbstractApplicationContext#initApplicationEventMulticaster() 方法</p>
<h2 id="Spring-应用上下文刷新阶段"><a href="#Spring-应用上下文刷新阶段" class="headerlink" title="Spring 应用上下文刷新阶段"></a>Spring 应用上下文刷新阶段</h2><p>AbstractApplicationContext#onRefresh() 方法</p>
<p>子类覆盖该方法</p>
<ul>
<li>org.springframework.web.context.support.AbstractRefreshableWebApplicationContext#onRefresh()</li>
<li>org.springframework.web.context.support.GenericWebApplicationContext#onRefresh()</li>
<li>org.springframework.boot.web.reactive.context.ReactiveWebServerApplicationContext#onRefresh()</li>
<li>org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext#onRefresh()</li>
<li>org.springframework.web.context.support.StaticWebApplicationContext#onRefresh()</li>
</ul>
<h2 id="Spring-事件监听器注册阶段"><a href="#Spring-事件监听器注册阶段" class="headerlink" title="Spring 事件监听器注册阶段"></a>Spring 事件监听器注册阶段</h2><p>AbstractApplicationContext#registerListeners() 方法</p>
<ul>
<li>添加当前应用上下文所关联的 ApplicationListener 对象（集合）</li>
<li>添加 BeanFactory 所注册 ApplicationListener Beans</li>
<li>广播早期 Spring 事件</li>
</ul>
<h2 id="BeanFactory-初始化完成阶段"><a href="#BeanFactory-初始化完成阶段" class="headerlink" title="BeanFactory 初始化完成阶段"></a>BeanFactory 初始化完成阶段</h2><p>AbstractApplicationContext#finishBeanFactoryInitialization(ConfigurableListableBeanFactory) 方法</p>
<ul>
<li>BeanFactory 关联 ConversionService Bean，如果存在</li>
<li>添加 StringValueResolver 对象</li>
<li>依赖查找 LoadTimeWeaverAware Bean</li>
<li>BeanFactory 临时 ClassLoader 置为 null</li>
<li>BeanFactory 冻结配置</li>
<li>BeanFactory 初始化非延迟单例 Beans</li>
</ul>
<h2 id="Spring-应用上下刷新完成阶段"><a href="#Spring-应用上下刷新完成阶段" class="headerlink" title="Spring 应用上下刷新完成阶段"></a>Spring 应用上下刷新完成阶段</h2><p>AbstractApplicationContext#finishRefresh() 方法</p>
<ul>
<li>清除 ResourceLoader 缓存 - clearResourceCaches() @since 5.0</li>
<li>初始化 LifecycleProcessor 对象 - initLifecycleProcessor()</li>
<li>调用 LifecycleProcessor#onRefresh() 方法</li>
<li>发布 Spring 应用上下文已刷新事件 - ContextRefreshedEvent</li>
<li>向 MBeanServer 托管 Live Beans</li>
</ul>
<h2 id="Spring-应用上下文启动阶段"><a href="#Spring-应用上下文启动阶段" class="headerlink" title="Spring 应用上下文启动阶段"></a>Spring 应用上下文启动阶段</h2><p>AbstractApplicationContext#start() 方法</p>
<ul>
<li>启动 LifecycleProcessor<ul>
<li>依赖查找 Lifecycle Beans</li>
<li>启动 Lifecycle Beans</li>
</ul>
</li>
<li>发布 Spring 应用上下文已启动事件 - ContextStartedEvent</li>
</ul>
<h2 id="Spring-应用上下文停止阶段"><a href="#Spring-应用上下文停止阶段" class="headerlink" title="Spring 应用上下文停止阶段"></a>Spring 应用上下文停止阶段</h2><p>AbstractApplicationContext#stop() 方法</p>
<ul>
<li>停止 LifecycleProcessor<ul>
<li>依赖查找 Lifecycle Beans</li>
<li>停止 Lifecycle Beans</li>
</ul>
</li>
<li>发布 Spring 应用上下文已停止事件 - ContextStoppedEvent</li>
</ul>
<h2 id="Spring-应用上下文关闭阶段"><a href="#Spring-应用上下文关闭阶段" class="headerlink" title="Spring 应用上下文关闭阶段"></a>Spring 应用上下文关闭阶段</h2><p>AbstractApplicationContext#close() 方法</p>
<ul>
<li>状态标识：active(false)、closed(true)</li>
<li>Live Beans JMX 撤销托管<ul>
<li>LiveBeansView.unregisterApplicationContext(ConfigurableApplicationContext)</li>
</ul>
</li>
<li>发布 Spring 应用上下文已关闭事件 - ContextClosedEvent</li>
<li>关闭 LifecycleProcessor<ul>
<li>依赖查找 Lifecycle Beans</li>
<li>停止 Lifecycle Beans</li>
</ul>
</li>
<li>销毁 Spring Beans</li>
<li>关闭 BeanFactory</li>
<li>回调 onClose()</li>
<li>注册 Shutdown Hook 线程（如果曾注册）</li>
</ul>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><strong>Spring 应用上下文生命周期有哪些阶段</strong>？</p>
<ul>
<li>刷新阶段 - ConfigurableApplicationContext#refresh()</li>
<li>启动阶段 - ConfigurableApplicationContext#start()</li>
<li>停止阶段 - ConfigurableApplicationContext#stop()</li>
<li>关闭阶段 - ConfigurableApplicationContext#close()</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans">Spring 官方文档之 Core Technologies</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/course/intro/265">《小马哥讲 Spring 核心编程思想》</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/47/">47</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备2021160229号 </a>
  </div>
  <div class="copyright">
    &copy; 2015 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">李狗蛋</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">3.5m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">53:28</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/yiyirushi/" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.1/dist/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  




<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>

</body>
</html>
