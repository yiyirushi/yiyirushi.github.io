<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/uploads/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/uploads/favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.ligoudan.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="天气不错哇，你看这大冰雹下得">
<meta property="og:type" content="website">
<meta property="og:title" content="LIGOUDAN">
<meta property="og:url" content="https://www.ligoudan.cn/page/44/index.html">
<meta property="og:site_name" content="LIGOUDAN">
<meta property="og:description" content="天气不错哇，你看这大冰雹下得">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="李狗蛋">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://www.ligoudan.cn/page/44/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/44/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>LIGOUDAN</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">LIGOUDAN</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">好好学习，天天向上</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">326</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">137</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">461</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="李狗蛋"
      src="/uploads/ligoudan.png">
  <p class="site-author-name" itemprop="name">李狗蛋</p>
  <div class="site-description" itemprop="description">天气不错哇，你看这大冰雹下得</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">461</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">137</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">326</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/yiyirushi" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yiyirushi" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yuanhaohoo@163.com" title="E-Mail → mailto:yuanhaohoo@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/ff930b/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/ff930b/" class="post-title-link" itemprop="url">设计模式之简单工厂模式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2015-06-03 09:41:00" itemprop="dateCreated datePublished" datetime="2015-06-03T09:41:00+08:00">2015-06-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">设计</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="设计模式之简单工厂模式"><a href="#设计模式之简单工厂模式" class="headerlink" title="设计模式之简单工厂模式"></a>设计模式之简单工厂模式</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="简单工厂模式思想"><a href="#简单工厂模式思想" class="headerlink" title="简单工厂模式思想"></a>简单工厂模式思想</h3><p><strong>简单工厂模式 (Simple Factory)</strong> 又叫静态工厂方法（Static Factory Method）模式。</p>
<p>简单工厂模式通常是定义一个工厂类，这个类可以<strong>根据不同变量返回不同类的产品实例</strong>。</p>
<p>简单工厂模式是一种<strong>对象创建型模式</strong>。但是简单工厂模式<strong>不属于</strong>23 种 Gof 设计模式之一。</p>
<h3 id="简单工厂模式要点"><a href="#简单工厂模式要点" class="headerlink" title="简单工厂模式要点"></a>简单工厂模式要点</h3><p><strong>优点</strong>：简单工厂模式的工厂类是整个模式的关键。其中包含了必要的<strong>逻辑判断</strong>，根据外部信息，决定究竟应该创建哪个具体类的对象。通过使用简单工厂模式，用户无需了解对象如何创建的，只要传入必要信息就可以了。</p>
<p><strong>缺点</strong>：工厂类集中了所有实例的创建逻辑，<strong>违背了高内聚责任分配原则</strong>。随着系统中具体产品类不断增多，势必要不断修改工厂类，不易维护和扩展。同时，这也<strong>违背了开放封闭原则</strong>。</p>
<blockquote>
<p><strong>开放封闭原则</strong>：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</p>
</blockquote>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>如何实现一个具有加减乘除基本功能的计算器？</p>
<p>对于这四种运算来说，都需要两个操作数，差别仅在于返回的结果不同。</p>
<p>由此，我们可以抽象化它们的共性，提炼出一个父类。这个类中包含两个操作数，一个返回结果方法，这个方法期望在子类中得以实现。</p>
<p>以下通过具体代码来说明。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200724093427.png" alt="img"></p>
<p>【Product (Operation) 】</p>
<p>产品角色，简单工厂模式所创建的所有对象的父类，它负责描述<strong>所有实例所共有的公共接口</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Product角色，所有实例所共有的公共接口</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> numA;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> numB;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">GetResult</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【ConcreteProduct 组】</p>
<p>具体产品角色，实现 Product 中的接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConcreteProduct 角色，实现 Product 中的接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Add</span> <span class="keyword">extends</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">GetResult</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> numA + numB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ConcreteProduct 角色，实现 Product 中的接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">GetResult</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> numA - numB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ConcreteProduct 角色，实现 Product 中的接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mul</span> <span class="keyword">extends</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">GetResult</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> numA * numB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ConcreteProduct 角色，实现 Product 中的接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Div</span> <span class="keyword">extends</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">GetResult</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (numB == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ERROR!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numA / numB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【Factory (OperationFactory) 】</p>
<p>工厂角色，简单工厂模式的<strong>核心</strong>，它负责实现<strong>创建所有实例的内部逻辑</strong>。工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工厂角色，简单工厂模式的核心，它负责实现创建所有实例的内部逻辑</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OperationFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Operation <span class="title function_">CreateOperation</span> <span class="params">(<span class="type">char</span> operate)</span> &#123;</span><br><span class="line">        <span class="type">Operation</span> <span class="variable">oper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">switch</span>(operate) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            oper = <span class="keyword">new</span> <span class="title class_">Add</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            oper = <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            oper = <span class="keyword">new</span> <span class="title class_">Mul</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">            oper = <span class="keyword">new</span> <span class="title class_">Div</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【客户端】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleFactoryPattern</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numA</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numB</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">Operation</span> <span class="variable">oper</span> <span class="operator">=</span> OperationFactory.CreateOperation(<span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">        oper.numA = numA;</span><br><span class="line">        oper.numB = numB;</span><br><span class="line">        result = oper.GetResult();</span><br><span class="line">        System.out.println(numA + <span class="string">&quot; + &quot;</span> + numB + <span class="string">&quot; = &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【输出】</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">10 </span>+ <span class="number">3</span> = <span class="number">13</span></span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/2243615/">《Head First 设计模式》</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/2334288/">《大话设计模式》</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/cf046f/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/cf046f/" class="post-title-link" itemprop="url">设计模式之单例模式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2015-06-03 09:24:00" itemprop="dateCreated datePublished" datetime="2015-06-03T09:24:00+08:00">2015-06-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">设计</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="设计模式之单例模式"><a href="#设计模式之单例模式" class="headerlink" title="设计模式之单例模式"></a>设计模式之单例模式</h1><h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p><strong>单例模式</strong>（Singleton）是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。</p>
<p><strong>单例</strong> （Singleton） 类声明了一个名为 <code>get­Instance</code> 获取实例的静态方法来返回其所属类的一个相同实例。</p>
<p>单例的构造函数必须对客户端 （Client） 代码隐藏。 调用 <code>get­Instance</code> 方法必须是获取单例对象的唯一方式。</p>
<p>所有单例的实现都包含以下两个相同的步骤：</p>
<ul>
<li><strong>将默认构造函数设为私有</strong>， 防止其他对象使用单例类的 <code>new</code>运算符。</li>
<li><strong>新建一个静态构建方法作为构造函数</strong>。 该函数会 “偷偷” 调用私有构造函数来创建对象， 并将其保存在一个静态成员变量中。 此后所有对于该函数的调用都将返回这一缓存对象。</li>
</ul>
<p>如果你的代码能够访问单例类， 那它就能调用单例类的静态方法。 无论何时调用该方法， 它总是会返回相同的对象。</p>
<p>单例模式的优点：</p>
<ul>
<li>✔️️️ 你可以保证一个类只有一个实例。</li>
<li>✔️️️ 你获得了一个指向该实例的全局访问节点。</li>
<li>✔️️️ 仅在首次请求单例对象时对其进行初始化。</li>
</ul>
<p>单例模式的缺点：</p>
<ul>
<li>❌ 违反了<em>单一职责原则</em>。 该模式同时解决了两个问题。</li>
<li>❌ 单例模式可能掩盖不良设计， 比如程序各组件之间相互了解过多等。</li>
<li>❌ 该模式在多线程环境下需要进行特殊处理， 避免多个线程多次创建单例对象。</li>
<li>❌ 单例的客户端代码单元测试可能会比较困难， 因为许多测试框架以基于继承的方式创建模拟对象。 由于单例类的构造函数是私有的， 而且绝大部分语言无法重写静态方法， 所以你需要想出仔细考虑模拟单例的方法。 要么干脆不编写测试代码， 或者不使用单例模式。</li>
</ul>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>如果程序中的某个类对于所有客户端只有一个可用的实例， 可以使用单例模式。<br>⚡ 单例模式禁止通过除特殊构建方法以外的任何方式来创建自身类的对象。 该方法可以创建一个新对象， 但如果该对象已经被创建， 则返回已有的对象。</li>
<li>如果你需要更加严格地控制全局变量， 可以使用单例模式。<br>⚡ 单例模式与全局变量不同， 它保证类只存在一个实例。 除了单例类自己以外， 无法通过任何方式替换缓存的实例。</li>
</ul>
<p>请注意， 你可以随时调整限制并设定生成单例实例的数量， 只需修改 <code>获取实例</code> 方法， 即 <code>getInstance</code> 中的代码即可实现。</p>
<p>举例来说，一些资源管理器常常设计成单例模式。</p>
<p>在计算机系统中，需要管理的资源包括软件外部资源，譬如每台计算机可以有若干个打印机，但只能有一个 Printer Spooler， 以避免两个打印作业同时输出到打印机中。</p>
<p>每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。任务管理器中难以启动两个相同的 task。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20210517200626.png" alt="img"></p>
<ol>
<li><strong>单例</strong> （Singleton） 类声明了一个名为 <code>get­Instance</code>获取实例的静态方法来返回其所属类的一个相同实例。<ul>
<li>单例的构造函数必须对客户端 （Client） 代码隐藏。 调用 <code>获取实例</code>方法必须是获取单例对象的唯一方式。</li>
</ul>
</li>
</ol>
<h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><p>在本例中， 数据库连接类即是一个<strong>单例</strong>。</p>
<p>该类不提供公有构造函数， 因此获取该对象的唯一方式是调用 <code>获取实例</code>方法。 该方法将缓存首次生成的对象， 并为所有后续调用返回该对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据库类会对`getInstance（获取实例）`方法进行定义以让客户端在程序各处</span></span><br><span class="line"><span class="comment">// 都能访问相同的数据库连接实例。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Database</span> is</span><br><span class="line">    <span class="comment">// 保存单例实例的成员变量必须被声明为静态类型。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> field instance: Database</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例的构造函数必须永远是私有类型，以防止使用`new`运算符直接调用构</span></span><br><span class="line">    <span class="comment">// 造方法。</span></span><br><span class="line">    <span class="keyword">private</span> constructor <span class="title function_">Database</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// 部分初始化代码（例如到数据库服务器的实际连接）。</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于控制对单例实例的访问权限的静态方法。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> method <span class="title function_">getInstance</span><span class="params">()</span> is</span><br><span class="line">        <span class="title function_">if</span> <span class="params">(Database.instance == <span class="literal">null</span>)</span> then</span><br><span class="line">            <span class="title function_">acquireThreadLock</span><span class="params">()</span> and then</span><br><span class="line">                <span class="comment">// 确保在该线程等待解锁时，其他线程没有初始化该实例。</span></span><br><span class="line">                <span class="keyword">if</span> (Database.instance == <span class="literal">null</span>) then</span><br><span class="line">                    Database.instance = <span class="keyword">new</span> <span class="title class_">Database</span>()</span><br><span class="line">        <span class="keyword">return</span> Database.instance</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后，任何单例都必须定义一些可在其实例上执行的业务逻辑。</span></span><br><span class="line">    <span class="keyword">public</span> method <span class="title function_">query</span><span class="params">(sql)</span> is</span><br><span class="line">        <span class="comment">// 比如应用的所有数据库查询请求都需要通过该方法进行。因此，你可以</span></span><br><span class="line">        <span class="comment">// 在这里添加限流或缓冲逻辑。</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line">    method <span class="title function_">main</span><span class="params">()</span> is</span><br><span class="line">        <span class="type">Database</span> <span class="variable">foo</span> <span class="operator">=</span> Database.getInstance()</span><br><span class="line">        foo.query(<span class="string">&quot;SELECT ...&quot;</span>)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="type">Database</span> <span class="variable">bar</span> <span class="operator">=</span> Database.getInstance()</span><br><span class="line">        bar.query(<span class="string">&quot;SELECT ...&quot;</span>)</span><br><span class="line">        <span class="comment">// 变量 `bar` 和 `foo` 中将包含同一个对象。</span></span><br></pre></td></tr></table></figure>

<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p><strong>使用示例：</strong> 许多开发者将单例模式视为一种反模式。 因此它在 Java 代码中的使用频率正在逐步减少。</p>
<p>尽管如此， Java 核心程序库中仍有相当多的单例示例：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/8/docs/api/java/lang/Runtime.html#getRuntime--"><code>java.lang.Runtime#getRuntime()</code></a></li>
<li><a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/8/docs/api/java/awt/Desktop.html#getDesktop--"><code>java.awt.Desktop#getDesktop()</code></a></li>
<li><a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/8/docs/api/java/lang/System.html#getSecurityManager--"><code>java.lang.System#getSecurityManager()</code></a></li>
</ul>
<p><strong>识别方法：</strong> 单例可以通过返回相同缓存对象的静态构建方法来识别。</p>
<h3 id="数据库连接类"><a href="#数据库连接类" class="headerlink" title="数据库连接类"></a>数据库连接类</h3><p>数据库连接类即是一个<strong>单例</strong>。</p>
<p>该类不提供公有构造函数， 因此获取该对象的唯一方式是调用 <code>获取实例</code>方法。 该方法将缓存首次生成的对象， 并为所有后续调用返回该对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据库类会对`getInstance（获取实例）`方法进行定义以让客户端在程序各处</span></span><br><span class="line"><span class="comment">// 都能访问相同的数据库连接实例。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Database</span> is</span><br><span class="line">    <span class="comment">// 保存单例实例的成员变量必须被声明为静态类型。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> field instance: Database</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例的构造函数必须永远是私有类型，以防止使用`new`运算符直接调用构</span></span><br><span class="line">    <span class="comment">// 造方法。</span></span><br><span class="line">    <span class="keyword">private</span> constructor <span class="title function_">Database</span><span class="params">()</span> is</span><br><span class="line">        <span class="comment">// 部分初始化代码（例如到数据库服务器的实际连接）。</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于控制对单例实例的访问权限的静态方法。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> method <span class="title function_">getInstance</span><span class="params">()</span> is</span><br><span class="line">        <span class="title function_">if</span> <span class="params">(Database.instance == <span class="literal">null</span>)</span> then</span><br><span class="line">            <span class="title function_">acquireThreadLock</span><span class="params">()</span> and then</span><br><span class="line">                <span class="comment">// 确保在该线程等待解锁时，其他线程没有初始化该实例。</span></span><br><span class="line">                <span class="keyword">if</span> (Database.instance == <span class="literal">null</span>) then</span><br><span class="line">                    Database.instance = <span class="keyword">new</span> <span class="title class_">Database</span>()</span><br><span class="line">        <span class="keyword">return</span> Database.instance</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后，任何单例都必须定义一些可在其实例上执行的业务逻辑。</span></span><br><span class="line">    <span class="keyword">public</span> method <span class="title function_">query</span><span class="params">(sql)</span> is</span><br><span class="line">        <span class="comment">// 比如应用的所有数据库查询请求都需要通过该方法进行。因此，你可以</span></span><br><span class="line">        <span class="comment">// 在这里添加限流或缓冲逻辑。</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> is</span><br><span class="line">    method <span class="title function_">main</span><span class="params">()</span> is</span><br><span class="line">        <span class="type">Database</span> <span class="variable">foo</span> <span class="operator">=</span> Database.getInstance()</span><br><span class="line">        foo.query(<span class="string">&quot;SELECT ...&quot;</span>)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="type">Database</span> <span class="variable">bar</span> <span class="operator">=</span> Database.getInstance()</span><br><span class="line">        bar.query(<span class="string">&quot;SELECT ...&quot;</span>)</span><br><span class="line">        <span class="comment">// 变量 `bar` 和 `foo` 中将包含同一个对象。</span></span><br></pre></td></tr></table></figure>

<h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><p>懒汉式的实现思路是：你不找懒汉，懒汉根本就懒得去初始化自己。</p>
<p><code>instance</code> 初始时没有初始化，只有当第一次调 <code>getInstance()</code> 时才创建实例。</p>
<p><strong>缺点</strong>：当有两个线程调 <code>getInstance()</code> 方法，当它们同时执行到 <code>if (null == instance)</code> 这行代码，<code>instance</code> 为 <code>null</code>。</p>
<p>继续向下执行，会生成两个实例，违背了单例模式的初衷。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Singleton()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">LazySingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == instance) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>懒汉式的实现思路是：饿汉根本等不及别人来找他，不管三七二十一先初始化了自身的实例，生怕自己饿着了。</p>
<p>类默认先直接初始化一个实例，以后调用 <code>getInstance()</code> 总是返回这个已创建好的实例。</p>
<p><strong>缺点</strong>：在没有必要获取实例时，已经预先产生了开销。</p>
<p><strong>优点</strong>：规避了懒汉式方法的线程问题，不用显示编写线程安全代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HungerSinleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">HungerSinleton</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Singleton()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">HungerSinleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HungerSinleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HungerSinleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双重锁的形式"><a href="#双重锁的形式" class="headerlink" title="双重锁的形式"></a>双重锁的形式</h3><p>如果既不想在没有调用 <code>getInstance(</code>) 方法时产生开销，又不想发生线程安全问题，就可以采用双重锁的形式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncSingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SyncSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Singleton()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SyncSingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SyncSingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == instance) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(SyncSingleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == instance) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">SyncSingleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注：在外面判断了 instance 实例是否存在，为什么在锁定后又要在内部又判断一次？</strong></p>
<p>这是因为，如果 <code>instance</code> 为 <code>null</code> 时有两个线程同时调用 <code>getInstance()</code>，由于 <code>synchronized</code> 机制，只允许一个线程进入，另一个需要等待。</p>
<p>这时如果没有第二道 <code>instance</code> 是否为 <code>null</code> 的判断，就可能发生第一个线程创建一个实例，而第二个线程又创建一个实例的情况。</p>
</blockquote>
<h2 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><ul>
<li><a target="_blank" rel="noopener" href="https://refactoringguru.cn/design-patterns/facade">外观模式</a>类通常可以转换为<a target="_blank" rel="noopener" href="https://refactoringguru.cn/design-patterns/singleton">单例模式</a>类， 因为在大部分情况下一个外观对象就足够了。</li>
<li>如果你能将对象的所有共享状态简化为一个享元对象， 那么<a target="_blank" rel="noopener" href="https://refactoringguru.cn/design-patterns/flyweight">享元模式</a>就和<a target="_blank" rel="noopener" href="https://refactoringguru.cn/design-patterns/singleton">单例</a>类似了。 但这两个模式有两个根本性的不同。<ol>
<li>只会有一个单例实体， 但是<em>享元</em>类可以有多个实体， 各实体的内在状态也可以不同。</li>
<li><em>单例</em>对象可以是可变的。 享元对象是不可变的。</li>
</ol>
</li>
<li><a target="_blank" rel="noopener" href="https://refactoringguru.cn/design-patterns/abstract-factory">抽象工厂模式</a>、 <a target="_blank" rel="noopener" href="https://refactoringguru.cn/design-patterns/builder">生成器模式</a>和<a target="_blank" rel="noopener" href="https://refactoringguru.cn/design-patterns/prototype">原型模式</a>都可以用<a target="_blank" rel="noopener" href="https://refactoringguru.cn/design-patterns/singleton">单例</a>来实现。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/2243615/">《Head First 设计模式》</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/2334288/">《大话设计模式》</a></li>
<li><a target="_blank" rel="noopener" href="https://refactoringguru.cn/design-patterns/catalog">设计模式教程</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/6c31ed/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/6c31ed/" class="post-title-link" itemprop="url">数组和链表</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2015-04-10 18:46:13" itemprop="dateCreated datePublished" datetime="2015-04-10T18:46:13+08:00">2015-04-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构和算法</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%80%A7%E8%A1%A8/" itemprop="url" rel="index"><span itemprop="name">线性表</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="数组和链表"><a href="#数组和链表" class="headerlink" title="数组和链表"></a>数组和链表</h1><blockquote>
<p>数组和链表分别代表了连续空间和不连续空间的存储方式，它们是线性表（Linear List）的典型代表。其他所有的数据结构，比如栈、队列、二叉树、B+ 树等，实际上都是这两者的结合和变化。</p>
</blockquote>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组用 <strong>连续</strong> 的内存空间来存储数据。</p>
<h3 id="数组的访问"><a href="#数组的访问" class="headerlink" title="数组的访问"></a>数组的访问</h3><p>数组元素的访问是以行或列索引的单一下标表示。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220320115836.png" alt="img"></p>
<p>在上面的例子中，数组 a 中有 5 个元素。<code>也就是说</code>，a 的长度是 6 。我们可以使用 a[0] 来表示数组中的第一个元素。因此，a[0] &#x3D; A 。类似地，a[1] &#x3D; B，a[2] &#x3D; C，依此类推。</p>
<h3 id="数组的插入"><a href="#数组的插入" class="headerlink" title="数组的插入"></a>数组的插入</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220320115848.png" alt="img"></p>
<h3 id="数组的删除"><a href="#数组的删除" class="headerlink" title="数组的删除"></a>数组的删除</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220320115859.png" alt="img"></p>
<h3 id="数组的特性"><a href="#数组的特性" class="headerlink" title="数组的特性"></a>数组的特性</h3><p>数组设计之初是在形式上依赖内存分配而成的，所以必须在使用前预先分配好空间大小。这使得数组有以下特性：</p>
<ol>
<li><strong>用连续的内存空间来存储数据</strong>。</li>
<li>**数组支持随机访问，根据下标随机访问的时间复杂度为 <code>O(1)</code>**。</li>
<li>**数组的插入、删除操作，平均时间复杂度为 <code>O(n)</code>**。</li>
<li><strong>空间大小固定</strong>，一旦建立，不能再改变。扩容只能采用复制数组的方式。</li>
<li>在旧式编程语言中（如有中阶语言之称的 C），程序不会对数组的操作做下界判断，也就有潜在的越界操作的风险。</li>
</ol>
<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>数组是有下标和值组成集合。</p>
<p>如果数组的下标有多个维度，即为多维数组。比如：二维数组可以视为“数组元素为一维数组”的一维数组；三维数组可以视为“数组元素为二维数组”的一维数组；依次类推。</p>
<p>下图是由 M 个行向量，N 个列向量组成的二维数组.</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220320152607.png" alt="img"></p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><blockquote>
<p><strong>链表用不连续的内存空间来存储数据；并通过一个指针按顺序将这些空间串起来，形成一条链</strong>。</p>
</blockquote>
<p>区别于数组，链表中的元素不是存储在内存中连续的一片区域，链表中的数据存储在每一个称之为“结点”复合区域里，在每一个结点除了存储数据以外，还保存了到下一个节点的指针（Pointer）。由于不必按顺序存储，链表在插入数据的时候可以达到 <code>O(1)</code> 的复杂度，但是查找一个节点或者访问特定编号的节点则需要 <code>O(n)</code> 的时间。</p>
<p>链表具有以下特性：</p>
<ul>
<li>链表允许插入和移除任意位置上的节点，其时间复杂度为 <code>O(1)</code></li>
<li>链表没有数组的随机访问特性，<strong>链表只支持顺序访问</strong>，其时间复杂度为 <code>O(n)</code>。</li>
<li>数组的空间大小是固定的，而<strong>链表的空间大小可以动态增长</strong>。相比于数组，链表支持扩容，显然更为灵活，但是由于多了指针域，空间开销也更大。</li>
<li>链表相比于数组，多了头指针、尾指针（非必要），合理使用可以大大提高访问效率。</li>
</ul>
<p>链表有多种类型：</p>
<ul>
<li>单链表</li>
<li>双链表</li>
<li>循环链表</li>
</ul>
<h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>单链表中的每个结点不仅包含数据值，还包含一个指针，指向其后继节点。通过这种方式，单链表将所有结点按顺序组织起来。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220320174829.png" alt="img"></p>
<p>与数组不同，我们无法在常量时间内访问单链表中的随机元素。 如果我们想要获得第 i 个元素，我们必须从头结点逐个遍历。 我们按 <code>索引</code> 来 <code>访问元素</code> 平均要花费 <code>O(N)</code> 时间，其中 N 是链表的长度。</p>
<h4 id="单链表插入"><a href="#单链表插入" class="headerlink" title="单链表插入"></a>单链表插入</h4><p>如果我们想在给定的结点 <code>prev</code> 之后添加新值，我们应该：</p>
<p>（1）使用给定值初始化新结点 <code>cur</code>；</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220320174908.png" alt="img"></p>
<p>（2）将 <code>cur</code> 的 <code>next</code> 字段链接到 <code>prev</code> 的下一个结点 <code>next</code> ；</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220320174919.png" alt="img"></p>
<p>（3）将 <code>prev</code> 中的 <code>next</code> 字段链接到 <code>cur</code> 。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220320174932.png" alt="img"></p>
<p>与数组不同，我们不需要将所有元素移动到插入元素之后。因此，您可以在 <code>O(1)</code> 时间复杂度中将新结点插入到链表中，这非常高效。</p>
<h4 id="单链表删除"><a href="#单链表删除" class="headerlink" title="单链表删除"></a>单链表删除</h4><p>如果我们想从单链表中删除现有结点 <code>cur</code>，可以分两步完成：</p>
<p>（1）找到 <code>cur</code> 的上一个结点 <code>prev</code> 及其下一个结点 <code>next</code> ；</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220320174953.png" alt="img"></p>
<p>（2）接下来链接 <code>prev</code> 到 <code>cur</code> 的下一个节点 <code>next</code> 。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220320175006.png" alt="img"></p>
<p>在我们的第一步中，我们需要找出 <code>prev</code> 和 <code>next</code>。使用 <code>cur</code> 的参考字段很容易找出 <code>next</code>，但是，我们必须从头结点遍历链表，以找出 <code>prev</code>，它的平均时间是 <code>O(N)</code>，其中 <code>N</code> 是链表的长度。因此，删除结点的时间复杂度将是 <code>O(N)</code>。</p>
<p>空间复杂度为 <code>O(1)</code>，因为我们只需要常量空间来存储指针。</p>
<h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><p>双链表中的每个结点不仅包含数据值，还包含两个指针，分别指向指向其前驱节点和后继节点。</p>
<p>单链表的访问是单向的，而双链表的访问是双向的。显然，双链表比单链表操作更灵活，但是空间开销也更大。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220320181150.png" alt="img"></p>
<p>双链表以类似的方式工作，但<code>还有一个引用字段</code>，称为<code>“prev”</code>字段。有了这个额外的字段，您就能够知道当前结点的前一个结点。</p>
<h4 id="双链表插入"><a href="#双链表插入" class="headerlink" title="双链表插入"></a>双链表插入</h4><p>如果我们想在给定的结点 <code>prev</code> 之后添加新值，我们应该：</p>
<p>（1）使用给定值初始化新结点 <code>cur</code>；</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220320181208.png" alt="img"></p>
<p>（2）链接 <code>cur</code> 与 <code>prev</code> 和 <code>next</code>，其中 <code>next</code> 是 <code>prev</code> 原始的下一个节点；</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220320181303.png" alt="img"></p>
<p>（3）用 <code>cur</code> 重新链接 <code>prev</code> 和 <code>next</code>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220320181504.png" alt="img"></p>
<p>与单链表类似，添加操作的时间和空间复杂度都是 <code>O(1)</code>。</p>
<h4 id="双链表删除"><a href="#双链表删除" class="headerlink" title="双链表删除"></a>双链表删除</h4><p>如果我们想从双链表中删除一个现有的结点 <code>cur</code>，我们可以简单地将它的前一个结点 <code>prev</code> 与下一个结点 <code>next</code> 链接起来。</p>
<p>与单链表不同，使用 <code>prev</code> 字段可以很容易地在常量时间内获得前一个结点。</p>
<p>因为我们不再需要遍历链表来获取前一个结点，所以时间和空间复杂度都是 <code>O(1)</code>。</p>
<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><h4 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h4><p><strong>循环单链表是一种特殊的单链表</strong>。它和单链表唯一的区别就在最后结点。</p>
<ul>
<li>单链表的最后一个结点的后继指针 <code>next</code> 指向空地址。</li>
<li>循环链表的最后一个结点的后继指针 <code>next</code> 指向第一个节点（如果有头节点，就指向头节点）。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220322190534.png" alt="img"></p>
<h4 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表"></a>循环双链表</h4><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220322190423.png" alt="img"></p>
<h2 id="数组-vs-链表"><a href="#数组-vs-链表" class="headerlink" title="数组 vs. 链表"></a>数组 vs. 链表</h2><ul>
<li><strong>存储方式</strong><ul>
<li>数组用 <strong>连续</strong> 的内存空间来存储数据。</li>
<li>链表用 <strong>不连续</strong> 的内存空间来存储数据；并通过一个指针按顺序将这些空间串起来，形成一条链。</li>
</ul>
</li>
<li><strong>访问方式</strong><ul>
<li>数组<strong>支持随机访问</strong>。根据下标随机访问的时间复杂度为 <code>O(1)</code></li>
<li>链表<strong>不支持随机访问</strong>，只能顺序访问，时间复杂度为 <code>O(n)</code>。</li>
</ul>
</li>
<li><strong>空间大小</strong><ul>
<li>数组空间<strong>大小固定</strong>，扩容只能采用复制数组的方式。</li>
<li>链表空间<strong>大小不固定</strong>，扩容灵活。</li>
</ul>
</li>
<li><strong>效率比较</strong><ul>
<li>数组的 <strong>查找</strong> 效率高于链表。</li>
<li>链表的 <strong>添加</strong>、<strong>删除</strong> 效率高于数组。</li>
</ul>
</li>
</ul>
<h2 id="数组和链表的基本操作示例"><a href="#数组和链表的基本操作示例" class="headerlink" title="数组和链表的基本操作示例"></a>数组和链表的基本操作示例</h2><p>关于数组和链表的基本操作，网上和各种书籍、教程中已经有大量的示例，感兴趣可以自行搜索。本文只是简单展示一下数组和链表的基本操作。</p>
<h3 id="一维数组的基本操作"><a href="#一维数组的基本操作" class="headerlink" title="一维数组的基本操作"></a>一维数组的基本操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. Initialize</span></span><br><span class="line">        <span class="type">int</span>[] a0 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span>[] a1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="comment">// 2. Get Length</span></span><br><span class="line">        System.out.println(<span class="string">&quot;The size of a1 is: &quot;</span> + a1.length);</span><br><span class="line">        <span class="comment">// 3. Access Element</span></span><br><span class="line">        System.out.println(<span class="string">&quot;The first element is: &quot;</span> + a1[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 4. Iterate all Elements</span></span><br><span class="line">        System.out.print(<span class="string">&quot;[Version 1] The contents of a1 are:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a1.length; ++i) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot; &quot;</span> + a1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.print(<span class="string">&quot;[Version 2] The contents of a1 are:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> item: a1) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot; &quot;</span> + item);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">// 5. Modify Element</span></span><br><span class="line">        a1[<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line">        <span class="comment">// 6. Sort</span></span><br><span class="line">        Arrays.sort(a1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二维数组的基本操作"><a href="#二维数组的基本操作" class="headerlink" title="二维数组的基本操作"></a>二维数组的基本操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TwoDimensionArray</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span>[][] a)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; ++i) &#123;</span><br><span class="line">            System.out.println(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; a[i] != <span class="literal">null</span> &amp;&amp; j &lt; a[i].length; ++j) &#123;</span><br><span class="line">                System.out.print(a[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Example I:&quot;</span>);</span><br><span class="line">        <span class="type">int</span>[][] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][<span class="number">5</span>];</span><br><span class="line">        printArray(a);</span><br><span class="line">        System.out.println(<span class="string">&quot;Example II:&quot;</span>);</span><br><span class="line">        <span class="type">int</span>[][] b = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][];</span><br><span class="line">        printArray(b);</span><br><span class="line">        System.out.println(<span class="string">&quot;Example III:&quot;</span>);</span><br><span class="line">        b[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">        b[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">        printArray(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单链表的基本操作"><a href="#单链表的基本操作" class="headerlink" title="单链表的基本操作"></a>单链表的基本操作</h3><p>单链表节点的数据结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span>&lt;E&gt; &#123;</span><br><span class="line">    E value;</span><br><span class="line">    ListNode&lt;E&gt; next; <span class="comment">// 指向后继节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleLinkList</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> ListNode&lt;E&gt; head; <span class="comment">// 头节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）从头部添加节点（即头插法）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addHead</span><span class="params">(E value)</span> &#123;</span><br><span class="line">    ListNode&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">ListNode</span>&lt;&gt;(value, <span class="literal">null</span>);</span><br><span class="line">    newNode.next = <span class="built_in">this</span>.head.next;</span><br><span class="line">    <span class="built_in">this</span>.head.next = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）从尾部添加节点（即尾插法）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addTail</span><span class="params">(E value)</span> &#123;</span><br><span class="line">    <span class="comment">// init new node</span></span><br><span class="line">    ListNode&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">ListNode</span>&lt;&gt;(value, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find the last node</span></span><br><span class="line">    ListNode&lt;E&gt; node = <span class="built_in">this</span>.head;</span><br><span class="line">    <span class="keyword">while</span> (node.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add new node to tail</span></span><br><span class="line">    node.next = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）删除节点</p>
<p>找到要删除元素的前驱节点，将前驱节点的 next 指针指向下一个节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(E value)</span> &#123;</span><br><span class="line">    ListNode&lt;E&gt; prev = <span class="built_in">this</span>.head;</span><br><span class="line">    <span class="keyword">while</span> (prev.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        ListNode&lt;E&gt; curr = prev.next;</span><br><span class="line">        <span class="keyword">if</span> (curr.value.equals(value)) &#123;</span><br><span class="line">            prev.next = curr.next;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = prev.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）查找节点</p>
<p>从头开始查找，一旦发现有数值与查找值相等的节点，直接返回此节点。如果遍历结束，表明未找到节点，返回 null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode&lt;E&gt; <span class="title function_">find</span><span class="params">(E value)</span> &#123;</span><br><span class="line">    ListNode&lt;E&gt; node = <span class="built_in">this</span>.head.next;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.value.equals(value)) &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双链表的基本操作"><a href="#双链表的基本操作" class="headerlink" title="双链表的基本操作"></a>双链表的基本操作</h3><p>双链表节点的数据结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DListNode</span>&lt;E&gt; &#123;</span><br><span class="line">    E value;</span><br><span class="line">    DListNode&lt;E&gt; prev; <span class="comment">// 指向前驱节点</span></span><br><span class="line">    DListNode&lt;E&gt; next; <span class="comment">// 指向后继节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoubleLinkList</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">/** 头节点 */</span></span><br><span class="line">    <span class="keyword">private</span> DListNode&lt;E&gt; head;</span><br><span class="line">    <span class="comment">/** 尾节点 */</span></span><br><span class="line">    <span class="keyword">private</span> DListNode&lt;E&gt; tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）从头部添加节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addHead</span><span class="params">(E value)</span> &#123;</span><br><span class="line">    DListNode&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">DListNode</span>&lt;&gt;(<span class="literal">null</span>, value, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.head.next.prev = newNode;</span><br><span class="line">    newNode.next = <span class="built_in">this</span>.head.next;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.head.next = newNode;</span><br><span class="line">    newNode.prev = <span class="built_in">this</span>.head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）从尾部添加节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addTail</span><span class="params">(E value)</span> &#123;</span><br><span class="line">    DListNode&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">DListNode</span>&lt;&gt;(<span class="literal">null</span>, value, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.tail.prev.next = newNode;</span><br><span class="line">    newNode.prev = <span class="built_in">this</span>.tail.prev;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.tail.prev = newNode;</span><br><span class="line">    newNode.next = <span class="built_in">this</span>.tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）删除节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(E value)</span> &#123;</span><br><span class="line">    DListNode&lt;E&gt; prev = <span class="built_in">this</span>.head;</span><br><span class="line">    <span class="keyword">while</span> (prev.next != <span class="built_in">this</span>.tail) &#123;</span><br><span class="line">        DListNode&lt;E&gt; curr = prev.next;</span><br><span class="line">        <span class="keyword">if</span> (curr.value.equals(value)) &#123;</span><br><span class="line">            prev.next = curr.next;</span><br><span class="line">            curr.next.prev = prev;</span><br><span class="line">            curr.next = <span class="literal">null</span>;</span><br><span class="line">            curr.prev = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = prev.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）查找节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> DListNode&lt;E&gt; <span class="title function_">find</span><span class="params">(E value)</span> &#123;</span><br><span class="line">    DListNode&lt;E&gt; node = <span class="built_in">this</span>.head.next;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="built_in">this</span>.tail) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.value.equals(value)) &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ul>
<li>数组<ul>
<li><input checked="" disabled="" type="checkbox"> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-pivot-index/">724. 寻找数组的中心下标</a></li>
<li><input checked="" disabled="" type="checkbox"> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-insert-position/">35. 搜索插入位置</a></li>
<li><input checked="" disabled="" type="checkbox"> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-intervals/">56. 合并区间</a></li>
</ul>
</li>
<li>链表<ul>
<li><input disabled="" type="checkbox"> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/leetbook/read/linked-list/jy291/">设计链表</a></li>
<li><input disabled="" type="checkbox"> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/leetbook/read/linked-list/jbex5/">环形链表</a></li>
<li><input disabled="" type="checkbox"> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/leetbook/read/linked-list/jjhf6/">环形链表 II</a></li>
<li><input disabled="" type="checkbox"> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/leetbook/read/linked-list/jjbj2/">相交链表</a></li>
<li><input disabled="" type="checkbox"> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/leetbook/read/linked-list/jf1cc/">删除链表的倒数第 N 个节点</a></li>
<li><input disabled="" type="checkbox"> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/leetbook/read/linked-list/f58sg/">反转链表</a></li>
<li><input disabled="" type="checkbox"> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/leetbook/read/linked-list/f9izv/">移除链表元素</a></li>
<li><input disabled="" type="checkbox"> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/leetbook/read/linked-list/fe0kj/">奇偶链表</a></li>
<li><input disabled="" type="checkbox"> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/leetbook/read/linked-list/fov6t/">回文链表</a></li>
<li><input disabled="" type="checkbox"> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/leetbook/read/linked-list/fnzd1/">合并两个有序链表</a></li>
<li><input disabled="" type="checkbox"> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/leetbook/read/linked-list/fv6w7/">两数相加</a></li>
<li><input disabled="" type="checkbox"> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/leetbook/read/linked-list/fw8v5/">扁平化多级双向链表</a></li>
<li><input disabled="" type="checkbox"> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/leetbook/read/linked-list/fdi26/">复制带随机指针的链表</a></li>
<li><input disabled="" type="checkbox"> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/leetbook/read/linked-list/f00a2/">旋转链表</a></li>
</ul>
</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100017301">数据结构与算法之美</a></li>
<li><a target="_blank" rel="noopener" href="https://item.jd.com/12407475.html">数据结构（C 语言版）</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/25859528/">数据结构（C++语言版）</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/leetbook/detail/array-and-string/">Leetcode：数组和字符串</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/tag/linked-list/">Leetcode：链表</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/5dd75b/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/5dd75b/" class="post-title-link" itemprop="url">图</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2015-03-24 15:31:13" itemprop="dateCreated datePublished" datetime="2015-03-24T15:31:13+08:00">2015-03-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构和算法</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>在计算机科学中，一个图就是一些<em>顶点</em>的集合，这些顶点通过一系列<em>边</em>结对（连接）。顶点用圆圈表示，边就是这些圆圈之间的连线。顶点之间通过边连接。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/data-structure/graph/graph.png" alt="img"></p>
<h2 id="什么是图"><a href="#什么是图" class="headerlink" title="什么是图"></a>什么是图</h2><ul>
<li><strong>阶（Order）</strong> - 图 G 中点集 V 的大小称作图 G 的阶。</li>
<li><strong>子图（Sub-Graph）</strong> - 当图 G’&#x3D;(V’,E’)其中 V‘包含于 V，E’包含于 E，则 G’称作图 G&#x3D;(V,E)的子图。每个图都是本身的子图。</li>
<li>生成子图（Spanning Sub-Graph） - 指满足条件 V(G’) &#x3D; V(G)的 G 的子图 G’。</li>
<li>导出子图（Induced Subgraph） - 以图 G 的顶点集 V 的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%9D%9E%E7%A9%BA%E5%AD%90%E9%9B%86/10180460">非空子集</a>V1 为顶点集，以两端点均在 V1 中的全体边为边集的 G 的子图，称为 V1 导出的导出子图；以图 G 的边集 E 的非空子集 E1 为边集，以 E1 中边关联的顶点的全体为顶点集的 G 的子图，称为 E1 导出的导出子图。</li>
<li><strong>有向图</strong> - 如果给图的每条边规定一个方向，那么得到的图称为有向图。</li>
<li><strong>无向图</strong> - 边没有方向的图称为无向图。</li>
<li><strong>度（Degree）</strong> - 一个顶点的度是指与该顶点相关联的边的条数，顶点 v 的度记作 d(v)。</li>
<li><strong>入度（In-degree）</strong>和<strong>出度（Out-degree）</strong> - 对于有向图来说，一个顶点的度可细分为入度和出度。一个顶点的入度是指与其关联的各边之中，以其为终点的边数；出度则是相对的概念，指以该顶点为起点的边数。</li>
<li><strong>自环（Loop）</strong> - 若一条边的两个顶点为同一顶点，则此边称作自环。</li>
<li>路径（Path） - 从 u 到 v 的一条路径是指一个序列 v0,e1,v1,e2,v2,…ek,vk，其中 ei 的顶点为 vi 及 vi - 1，k 称作路径的长度。如果它的起止顶点相同，该路径是“闭”的，反之，则称为“开”的。一条路径称为一简单路径(simple path)，如果路径中除起始与终止<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%A1%B6%E7%82%B9">顶点</a>可以重合外，所有顶点两两不等。</li>
<li><strong>行迹（Trace）</strong> - 如果路径 P(u,v)中的边各不相同，则该路径称为 u 到 v 的一条行迹。闭的行迹称作回路（Circuit）。</li>
<li><strong>轨迹（Track）</strong> - 如果路径 P(u,v)中的顶点各不相同，则该路径称为 u 到 v 的一条轨迹。闭的轨迹称作圈（Cycle）。</li>
<li><strong>桥（Bridge）</strong> - 若去掉一条边，便会使得整个图不连通，该边称为<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%A1%A5">桥</a>。</li>
</ul>
<p>如果图的边没有方向性，则被成为无向图。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220314093554.jpg" alt="img"></p>
<h2 id="图的基本操作"><a href="#图的基本操作" class="headerlink" title="图的基本操作"></a>图的基本操作</h2><ul>
<li>创建一个图结构 - CreateGraph(G)</li>
<li>检索给定顶点 - LocateVex(G,elem)</li>
<li>获取图中某个顶点 - GetVex(G,v)</li>
<li>为图中顶点赋值 - PutVex(G,v,value)</li>
<li>返回第一个邻接点 - FirstAdjVex(G,v)</li>
<li>返回下一个邻接点 - NextAdjVex(G,v,w)</li>
<li>插入一个顶点 - InsertVex(G,v)</li>
<li>删除一个顶点 - DeleteVex(G,v)</li>
<li>插入一条边 - InsertEdge(G,v,w)</li>
<li>删除一条边 - DeleteEdge(G,v,w)</li>
<li>遍历图 - Traverse(G,v)</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100017301">数据结构与算法之美</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/be34fc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/be34fc/" class="post-title-link" itemprop="url">哈希表</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2015-03-16 14:19:59" itemprop="dateCreated datePublished" datetime="2015-03-16T14:19:59+08:00">2015-03-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构和算法</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><blockquote>
<p><strong>哈希表</strong> 是一种使用 <strong>哈希函数</strong> 组织数据，以支持快速插入和搜索的数据结构。</p>
<p>有两种不同类型的哈希表：<strong>哈希集合</strong> 和 <strong>哈希映射</strong>。</p>
<ul>
<li><strong>哈希集合</strong> 是集合数据结构的实现之一，用于存储非重复值。</li>
<li><strong>哈希映射</strong> 是映射 数据结构的实现之一，用于存储(key, value)键值对。</li>
</ul>
</blockquote>
<h2 id="什么是哈希表"><a href="#什么是哈希表" class="headerlink" title="什么是哈希表"></a>什么是哈希表</h2><p>哈希表的英文叫“Hash Table”，我们平时也叫它“散列表”或者“Hash 表”。</p>
<p><strong>哈希表</strong> 是一种使用 <strong>哈希函数</strong> 组织数据，以支持快速插入和搜索的数据结构。</p>
<p>有两种不同类型的哈希表：<strong>哈希集合</strong> 和 <strong>哈希映射</strong>。</p>
<ul>
<li><strong>哈希集合</strong> 是集合数据结构的实现之一，用于存储非重复值。</li>
<li><strong>哈希映射</strong> 是映射 数据结构的实现之一，用于存储(key, value)键值对。</li>
</ul>
<p><strong>哈希表用的是数组支持按照下标随机访问数据的特性，所以哈希表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有哈希表</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220320201844.png" alt="img"></p>
<p>哈希表通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。按照键值查询元素时，用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。</p>
<p>有两种不同类型的哈希表：哈希集合和哈希映射。</p>
<ul>
<li><code>哈希集合</code>是<code>集合</code>数据结构的实现之一，用于存储<code>非重复值</code>。</li>
<li><code>哈希映射</code>是<code>映射</code> 数据结构的实现之一，用于存储<code>(key, value)</code>键值对。</li>
</ul>
<p>在<code>标准模板库</code>的帮助下，哈希表是<code>易于使用的</code>。大多数常见语言（如 Java，C ++ 和 Python）都支持哈希集合和哈希映射。</p>
<h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><p>散列函数，顾名思义，它是一个函数。我们可以把它定义成 **hash(key)**，其中 key 表示元素的键值，hash(key) 的值表示经过散列函数计算得到的散列值。</p>
<p>哈希表的关键思想是使用哈希函数将键映射到存储桶。更确切地说，</p>
<ol>
<li>当我们插入一个新的键时，哈希函数将决定该键应该分配到哪个桶中，并将该键存储在相应的桶中；</li>
<li>当我们想要搜索一个键时，哈希表将使用相同的哈希函数来查找对应的桶，并只在特定的桶中进行搜索。</li>
</ol>
<p>散列函数将取决于 <code>键值的范围</code> 和 <code>桶的数量</code> 。</p>
<p><strong>散列函数设计的基本要求</strong>：</p>
<ol>
<li>散列函数计算得到的散列值是一个非负整数；</li>
<li>如果 key1 &#x3D; key2，那 hash(key1) &#x3D;&#x3D; hash(key2)；</li>
<li>如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)。</li>
</ol>
<h3 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h3><p>即便像业界著名的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/MD5">MD5</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/SHA%E5%AE%B6%E6%97%8F">SHA</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%BE%AA%E7%92%B0%E5%86%97%E9%A4%98%E6%A0%A1%E9%A9%97">CRC</a>等哈希算法，也无法完全避免这种<strong>散列冲突</strong>。</p>
<p>该如何解决散列冲突问题呢？我们常用的散列冲突解决方法有两类，开放寻址法（open addressing）和链表法（chaining）。</p>
<h3 id="装载因子"><a href="#装载因子" class="headerlink" title="装载因子"></a>装载因子</h3><p>当哈希表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证哈希表的操作效率，一般情况下，我们会尽可能保证哈希表中有一定比例的空闲槽位。我们用<strong>装载因子</strong>（load factor）来表示空位的多少。</p>
<p>装载因子的计算公式是：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">哈希表的装载因子 <span class="operator">=</span> 填入表中的元素个数 / 哈希表的长度</span><br></pre></td></tr></table></figure>

<p><strong>装载因子越大，说明空闲位置越少，冲突越多</strong>，哈希表的性能会下降。不仅插入数据的过程要多次寻址或者拉很长的链，查找的过程也会因此变得很慢。</p>
<p>当装载因子过大时，就需要对哈希表扩容。新申请一个更大的哈希表，将数据搬移到这个新哈希表中。针对数组的扩容，数据搬移操作比较简单。但是，针对哈希表的扩容，数据搬移操作要复杂很多。因为哈希表的大小变了，数据的存储位置也变了，所以我们需要通过散列函数重新计算每个数据的存储位置。</p>
<p>插入一个数据，最好情况下，不需要扩容，最好时间复杂度是 O(1)。最坏情况下，哈希表装载因子过高，启动扩容，我们需要重新申请内存空间，重新计算哈希位置，并且搬移数据，所以时间复杂度是 O(n)。用摊还分析法，均摊情况下，时间复杂度接近最好情况，就是 O(1)。</p>
<p>装载因子阈值需要选择得当。如果太大，会导致冲突过多；如果太小，会导致内存浪费严重。</p>
<h3 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><p>开放寻址法的核心思想是，如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入。</p>
<p><strong>当数据量比较小、装载因子小的时候，适合采用开放寻址法。这也是 Java 中的 <code>ThreadLocalMap</code> 使用开放寻址法解决散列冲突的原因</strong>。</p>
<p><strong>线性探测</strong>（Linear Probing）：当我们往哈希表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220323200359.png"></p>
<p>对于使用线性探测法解决冲突的哈希表，删除操作稍微有些特别。我们不能单纯地把要删除的元素设置为空。这是为什么呢？在查找的时候，一旦我们通过线性探测方法，找到一个空闲位置，我们就可以认定哈希表中不存在这个数据。但是，如果这个空闲位置是我们后来删除的，就会导致原来的查找算法失效。本来存在的数据，会被认定为不存在。这个问题如何解决呢？</p>
<p>我们可以将删除的元素，特殊标记为 deleted。当线性探测查找的时候，遇到标记为 deleted 的空间，并不是停下来，而是继续往下探测。</p>
<p>线性探测法其实存在很大问题。当哈希表中插入的数据越来越多时，散列冲突发生的可能性就会越来越大，空闲位置会越来越少，线性探测的时间就会越来越久。极端情况下，我们可能需要探测整个哈希表，所以最坏情况下的时间复杂度为 O(n)。同理，在删除和查找时，也有可能会线性探测整张哈希表，才能找到要查找或者删除的数据。</p>
<h3 id="链表法"><a href="#链表法" class="headerlink" title="链表法"></a>链表法</h3><p>在哈希表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。</p>
<p>链表法比起开放寻址法，对大装载因子的容忍度更高。开放寻址法只能适用装载因子小于 1 的情况。接近 1 时，就可能会有大量的散列冲突，导致大量的探测、再散列等，性能会下降很多。但是对于链表法来说，只要散列函数的值随机均匀，即便装载因子变成 10，也就是链表的长度变长了而已，虽然查找效率有所下降，但是比起顺序查找还是快很多。</p>
<p><strong>基于链表的散列冲突处理方法比较适合存储大对象、大数据量的哈希表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220323200419.png"></p>
<p>当插入的时候，我们只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，所以插入的时间复杂度是 O(1)。当查找、删除一个元素时，我们同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除。那查找或删除操作的时间复杂度是多少呢？</p>
<p>实际上，这两个操作的时间复杂度跟链表的长度 k 成正比，也就是 O(k)。对于散列比较均匀的散列函数来说，理论上讲，k&#x3D;n&#x2F;m，其中 n 表示散列中数据的个数，m 表示哈希表中“槽”的个数。</p>
<h3 id="开放寻址法-vs-链表法"><a href="#开放寻址法-vs-链表法" class="headerlink" title="开放寻址法 vs. 链表法"></a>开放寻址法 vs. 链表法</h3><p><strong>开放寻址法适用于数据量比较小、装载因子小的场景</strong>。</p>
<p><strong>链表法适用于存储大对象、大数据量的哈希表</strong>。<strong>比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表</strong>。</p>
<h2 id="哈希表的应用场景"><a href="#哈希表的应用场景" class="headerlink" title="哈希表的应用场景"></a>哈希表的应用场景</h2><p>哈希算法的应用非常非常多，最常见的七个，分别是：</p>
<ul>
<li><strong>安全加密</strong>：如：MD5、SHA</li>
<li><strong>唯一标识</strong>：UUID</li>
<li>数据校验：数字签名</li>
<li><strong>散列函数</strong>：</li>
<li><strong>负载均衡</strong>：会话粘滞（session sticky）负载均衡算法。<strong>可以通过哈希算法，对客户端 IP 地址或者会话 ID 计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该被路由到的服务器编号。</strong> 这样，我们就可以把同一个 IP 过来的所有请求，都路由到同一个后端服务器上。</li>
<li>数据分片</li>
<li>分布式存储：一致性哈希算法、虚拟哈希槽</li>
</ul>
<h3 id="典型应用场景"><a href="#典型应用场景" class="headerlink" title="典型应用场景"></a>典型应用场景</h3><p>Java 的 HashMap 工具类，其</p>
<ul>
<li>HashMap 默认的初始大小是 16</li>
<li>最大装载因子默认是 0.75，当 HashMap 中元素个数超过 0.75*capacity（capacity 表示哈希表的容量）的时候，就会启动扩容，每次扩容都会扩容为原来的两倍大小。</li>
<li>HashMap 底层采用链表法来解决冲突。即使负载因子和散列函数设计得再合理，也免不了会出现链表过长的情况，一旦出现链表过长，则会严重影响 HashMap 的性能。在 JDK1.8 版本中，对 HashMap 做了进一步优化：引入了红黑树。当链表长度太长（默认超过 8）时，链表就转换为红黑树。我们可以利用红黑树快速增删改查的特点，提高 HashMap 的性能。当红黑树结点个数少于 8 个的时候，又会将红黑树转化为链表。因为在数据量较小的情况下，红黑树要维护平衡，比起链表来，性能上的优势并不明显。</li>
</ul>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>Leetcode 练习题：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/design-hashset/">705. 设计哈希集合</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/design-hashmap/">706. 设计哈希映射</a></li>
</ul>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol>
<li>假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？</li>
<li>有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100017301">数据结构与算法之美</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/241e98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/241e98/" class="post-title-link" itemprop="url">数据结构和算法指南</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2015-03-10 18:29:37" itemprop="dateCreated datePublished" datetime="2015-03-10T18:29:37+08:00">2015-03-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构和算法</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%BB%BC%E5%90%88/" itemprop="url" rel="index"><span itemprop="name">综合</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>318</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="数据结构和算法指南"><a href="#数据结构和算法指南" class="headerlink" title="数据结构和算法指南"></a>数据结构和算法指南</h1><h2 id="1-为什么学习数据结构和算法"><a href="#1-为什么学习数据结构和算法" class="headerlink" title="1. 为什么学习数据结构和算法"></a>1. 为什么学习数据结构和算法</h2><ul>
<li><strong>为了找到一份好工作</strong>：大厂面试喜欢考算法</li>
<li><strong>更深入了解流行技术的设计思想</strong>：数据结构和算法是计算机基础学科，很多框架、中间、底层系统设的设计，都借鉴了其思想。因此，掌握数据结构和算法，有利于更深入了解这些技术的设计思想。</li>
<li>提升个人的编程水平</li>
<li>不满足于做业务狗，拓展性能思考的视角</li>
</ul>
<h2 id="2-如何学习数据结构和算法"><a href="#2-如何学习数据结构和算法" class="headerlink" title="2. 如何学习数据结构和算法"></a>2. 如何学习数据结构和算法</h2><p>数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。</p>
<p>数据结构和算法是相辅相成的。<strong>数据结构是为算法服务的，算法要作用在特定的数据结构之上。</strong></p>
<p>先要学会复杂度分析，才能识别数据结构和算法的利弊。</p>
<ul>
<li>循序渐进</li>
<li>边学边练，适度刷题</li>
<li>学习并思考：学而不思则罔，思而不学则殆</li>
<li>知识需要沉淀，不要想试图一下子掌握所有</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/b14afb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/b14afb/" class="post-title-link" itemprop="url">线性表的查找</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2015-03-10 18:29:13" itemprop="dateCreated datePublished" datetime="2015-03-10T18:29:13+08:00">2015-03-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构和算法</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%80%A7%E8%A1%A8/" itemprop="url" rel="index"><span itemprop="name">线性表</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="线性表的查找"><a href="#线性表的查找" class="headerlink" title="线性表的查找"></a>线性表的查找</h1><h2 id="查找简介"><a href="#查找简介" class="headerlink" title="查找简介"></a>查找简介</h2><h3 id="什么是查找？"><a href="#什么是查找？" class="headerlink" title="什么是查找？"></a>什么是查找？</h3><p><strong>查找</strong>是根据给定的某个值，在表中确定一个关键字的值等于给定值的记录或数据元素。</p>
<h3 id="查找算法的分类"><a href="#查找算法的分类" class="headerlink" title="查找算法的分类"></a>查找算法的分类</h3><p>若在查找的同时对表记录做修改操作（如插入和删除），则相应的表称之为<strong>动态查找表</strong>；</p>
<p>否则，称之为<strong>静态查找表</strong>。</p>
<p>此外，如果查找的全过程都在内存中进行，称之为<strong>内查找</strong>；</p>
<p>反之，如果查找过程中需要访问外存，称之为<strong>外查找</strong>。</p>
<h3 id="查找算法性能比较的标准"><a href="#查找算法性能比较的标准" class="headerlink" title="查找算法性能比较的标准"></a>查找算法性能比较的标准</h3><p><strong>——平均查找长度 ASL（Average Search Length）</strong></p>
<p>由于查找算法的主要运算是关键字的比较过程，所以通常把查找过程中对关键字需要执行的<strong>平均比较长度</strong>（也称为<strong>平均比较次数</strong>）作为衡量一个查找算法效率优劣的比较标准。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3101171-a38f84148d091364.gif?imageMogr2/auto-orient/strip" alt="img"></p>
<p><strong>选取查找算法的因素</strong></p>
<p>(1) 使用什么数据存储结构（如线性表、树形表等）。</p>
<p>(2) 表中的次序，即对无序表还是有序表进行查找。</p>
<h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><p><strong>要点</strong></p>
<p>它是一种最简单的查找算法，效率也很低下。</p>
<p><strong>存储结构</strong></p>
<p>没有存储结构要求，可以无序，也可以有序。</p>
<p><strong>基本思想</strong></p>
<p>从数据结构线形表的<strong>一端</strong>开始，<strong>顺序扫描</strong>，<strong>依次</strong>将扫描到的结点关键字与给定值 k 相<strong>比较</strong>，若相等则表示查找成功；</p>
<p>若扫描结束仍没有找到关键字等于 k 的结点，表示查找失败。</p>
<p><strong>核心代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">orderSearch</span><span class="params">(<span class="type">int</span>[] list, <span class="type">int</span> length, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="comment">// 从前往后扫描list数组，如果有元素的值与key相等，直接返回其位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == list[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果扫描完，说明没有元素的值匹配key，返回-1，表示查找失败</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>算法分析</strong></p>
<p>顺序查找算法<strong>最好的情况</strong>是，第一个记录即匹配关键字，则需要比较 <strong>1</strong> 次；</p>
<p><strong>最坏的情况</strong>是，最后一个记录匹配关键字，则需要比较 <strong>N</strong> 次。</p>
<p>所以，顺序查找算法的平均查找长度为</p>
<p>ASL &#x3D; (N + N-1 + … + 2 + 1) &#x2F; N &#x3D; (N+1) &#x2F; 2</p>
<p>顺序查找的<strong>平均时间复杂度</strong>为**O(N)**。</p>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><blockquote>
<p><strong>二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0</strong>。</p>
</blockquote>
<p><strong>存储结构</strong></p>
<p>使用二分查找需要两个前提：</p>
<p>(1) 必须是<strong>顺序</strong>存储结构。</p>
<p>(2) 必须是<strong>有序</strong>的表。</p>
<p><strong>基本思想</strong></p>
<p>首先，将表<strong>中间位置</strong>记录的关键字与查找关键字比较，如果两者相等，则查找成功；</p>
<p>否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。<br>重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。</p>
<p><strong>核心代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] list, <span class="type">int</span> length, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>, mid = <span class="number">0</span>, high = length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (list[mid] == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid; <span class="comment">// 查找成功，直接返回位置</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list[mid] &lt; key) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>; <span class="comment">// 关键字大于中间位置的值，则在大值区间[mid+1, high]继续查找</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>; <span class="comment">// 关键字小于中间位置的值，则在小值区间[low, mid-1]继续查找</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>算法分析</strong></p>
<p><strong>二分查找的过程可看成一个二叉树</strong>。</p>
<p>把查找区间的中间位置视为树的根，左区间和右区间视为根的左子树和右子树。</p>
<p>由此得到的二叉树，称为二分查找的判定树或比较树。</p>
<p>由此可知，二分查找的<strong>平均查找长度</strong>实际上就是树的高度**O(log<sub>2</sub>N)**。</p>
<p><strong>二分查找的局限性</strong></p>
<ul>
<li>二分查找依赖的是顺序表结构，简单点说就是数组</li>
<li>二分查找针对的是有序数据</li>
<li>数据量太小不适合二分查找</li>
<li>数据量太大也不适合二分查找</li>
</ul>
<h2 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h2><p><strong>要点</strong></p>
<p>分块查找(Blocking Search)又称<strong>索引顺序查找</strong>。它是一种性能介于顺序查找和二分查找之间的查找方法。</p>
<p>分块查找由于只要求索引表是有序的，对块内节点没有排序要求，因此特别适合于节点动态变化的情况。</p>
<p><strong>存储结构</strong></p>
<p>分块查找表是由<strong>“分块有序”的线性表</strong>和<strong>索引表</strong>两部分构成的。</p>
<p>所谓<strong>“分块有序”的线性表</strong>，是指：</p>
<p>假设要排序的表为 R[0…N-1]，<strong>将表均匀分成 b 块</strong>，前 b-1 块中记录个数为 s&#x3D;N&#x2F;b，最后一块记录数小于等于 s；</p>
<p>每一块中的关键字不一定有序，但<strong>前一块中的最大关键字必须小于后一块中的最小关键字</strong>。</p>
<p><strong><em>注：这是使用分块查找的前提条件。</em></strong></p>
<p>如上将表均匀分成 b 块后，抽取各块中的<strong>最大关键字</strong>和<strong>起始位置</strong>构成一个索引表 IDX[0…b-1]。</p>
<p>由于表 R 是分块有序的，所以<strong>索引表是一个递增有序表</strong>。</p>
<p>下图就是一个分块查找表的存储结构示意图</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3101171-b7ad44c68d0c3c75.png" alt="img"></p>
<p><strong>基本思想</strong></p>
<p>分块查找算法有两个处理步骤：</p>
<p><strong>(1) 首先查找索引表</strong></p>
<p>因为分块查找表是“分块有序”的，所以我们可以通过索引表来锁定关键字所在的区间。</p>
<p>又因为索引表是递增有序的，所以查找索引可以使用顺序查找或二分查找。</p>
<p><strong>(2) 然后在已确定的块中进行顺序查找</strong></p>
<p>因为块中不一定是有序的，所以只能使用顺序查找。</p>
<p><strong>代码范例</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3101171-2737612c781e66e8.gif?imageMogr2/auto-orient/strip" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BlockSearch</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">IndexType</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> key; <span class="comment">// 分块中的最大值</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> link; <span class="comment">// 分块的起始位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立索引方法，n 是线性表最大长度，gap是分块的最大长度</span></span><br><span class="line">    <span class="keyword">public</span> IndexType[] createIndex(<span class="type">int</span>[] list, <span class="type">int</span> n, <span class="type">int</span> gap) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> n / gap;</span><br><span class="line">        IndexType[] idxGroup = <span class="keyword">new</span> <span class="title class_">IndexType</span>[num]; <span class="comment">// 根据步长数分配索引数组大小</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; num) &#123;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">            idxGroup[i] = <span class="keyword">new</span> <span class="title class_">IndexType</span>();</span><br><span class="line">            idxGroup[i].link = gap * i; <span class="comment">// 确定当前索引组的第一个元素位置</span></span><br><span class="line">            max = list[gap * i]; <span class="comment">// 每次假设当前组的第一个数为最大值</span></span><br><span class="line">            <span class="comment">// 遍历这个分块，找到最大值</span></span><br><span class="line">            <span class="keyword">while</span> (j &lt; gap) &#123;</span><br><span class="line">                <span class="keyword">if</span> (max &lt; list[gap * i + j]) &#123;</span><br><span class="line">                    max = list[gap * i + j];</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            idxGroup[i].key = max;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> idxGroup;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分块查找算法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">blockSearch</span><span class="params">(IndexType[] idxGroup, <span class="type">int</span> m, <span class="type">int</span>[] list, <span class="type">int</span> n, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> m -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> n / m; <span class="comment">// 分块大小等于线性表长度除以组数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先在索引表中进行二分查找，找到的位置存放在 low 中</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (idxGroup[mid].key &gt;= key) &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在索引表中查找成功后，再在线性表的指定块中进行顺序查找</span></span><br><span class="line">        <span class="keyword">if</span> (low &lt; m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> idxGroup[low].link; i &lt; idxGroup[low].link + gap; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (list[i] == key)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印完整序列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printAll</span><span class="params">(<span class="type">int</span>[] list)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : list) &#123;</span><br><span class="line">            System.out.print(value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印索引表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printIDX</span><span class="params">(IndexType[] list)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造索引表如下：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (IndexType elem : list) &#123;</span><br><span class="line">            System.out.format(<span class="string">&quot;key = %d, link = %d\n&quot;</span>, elem.key, elem.link);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> <span class="number">85</span>;</span><br><span class="line">        <span class="type">int</span> array2[] = &#123; <span class="number">8</span>, <span class="number">14</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">22</span>, <span class="number">34</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">31</span>, <span class="number">40</span>, <span class="number">38</span>, <span class="number">54</span>, <span class="number">66</span>, <span class="number">46</span>, <span class="number">71</span>, <span class="number">78</span>, <span class="number">68</span>, <span class="number">80</span>, <span class="number">85</span> &#125;;</span><br><span class="line">        <span class="type">BlockSearch</span> <span class="variable">search</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BlockSearch</span>();</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;线性表: &quot;</span>);</span><br><span class="line">        search.printAll(array2);</span><br><span class="line"></span><br><span class="line">        IndexType[] idxGroup = search.createIndex(array2, array2.length, <span class="number">5</span>);</span><br><span class="line">        search.printIDX(idxGroup);</span><br><span class="line">        <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> search.blockSearch(idxGroup, idxGroup.length, array2,</span><br><span class="line">                array2.length, key);</span><br><span class="line">        <span class="keyword">if</span> (-<span class="number">1</span> == pos) &#123;</span><br><span class="line">            System.out.format(<span class="string">&quot;查找key = %d失败&quot;</span>, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.format(<span class="string">&quot;查找key = %d成功，位置为%d&quot;</span>, key, pos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">线性表:<span class="number"> 8 </span>14<span class="number"> 6 </span>9<span class="number"> 10 </span>22<span class="number"> 34 </span>18<span class="number"> 19 </span>31<span class="number"> 40 </span>38<span class="number"> 54 </span>66<span class="number"> 46 </span>71<span class="number"> 78 </span>68<span class="number"> 80 </span>85</span><br><span class="line">构造索引表如下：</span><br><span class="line">key = 14, link = 0</span><br><span class="line">key = 34, link = 5</span><br><span class="line">key = 66, link = 10</span><br><span class="line">key = 85, link = 15</span><br><span class="line"></span><br><span class="line">查找key = 85成功，位置为19</span><br></pre></td></tr></table></figure>

<p><strong>算法分析</strong></p>
<p>因为分块查找实际上是两次查找过程之和。若以二分查找来确定块，显然它的查找效率介于顺序查找和二分查找之间。</p>
<h2 id="三种线性查找的-PK"><a href="#三种线性查找的-PK" class="headerlink" title="三种线性查找的 PK"></a>三种线性查找的 PK</h2><p>(1) 以平均查找长度而言，二分查找 &gt; 分块查找 &gt; 顺序查找。</p>
<p>(2) 从适用性而言，顺序查找无限制条件，二分查找仅适用于有序表，分块查找要求“分块有序”。</p>
<p>(3) 从存储结构而言，顺序查找和分块查找既可用于顺序表也可用于链表；而二分查找只适用于顺序表。</p>
<p>(4) 分块查找综合了顺序查找和二分查找的优点，既可以较为快速，也能使用动态变化的要求。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/99ac45/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/99ac45/" class="post-title-link" itemprop="url">堆</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2015-03-09 16:01:27" itemprop="dateCreated datePublished" datetime="2015-03-09T16:01:27+08:00">2015-03-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构和算法</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%A0%91/" itemprop="url" rel="index"><span itemprop="name">树</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>741</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="什么是堆？"><a href="#什么是堆？" class="headerlink" title="什么是堆？"></a>什么是堆？</h2><p>堆（Heap）是一个可以被看成近似完全二叉树的数组。</p>
<ul>
<li><strong>堆是一个完全二叉树</strong>。完全二叉树要求，除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。</li>
<li><strong>堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值</strong>。</li>
</ul>
<p>堆可以分为大顶堆和小顶堆。</p>
<ul>
<li><p>对于每个节点的值都大于等于子树中每个节点值的堆，叫作“<strong>大顶堆</strong>”。</p>
</li>
<li><p>对于每个节点的值都小于等于子树中每个节点值的堆，叫作“<strong>小顶堆</strong>”。</p>
</li>
</ul>
<h2 id="如何实现堆"><a href="#如何实现堆" class="headerlink" title="如何实现堆"></a>如何实现堆</h2><p>完全二叉树比较适合用数组来存储。用数组来存储完全二叉树是非常节省存储空间的。因为我们不需要存储左右子节点的指针，单纯地通过数组的下标，就可以找到一个节点的左右子节点和父节点。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220311112542.jpg" alt="img"></p>
<p>堆常见的操作：</p>
<ul>
<li>HEAPIFY 建堆：把一个乱序的数组变成堆结构的数组，时间复杂度为 $$O(n)$$。</li>
<li>HEAPPUSH：把一个数值放进已经是堆结构的数组中，并保持堆结构，时间复杂度为 $$O(log N)$$</li>
<li>HEAPPOP：从最大堆中取出最大值或从最小堆中取出最小值，并将剩余的数组保持堆结构，时间复杂度为 $$O(log N)$$。</li>
<li>HEAPSORT：借由 HEAPFY 建堆和 HEAPPOP 堆数组进行排序，时间复杂度为$$ O(N log N)$$，空间复杂度为 $$O(1)$$。</li>
</ul>
<h2 id="堆的应用场景"><a href="#堆的应用场景" class="headerlink" title="堆的应用场景"></a>堆的应用场景</h2><h3 id="求-TOP-N"><a href="#求-TOP-N" class="headerlink" title="求 TOP N"></a>求 TOP N</h3><p>堆结构的一个常见应用是建立优先队列（Priority Queue）。</p>
<p>求 Top K 的问题抽象成两类。一类是针对静态数据集合；另一类是针对动态数据集合</p>
<h3 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h3><p>在优先级队列中，数据的出队顺序不是先进先出，而是按照优先级来，优先级最高的，最先出队。</p>
<p>堆和优先级队列非常相似：往优先级队列中插入一个元素，就相当于往堆中插入一个元素；从优先级队列中取出优先级最高的元素，就相当于取出堆顶元素。</p>
<blockquote>
<p>参考：Java 的 <code>PriorityQueue</code> 类</p>
</blockquote>
<h3 id="求中位数"><a href="#求中位数" class="headerlink" title="求中位数"></a>求中位数</h3>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/3bac06/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/3bac06/" class="post-title-link" itemprop="url">线性表的排序</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2015-03-03 17:37:24" itemprop="dateCreated datePublished" datetime="2015-03-03T17:37:24+08:00">2015-03-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构和算法</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%80%A7%E8%A1%A8/" itemprop="url" rel="index"><span itemprop="name">线性表</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>13k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>12 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="线性表的排序"><a href="#线性表的排序" class="headerlink" title="线性表的排序"></a>线性表的排序</h1><blockquote>
<p>📦 本文已归档到：“<a target="_blank" rel="noopener" href="https://github.com/dunwu/blog/tree/master/source/_posts/algorithm">blog</a>”</p>
<p>🔁 本文中的示例代码已归档到：“<a target="_blank" rel="noopener" href="https://github.com/dunwu/algorithm-tutorial/blob/master/codes/algorithm/src/test/java/io/github/dunwu/algorithm/sort/SortStrategyTest.java">algorithm-tutorial</a>”</p>
</blockquote>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><p>冒泡排序是一种交换排序。</p>
<p>什么是交换排序呢？</p>
<blockquote>
<p>交换排序：两两比较待排序的关键字，并交换不满足次序要求的那对数，直到整个表都满足次序要求为止。</p>
</blockquote>
<h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。</p>
<p>这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端，故名。</p>
<p>假设有一个大小为 N 的无序序列。冒泡排序就是要每趟排序过程中通过两两比较，找到第 i 个小（大）的元素，将其往上排。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/algorithm/sort/bubble-sort.png" alt="img"></p>
<p>以上图为例，演示一下冒泡排序的实际流程：</p>
<p>假设有一个无序序列 { 4. 3. 1. 2, 5 }</p>
<ul>
<li>第一趟排序：通过两两比较，找到第一小的数值 1 ，将其放在序列的第一位。</li>
<li>第二趟排序：通过两两比较，找到第二小的数值 2 ，将其放在序列的第二位。</li>
<li>第三趟排序：通过两两比较，找到第三小的数值 3 ，将其放在序列的第三位。</li>
</ul>
<p>至此，所有元素已经有序，排序结束。</p>
<p>要将以上流程转化为代码，我们需要像机器一样去思考，不然编译器可看不懂。</p>
<ul>
<li>假设要对一个大小为 N 的无序序列进行升序排序（即从小到大）。<ul>
<li>每趟排序过程中需要通过比较找到第 i 个小的元素。</li>
<li>所以，我们需要一个外部循环，从数组首端(下标 0) 开始，一直扫描到倒数第二个元素（即下标 N - 2) ，剩下最后一个元素，必然为最大。</li>
</ul>
</li>
<li>假设是第 i 趟排序，可知，前 i-1 个元素已经有序。现在要找第 i 个元素，只需从数组末端开始，扫描到第 i 个元素，将它们两两比较即可。<ul>
<li>所以，需要一个内部循环，从数组末端开始（下标 N - 1），扫描到 (下标 i + 1)。</li>
</ul>
</li>
</ul>
<p><strong>核心代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] list)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 用来交换的临时数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要遍历的次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 从后向前依次的比较相邻两个数的大小，遍历一次后，把数组中第i小的数放在第i个位置上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> list.length - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">            <span class="comment">// 比较相邻的元素，如果前面的数大于后面的数，则交换</span></span><br><span class="line">            <span class="keyword">if</span> (list[j - <span class="number">1</span>] &gt; list[j]) &#123;</span><br><span class="line">                temp = list[j - <span class="number">1</span>];</span><br><span class="line">                list[j - <span class="number">1</span>] = list[j];</span><br><span class="line">                list[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.format(<span class="string">&quot;第 %d 趟：\t&quot;</span>, i);</span><br><span class="line">        printAll(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p><strong>冒泡排序算法的性能</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>排序类别</td>
<td>交换排序</td>
</tr>
<tr>
<td>排序方法</td>
<td>冒泡排序</td>
</tr>
<tr>
<td>时间复杂度平均情况</td>
<td>O(N2)</td>
</tr>
<tr>
<td>时间复杂度最坏情况</td>
<td>O(N3)</td>
</tr>
<tr>
<td>时间复杂度最好情况</td>
<td>O(N)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(1)</td>
</tr>
<tr>
<td>稳定性</td>
<td>稳定</td>
</tr>
<tr>
<td>复杂性</td>
<td>简单</td>
</tr>
</tbody></table>
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>若文件的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数 C 和记录移动次数 M 均达到最小值：Cmin &#x3D; N - 1, Mmin &#x3D; 0。所以，冒泡排序最好时间复杂度为 O(N)。</p>
<p>若初始文件是反序的，需要进行 N -1 趟排序。每趟排序要进行 N - i 次关键字的比较(1 ≤ i ≤ N - 1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：</p>
<p>Cmax &#x3D; N(N-1)&#x2F;2 &#x3D; O(N2)</p>
<p>Mmax &#x3D; 3N(N-1)&#x2F;2 &#x3D; O(N2)</p>
<p>冒泡排序的最坏时间复杂度为 O(N2)。</p>
<p>因此，冒泡排序的平均时间复杂度为 O(N2)。</p>
<p>总结起来，其实就是一句话：当数据越接近正序时，冒泡排序性能越好。</p>
<h4 id="算法稳定性"><a href="#算法稳定性" class="headerlink" title="算法稳定性"></a>算法稳定性</h4><p>冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。</p>
<p>所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。</p>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>对冒泡排序常见的改进方法是加入标志性变量 exchange，用于标志某一趟排序过程中是否有数据交换。</p>
<p>如果进行某一趟排序时并没有进行数据交换，则说明所有数据已经有序，可立即结束排序，避免不必要的比较过程。</p>
<p><strong>核心代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对 bubbleSort 的优化算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bubbleSort_2</span><span class="params">(<span class="type">int</span>[] list)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 用来交换的临时数</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">bChange</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 交换标志</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要遍历的次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        bChange = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 从后向前依次的比较相邻两个数的大小，遍历一次后，把数组中第i小的数放在第i个位置上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> list.length - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">            <span class="comment">// 比较相邻的元素，如果前面的数大于后面的数，则交换</span></span><br><span class="line">            <span class="keyword">if</span> (list[j - <span class="number">1</span>] &gt; list[j]) &#123;</span><br><span class="line">                temp = list[j - <span class="number">1</span>];</span><br><span class="line">                list[j - <span class="number">1</span>] = list[j];</span><br><span class="line">                list[j] = temp;</span><br><span class="line">                bChange = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果标志为false，说明本轮遍历没有交换，已经是有序数列，可以结束排序</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">false</span> == bChange)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        System.out.format(<span class="string">&quot;第 %d 趟：\t&quot;</span>, i);</span><br><span class="line">        printAll(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p><a target="_blank" rel="noopener" href="https://github.com/dunwu/algorithm-tutorial/blob/master/codes/algorithm/src/test/java/io/github/dunwu/algorithm/sort/SortStrategyTest.java">我的 Github 测试例</a></p>
<p>样本包含：数组个数为奇数、偶数的情况；元素重复或不重复的情况。且样本均为随机样本，实测有效。</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="要点-1"><a href="#要点-1" class="headerlink" title="要点"></a>要点</h3><blockquote>
<p>快速排序是一种交换排序。</p>
</blockquote>
<p>快速排序由 C. A. R. Hoare 在 1962 年提出。</p>
<h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>它的基本思想是：</p>
<p>通过一趟排序将要排序的数据分割成独立的两部分：分割点左边都是比它小的数，右边都是比它大的数。</p>
<p>然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<p>详细的图解往往比大堆的文字更有说明力，所以直接上图：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/algorithm/sort/quick-sort.png" alt="img"></p>
<p>上图中，演示了快速排序的处理过程：</p>
<ol>
<li>初始状态为一组无序的数组：2、4、5、1、3。</li>
<li>经过以上操作步骤后，完成了第一次的排序，得到新的数组：1、2、5、4、3。</li>
<li>新的数组中，以 2 为分割点，左边都是比 2 小的数，右边都是比 2 大的数。</li>
<li>因为 2 已经在数组中找到了合适的位置，所以不用再动。</li>
<li>2 左边的数组只有一个元素 1，所以显然不用再排序，位置也被确定。（注：这种情况时，left 指针和 right 指针显然是重合的。因此在代码中，我们可以通过设置判定条件 left 必须小于 right，如果不满足，则不用排序了）。</li>
<li>而对于 2 右边的数组 5、4、3，设置 left 指向 5，right 指向 3，开始继续重复图中的一、二、三、四步骤，对新的数组进行排序。</li>
</ol>
<p><strong>核心代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">division</span><span class="params">(<span class="type">int</span>[] list, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="comment">// 以最左边的数(left)为基准</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">base</span> <span class="operator">=</span> list[left];</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 从序列右端开始，向左遍历，直到找到小于base的数</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; list[right] &gt;= base)</span><br><span class="line">            right--;</span><br><span class="line">        <span class="comment">// 找到了比base小的元素，将这个元素放到最左边的位置</span></span><br><span class="line">        list[left] = list[right];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从序列左端开始，向右遍历，直到找到大于base的数</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; list[left] &lt;= base)</span><br><span class="line">            left++;</span><br><span class="line">        <span class="comment">// 找到了比base大的元素，将这个元素放到最右边的位置</span></span><br><span class="line">        list[right] = list[left];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后将base放到left位置。此时，left位置的左侧数值应该都比left小；</span></span><br><span class="line">    <span class="comment">// 而left位置的右侧数值应该都比left大。</span></span><br><span class="line">    list[left] = base;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] list, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左下标一定小于右下标，否则就越界了</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 对数组进行分割，取出下次分割的基准标号</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">base</span> <span class="operator">=</span> division(list, left, right);</span><br><span class="line"></span><br><span class="line">        System.out.format(<span class="string">&quot;base = %d:\t&quot;</span>, list[base]);</span><br><span class="line">        printPart(list, left, right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对“基准标号“左侧的一组数值进行递归的切割，以至于将这些数值完整的排序</span></span><br><span class="line">        quickSort(list, left, base - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对“基准标号“右侧的一组数值进行递归的切割，以至于将这些数值完整的排序</span></span><br><span class="line">        quickSort(list, base + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><p>快速排序算法的性能</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>排序类别</td>
<td>交换排序</td>
</tr>
<tr>
<td>排序方法</td>
<td>快速排序</td>
</tr>
<tr>
<td>时间复杂度平均情况</td>
<td>O(Nlog2N)</td>
</tr>
<tr>
<td>时间复杂度最坏情况</td>
<td>O(N2)</td>
</tr>
<tr>
<td>时间复杂度最好情况</td>
<td>O(Nlog2N)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(Nlog2N)</td>
</tr>
<tr>
<td>稳定性</td>
<td>不稳定</td>
</tr>
<tr>
<td>复杂性</td>
<td>较复杂</td>
</tr>
</tbody></table>
<h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>当数据有序时，以第一个关键字为基准分为两个子序列，前一个子序列为空，此时执行效率最差。</p>
<p>而当数据随机分布时，以第一个关键字为基准分为两个子序列，两个子序列的元素个数接近相等，此时执行效率最好。</p>
<p>所以，数据越随机分布时，快速排序性能越好；数据越接近有序，快速排序性能越差。</p>
<h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>快速排序在每次分割的过程中，需要 1 个空间存储基准值。而快速排序的大概需要 Nlog2N 次的分割处理，所以占用空间也是 Nlog2N 个。</p>
<h4 id="算法稳定性-1"><a href="#算法稳定性-1" class="headerlink" title="算法稳定性"></a>算法稳定性</h4><p>在快速排序中，相等元素可能会因为分区而交换顺序，所以它是不稳定的算法。</p>
<h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><p><a target="_blank" rel="noopener" href="https://github.com/dunwu/algorithm-tutorial/blob/master/codes/algorithm/src/test/java/io/github/dunwu/algorithm/sort/SortStrategyTest.java">我的 Github 测试例</a></p>
<p>样本包含：数组个数为奇数、偶数的情况；元素重复或不重复的情况。且样本均为随机样本，实测有效。</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="要点-2"><a href="#要点-2" class="headerlink" title="要点"></a>要点</h3><blockquote>
<p>直接插入排序是一种最简单的<strong>插入排序</strong>。</p>
<p><strong>插入排序</strong>：每一趟将一个待排序的记录，按照其关键字的大小插入到有序队列的合适位置里，知道全部插入完成。</p>
</blockquote>
<h3 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h3><p>在讲解直接插入排序之前，先让我们脑补一下我们打牌的过程。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/algorithm/sort/insert-sort.png" alt="img"></p>
<ul>
<li>先拿一张 5 在手里，</li>
<li>再摸到一张 4，比 5 小，插到 5 前面，</li>
<li>摸到一张 6，嗯，比 5 大，插到 5 后面，</li>
<li>摸到一张 8，比 6 大，插到 6 后面，</li>
<li>。。。</li>
<li>最后一看，我靠，凑到的居然是同花顺，这下牛逼大了。</li>
</ul>
<p>以上的过程，其实就是典型的<strong>直接插入排序，每次将一个新数据插入到有序队列中的合适位置里</strong>。</p>
<p>很简单吧，接下来，我们要将这个算法转化为编程语言。</p>
<p>假设有一组无序序列 R0, R1, … , RN-1。</p>
<ul>
<li>我们先将这个序列中下标为 0 的元素视为元素个数为 1 的有序序列。</li>
<li>然后，我们要依次把 R1, R2, … , RN-1 插入到这个有序序列中。所以，我们需要一个<strong>外部循环</strong>，从下标 1 扫描到 N-1 。</li>
<li>接下来描述插入过程。假设这是要将 Ri 插入到前面有序的序列中。由前面所述，我们可知，插入 Ri 时，前 i-1 个数肯定已经是有序了。</li>
</ul>
<p>所以我们需要将 Ri 和 R0 ~ Ri-1 进行比较，确定要插入的合适位置。这就需要一个<strong>内部循环</strong>，我们一般是从后往前比较，即从下标 i-1 开始向 0 进行扫描。</p>
<p><strong>核心代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span>[] list)</span> &#123;</span><br><span class="line">   <span class="comment">// 打印第一个元素</span></span><br><span class="line">   System.out.format(<span class="string">&quot;i = %d:\t&quot;</span>, <span class="number">0</span>);</span><br><span class="line">   printPart(list, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 第1个数肯定是有序的，从第2个数开始遍历，依次插入有序序列</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> list[i]; <span class="comment">// 取出第i个数，和前i-1个数比较后，插入合适位置</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 因为前i-1个数都是从小到大的有序序列，所以只要当前比较的数(list[j])比temp大，就把这个数后移一位</span></span><br><span class="line">       <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; temp &lt; list[j]; j--) &#123;</span><br><span class="line">           list[j + <span class="number">1</span>] = list[j];</span><br><span class="line">       &#125;</span><br><span class="line">       list[j + <span class="number">1</span>] = temp;</span><br><span class="line"></span><br><span class="line">       System.out.format(<span class="string">&quot;i = %d:\t&quot;</span>, i);</span><br><span class="line">       printPart(list, <span class="number">0</span>, i);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h3><p><strong>直接插入排序的算法性能</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>排序类别</td>
<td>插入排序</td>
</tr>
<tr>
<td>排序方法</td>
<td>直接插入排序</td>
</tr>
<tr>
<td>时间复杂度平均情况</td>
<td>O(N2)</td>
</tr>
<tr>
<td>时间复杂度最坏情况</td>
<td>O(N2)</td>
</tr>
<tr>
<td>时间复杂度最好情况</td>
<td>O(N)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(1)</td>
</tr>
<tr>
<td>稳定性</td>
<td>稳定</td>
</tr>
<tr>
<td>复杂性</td>
<td>简单</td>
</tr>
</tbody></table>
<h4 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>当数据<strong>正序</strong>时，执行效率<strong>最好</strong>，每次插入都不用移动前面的元素，时间复杂度为 **O(N)**。</p>
<p>当数据<strong>反序</strong>时，执行效率<strong>最差</strong>，每次插入都要前面的元素后移，时间复杂度为 **O(N2)**。</p>
<p>所以，<strong>数据越接近正序，直接插入排序的算法性能越好</strong>。</p>
<h4 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>由直接插入排序算法可知，我们在排序过程中，需要一个临时变量存储要插入的值，所以空间复杂度为 <strong>1</strong> 。</p>
<h4 id="算法稳定性-2"><a href="#算法稳定性-2" class="headerlink" title="算法稳定性"></a>算法稳定性</h4><p>直接插入排序的过程中，不需要改变相等数值元素的位置，所以它是<strong>稳定的</strong>算法。</p>
<h3 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h3><p><a target="_blank" rel="noopener" href="https://github.com/dunwu/algorithm-tutorial/blob/master/codes/algorithm/src/test/java/io/github/dunwu/algorithm/sort/SortStrategyTest.java">我的 Github 测试例</a></p>
<p>样本包含：数组个数为奇数、偶数的情况；元素重复或不重复的情况。且样本均为随机样本，实测有效。</p>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><h3 id="要点-3"><a href="#要点-3" class="headerlink" title="要点"></a>要点</h3><blockquote>
<p>希尔(Shell)排序又称为<strong>缩小增量排序</strong>，它是一种<strong>插入排序</strong>。它<strong>是直接插入排序算法的一种威力加强版</strong>。</p>
</blockquote>
<p>该方法因 DL．Shell 于 1959 年提出而得名。</p>
<h3 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a>算法思想</h3><p>希尔排序的<strong>基本思想</strong>是：</p>
<p>把记录按<strong>步长 gap</strong> 分组，对每组记录采用<strong>直接插入排序</strong>方法进行排序。<br>随着<strong>步长逐渐减小</strong>，所分成的组包含的记录越来越多，当步长的值减小到 <strong>1</strong> 时，整个数据合成为一组，构成一组有序记录，则完成排序。</p>
<p>我们来通过演示图，更深入的理解一下这个过程。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/algorithm/sort/shell-sort.png" alt="img"></p>
<p>在上面这幅图中：</p>
<p>初始时，有一个大小为 10 的无序序列。</p>
<ul>
<li>在<strong>第一趟排序中</strong>，我们不妨设 gap1 &#x3D; N &#x2F; 2 &#x3D; 5，即相隔距离为 5 的元素组成一组，可以分为 5 组。<ul>
<li>接下来，按照直接插入排序的方法对每个组进行排序。</li>
</ul>
</li>
<li>在** 第二趟排序中**，我们把上次的 gap 缩小一半，即 gap2 &#x3D; gap1 &#x2F; 2 &#x3D; 2 (取整数)。这样每相隔距离为 2 的元素组成一组，可以分为 2 组。<ul>
<li>按照直接插入排序的方法对每个组进行排序。</li>
</ul>
</li>
<li>在<strong>第三趟排序中</strong>，再次把 gap 缩小一半，即 gap3 &#x3D; gap2 &#x2F; 2 &#x3D; 1。 这样相隔距离为 1 的元素组成一组，即只有一组。<ul>
<li>按照直接插入排序的方法对每个组进行排序。此时，<strong>排序已经结束</strong>。</li>
</ul>
</li>
</ul>
<p>需要注意一下的是，图中有两个相等数值的元素 <strong>5</strong> 和 <strong>5</strong> 。我们可以清楚的看到，在排序过程中，<strong>两个元素位置交换了</strong>。</p>
<p>所以，希尔排序是不稳定的算法。</p>
<p><strong>核心代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] list)</span> &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> list.length / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span> (<span class="number">1</span> &lt;= gap) &#123;</span><br><span class="line">       <span class="comment">// 把距离为 gap 的元素编为一个组，扫描所有组</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; list.length; i++) &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">           <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> list[i];</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 对距离为 gap 的元素组进行排序</span></span><br><span class="line">           <span class="keyword">for</span> (j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; temp &lt; list[j]; j = j - gap) &#123;</span><br><span class="line">               list[j + gap] = list[j];</span><br><span class="line">           &#125;</span><br><span class="line">           list[j + gap] = temp;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       System.out.format(<span class="string">&quot;gap = %d:\t&quot;</span>, gap);</span><br><span class="line">       printAll(list);</span><br><span class="line">       gap = gap / <span class="number">2</span>; <span class="comment">// 减小增量</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h3><p><strong>希尔排序的算法性能</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>排序类别</td>
<td>插入排序</td>
</tr>
<tr>
<td>排序方法</td>
<td>希尔排序</td>
</tr>
<tr>
<td>时间复杂度平均情况</td>
<td>O(Nlog2N)</td>
</tr>
<tr>
<td>时间复杂度最坏情况</td>
<td>O(N1.5)</td>
</tr>
<tr>
<td>时间复杂度最好情况</td>
<td></td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(1)</td>
</tr>
<tr>
<td>稳定性</td>
<td>不稳定</td>
</tr>
<tr>
<td>复杂性</td>
<td>较复杂</td>
</tr>
</tbody></table>
<h4 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>步长的选择是希尔排序的重要部分。只要最终步长为 1 任何步长序列都可以工作。</p>
<p>算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为 1 进行排序。当步长为 1 时，算法变为插入排序，这就保证了数据一定会被排序。</p>
<p>Donald Shell 最初建议步长选择为 N&#x2F;2 并且对步长取半直到步长达到 1。虽然这样取可以比 O(N2)类的算法（插入排序）更好，但这样仍然有减少平均时间和最差时间的余地。可能希尔排序最重要的地方在于当用较小步长排序后，以前用的较大步长仍然是有序的。比如，如果一个数列以步长 5 进行了排序然后再以步长 3 进行排序，那么该数列不仅是以步长 3 有序，而且是以步长 5 有序。如果不是这样，那么算法在迭代过程中会打乱以前的顺序，那就不会以如此短的时间完成排序了。</p>
<p>已知的最好步长序列是由 Sedgewick 提出的(1, 5, 19, 41, 109,…)，该序列的项来自这两个算式。</p>
<p>这项研究也表明“比较在希尔排序中是最主要的操作，而不是交换。”用这样步长序列的希尔排序比插入排序和堆排序都要快，甚至在小数组中比快速排序还快，但是在涉及大量数据时希尔排序还是比快速排序慢。</p>
<h4 id="算法稳定性-3"><a href="#算法稳定性-3" class="headerlink" title="算法稳定性"></a>算法稳定性</h4><p>由上文的<strong>希尔排序算法演示图</strong>即可知，希尔排序中相等数据可能会交换位置，所以希尔排序是<strong>不稳定</strong>的算法。</p>
<h4 id="直接插入排序和希尔排序的比较"><a href="#直接插入排序和希尔排序的比较" class="headerlink" title="直接插入排序和希尔排序的比较"></a>直接插入排序和希尔排序的比较</h4><ul>
<li>直接插入排序是<strong>稳定的</strong>；而希尔排序是<strong>不稳定</strong>的。</li>
<li>直接插入排序更适合于原始记录基本<strong>有序</strong>的集合。</li>
<li>希尔排序的比较次数和移动次数都要比直接插入排序少，当 N 越大时，效果越明显。</li>
<li>在希尔排序中，增量序列 gap 的取法必须满足：**最后一个步长必须是 1 。 **</li>
<li>直接插入排序也<strong>适用于链式存储结构</strong>；希尔排序<strong>不适用于链式结构</strong>。</li>
</ul>
<h3 id="示例代码-3"><a href="#示例代码-3" class="headerlink" title="示例代码"></a>示例代码</h3><p><a target="_blank" rel="noopener" href="https://github.com/dunwu/algorithm-tutorial/blob/master/codes/algorithm/src/test/java/io/github/dunwu/algorithm/sort/SortStrategyTest.java">我的 Github 测试例</a></p>
<p>样本包含：数组个数为奇数、偶数的情况；元素重复或不重复的情况。且样本均为随机样本，实测有效。</p>
<h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><h3 id="要点-4"><a href="#要点-4" class="headerlink" title="要点"></a>要点</h3><blockquote>
<p>简单选择排序是一种<strong>选择排序</strong>。</p>
<p><strong>选择排序</strong>：每趟从待排序的记录中选出关键字最小的记录，顺序放在已排序的记录序列末尾，直到全部排序结束为止。</p>
</blockquote>
<h3 id="算法思想-4"><a href="#算法思想-4" class="headerlink" title="算法思想"></a>算法思想</h3><ol>
<li>从待排序序列中，找到关键字最小的元素；</li>
<li>如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；</li>
<li>从余下的 N - 1 个元素中，找出关键字最小的元素，重复 1、2 步，直到排序结束。</li>
</ol>
<p>如图所示，每趟排序中，将当前**第 i 小的元素放在位置 i **上。</p>
<p><strong>核心代码</strong></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/algorithm/sort/selection-sort.png" alt="img"></p>
<h3 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h3><p><strong>简单选择排序算法的性能</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>排序类别</td>
<td>选择排序</td>
</tr>
<tr>
<td>排序方法</td>
<td>简单选择排序</td>
</tr>
<tr>
<td>时间复杂度平均情况</td>
<td>O(N2)</td>
</tr>
<tr>
<td>时间复杂度最坏情况</td>
<td>O(N2)</td>
</tr>
<tr>
<td>时间复杂度最好情况</td>
<td>O(N2)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(1)</td>
</tr>
<tr>
<td>稳定性</td>
<td>不稳定</td>
</tr>
<tr>
<td>复杂性</td>
<td>简单</td>
</tr>
</tbody></table>
<h4 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>简单选择排序的比较次数与序列的初始排序无关。 假设待排序的序列有 <strong>N</strong> 个元素，则**比较次数总是 N (N - 1) &#x2F; 2 **。</p>
<p>而移动次数与序列的初始排序有关。当序列正序时，移动次数最少，为 <strong>0</strong>.</p>
<p>当序列反序时，移动次数最多，为 <strong>3N (N - 1) &#x2F; 2</strong>。</p>
<p>所以，综合以上，简单排序的时间复杂度为 **O(N2)**。</p>
<h4 id="空间复杂度-2"><a href="#空间复杂度-2" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>简单选择排序需要占用一个临时空间，在交换数值时使用。</p>
<h3 id="示例代码-4"><a href="#示例代码-4" class="headerlink" title="示例代码"></a>示例代码</h3><p><a target="_blank" rel="noopener" href="https://github.com/dunwu/algorithm-tutorial/blob/master/codes/algorithm/src/test/java/io/github/dunwu/algorithm/sort/SortStrategyTest.java">我的 Github 测试例</a></p>
<p>样本包含：数组个数为奇数、偶数的情况；元素重复或不重复的情况。且样本均为随机样本，实测有效。</p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="要点-5"><a href="#要点-5" class="headerlink" title="要点"></a>要点</h3><p>在介绍堆排序之前，首先需要说明一下，堆是个什么玩意儿。</p>
<p><strong>堆</strong>是一棵<strong>顺序存储</strong>的<strong>完全二叉树</strong>。</p>
<p>其中每个结点的关键字都<strong>不大于</strong>其孩子结点的关键字，这样的堆称为<strong>小根堆</strong>。<br>其中每个结点的关键字都<strong>不小于</strong>其孩子结点的关键字，这样的堆称为<strong>大根堆</strong>。<br>举例来说，对于 n 个元素的序列 {R0, R1, … , Rn} 当且仅当满足下列关系之一时，称之为堆：</p>
<ul>
<li><strong>Ri &lt;&#x3D; R2i+1 且 Ri &lt;&#x3D; R2i+2 （小根堆）</strong></li>
<li><strong>Ri &gt;&#x3D; R2i+1 且 Ri &gt;&#x3D; R2i+2 （大根堆）</strong></li>
</ul>
<p>其中 i&#x3D;1,2,…,n&#x2F;2 向下取整;</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/algorithm/sort/heap-sort.png" alt="img"></p>
<p>如上图所示，序列 R{3, 8,15, 31, 25} 是一个典型的小根堆。</p>
<p>堆中有两个父结点，元素 3 和元素 8。</p>
<p>元素 3 在数组中以 R[0] 表示，它的左孩子结点是 R[1]，右孩子结点是 R[2]。</p>
<p>元素 8 在数组中以 R[1] 表示，它的左孩子结点是 R[3]，右孩子结点是 R[4]，它的父结点是 R[0]。可以看出，它们<strong>满足以下规律</strong>：</p>
<p>设当前元素在数组中以 <strong>R[i]</strong> 表示，那么，</p>
<ul>
<li>它的<strong>左孩子结点</strong>是：<strong>R[2*i+1]</strong>;</li>
<li>它的<strong>右孩子结点</strong>是：<strong>R[2*i+2]</strong>;</li>
<li>它的<strong>父结点</strong>是：<strong>R[(i-1)&#x2F;2]</strong>;</li>
<li>R[i] &lt;&#x3D; R[2*i+1] 且 R[i] &lt;&#x3D; R[2i+2]。</li>
</ul>
<h3 id="算法思想-5"><a href="#算法思想-5" class="headerlink" title="算法思想"></a>算法思想</h3><ul>
<li>首先，按堆的定义将数组 R[0..n]调整为堆（这个过程称为创建初始堆），交换 R[0]和 R[n]；</li>
<li>然后，将 R[0..n-1]调整为堆，交换 R[0]和 R[n-1]；</li>
<li>如此反复，直到交换了 R[0]和 R[1]为止。</li>
</ul>
<p>以上思想可归纳为两个操作：</p>
<ol>
<li>根据初始数组去<strong>构造初始堆</strong>（构建一个完全二叉树，保证所有的父结点都比它的孩子结点数值大）。</li>
<li>每次<strong>交换第一个和最后一个元素，输出最后一个元素</strong>（最大值），然后把剩下元素<strong>重新调整</strong>为大根堆。</li>
</ol>
<p>当输出完最后一个元素后，这个数组已经是按照从小到大的顺序排列了。</p>
<p>先通过详细的实例图来看一下，如何构建初始堆。</p>
<p>设有一个无序序列 { 1, 3,4, 5, 2, 6, 9, 7, 8, 0 }。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/algorithm/sort/heap-sort-02.png" alt="img"></p>
<p>构造了初始堆后，我们来看一下完整的堆排序处理：</p>
<p>还是针对前面提到的无序序列 { 1,3, 4, 5, 2, 6, 9, 7, 8, 0 } 来加以说明。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/algorithm/sort/heap-sort-03.png" alt="img"></p>
<p>相信，通过以上两幅图，应该能很直观的演示堆排序的操作处理。</p>
<p><strong>核心代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">HeapAdjust</span><span class="params">(<span class="type">int</span>[] array2, <span class="type">int</span> parent, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array2[parent]; <span class="comment">// temp保存当前父节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> <span class="number">2</span> * parent + <span class="number">1</span>; <span class="comment">// 先获得左孩子</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (child &lt; length) &#123;</span><br><span class="line">        <span class="comment">// 如果有右孩子结点，并且右孩子结点的值大于左孩子结点，则选取右孩子结点</span></span><br><span class="line">        <span class="keyword">if</span> (child + <span class="number">1</span> &lt; length &amp;&amp; array2[child] &lt; array2[child + <span class="number">1</span>]) &#123;</span><br><span class="line">            child++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果父结点的值已经大于孩子结点的值，则直接结束</span></span><br><span class="line">        <span class="keyword">if</span> (temp &gt;= array2[child])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把孩子结点的值赋给父结点</span></span><br><span class="line">        array2[parent] = array2[child];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选取孩子结点的左孩子结点,继续向下筛选</span></span><br><span class="line">        parent = child;</span><br><span class="line">        child = <span class="number">2</span> * child + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    array2[parent] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] list)</span> &#123;</span><br><span class="line">    <span class="comment">// 循环建立初始堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> list.length / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        HeapAdjust(list, i, list.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行n-1次循环，完成排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> list.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 最后一个元素和第一元素进行交换</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> list[i];</span><br><span class="line">        list[i] = list[<span class="number">0</span>];</span><br><span class="line">        list[<span class="number">0</span>] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 筛选 R[0] 结点，得到i-1个结点的堆</span></span><br><span class="line">        HeapAdjust(list, <span class="number">0</span>, i);</span><br><span class="line">        System.out.format(<span class="string">&quot;第 %d 趟: \t&quot;</span>, list.length - i);</span><br><span class="line">        printPart(list, <span class="number">0</span>, list.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-5"><a href="#算法分析-5" class="headerlink" title="算法分析"></a>算法分析</h3><p><strong>堆排序算法的总体情况</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>排序类别</td>
<td>选择排序</td>
</tr>
<tr>
<td>排序方法</td>
<td>堆排序</td>
</tr>
<tr>
<td>时间复杂度平均情况</td>
<td>O(nlog2n)</td>
</tr>
<tr>
<td>时间复杂度最坏情况</td>
<td>O(nlog2n)</td>
</tr>
<tr>
<td>时间复杂度最好情况</td>
<td>O(nlog2n)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(1)</td>
</tr>
<tr>
<td>稳定性</td>
<td>不稳定</td>
</tr>
<tr>
<td>复杂性</td>
<td>较复杂</td>
</tr>
</tbody></table>
<h4 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>堆的存储表示是<strong>顺序的</strong>。因为堆所对应的二叉树为完全二叉树，而完全二叉树通常采用顺序存储方式。</p>
<p>当想得到一个序列中第 <strong>k</strong> 个最小的元素之前的部分排序序列，最好采用堆排序。</p>
<p>因为堆排序的时间复杂度是 **O(n+klog2n)**，若 <strong>k ≤ n&#x2F;log2n</strong>，则可得到的时间复杂度为 **O(n)**。</p>
<h4 id="算法稳定性-4"><a href="#算法稳定性-4" class="headerlink" title="算法稳定性"></a>算法稳定性</h4><p>堆排序是一种<strong>不稳定</strong>的排序方法。</p>
<p>因为在堆的调整过程中，关键字进行比较和交换所走的是该结点到叶子结点的一条路径，</p>
<p>因此对于相同的关键字就可能出现排在后面的关键字被交换到前面来的情况。</p>
<h3 id="示例代码-5"><a href="#示例代码-5" class="headerlink" title="示例代码"></a>示例代码</h3><p><a target="_blank" rel="noopener" href="https://github.com/dunwu/algorithm-tutorial/blob/master/codes/algorithm/src/test/java/io/github/dunwu/algorithm/sort/SortStrategyTest.java">我的 Github 测试例</a></p>
<p>样本包含：数组个数为奇数、偶数的情况；元素重复或不重复的情况。且样本均为随机样本，实测有效。</p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="要点-6"><a href="#要点-6" class="headerlink" title="要点"></a>要点</h3><blockquote>
<p>归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用<strong>分治法（Divide and Conquer）</strong>的一个非常典型的应用。</p>
<p>将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为<strong>二路归并</strong>。</p>
</blockquote>
<h3 id="算法思想-6"><a href="#算法思想-6" class="headerlink" title="算法思想"></a>算法思想</h3><p>将待排序序列 R[0…n-1] 看成是 n 个长度为 1 的有序序列，将相邻的有序表成对归并，得到 n&#x2F;2 个长度为 2 的有序表；将这些有序序列再次归并，得到 n&#x2F;4 个长度为 4 的有序序列；如此反复进行下去，最后得到一个长度为 n 的有序序列。</p>
<p>综上可知：</p>
<p>归并排序其实要做两件事：</p>
<ul>
<li>“分解”——将序列每次<strong>折半划分</strong>。</li>
<li>“合并”——将划分后的序列段<strong>两两合并后排序</strong>。</li>
</ul>
<p>我们先来考虑第二步，<strong>如何合并</strong>？</p>
<p>在每次合并过程中，都是对两个有序的序列段进行合并，然后排序。</p>
<p>这两个有序序列段分别为 R[low, mid] 和 R[mid+1, high]。</p>
<p>先将他们合并到一个局部的<strong>暂存数组</strong>R2 中，带合并完成后再将 R2 复制回 R 中。</p>
<p>为了方便描述，我们称 R[low, mid] 第一段，R[mid+1, high] 为第二段。</p>
<p>每次从两个段中取出一个记录进行关键字的比较，将较小者放入 R2 中。最后将各段中余下的部分直接复制到 R2 中。</p>
<p>经过这样的过程，R2 已经是一个有序的序列，再将其复制回 R 中，一次合并排序就完成了。</p>
<p><strong>核心代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Merge</span><span class="params">(<span class="type">int</span>[] array2, <span class="type">int</span> low, <span class="type">int</span> mid, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low; <span class="comment">// i是第一段序列的下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> mid + <span class="number">1</span>; <span class="comment">// j是第二段序列的下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// k是临时存放合并序列的下标</span></span><br><span class="line">    <span class="type">int</span>[] array2 = <span class="keyword">new</span> <span class="title class_">int</span>[high - low + <span class="number">1</span>]; <span class="comment">// array2是临时合并序列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描第一段和第二段序列，直到有一个扫描结束</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</span><br><span class="line">        <span class="comment">// 判断第一段和第二段取出的数哪个更小，将其存入合并序列，并继续向下扫描</span></span><br><span class="line">        <span class="keyword">if</span> (array2[i] &lt;= array2[j]) &#123;</span><br><span class="line">            array2[k] = array2[i];</span><br><span class="line">            i++;</span><br><span class="line">            k++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            array2[k] = array2[j];</span><br><span class="line">            j++;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若第一段序列还没扫描完，将其全部复制到合并序列</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">        array2[k] = array2[i];</span><br><span class="line">        i++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若第二段序列还没扫描完，将其全部复制到合并序列</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= high) &#123;</span><br><span class="line">        array2[k] = array2[j];</span><br><span class="line">        j++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将合并序列复制到原始序列中</span></span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>, i = low; i &lt;= high; i++, k++) &#123;</span><br><span class="line">        array2[i] = array2[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>掌握了合并的方法，接下来，让我们来了解<strong>如何分解</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/algorithm/sort/merge-sort.png" alt="img"></p>
<p>在某趟归并中，设各子表的长度为 <strong>gap</strong>，则归并前 R[0…n-1] 中共有 <strong>n&#x2F;gap</strong> 个有序的子表：<code>R[0...gap-1]</code>, <code>R[gap...2*gap-1]</code>, … , <code>R[(n/gap)*gap ... n-1]</code>。</p>
<p>调用 Merge <strong>将相邻的子表归并</strong>时，必须对表的特殊情况进行特殊处理。</p>
<p>若子表个数为奇数，则最后一个子表无须和其他子表归并（即本趟处理轮空）：若子表个数为偶数，则要注意到最后一对子表中后一个子表区间的上限为 n-1。</p>
<p><strong>核心代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">MergePass</span><span class="params">(<span class="type">int</span>[] array2, <span class="type">int</span> gap, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 归并gap长度的两个相邻子表</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i + <span class="number">2</span> * gap - <span class="number">1</span> &lt; length; i = i + <span class="number">2</span> * gap) &#123;</span><br><span class="line">        Merge(array2, i, i + gap - <span class="number">1</span>, i + <span class="number">2</span> * gap - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 余下两个子表，后者长度小于gap</span></span><br><span class="line">    <span class="keyword">if</span> (i + gap - <span class="number">1</span> &lt; length) &#123;</span><br><span class="line">        Merge(array2, i, i + gap - <span class="number">1</span>, length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] list) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> <span class="number">1</span>; gap &lt; list.length; gap = <span class="number">2</span> * gap) &#123;</span><br><span class="line">        MergePass(list, gap, list.length);</span><br><span class="line">        System.out.print(<span class="string">&quot;gap = &quot;</span> + gap + <span class="string">&quot;:\t&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.printAll(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-6"><a href="#算法分析-6" class="headerlink" title="算法分析"></a>算法分析</h3><p><strong>归并排序算法的性能</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>排序类别</td>
<td>归并排序</td>
</tr>
<tr>
<td>排序方法</td>
<td>归并排序</td>
</tr>
<tr>
<td>时间复杂度平均情况</td>
<td>O(nlog2n)</td>
</tr>
<tr>
<td>时间复杂度最坏情况</td>
<td>O(nlog2n)</td>
</tr>
<tr>
<td>时间复杂度最好情况</td>
<td>O(nlog2n)</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(n)</td>
</tr>
<tr>
<td>稳定性</td>
<td>稳定</td>
</tr>
<tr>
<td>复杂性</td>
<td>较复杂</td>
</tr>
</tbody></table>
<h4 id="时间复杂度-6"><a href="#时间复杂度-6" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>归并排序的形式就是一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的可以得出它的时间复杂度是 **O(n*log2n)**。</p>
<h4 id="空间复杂度-3"><a href="#空间复杂度-3" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>由前面的算法说明可知，算法处理过程中，需要一个大小为 <strong>n</strong> 的临时存储空间用以保存合并序列。</p>
<h4 id="算法稳定性-5"><a href="#算法稳定性-5" class="headerlink" title="算法稳定性"></a>算法稳定性</h4><p>在归并排序中，相等的元素的顺序不会改变，所以它是<strong>稳定的</strong>算法。</p>
<h4 id="归并排序和堆排序、快速排序的比较"><a href="#归并排序和堆排序、快速排序的比较" class="headerlink" title="归并排序和堆排序、快速排序的比较"></a>归并排序和堆排序、快速排序的比较</h4><p>若从空间复杂度来考虑：首选堆排序，其次是快速排序，最后是归并排序。</p>
<p>若从稳定性来考虑，应选取归并排序，因为堆排序和快速排序都是不稳定的。</p>
<p>若从平均情况下的排序速度考虑，应该选择快速排序。</p>
<h3 id="示例代码-6"><a href="#示例代码-6" class="headerlink" title="示例代码"></a>示例代码</h3><p><a target="_blank" rel="noopener" href="https://github.com/dunwu/algorithm-tutorial/blob/master/codes/algorithm/src/test/java/io/github/dunwu/algorithm/sort/SortStrategyTest.java">我的 Github 测试例</a></p>
<p>样本包含：数组个数为奇数、偶数的情况；元素重复或不重复的情况。且样本均为随机样本，实测有效。</p>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><h3 id="要点-7"><a href="#要点-7" class="headerlink" title="要点"></a>要点</h3><p>基数排序与本系列前面讲解的七种排序方法都不同，它<strong>不需要比较关键字的大小</strong>。</p>
<p>它是根据关键字中各位的值，通过对排序的 N 个元素进行若干趟“分配”与“收集”来实现排序的。</p>
<p>不妨通过一个具体的实例来展示一下，基数排序是如何进行的。</p>
<p>设有一个初始序列为: R {50, 123, 543, 187, 49, 30,0, 2, 11, 100}。</p>
<p>我们知道，任何一个阿拉伯数，它的各个位数上的基数都是以 0~9 来表示的。</p>
<p>所以我们不妨把 0~9 视为 10 个桶。</p>
<p>我们先根据序列的个位数的数字来进行分类，将其分到指定的桶中。例如：R[0] &#x3D; 50，个位数上是 0，将这个数存入编号为 0 的桶中。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/algorithm/sort/radix-sort.png" alt="img"></p>
<p>分类后，我们在从各个桶中，将这些数按照从编号 0 到编号 9 的顺序依次将所有数取出来。</p>
<p>这时，得到的序列就是个位数上呈递增趋势的序列。</p>
<p>按照个位数排序： {50, 30, 0, 100, 11, 2, 123,543, 187, 49}。</p>
<p>接下来，可以对十位数、百位数也按照这种方法进行排序，最后就能得到排序完成的序列。</p>
<h3 id="算法分析-7"><a href="#算法分析-7" class="headerlink" title="算法分析"></a>算法分析</h3><p><strong>基数排序的性能</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>排序类别</td>
<td>基数排序</td>
</tr>
<tr>
<td>排序方法</td>
<td>基数排序</td>
</tr>
<tr>
<td>时间复杂度平均情况</td>
<td>O(d(n+r))</td>
</tr>
<tr>
<td>时间复杂度最坏情况</td>
<td>O(d(n+r))</td>
</tr>
<tr>
<td>时间复杂度最好情况</td>
<td>O(d(n+r))</td>
</tr>
<tr>
<td>空间复杂度</td>
<td>O(n+r)</td>
</tr>
<tr>
<td>稳定性</td>
<td>稳定</td>
</tr>
<tr>
<td>复杂性</td>
<td>较复杂</td>
</tr>
</tbody></table>
<h4 id="时间复杂度-7"><a href="#时间复杂度-7" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>通过上文可知，假设在基数排序中，r 为基数，d 为位数。则基数排序的时间复杂度为 **O(d(n+r))**。</p>
<p>我们可以看出，基数排序的效率和初始序列是否有序没有关联。</p>
<h4 id="空间复杂度-4"><a href="#空间复杂度-4" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>在基数排序过程中，对于任何位数上的基数进行“装桶”操作时，都需要 <strong>n+r</strong> 个临时空间。</p>
<h4 id="算法稳定性-6"><a href="#算法稳定性-6" class="headerlink" title="算法稳定性"></a>算法稳定性</h4><p>在基数排序过程中，每次都是将当前位数上相同数值的元素统一“装桶”，并不需要交换位置。所以基数排序是<strong>稳定</strong>的算法。</p>
<h3 id="示例代码-7"><a href="#示例代码-7" class="headerlink" title="示例代码"></a>示例代码</h3><p><a target="_blank" rel="noopener" href="https://github.com/dunwu/algorithm-tutorial/blob/master/codes/algorithm/src/test/java/io/github/dunwu/algorithm/sort/SortStrategyTest.java">我的 Github 测试例</a></p>
<p>样本包含：数组个数为奇数、偶数的情况；元素重复或不重复的情况。且样本均为随机样本，实测有效。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/9a2452/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/9a2452/" class="post-title-link" itemprop="url">设计模式概述</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2015-01-27 16:50:00" itemprop="dateCreated datePublished" datetime="2015-01-27T16:50:00+08:00">2015-01-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">设计</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="设计模式概述"><a href="#设计模式概述" class="headerlink" title="设计模式概述"></a>设计模式概述</h1><blockquote>
<p>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p>
</blockquote>
<h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><h3 id="创建型模式简介"><a href="#创建型模式简介" class="headerlink" title="创建型模式简介"></a>创建型模式简介</h3><p><strong>创建型模式</strong>抽象了<strong>实例化</strong>的过程。它将<strong>系统</strong>与它的<strong>对象</strong>创建、结合、表示的方式<strong>分离</strong>。</p>
<p>创建型模式都会将关于该系统使用哪些具体的类的信息<strong>封装</strong>起来。</p>
<p>在软件工程中，创建型模式是处理对象创建的设计模式，试图根据实际情况使用合适的方式创建对象。</p>
<p>基本的对象创建方式可能会导致设计上的问题，或增加设计的复杂度。创建型模式通过以某种方式控制对象的创建来解决问题。</p>
<p>创建型模式的<strong>指导思想</strong>是：</p>
<ul>
<li>将系统使用的具体类封装起来。</li>
<li>隐藏这些具体类的实例创建和结合的方式。</li>
</ul>
<p>创建型模式又分为<strong>对象创建型模式</strong>和<strong>类创建型模式</strong>。对象创建型模式处理对象的创建，类创建型模式处理类的创建。</p>
<ul>
<li><strong>对象创建型模式</strong>把对象创建的一部分推迟到另一个对象中。（代表模式：<strong>单例模式</strong>、<strong>建造者模式</strong>、<strong>原型模式</strong>、<strong>抽象工厂模式</strong>）</li>
<li><strong>类创建型模式</strong>将它对象的创建推迟到子类中。（代表模式：<strong>工厂方法模式</strong>）</li>
</ul>
<h3 id="创建型模式应用"><a href="#创建型模式应用" class="headerlink" title="创建型模式应用"></a>创建型模式应用</h3><p>现代软件工程更加依赖对象的组合，而不是类的继承，强调从硬编码的行为转变到定义一组基本行为来组合成复杂的行为。</p>
<p>硬编码的行为不够灵活，因为如果想要改变设计的一部分，需要通过重写或者重新实现才能完成。</p>
<p>另外，硬编码没有提高重用性，而且难以跟踪错误。由于这些原因，创建型模式比硬编码的行为更有用。</p>
<p>创建型模式使设计变得更灵活，提供了不同的方式，从代码中移除了对需要实例化的具体类的引用。换句话说，这些模式增强了对象和类之间的独立性。</p>
<p>在以下情况中，可以考虑应用创建型模式：</p>
<ul>
<li>一个系统需要和它的对象和产品的创建相互独立。</li>
<li>一组相关的对象被设计为一起使用。</li>
<li>隐藏一个类库的具体实现，仅暴露它们的接口。</li>
<li>创建独立复杂对象的不同表示。</li>
<li>一个类希望它的子类实现它所创建的对象。</li>
<li>类的实例化在运行时才指定。</li>
<li>一个类只能有一个实例，而且这个实例能在任何时候访问到。</li>
<li>实例应该能在不修改的情况下具有可扩展性。</li>
</ul>
<h3 id="创建型模式代表"><a href="#创建型模式代表" class="headerlink" title="创建型模式代表"></a>创建型模式代表</h3><blockquote>
<p>创建型模式提供了创建对象的机制， 能够提升已有代码的灵活性和可复用性。</p>
</blockquote>
<ul>
<li><a href="01.%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.md">简单工厂模式 (Simple Factory)</a></li>
<li><a href="02.%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.md">工厂方法模式 (Factory Method)</a></li>
<li><a href="03.%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.md">抽象工厂模式 (Abstract Factory)</a></li>
<li><a href="04.%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.md">建造者模式 (Builder)</a></li>
<li><a href="05.%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.md">原型模式 (Prototype)</a></li>
<li><a href="06.%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.md">单例模式 (Singleton)</a></li>
</ul>
<h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><blockquote>
<p>结构型模式介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。</p>
</blockquote>
<ul>
<li><a href="07.%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.md">适配器模式 (Adapter)</a></li>
<li><a href="08.%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F.md">桥接模式 (Bridge)</a></li>
<li><a href="09.%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F.md">组合模式 (Composite)</a></li>
<li><a href="10.%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F.md">装饰模式 (Decorator)</a></li>
<li><a href="11.%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F.md">外观模式 (Facade)</a></li>
<li><a href="12.%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.md">享元模式 (Flyweight)</a></li>
<li><a href="13.%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.md">代理模式 (Proxy)</a></li>
</ul>
<h3 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h3><blockquote>
<p>行为模式负责对象间的高效沟通和职责委派。</p>
</blockquote>
<ul>
<li><a href="14.%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.md">模板方法模式 (Template Method)</a></li>
<li><a href="15.%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.md">命令模式 (Command)</a></li>
<li><a href="16.%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F.md">迭代器模式 (Iterator)</a></li>
<li><a href="17.%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.md">观察者模式 (Observer)</a></li>
<li><a href="18.%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F.md">解释器模式 (Interpreter)</a></li>
<li><a href="19.%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F.md">中介者模式 (Mediator)</a></li>
<li><a href="20.%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F.md">职责链模式 (Chain of Responsibility)</a></li>
<li><a href="21.%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F.md">备忘录模式 (Memento)</a></li>
<li><a href="22.%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.md">策略模式 (Strategy)</a></li>
<li><a href="23.%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F.md">访问者模式 (Visitor)</a></li>
<li><a href="24.%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.md">状态模式 (State)</a></li>
</ul>
<h2 id="📚-资料"><a href="#📚-资料" class="headerlink" title="📚 资料"></a>📚 资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/2243615/">《Head First 设计模式》</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/2334288/">《大话设计模式》</a></li>
</ul>
<h2 id="🚪-传送"><a href="#🚪-传送" class="headerlink" title="🚪 传送"></a>🚪 传送</h2><p>◾ 💧 <a target="_blank" rel="noopener" href="https://dunwu.github.io/waterdrop/">钝悟的 IT 知识图谱</a> ◾</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/43/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/43/">43</a><span class="page-number current">44</span><a class="page-number" href="/page/45/">45</a><span class="space">&hellip;</span><a class="page-number" href="/page/47/">47</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/45/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2015 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">李狗蛋</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">3.5m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">53:28</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/yiyirushi/" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.1/dist/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  




<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>

</body>
</html>
