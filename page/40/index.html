<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/uploads/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/uploads/favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.ligoudan.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="天气不错哇，你看这大冰雹下得">
<meta property="og:type" content="website">
<meta property="og:title" content="LIGOUDAN">
<meta property="og:url" content="https://www.ligoudan.cn/page/40/index.html">
<meta property="og:site_name" content="LIGOUDAN">
<meta property="og:description" content="天气不错哇，你看这大冰雹下得">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="李狗蛋">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://www.ligoudan.cn/page/40/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/40/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>LIGOUDAN</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">LIGOUDAN</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">好好学习，天天向上</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">326</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">137</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">462</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="李狗蛋"
      src="/uploads/ligoudan.png">
  <p class="site-author-name" itemprop="name">李狗蛋</p>
  <div class="site-description" itemprop="description">天气不错哇，你看这大冰雹下得</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">462</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">137</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">326</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/yiyirushi" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yiyirushi" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yuanhaohoo@163.com" title="E-Mail → mailto:yuanhaohoo@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/65ee05/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/65ee05/" class="post-title-link" itemprop="url">代码坏味道之滥用面向对象</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-10-13 22:48:00" itemprop="dateCreated datePublished" datetime="2018-10-13T22:48:00+08:00">2018-10-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">设计</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1/%E9%87%8D%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">重构</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>翻译自：<a target="_blank" rel="noopener" href="https://sourcemaking.com/refactoring/smells/oo-abusers">https://sourcemaking.com/refactoring/smells/oo-abusers</a></p>
<p><strong>滥用面向对象(Object-Orientation Abusers)这组坏味道意味着：代码部分或完全地违背了面向对象编程原则。</strong></p>
</blockquote>
<h2 id="Switch-声明"><a href="#Switch-声明" class="headerlink" title="Switch 声明"></a>Switch 声明</h2><blockquote>
<p>Switch 声明(Switch Statements)</p>
<p>你有一个复杂的 <code>switch</code> 语句或 <code>if</code> 序列语句。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/switch-statements-1.png" alt="img"></p>
<h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p>面向对象程序的一个最明显特征就是：少用 <code>switch</code> 和 <code>case</code> 语句。从本质上说，<code>switch</code> 语句的问题在于重复（<code>if</code> 序列也同样如此）。你常会发现 <code>switch</code> 语句散布于不同地点。如果要为它添加一个新的 <code>case</code> 子句，就必须找到所有 <code>switch</code> 语句并修改它们。面向对象中的多态概念可为此带来优雅的解决办法。</p>
<p>大多数时候，一看到 <code>switch</code> 语句，就应该考虑以多态来替换它。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ul>
<li>问题是多态该出现在哪？switch 语句常常根据类型码进行选择，你要的是“与该类型码相关的函数或类”，所以应该运用 <code>提炼函数(Extract Method)</code> 将 <code>switch</code> 语句提炼到一个独立函数中，再以 <code>搬移函数(Move Method)</code> 将它搬移到需要多态性的那个类里。</li>
<li>如果你的 <code>switch</code> 是基于类型码来识别分支，这时可以运用 <code>以子类取代类型码(Replace Type Code with Subclass)</code> 或 <code>以状态/策略模式取代类型码(Replace Type Code with State/Strategy)</code> 。</li>
<li>一旦完成这样的继承结构后，就可以运用 <code>以多态取代条件表达式(Replace Conditional with Polymorphism)</code> 了。</li>
<li>如果条件分支并不多并且它们使用不同参数调用相同的函数，多态就没必要了。在这种情况下，你可以运用 <code>以明确函数取代参数(Replace Parameter with Explicit Methods)</code> 。</li>
<li>如果你的选择条件之一是 null，可以运用 <code>引入 Null 对象(Introduce Null Object)</code> 。</li>
</ul>
<h3 id="收益"><a href="#收益" class="headerlink" title="收益"></a>收益</h3><ul>
<li>提升代码组织性。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/switch-statements-2.png" alt="img"></p>
<h3 id="何时忽略"><a href="#何时忽略" class="headerlink" title="何时忽略"></a>何时忽略</h3><ul>
<li>如果一个 <code>switch</code> 操作只是执行简单的行为，就没有重构的必要了。</li>
<li><code>switch</code> 常被工厂设计模式族（<code>工厂方法模式(Factory Method)</code>和<code>抽象工厂模式(Abstract Factory)</code>）所使用，这种情况下也没必要重构。</li>
</ul>
<h3 id="重构方法说明"><a href="#重构方法说明" class="headerlink" title="重构方法说明"></a>重构方法说明</h3><h4 id="提炼函数-Extract-Method"><a href="#提炼函数-Extract-Method" class="headerlink" title="提炼函数(Extract Method)"></a>提炼函数(Extract Method)</h4><p><strong>问题</strong></p>
<p>你有一段代码可以组织在一起。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">printOwing</span><span class="params">()</span> &#123;</span><br><span class="line">  printBanner();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//print details</span></span><br><span class="line">  System.out.println(<span class="string">&quot;name: &quot;</span> + name);</span><br><span class="line">  System.out.println(<span class="string">&quot;amount: &quot;</span> + getOutstanding());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决</strong></p>
<p>移动这段代码到一个新的函数中，使用函数的调用来替代老代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">printOwing</span><span class="params">()</span> &#123;</span><br><span class="line">  printBanner();</span><br><span class="line">  printDetails(getOutstanding());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">printDetails</span><span class="params">(<span class="type">double</span> outstanding)</span> &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;name: &quot;</span> + name);</span><br><span class="line">  System.out.println(<span class="string">&quot;amount: &quot;</span> + outstanding);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="搬移函数-Move-Method"><a href="#搬移函数-Move-Method" class="headerlink" title="搬移函数(Move Method)"></a>搬移函数(Move Method)</h4><p><strong>问题</strong></p>
<p>你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/move-method-before.png" alt="img"></p>
<p><strong>解决</strong></p>
<p>在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/move-method-after.png" alt="img"></p>
<h4 id="以子类取代类型码-Replace-Type-Code-with-Subclass"><a href="#以子类取代类型码-Replace-Type-Code-with-Subclass" class="headerlink" title="以子类取代类型码(Replace Type Code with Subclass)"></a>以子类取代类型码(Replace Type Code with Subclass)</h4><p><strong>问题</strong></p>
<p>你有一个不可变的类型码，它会影响类的行为。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/replace-type-code-with-subclasses-before.png" alt="img"></p>
<p><strong>解决</strong></p>
<p>以子类取代这个类型码。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/replace-type-code-with-subclasses-after.png" alt="img"></p>
<h4 id="以状态-策略模式取代类型码-Replace-Type-Code-with-State-Strategy"><a href="#以状态-策略模式取代类型码-Replace-Type-Code-with-State-Strategy" class="headerlink" title="以状态&#x2F;策略模式取代类型码(Replace Type Code with State&#x2F;Strategy)"></a>以状态&#x2F;策略模式取代类型码(Replace Type Code with State&#x2F;Strategy)</h4><p><strong>问题</strong></p>
<p>你有一个类型码，它会影响类的行为，但你无法通过继承消除它。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/replace-type-code-with-state-strategy-before.png" alt="img"></p>
<p><strong>解决</strong></p>
<p>以状态对象取代类型码。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/replace-type-code-with-state-strategy-after.png" alt="img"></p>
<h4 id="以多态取代条件表达式-Replace-Conditional-with-Polymorphism"><a href="#以多态取代条件表达式-Replace-Conditional-with-Polymorphism" class="headerlink" title="以多态取代条件表达式(Replace Conditional with Polymorphism)"></a>以多态取代条件表达式(Replace Conditional with Polymorphism)</h4><p><strong>问题</strong></p>
<p>你手上有个条件表达式，它根据对象类型的不同而选择不同的行为。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="type">double</span> <span class="title function_">getSpeed</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">      <span class="keyword">case</span> EUROPEAN:</span><br><span class="line">        <span class="keyword">return</span> getBaseSpeed();</span><br><span class="line">      <span class="keyword">case</span> AFRICAN:</span><br><span class="line">        <span class="keyword">return</span> getBaseSpeed() - getLoadFactor() * numberOfCoconuts;</span><br><span class="line">      <span class="keyword">case</span> NORWEGIAN_BLUE:</span><br><span class="line">        <span class="keyword">return</span> (isNailed) ? <span class="number">0</span> : getBaseSpeed(voltage);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Should be unreachable&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决</strong></p>
<p>将这个条件表达式的每个分支放进一个子类内的覆写函数中，然后将原始函数声明为抽象函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">getSpeed</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">European</span> <span class="keyword">extends</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">  <span class="type">double</span> <span class="title function_">getSpeed</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getBaseSpeed();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">African</span> <span class="keyword">extends</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">  <span class="type">double</span> <span class="title function_">getSpeed</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getBaseSpeed() - getLoadFactor() * numberOfCoconuts;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NorwegianBlue</span> <span class="keyword">extends</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">  <span class="type">double</span> <span class="title function_">getSpeed</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (isNailed) ? <span class="number">0</span> : getBaseSpeed(voltage);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Somewhere in client code</span></span><br><span class="line">speed = bird.getSpeed();</span><br></pre></td></tr></table></figure>

<h4 id="以明确函数取代参数-Replace-Parameter-with-Explicit-Methods"><a href="#以明确函数取代参数-Replace-Parameter-with-Explicit-Methods" class="headerlink" title="以明确函数取代参数(Replace Parameter with Explicit Methods)"></a>以明确函数取代参数(Replace Parameter with Explicit Methods)</h4><p><strong>问题</strong></p>
<p>你有一个函数，其中完全取决于参数值而采取不同的行为。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(String name, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (name.equals(<span class="string">&quot;height&quot;</span>)) &#123;</span><br><span class="line">    height = value;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (name.equals(<span class="string">&quot;width&quot;</span>)) &#123;</span><br><span class="line">    width = value;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Assert.shouldNeverReachHere();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决</strong></p>
<p>针对该参数的每一个可能值，建立一个独立函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">setHeight</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">  height = arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setWidth</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">  width = arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="引入-Null-对象-Introduce-Null-Object"><a href="#引入-Null-对象-Introduce-Null-Object" class="headerlink" title="引入 Null 对象(Introduce Null Object)"></a>引入 Null 对象(Introduce Null Object)</h4><p><strong>问题</strong></p>
<p>你需要再三检查某对象是否为 null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (customer == <span class="literal">null</span>) &#123;</span><br><span class="line">  plan = BillingPlan.basic();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  plan = customer.getPlan();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决</strong></p>
<p>将 null 值替换为 null 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NullCustomer</span> <span class="keyword">extends</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">  Plan <span class="title function_">getPlan</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NullPlan</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Some other NULL functionality.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Replace null values with Null-object.</span></span><br><span class="line">customer = (order.customer != <span class="literal">null</span>) ? order.customer : <span class="keyword">new</span> <span class="title class_">NullCustomer</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use Null-object as if it&#x27;s normal subclass.</span></span><br><span class="line">plan = customer.getPlan();</span><br></pre></td></tr></table></figure>

<h2 id="临时字段"><a href="#临时字段" class="headerlink" title="临时字段"></a>临时字段</h2><blockquote>
<p>临时字段(Temporary Field)的值只在特定环境下有意义，离开这个环境，它们就什么也不是了。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/temporary-field-1.png" alt="img"></p>
<h3 id="问题原因-1"><a href="#问题原因-1" class="headerlink" title="问题原因"></a>问题原因</h3><p>有时你会看到这样的对象：其内某个实例变量仅为某种特定情况而设。这样的代码让人不易理解，因为你通常认为对象在所有时候都需要它的所有变量。在变量未被使用的情况下猜测当初设置目的，会让你发疯。<br>通常，临时字段是在某一算法需要大量输入时而创建。因此，为了避免函数有过多参数，程序员决定在类中创建这些数据的临时字段。这些临时字段仅仅在算法中使用，其他时候却毫无用处。<br>这种代码不好理解。你期望查看对象字段的数据，但是出于某种原因，它们总是为空。</p>
<h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><ul>
<li>可以通过 <code>提炼类(Extract Class)</code> 将临时字段和操作它们的所有代码提炼到一个单独的类中。此外，你可以运用 <code>以函数对象取代函数(Replace Method with Method Object)</code> 来实现同样的目的。</li>
<li><code>引入 Null 对象(Introduce Null Object)</code> 在“变量不合法”的情况下创建一个 null 对象，从而避免写出条件表达式。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/temporary-field-2.png" alt="img"></p>
<h3 id="收益-1"><a href="#收益-1" class="headerlink" title="收益"></a>收益</h3><ul>
<li>更好的代码清晰度和组织性。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/temporary-field-3.png" alt="img"></p>
<h3 id="重构方法说明-1"><a href="#重构方法说明-1" class="headerlink" title="重构方法说明"></a>重构方法说明</h3><h4 id="提炼类-Extract-Class"><a href="#提炼类-Extract-Class" class="headerlink" title="提炼类(Extract Class)"></a>提炼类(Extract Class)</h4><p><strong>问题</strong></p>
<p>某个类做了不止一件事。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/extract-class-before.png" alt="img"></p>
<p><strong>解决</strong></p>
<p>建立一个新类，将相关的字段和函数从旧类搬移到新类。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/extract-class-after.png" alt="img"></p>
<h4 id="以函数对象取代函数-Replace-Method-with-Method-Object"><a href="#以函数对象取代函数-Replace-Method-with-Method-Object" class="headerlink" title="以函数对象取代函数(Replace Method with Method Object)"></a>以函数对象取代函数(Replace Method with Method Object)</h4><p><strong>问题</strong></p>
<p>你有一个过长函数，它的局部变量交织在一起，以致于你无法应用提炼函数(Extract Method) 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">price</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">double</span> primaryBasePrice;</span><br><span class="line">    <span class="type">double</span> secondaryBasePrice;</span><br><span class="line">    <span class="type">double</span> tertiaryBasePrice;</span><br><span class="line">    <span class="comment">// long computation.</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决</strong></p>
<p>将函数移到一个独立的类中，使得局部变量成了这个类的字段。然后，你可以将函数分割成这个类中的多个函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">price</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PriceCalculator</span>(<span class="built_in">this</span>).compute();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PriceCalculator</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">double</span> primaryBasePrice;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">double</span> secondaryBasePrice;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">double</span> tertiaryBasePrice;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">PriceCalculator</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">    <span class="comment">// copy relevant information from order object.</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// long computation.</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="引入-Null-对象-Introduce-Null-Object-1"><a href="#引入-Null-对象-Introduce-Null-Object-1" class="headerlink" title="引入 Null 对象(Introduce Null Object)"></a>引入 Null 对象(Introduce Null Object)</h4><p><strong>问题</strong></p>
<p>你需要再三检查某对象是否为 null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (customer == <span class="literal">null</span>) &#123;</span><br><span class="line">  plan = BillingPlan.basic();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  plan = customer.getPlan();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决</strong></p>
<p>将 null 值替换为 null 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NullCustomer</span> <span class="keyword">extends</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">  Plan <span class="title function_">getPlan</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NullPlan</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Some other NULL functionality.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Replace null values with Null-object.</span></span><br><span class="line">customer = (order.customer != <span class="literal">null</span>) ? order.customer : <span class="keyword">new</span> <span class="title class_">NullCustomer</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use Null-object as if it&#x27;s normal subclass.</span></span><br><span class="line">plan = customer.getPlan();</span><br></pre></td></tr></table></figure>

<h2 id="异曲同工的类"><a href="#异曲同工的类" class="headerlink" title="异曲同工的类"></a>异曲同工的类</h2><blockquote>
<p>异曲同工的类(Alternative Classes with Different Interfaces)</p>
<p>两个类中有着不同的函数，却在做着同一件事。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/alternative-classes-with-different-interfaces-1.png" alt="img"></p>
<h3 id="问题原因-2"><a href="#问题原因-2" class="headerlink" title="问题原因"></a>问题原因</h3><p>这种情况往往是因为：创建这个类的程序员并不知道已经有实现这个功能的类存在了。</p>
<h3 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h3><ul>
<li>如果两个函数做同一件事，却有着不同的签名，请运用 <code>函数改名(Rename Method)</code> 根据它们的用途重新命名。</li>
<li>运用 <code>搬移函数(Move Method)</code> 、 <code>添加参数(Add Parameter)</code> 和 <code>令函数携带参数(Parameterize Method)</code> 来使得方法的名称和实现一致。</li>
<li>如果两个类仅有部分功能是重复的，尝试运用 <code>提炼超类(Extract Superclass)</code> 。这种情况下，已存在的类就成了超类。</li>
<li>当最终选择并运用某种方法来重构后，也许你就能删除其中一个类了。</li>
</ul>
<h3 id="收益-2"><a href="#收益-2" class="headerlink" title="收益"></a>收益</h3><ul>
<li>消除了不必要的重复代码，为代码瘦身了。</li>
<li>代码更易读（不再需要猜测为什么要有两个功能相同的类）。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/alternative-classes-with-different-interfaces-2.png" alt="img"></p>
<h3 id="何时忽略-1"><a href="#何时忽略-1" class="headerlink" title="何时忽略"></a>何时忽略</h3><ul>
<li>有时合并类是不可能的，或者是如此困难以至于没有意义。例如：两个功能相似的类存在于不同的 lib 库中。</li>
</ul>
<h3 id="重构方法说明-2"><a href="#重构方法说明-2" class="headerlink" title="重构方法说明"></a>重构方法说明</h3><h4 id="函数改名-Rename-Method"><a href="#函数改名-Rename-Method" class="headerlink" title="函数改名(Rename Method)"></a>函数改名(Rename Method)</h4><p><strong>问题</strong></p>
<p>函数的名称未能恰当的揭示函数的用途。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getsnm</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决</strong></p>
<p>修改函数名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getSecondName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="搬移函数-Move-Method-1"><a href="#搬移函数-Move-Method-1" class="headerlink" title="搬移函数(Move Method)"></a>搬移函数(Move Method)</h4><p><strong>问题</strong></p>
<p>你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/move-method-before.png" alt="img"></p>
<p><strong>解决</strong></p>
<p>在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/move-method-after.png" alt="img"></p>
<h4 id="添加参数-Add-Parameter"><a href="#添加参数-Add-Parameter" class="headerlink" title="添加参数(Add Parameter)"></a>添加参数(Add Parameter)</h4><p><strong>问题</strong><br>某个函数需要从调用端得到更多信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> Contact <span class="title function_">getContact</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决</strong><br>为此函数添加一个对象函数，让改对象带进函数所需信息。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">  public Contact getContact(Date date);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="令函数携带参数-Parameterize-Method"><a href="#令函数携带参数-Parameterize-Method" class="headerlink" title="令函数携带参数(Parameterize Method)"></a>令函数携带参数(Parameterize Method)</h4><p><strong>问题</strong></p>
<p>若干函数做了类似的工作，但在函数本体中却包含了不同的值。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/parameterize-method-before.png" alt="img"><br><strong>解决</strong></p>
<p>建立单一函数，以参数表达哪些不同的值。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/parameterize-method-after.png" alt="img"></p>
<h4 id="提炼超类-Extract-Superclass"><a href="#提炼超类-Extract-Superclass" class="headerlink" title="提炼超类(Extract Superclass)"></a>提炼超类(Extract Superclass)</h4><p><strong>问题</strong></p>
<p>两个类有相似特性。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/extract-superclass-before.png" alt="img"></p>
<p><strong>解决</strong></p>
<p>为这两个类建立一个超类，将相同特性移至超类。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/extract-superclass-after.png" alt="img"></p>
<h2 id="被拒绝的馈赠"><a href="#被拒绝的馈赠" class="headerlink" title="被拒绝的馈赠"></a>被拒绝的馈赠</h2><blockquote>
<p>被拒绝的馈赠(Refused Bequest)</p>
<p>子类仅仅使用父类中的部分方法和属性。其他来自父类的馈赠成为了累赘。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/refused-bequest-1.png" alt="img"></p>
<h3 id="问题原因-3"><a href="#问题原因-3" class="headerlink" title="问题原因"></a>问题原因</h3><p>有些人仅仅是想重用超类中的部分代码而创建了子类。但实际上超类和子类完全不同。</p>
<h3 id="解决方法-3"><a href="#解决方法-3" class="headerlink" title="解决方法"></a>解决方法</h3><ul>
<li>如果继承没有意义并且子类和父类之间确实没有共同点，可以运用 <code>以委托取代继承(Replace Inheritance with Delegation)</code> 消除继承。</li>
<li>如果继承是适当的，则去除子类中不需要的字段和方法。运用 <code>提炼超类(Extract Superclass)</code> 将所有超类中对于子类有用的字段和函数提取出来，置入一个新的超类中，然后让两个类都继承自它。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/refused-bequest-2.png" alt="img"></p>
<h3 id="收益-3"><a href="#收益-3" class="headerlink" title="收益"></a>收益</h3><ul>
<li>提高代码的清晰度和组织性。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/refused-bequest-3.png" alt="img"></p>
<h3 id="重构方法说明-3"><a href="#重构方法说明-3" class="headerlink" title="重构方法说明"></a>重构方法说明</h3><h4 id="以委托取代继承-Replace-Inheritance-with-Delegation"><a href="#以委托取代继承-Replace-Inheritance-with-Delegation" class="headerlink" title="以委托取代继承(Replace Inheritance with Delegation)"></a>以委托取代继承(Replace Inheritance with Delegation)</h4><p><strong>问题</strong></p>
<p>某个子类只使用超类接口中的一部分，或是根本不需要继承而来的数据。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/replace-inheritance-with-delegation-before.png" alt="img"></p>
<p><strong>解决</strong></p>
<ol>
<li>在子类中新建一个字段用以保存超类；</li>
<li>调整子类函数，令它改而委托超类；</li>
<li>然后去掉两者之间的继承关系。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/replace-inheritance-with-delegation-after.png" alt="img"></p>
<h4 id="提炼超类-Extract-Superclass-1"><a href="#提炼超类-Extract-Superclass-1" class="headerlink" title="提炼超类(Extract Superclass)"></a>提炼超类(Extract Superclass)</h4><p><strong>问题</strong></p>
<p>两个类有相似特性。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/extract-superclass-before.png" alt="img"></p>
<p><strong>解决</strong></p>
<p>为这两个类建立一个超类，将相同特性移至超类。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/extract-superclass-after.png" alt="img"></p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/dunwu/design/blob/master/docs/refactor/%E4%BB%A3%E7%A0%81%E7%9A%84%E5%9D%8F%E5%91%B3%E9%81%93%E5%92%8C%E9%87%8D%E6%9E%84.md">代码的坏味道和重构</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/dunwu/design/blob/master/docs/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%87%83%E8%82%BF.md">代码坏味道之代码臃肿</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/dunwu/design/blob/master/docs/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E6%BB%A5%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.md">代码坏味道之滥用面向对象</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/dunwu/design/blob/master/docs/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E5%8F%98%E9%9D%A9%E7%9A%84%E9%9A%9C%E7%A2%8D.md">代码坏味道之变革的障碍</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/dunwu/design/blob/master/docs/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E9%9D%9E%E5%BF%85%E8%A6%81%E7%9A%84.md">代码坏味道之非必要的</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/dunwu/design/blob/master/docs/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E8%80%A6%E5%90%88.md">代码坏味道之耦合</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/4199741/">《代码整洁之道》</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/4262627/">《重构 - 改善既有代码的设计》</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/1477390/">《代码大全》</a></li>
<li><a target="_blank" rel="noopener" href="https://sourcemaking.com/refactoring">https://sourcemaking.com/refactoring</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/47acb5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/47acb5/" class="post-title-link" itemprop="url">代码坏味道之非必要的</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-10-13 22:48:00" itemprop="dateCreated datePublished" datetime="2018-10-13T22:48:00+08:00">2018-10-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">设计</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1/%E9%87%8D%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">重构</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>翻译自：<a target="_blank" rel="noopener" href="https://sourcemaking.com/refactoring/smells/dispensables">https://sourcemaking.com/refactoring/smells/dispensables</a></p>
<p><strong>非必要的(Dispensables)这组坏味道意味着：这样的代码可有可无，它的存在反而影响整体代码的整洁和可读性。</strong></p>
</blockquote>
<h2 id="冗余类"><a href="#冗余类" class="headerlink" title="冗余类"></a>冗余类</h2><blockquote>
<p>冗余类(Lazy Class)</p>
<p>理解和维护总是费时费力的。如果一个类不值得你花费精力，它就应该被删除。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/lazy-class-1.png" alt="img"></p>
<h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p>也许一个类的初始设计是一个功能完全的类，然而随着代码的变迁，变得没什么用了。<br>又或者类起初的设计是为了支持未来的功能扩展，然而却一直未派上用场。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ul>
<li>没什么用的类可以运用 <code>将类内联化(Inline Class)</code> 来干掉。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/lazy-class-2.png" alt="img"></p>
<ul>
<li>如果子类用处不大，试试 <code>折叠继承体系(Collapse Hierarchy)</code> 。</li>
</ul>
<h3 id="收益"><a href="#收益" class="headerlink" title="收益"></a>收益</h3><ul>
<li>减少代码量</li>
<li>易于维护</li>
</ul>
<h3 id="何时忽略"><a href="#何时忽略" class="headerlink" title="何时忽略"></a>何时忽略</h3><ul>
<li>有时，创建冗余类是为了描述未来开发的意图。在这种情况下，尝试在代码中保持清晰和简单之间的平衡。</li>
</ul>
<h3 id="重构方法说明"><a href="#重构方法说明" class="headerlink" title="重构方法说明"></a>重构方法说明</h3><h4 id="将类内联化-Inline-Class"><a href="#将类内联化-Inline-Class" class="headerlink" title="将类内联化(Inline Class)"></a>将类内联化(Inline Class)</h4><p><strong>问题</strong></p>
<p>某个类没有做太多事情。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/inline-class-before.png" alt="img"></p>
<p><strong>解决</strong></p>
<p>将这个类的所有特性搬移到另一个类中，然后移除原类。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/inline-class-after.png" alt="img"></p>
<h4 id="折叠继承体系-Collapse-Hierarchy"><a href="#折叠继承体系-Collapse-Hierarchy" class="headerlink" title="折叠继承体系(Collapse Hierarchy)"></a>折叠继承体系(Collapse Hierarchy)</h4><p><strong>问题</strong></p>
<p>超类和子类之间无太大区别。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/collapse-hierarchy-before.png" alt="img"></p>
<p><strong>解决</strong></p>
<p>将它们合为一体。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/collapse-hierarchy-after.png" alt="img"></p>
<h2 id="夸夸其谈未来性"><a href="#夸夸其谈未来性" class="headerlink" title="夸夸其谈未来性"></a>夸夸其谈未来性</h2><blockquote>
<p>夸夸其谈未来性(Speculative Generality)</p>
<p>存在未被使用的类、函数、字段或参数。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/speculative-generality-1.png" alt="img"></p>
<h3 id="问题原因-1"><a href="#问题原因-1" class="headerlink" title="问题原因"></a>问题原因</h3><p>有时，代码仅仅为了支持未来的特性而产生，然而却一直未实现。结果，代码变得难以理解和维护。</p>
<h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><ul>
<li>如果你的某个抽象类其实没有太大作用，请运用 <code>折叠继承体系(Collapse Hierarch)</code> 。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/speculative-generality-2.png" alt="img"></p>
<ul>
<li>不必要的委托可运用 <code>将类内联化(Inline Class)</code> 消除。</li>
<li>无用的函数可运用 <code>内联函数(Inline Method)</code> 消除。</li>
<li>函数中有无用的参数应该运用 <code>移除参数(Remove Parameter)</code> 消除。</li>
<li>无用字段可以直接删除。</li>
</ul>
<h3 id="收益-1"><a href="#收益-1" class="headerlink" title="收益"></a>收益</h3><ul>
<li>减少代码量。</li>
<li>更易维护。</li>
</ul>
<h3 id="何时忽略-1"><a href="#何时忽略-1" class="headerlink" title="何时忽略"></a>何时忽略</h3><ul>
<li>如果你在一个框架上工作，创建框架本身没有使用的功能是非常合理的，只要框架的用户需要这个功能。</li>
<li>删除元素之前，请确保它们不在单元测试中使用。如果测试需要从类中获取某些内部信息或执行特殊的测试相关操作，就会发生这种情况。</li>
</ul>
<h3 id="重构方法说明-1"><a href="#重构方法说明-1" class="headerlink" title="重构方法说明"></a>重构方法说明</h3><h4 id="折叠继承体系-Collapse-Hierarchy-1"><a href="#折叠继承体系-Collapse-Hierarchy-1" class="headerlink" title="折叠继承体系(Collapse Hierarchy)"></a>折叠继承体系(Collapse Hierarchy)</h4><p><strong>问题</strong></p>
<p>超类和子类之间无太大区别。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/collapse-hierarchy-before.png" alt="img"></p>
<p><strong>解决</strong></p>
<p>将它们合为一体。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/collapse-hierarchy-after.png" alt="img"></p>
<h4 id="将类内联化-Inline-Class-1"><a href="#将类内联化-Inline-Class-1" class="headerlink" title="将类内联化(Inline Class)"></a>将类内联化(Inline Class)</h4><p><strong>问题</strong></p>
<p>某个类没有做太多事情。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/inline-class-before.png" alt="img"></p>
<p><strong>解决</strong></p>
<p>将这个类的所有特性搬移到另一个类中，然后移除原类。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/inline-class-after.png" alt="img"></p>
<h4 id="内联函数-Inline-Method"><a href="#内联函数-Inline-Method" class="headerlink" title="内联函数(Inline Method)"></a>内联函数(Inline Method)</h4><p><strong>问题</strong></p>
<p>一个函数的本体比函数名更清楚易懂。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PizzaDelivery</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="type">int</span> <span class="title function_">getRating</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> moreThanFiveLateDeliveries() ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">moreThanFiveLateDeliveries</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> numberOfLateDeliveries &gt; <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决</strong></p>
<p>在函数调用点插入函数本体，然后移除该函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PizzaDelivery</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="type">int</span> <span class="title function_">getRating</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> numberOfLateDeliveries &gt; <span class="number">5</span> ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="移除参数-Remove-Parameter"><a href="#移除参数-Remove-Parameter" class="headerlink" title="移除参数(Remove Parameter)"></a>移除参数(Remove Parameter)</h4><p><strong>问题</strong></p>
<p>函数本体不再需要某个参数。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/remove-parameter-before.png" alt="img"></p>
<p><strong>解决</strong></p>
<p>将该参数去除。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/remove-parameter-after.png" alt="img"></p>
<h2 id="纯稚的数据类"><a href="#纯稚的数据类" class="headerlink" title="纯稚的数据类"></a>纯稚的数据类</h2><blockquote>
<p><code>纯稚的数据类(Data Class)</code> 指的是只包含字段和访问它们的 getter 和 setter 函数的类。这些仅仅是供其他类使用的数据容器。这些类不包含任何附加功能，并且不能对自己拥有的数据进行独立操作。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/data-class-1.png" alt="img"></p>
<h3 id="问题原因-2"><a href="#问题原因-2" class="headerlink" title="问题原因"></a>问题原因</h3><p>当一个新创建的类只包含几个公共字段（甚至可能几个 getters &#x2F; setters）是很正常的。但是对象的真正力量在于它们可以包含作用于数据的行为类型或操作。</p>
<h3 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h3><ul>
<li>如果一个类有公共字段，你应该运用 <code>封装字段(Encapsulated Field)</code> 来隐藏字段的直接访问方式。</li>
<li>如果这些类含容器类的字段，你应该检查它们是不是得到了恰当的封装；如果没有，就运用 <code>封装集合(Encapsulated Collection)</code> 把它们封装起来。</li>
<li>找出这些 getter&#x2F;setter 函数被其他类运用的地点。尝试以 <code>搬移函数(Move Method)</code> 把那些调用行为搬移到 <code>纯稚的数据类(Data Class)</code> 来。如果无法搬移这个函数，就运用 <code>提炼函数(Extract Method)</code> 产生一个可搬移的函数。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/data-class-2.png" alt="img"></p>
<ul>
<li>在类已经充满了深思熟虑的函数之后，你可能想要摆脱旧的数据访问方法，以提供适应面较广的类数据访问接口。为此，可以运用 <code>移除设置函数(Remove Setting Method)</code> 和 <code>隐藏函数(Hide Method)</code> 。</li>
</ul>
<h3 id="收益-2"><a href="#收益-2" class="headerlink" title="收益"></a>收益</h3><ul>
<li>提高代码的可读性和组织性。特定数据的操作现在被集中在一个地方，而不是在分散在代码各处。</li>
<li>帮助你发现客户端代码的重复处。</li>
</ul>
<h3 id="重构方法说明-2"><a href="#重构方法说明-2" class="headerlink" title="重构方法说明"></a>重构方法说明</h3><h4 id="封装字段-Encapsulated-Field"><a href="#封装字段-Encapsulated-Field" class="headerlink" title="封装字段(Encapsulated Field)"></a>封装字段(Encapsulated Field)</h4><p><strong>问题</strong></p>
<p>你的类中存在 public 字段。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  public String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决</strong></p>
<p>将它声明为 private，并提供相应的访问函数。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="title class_">String</span> name;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">setName</span>(<span class="params"><span class="title class_">String</span> arg</span>) &#123;</span><br><span class="line">    name = arg;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="封装集合-Encapsulated-Collection"><a href="#封装集合-Encapsulated-Collection" class="headerlink" title="封装集合(Encapsulated Collection)"></a>封装集合(Encapsulated Collection)</h4><p><strong>问题</strong></p>
<p>有个函数返回一个集合。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/encapsulate-collection-before.png" alt="img"></p>
<p><strong>解决</strong></p>
<p>让该函数返回该集合的一个只读副本，并在这个类中提供添加、移除集合元素的函数。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/encapsulate-collection-after.png" alt="img"></p>
<h4 id="搬移函数-Move-Method"><a href="#搬移函数-Move-Method" class="headerlink" title="搬移函数(Move Method)"></a>搬移函数(Move Method)</h4><p><strong>问题</strong></p>
<p>你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/move-method-before.png" alt="img"></p>
<p><strong>解决</strong></p>
<p>在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/move-method-after.png" alt="img"></p>
<h4 id="提炼函数-Extract-Method"><a href="#提炼函数-Extract-Method" class="headerlink" title="提炼函数(Extract Method)"></a>提炼函数(Extract Method)</h4><p><strong>问题</strong></p>
<p>你有一段代码可以组织在一起。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">printOwing</span><span class="params">()</span> &#123;</span><br><span class="line">  printBanner();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//print details</span></span><br><span class="line">  System.out.println(<span class="string">&quot;name: &quot;</span> + name);</span><br><span class="line">  System.out.println(<span class="string">&quot;amount: &quot;</span> + getOutstanding());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决</strong></p>
<p>移动这段代码到一个新的函数中，使用函数的调用来替代老代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">printOwing</span><span class="params">()</span> &#123;</span><br><span class="line">  printBanner();</span><br><span class="line">  printDetails(getOutstanding());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">printDetails</span><span class="params">(<span class="type">double</span> outstanding)</span> &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;name: &quot;</span> + name);</span><br><span class="line">  System.out.println(<span class="string">&quot;amount: &quot;</span> + outstanding);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="移除设置函数-Remove-Setting-Method"><a href="#移除设置函数-Remove-Setting-Method" class="headerlink" title="移除设置函数(Remove Setting Method)"></a>移除设置函数(Remove Setting Method)</h4><p><strong>问题</strong></p>
<p>类中的某个字段应该在对象创建时被设值，然后就不再改变。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/remove-setting-method-before.png" alt="img"></p>
<p><strong>解决</strong></p>
<p>去掉该字段的所有设值函数。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/remove-setting-method-after.png" alt="img"></p>
<h4 id="隐藏函数-Hide-Method"><a href="#隐藏函数-Hide-Method" class="headerlink" title="隐藏函数(Hide Method)"></a>隐藏函数(Hide Method)</h4><p><strong>问题</strong></p>
<p>有一个函数，从来没有被其他任何类用到。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/hide-method-before.png" alt="img"></p>
<p><strong>解决</strong></p>
<p>将这个函数修改为 private。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/hide-method-after.png" alt="img"></p>
<h2 id="过多的注释"><a href="#过多的注释" class="headerlink" title="过多的注释"></a>过多的注释</h2><blockquote>
<p>过多的注释(Comments)</p>
<p>注释本身并不是坏事。但是常常有这样的情况：一段代码中出现长长的注释，而它之所以存在，是因为代码很糟糕。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/comments-1.png" alt="img"></p>
<h3 id="问题原因-3"><a href="#问题原因-3" class="headerlink" title="问题原因"></a>问题原因</h3><p>注释的作者意识到自己的代码不直观或不明显，所以想使用注释来说明自己的意图。这种情况下，注释就像是烂代码的除臭剂。</p>
<blockquote>
<p>最好的注释是为函数或类起一个恰当的名字。</p>
</blockquote>
<p>如果你觉得一个代码片段没有注释就无法理解，请先尝试重构，试着让所有注释都变得多余。</p>
<h3 id="解决方法-3"><a href="#解决方法-3" class="headerlink" title="解决方法"></a>解决方法</h3><ul>
<li>如果一个注释是为了解释一个复杂的表达式，可以运用 <code>提炼变量(Extract Variable)</code> 将表达式切分为易理解的子表达式。</li>
<li>如果你需要通过注释来解释一段代码做了什么，请试试 <code>提炼函数(Extract Method)</code> 。</li>
<li>如果函数已经被提炼，但仍需要注释函数做了什么，试试运用 <code>函数改名(Rename Method)</code> 来为函数起一个可以自解释的名字。</li>
<li>如果需要对系统某状态进行断言，请运用 <code>引入断言(Introduce Assertion)</code> 。</li>
</ul>
<h3 id="收益-3"><a href="#收益-3" class="headerlink" title="收益"></a>收益</h3><ul>
<li>代码变得更直观和明显。</li>
</ul>
<h3 id="何时忽略-2"><a href="#何时忽略-2" class="headerlink" title="何时忽略"></a>何时忽略</h3><p>注释有时候很有用：</p>
<ul>
<li>当解释为什么某事物要以特殊方式实现时。</li>
<li>当解释某种复杂算法时。</li>
<li>当你实在不知可以做些什么时。</li>
</ul>
<h3 id="重构方法说明-3"><a href="#重构方法说明-3" class="headerlink" title="重构方法说明"></a>重构方法说明</h3><h4 id="提炼变量-Extract-Variable"><a href="#提炼变量-Extract-Variable" class="headerlink" title="提炼变量(Extract Variable)"></a>提炼变量(Extract Variable)</h4><p><strong>问题</strong></p>
<p>你有个难以理解的表达式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">renderBanner</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> ((platform.toUpperCase().indexOf(<span class="string">&quot;MAC&quot;</span>) &gt; -<span class="number">1</span>) &amp;&amp;</span><br><span class="line">       (browser.toUpperCase().indexOf(<span class="string">&quot;IE&quot;</span>) &gt; -<span class="number">1</span>) &amp;&amp;</span><br><span class="line">        wasInitialized() &amp;&amp; resize &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决</strong></p>
<p>将表达式的结果或它的子表达式的结果用不言自明的变量来替代。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">renderBanner</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">isMacOs</span> <span class="operator">=</span> platform.toUpperCase().indexOf(<span class="string">&quot;MAC&quot;</span>) &gt; -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">isIE</span> <span class="operator">=</span> browser.toUpperCase().indexOf(<span class="string">&quot;IE&quot;</span>) &gt; -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">wasResized</span> <span class="operator">=</span> resize &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isMacOs &amp;&amp; isIE &amp;&amp; wasInitialized() &amp;&amp; wasResized) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="提炼函数-Extract-Method-1"><a href="#提炼函数-Extract-Method-1" class="headerlink" title="提炼函数(Extract Method)"></a>提炼函数(Extract Method)</h4><p><strong>问题</strong></p>
<p>你有一段代码可以组织在一起。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">printOwing</span><span class="params">()</span> &#123;</span><br><span class="line">  printBanner();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//print details</span></span><br><span class="line">  System.out.println(<span class="string">&quot;name: &quot;</span> + name);</span><br><span class="line">  System.out.println(<span class="string">&quot;amount: &quot;</span> + getOutstanding());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决</strong></p>
<p>移动这段代码到一个新的函数中，使用函数的调用来替代老代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">printOwing</span><span class="params">()</span> &#123;</span><br><span class="line">  printBanner();</span><br><span class="line">  printDetails(getOutstanding());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">printDetails</span><span class="params">(<span class="type">double</span> outstanding)</span> &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;name: &quot;</span> + name);</span><br><span class="line">  System.out.println(<span class="string">&quot;amount: &quot;</span> + outstanding);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="函数改名-Rename-Method"><a href="#函数改名-Rename-Method" class="headerlink" title="函数改名(Rename Method)"></a>函数改名(Rename Method)</h4><p><strong>问题</strong></p>
<p>函数的名称未能恰当的揭示函数的用途。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getsnm</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决</strong></p>
<p>修改函数名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getSecondName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="引入断言-Introduce-Assertion"><a href="#引入断言-Introduce-Assertion" class="headerlink" title="引入断言(Introduce Assertion)"></a>引入断言(Introduce Assertion)</h4><p><strong>问题</strong></p>
<p>某一段代码需要对程序状态做出某种假设。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">getExpenseLimit</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// should have either expense limit or a primary project</span></span><br><span class="line">  <span class="keyword">return</span> (expenseLimit != NULL_EXPENSE) ?</span><br><span class="line">    expenseLimit:</span><br><span class="line">    primaryProject.getMemberExpenseLimit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决</strong></p>
<p>以断言明确表现这种假设。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">getExpenseLimit</span><span class="params">()</span> &#123;</span><br><span class="line">  Assert.isTrue(expenseLimit != NULL_EXPENSE || primaryProject != <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (expenseLimit != NULL_EXPENSE) ?</span><br><span class="line">    expenseLimit:</span><br><span class="line">    primaryProject.getMemberExpenseLimit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>注：请不要滥用断言。不要使用它来检查”应该为真“的条件，只能使用它来检查“一定必须为真”的条件。实际上，断言更多是用于自我检测代码的一种手段。在产品真正交付时，往往都会消除所有断言。</em></p>
<h2 id="重复代码"><a href="#重复代码" class="headerlink" title="重复代码"></a>重复代码</h2><blockquote>
<p>重复代码(Duplicate Code)</p>
<p>重复代码堪称为代码坏味道之首。消除重复代码总是有利无害的。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/duplicate-code-1.png" alt="img"></p>
<h3 id="问题原因-4"><a href="#问题原因-4" class="headerlink" title="问题原因"></a>问题原因</h3><p>重复代码通常发生在多个程序员同时在同一程序的不同部分上工作时。由于他们正在处理不同的任务，他们可能不知道他们的同事已经写了类似的代码。</p>
<p>还有一种更隐晦的重复，特定部分的代码看上去不同但实际在做同一件事。这种重复代码往往难以找到和消除。</p>
<p>有时重复是有目的性的。当急于满足 deadline，并且现有代码对于要交付的任务是“几乎正确的”时，新手程序员可能无法抵抗复制和粘贴相关代码的诱惑。在某些情况下，程序员只是太懒惰。</p>
<h3 id="解决方法-4"><a href="#解决方法-4" class="headerlink" title="解决方法"></a>解决方法</h3><ul>
<li>同一个类的两个函数含有相同的表达式，这时可以采用 <code>提炼函数(Extract Method)</code> 提炼出重复的代码，然后让这两个地点都调用被提炼出来的那段代码。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/duplicate-code-2.png" alt="img"></p>
<ul>
<li>如果两个互为兄弟的子类含有重复代码：<ul>
<li>首先对两个类都运用 <code>提炼函数(Extract Method)</code> ，然后对被提炼出来的函数运用 <code>函数上移(Pull Up Method)</code> ，将它推入超类。</li>
<li>如果重复代码在构造函数中，运用 <code>构造函数本体上移(Pull Up Constructor Body)</code> 。</li>
<li>如果重复代码只是相似但不是完全相同，运用 <code>塑造模板函数(Form Template Method)</code> 获得一个 <strong>模板方法模式(Template Method)</strong> 。</li>
<li>如果有些函数以不同的算法做相同的事，你可以选择其中较清晰地一个，并运用 <code>替换算法(Substitute Algorithm)</code> 将其他函数的算法替换掉。</li>
</ul>
</li>
<li>如果两个毫不相关的类中有重复代码：<ul>
<li>请尝试运用 <code>提炼超类(Extract Superclass)</code> ，以便为维护所有先前功能的这些类创建一个超类。</li>
<li>如果创建超类十分困难，可以在一个类中运用 <code>提炼类(Extract Class)</code> ，并在另一个类中使用这个新的组件。</li>
</ul>
</li>
<li>如果存在大量的条件表达式，并且它们执行完全相同的代码（仅仅是它们的条件不同），可以运用 <code>合并条件表达式(Consolidate Conditional Expression)</code> 将这些操作合并为单个条件，并运用 <code>提炼函数(Extract Method)</code> 将该条件放入一个名字容易理解的独立函数中。</li>
<li>如果条件表达式的所有分支都有部分相同的代码片段：可以运用 <code>合并重复的条件片段(Consolidate Duplicate Conditional Fragments)</code> 将它们都存在的代码片段置于条件表达式外部。</li>
</ul>
<h3 id="收益-4"><a href="#收益-4" class="headerlink" title="收益"></a>收益</h3><ul>
<li>合并重复代码会简化代码的结构，并减少代码量。</li>
<li>代码更简化、更易维护。</li>
</ul>
<h3 id="重构方法说明-4"><a href="#重构方法说明-4" class="headerlink" title="重构方法说明"></a>重构方法说明</h3><h4 id="提炼函数-Extract-Method-2"><a href="#提炼函数-Extract-Method-2" class="headerlink" title="提炼函数(Extract Method)"></a>提炼函数(Extract Method)</h4><p><strong>问题</strong></p>
<p>你有一段代码可以组织在一起。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">printOwing</span><span class="params">()</span> &#123;</span><br><span class="line">  printBanner();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//print details</span></span><br><span class="line">  System.out.println(<span class="string">&quot;name: &quot;</span> + name);</span><br><span class="line">  System.out.println(<span class="string">&quot;amount: &quot;</span> + getOutstanding());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决</strong></p>
<p>移动这段代码到一个新的函数中，使用函数的调用来替代老代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">printOwing</span><span class="params">()</span> &#123;</span><br><span class="line">  printBanner();</span><br><span class="line">  printDetails(getOutstanding());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">printDetails</span><span class="params">(<span class="type">double</span> outstanding)</span> &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;name: &quot;</span> + name);</span><br><span class="line">  System.out.println(<span class="string">&quot;amount: &quot;</span> + outstanding);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="函数上移-Pull-Up-Method"><a href="#函数上移-Pull-Up-Method" class="headerlink" title="函数上移(Pull Up Method)"></a>函数上移(Pull Up Method)</h4><p><strong>问题</strong></p>
<p>有些函数，在各个子类中产生完全相同的结果。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/pull-up-method-before.png" alt="img"></p>
<p><strong>解决</strong></p>
<p>将该函数移至超类。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/pull-up-method-after.png" alt="img"></p>
<h4 id="构造函数本体上移-Pull-Up-Constructor-Body"><a href="#构造函数本体上移-Pull-Up-Constructor-Body" class="headerlink" title="构造函数本体上移(Pull Up Constructor Body)"></a>构造函数本体上移(Pull Up Constructor Body)</h4><p><strong>问题</strong></p>
<p>你在各个子类中拥有一些构造函数，它们的本体几乎完全一致。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">(String name, String id, <span class="type">int</span> grade)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.id = id;</span><br><span class="line">    <span class="built_in">this</span>.grade = grade;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决</strong></p>
<p>在超类中新建一个构造函数，并在子类构造函数中调用它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">(String name, String id, <span class="type">int</span> grade)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name, id);</span><br><span class="line">    <span class="built_in">this</span>.grade = grade;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="塑造模板函数-Form-Template-Method"><a href="#塑造模板函数-Form-Template-Method" class="headerlink" title="塑造模板函数(Form Template Method)"></a>塑造模板函数(Form Template Method)</h4><p><strong>问题</strong></p>
<p>你有一些子类，其中相应的某些函数以相同的顺序执行类似的操作，但各个操作的细节上有所不同。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/form-template-method-before.png" alt="img"></p>
<p><strong>解决</strong></p>
<p>将这些操作分别放进独立函数中，并保持它们都有相同的签名，于是原函数也就变得相同了。然后将原函数上移至超类。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/form-template-method-after.png" alt="img"></p>
<p><em>注：这里只提到具体做法，建议了解一下模板方法设计模式。</em></p>
<h4 id="替换算法-Substitute-Algorithm"><a href="#替换算法-Substitute-Algorithm" class="headerlink" title="替换算法(Substitute Algorithm)"></a>替换算法(Substitute Algorithm)</h4><p><strong>问题</strong></p>
<p>你想要把某个算法替换为另一个更清晰的算法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">foundPerson</span><span class="params">(String[] people)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; people.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (people[i].equals(<span class="string">&quot;Don&quot;</span>))&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Don&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (people[i].equals(<span class="string">&quot;John&quot;</span>))&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;John&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (people[i].equals(<span class="string">&quot;Kent&quot;</span>))&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Kent&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决</strong></p>
<p>将函数本体替换为另一个算法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">foundPerson</span><span class="params">(String[] people)</span>&#123;</span><br><span class="line">  <span class="type">List</span> <span class="variable">candidates</span> <span class="operator">=</span></span><br><span class="line">    Arrays.asList(<span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;Don&quot;</span>, <span class="string">&quot;John&quot;</span>, <span class="string">&quot;Kent&quot;</span>&#125;);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; people.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (candidates.contains(people[i])) &#123;</span><br><span class="line">      <span class="keyword">return</span> people[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="提炼超类-Extract-Superclass"><a href="#提炼超类-Extract-Superclass" class="headerlink" title="提炼超类(Extract Superclass)"></a>提炼超类(Extract Superclass)</h4><p><strong>问题</strong></p>
<p>两个类有相似特性。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/extract-superclass-before.png" alt="img"></p>
<p><strong>解决</strong></p>
<p>为这两个类建立一个超类，将相同特性移至超类。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/extract-superclass-after.png" alt="img"></p>
<h4 id="提炼类-Extract-Class"><a href="#提炼类-Extract-Class" class="headerlink" title="提炼类(Extract Class)"></a>提炼类(Extract Class)</h4><p><strong>问题</strong></p>
<p>某个类做了不止一件事。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/extract-class-before.png" alt="img"></p>
<p><strong>解决</strong></p>
<p>建立一个新类，将相关的字段和函数从旧类搬移到新类。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/extract-class-after.png" alt="img"></p>
<h4 id="合并条件表达式-Consolidate-Conditional-Expression"><a href="#合并条件表达式-Consolidate-Conditional-Expression" class="headerlink" title="合并条件表达式(Consolidate Conditional Expression)"></a>合并条件表达式(Consolidate Conditional Expression)</h4><p><strong>问题</strong></p>
<p>你有一系列条件分支，都得到相同结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">disabilityAmount</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (seniority &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (monthsDisabled &gt; <span class="number">12</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isPartTime) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// compute the disability amount</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决</strong></p>
<p>将这些条件分支合并为一个条件，并将这个条件提炼为一个独立函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">disabilityAmount</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (isNotEligableForDisability()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// compute the disability amount</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="合并重复的条件片段-Consolidate-Duplicate-Conditional-Fragments"><a href="#合并重复的条件片段-Consolidate-Duplicate-Conditional-Fragments" class="headerlink" title="合并重复的条件片段(Consolidate Duplicate Conditional Fragments)"></a>合并重复的条件片段(Consolidate Duplicate Conditional Fragments)</h4><p><strong>问题</strong></p>
<p>在条件表达式的每个分支上有着相同的一段代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isSpecialDeal()) &#123;</span><br><span class="line">  total = price * <span class="number">0.95</span>;</span><br><span class="line">  send();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  total = price * <span class="number">0.98</span>;</span><br><span class="line">  send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决</strong></p>
<p>将这段重复代码搬移到条件表达式之外。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isSpecialDeal()) &#123;</span><br><span class="line">  total = price * <span class="number">0.95</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  total = price * <span class="number">0.98</span>;</span><br><span class="line">&#125;</span><br><span class="line">send();</span><br></pre></td></tr></table></figure>

<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/dunwu/design/blob/master/docs/refactor/">代码的坏味道和重构</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/dunwu/design/blob/master/docs/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%87%83%E8%82%BF.md">代码坏味道之代码臃肿</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/dunwu/design/blob/master/docs/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E6%BB%A5%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.md">代码坏味道之滥用面向对象</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/dunwu/design/blob/master/docs/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E5%8F%98%E9%9D%A9%E7%9A%84%E9%9A%9C%E7%A2%8D.md">代码坏味道之变革的障碍</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/dunwu/design/blob/master/docs/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E9%9D%9E%E5%BF%85%E8%A6%81%E7%9A%84.md">代码坏味道之非必要的</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/dunwu/design/blob/master/docs/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E8%80%A6%E5%90%88.md">代码坏味道之耦合</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/4199741/">《代码整洁之道》</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/4262627/">《重构 - 改善既有代码的设计》</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/1477390/">《代码大全》</a></li>
<li><a target="_blank" rel="noopener" href="https://sourcemaking.com/refactoring">https://sourcemaking.com/refactoring</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/56ca63/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/56ca63/" class="post-title-link" itemprop="url">代码坏味道之变革的障碍</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-10-13 22:48:00" itemprop="dateCreated datePublished" datetime="2018-10-13T22:48:00+08:00">2018-10-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">设计</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1/%E9%87%8D%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">重构</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>翻译自：<a target="_blank" rel="noopener" href="https://sourcemaking.com/refactoring/smells/change-preventers">https://sourcemaking.com/refactoring/smells/change-preventers</a></p>
<p><strong>变革的障碍(Change Preventers)这组坏味道意味着：当你需要改变一处代码时，却发现不得不改变其他的地方。这使得程序开发变得复杂、代价高昂。</strong></p>
</blockquote>
<h2 id="发散式变化"><a href="#发散式变化" class="headerlink" title="发散式变化"></a>发散式变化</h2><blockquote>
<p><code>发散式变化(Divergent Change)</code> 类似于 <code>霰弹式修改(Shotgun Surgery)</code> ，但实际上完全不同。<code>发散式变化(Divergent Change)</code> 是指一个类受多种变化的影响。<code>霰弹式修改(Shotgun Surgery)</code> 是指多种变化引发多个类相应的修改。</p>
</blockquote>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>你发现你想要修改一个函数，却必须要同时修改许多不相关的函数。例如，当你想要添加一个新的产品类型时，你需要同步修改对产品进行查找、显示、排序的函数。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/divergent-change-1.png" alt="img"></p>
<h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p>通常，这种发散式修改是由于编程结构不合理或者“复制-粘贴式编程”。</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><ul>
<li>运用 <code>提炼类(Extract Class)</code> 拆分类的行为。</li>
</ul>
<h3 id="收益"><a href="#收益" class="headerlink" title="收益"></a>收益</h3><ul>
<li>提高代码组织结构</li>
<li>减少重复代码</li>
</ul>
<h3 id="重构方法说明"><a href="#重构方法说明" class="headerlink" title="重构方法说明"></a>重构方法说明</h3><h4 id="提炼类-Extract-Class"><a href="#提炼类-Extract-Class" class="headerlink" title="提炼类(Extract Class)"></a>提炼类(Extract Class)</h4><p><strong>问题</strong></p>
<p>某个类做了不止一件事。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/extract-class-before.png" alt="img"></p>
<p><strong>解决</strong></p>
<p>建立一个新类，将相关的字段和函数从旧类搬移到新类。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/extract-class-after.png" alt="img"></p>
<h2 id="平行继承体系"><a href="#平行继承体系" class="headerlink" title="平行继承体系"></a>平行继承体系</h2><blockquote>
<p><code>平行继承体系(Parallel Inheritance Hierarchies)</code> 其实是 <code>霰弹式修改(Shotgun Surgery)</code> 的特殊情况。</p>
</blockquote>
<h3 id="特征-1"><a href="#特征-1" class="headerlink" title="特征"></a>特征</h3><p>每当你为某个类添加一个子类，必须同时为另一个类相应添加一个子类。这种情况的典型特征是：某个继承体系的类名前缀或类名后缀完全相同。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/parallel-inheritance-hierarchies-1.png" alt="img"></p>
<h3 id="问题原因-1"><a href="#问题原因-1" class="headerlink" title="问题原因"></a>问题原因</h3><p>起初的继承体系很小，随着不断添加新类，继承体系越来越大，也越来越难修改。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ul>
<li>一般策略是：让一个继承体系的实例引用另一个继承体系的实例。如果再接再厉运用 <code>搬移函数(Move Method)</code> 和 <code>搬移字段(Move Field)</code>，就可以消除引用端的继承体系。</li>
</ul>
<h3 id="收益-1"><a href="#收益-1" class="headerlink" title="收益"></a>收益</h3><ul>
<li>更好的代码组织</li>
<li>减少重复代码</li>
</ul>
<h3 id="何时忽略"><a href="#何时忽略" class="headerlink" title="何时忽略"></a>何时忽略</h3><ul>
<li>有时具有并行类层次结构只是一种为了避免程序体系结构更混乱的方法。如果你发现尝试消除平行继承体系导致代码更加丑陋，那么你应该回滚你的修改。</li>
</ul>
<h3 id="重构方法说明-1"><a href="#重构方法说明-1" class="headerlink" title="重构方法说明"></a>重构方法说明</h3><h4 id="搬移函数-Move-Method"><a href="#搬移函数-Move-Method" class="headerlink" title="搬移函数(Move Method)"></a>搬移函数(Move Method)</h4><p><strong>问题</strong></p>
<p>你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/move-method-before.png" alt="img"></p>
<p><strong>解决</strong></p>
<p>在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/move-method-after.png" alt="img"></p>
<h4 id="搬移字段-Move-Field"><a href="#搬移字段-Move-Field" class="headerlink" title="搬移字段(Move Field)"></a>搬移字段(Move Field)</h4><p><strong>问题</strong></p>
<p>在你的程序中，某个字段被其所驻类之外的另一个类更多地用到。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/move-field-before.png" alt="img"></p>
<p><strong>解决</strong></p>
<p>在目标类新建一个字段，修改源字段的所有用户，令他们改用新字段。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/move-field-after.png" alt="img"></p>
<h2 id="霰弹式修改"><a href="#霰弹式修改" class="headerlink" title="霰弹式修改"></a>霰弹式修改</h2><blockquote>
<p><code>霰弹式修改(Shotgun Surgery)</code> 类似于 <code>发散式变化(Divergent Change)</code> ，但实际上完全不同。<code>发散式变化(Divergent Change)</code> 是指一个类受多种变化的影响。<code>霰弹式修改(Shotgun Surgery)</code> 是指多种变化引发多个类相应的修改。</p>
</blockquote>
<h3 id="特征-2"><a href="#特征-2" class="headerlink" title="特征"></a>特征</h3><p>任何修改都需要在许多不同类上做小幅度修改。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/shotgun-surgery-1.png" alt="img"></p>
<h3 id="问题原因-2"><a href="#问题原因-2" class="headerlink" title="问题原因"></a>问题原因</h3><p>一个单一的职责被拆分成大量的类。</p>
<h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><ul>
<li>运用<code>搬移函数(Move Method)</code> 和 <code>搬移字段(Move Field)</code> 来搬移不同类中相同的行为到一个独立类中。如果没有适合存放搬移函数或字段的类，就创建一个新类。</li>
<li>通常，可以运用 <code>将类内联化(Inline Class)</code> 将一些列相关行为放进同一个类。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/shotgun-surgery-2.png" alt="img"></p>
<h3 id="收益-2"><a href="#收益-2" class="headerlink" title="收益"></a>收益</h3><ul>
<li>更好的代码组织</li>
<li>减少重复代码</li>
<li>更易维护</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/shotgun-surgery-3.png" alt="img"></p>
<h3 id="重构方法说明-2"><a href="#重构方法说明-2" class="headerlink" title="重构方法说明"></a>重构方法说明</h3><h4 id="搬移函数-Move-Method-1"><a href="#搬移函数-Move-Method-1" class="headerlink" title="搬移函数(Move Method)"></a>搬移函数(Move Method)</h4><p><strong>问题</strong></p>
<p>你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/move-method-before.png" alt="img"></p>
<p><strong>解决</strong></p>
<p>在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/move-method-after.png" alt="img"></p>
<h4 id="搬移字段-Move-Field-1"><a href="#搬移字段-Move-Field-1" class="headerlink" title="搬移字段(Move Field)"></a>搬移字段(Move Field)</h4><p><strong>问题</strong></p>
<p>在你的程序中，某个字段被其所驻类之外的另一个类更多地用到。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/move-field-before.png" alt="img"></p>
<p><strong>解决</strong></p>
<p>在目标类新建一个字段，修改源字段的所有用户，令他们改用新字段。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/move-field-after.png" alt="img"></p>
<h4 id="将类内联化-Inline-Class"><a href="#将类内联化-Inline-Class" class="headerlink" title="将类内联化(Inline Class)"></a>将类内联化(Inline Class)</h4><p><strong>问题</strong></p>
<p>某个类没有做太多事情。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/inline-class-before.png" alt="img"></p>
<p><strong>解决</strong></p>
<p>将这个类的所有特性搬移到另一个类中，然后移除原类。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/refactor/inline-class-after.png" alt="img"></p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/dunwu/design/blob/master/docs/refactor/%E4%BB%A3%E7%A0%81%E7%9A%84%E5%9D%8F%E5%91%B3%E9%81%93%E5%92%8C%E9%87%8D%E6%9E%84.md">代码的坏味道和重构</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/dunwu/design/blob/master/docs/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%87%83%E8%82%BF.md">代码坏味道之代码臃肿</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/dunwu/design/blob/master/docs/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E6%BB%A5%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.md">代码坏味道之滥用面向对象</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/dunwu/design/blob/master/docs/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E5%8F%98%E9%9D%A9%E7%9A%84%E9%9A%9C%E7%A2%8D.md">代码坏味道之变革的障碍</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/dunwu/design/blob/master/docs/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E9%9D%9E%E5%BF%85%E8%A6%81%E7%9A%84.md">代码坏味道之非必要的</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/dunwu/design/blob/master/docs/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E8%80%A6%E5%90%88.md">代码坏味道之耦合</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/4199741/">《代码整洁之道》</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/4262627/">《重构 - 改善既有代码的设计》</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/1477390/">《代码大全》</a></li>
<li><a target="_blank" rel="noopener" href="https://sourcemaking.com/refactoring">https://sourcemaking.com/refactoring</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/8d1bee/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/8d1bee/" class="post-title-link" itemprop="url">kong</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-10-11 13:08:18" itemprop="dateCreated datePublished" datetime="2018-10-11T13:08:18+08:00">2018-10-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:53" itemprop="dateModified" datetime="2024-12-12T10:02:53+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/" itemprop="url" rel="index"><span itemprop="name">分布式通信</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1/RPC/" itemprop="url" rel="index"><span itemprop="name">RPC</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Kong"><a href="#Kong" class="headerlink" title="Kong"></a>Kong</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/Kong/kong">Kong</a> 是一个云原生、快速、可扩展和分布式的微服务抽象层（也称为 API 网关，API 中间件）。</p>
<p>关键词：<code>nginx</code>,<code>api网关</code>,<code>微服务</code></p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="为什么选择-Kong"><a href="#为什么选择-Kong" class="headerlink" title="为什么选择 Kong"></a>为什么选择 Kong</h3><p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/microservices/kong/why-kong.png"/></div><br></p>
<h2 id="Quickstart"><a href="#Quickstart" class="headerlink" title="Quickstart"></a>Quickstart</h2><h3 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h3><blockquote>
<p>本文仅以 Centos7 为例。</p>
</blockquote>
<p>Kong 支持在多种环境下安装。</p>
<p>官方安装说明：<a target="_blank" rel="noopener" href="https://konghq.com/install/">https://konghq.com/install/</a></p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20180920181011104339.png"/></div><br></p>
<p>以下为 Centos7 安装步骤：</p>
<p>（1）下载 rpm 安装包到本地</p>
<p>（2）安装 Kong</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> yum install epel-release</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> yum install kong-community-edition-0.14.1.*.noarch.rpm --nogpgcheck</span></span><br></pre></td></tr></table></figure>

<p>（3）准备数据库</p>
<p>Kong 需要存储数据，支持两种数据库：<a target="_blank" rel="noopener" href="http://www.postgresql.org/">PostgreSQL 9.5+</a> 和 <a target="_blank" rel="noopener" href="http://cassandra.apache.org/">Cassandra 3.x.x</a></p>
<p>本人选择了 PostgreSQL，安装方法可以参考 —— <a target="_blank" rel="noopener" href="https://github.com/dunwu/database/blob/master/docs/postgresql.md#%E5%AE%89%E8%A3%85">PostgreSQL 安装</a></p>
<p>安装 PostgreSQL 后，配置一个数据库和数据库用户：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> kong;</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE kong OWNER kong;</span><br></pre></td></tr></table></figure>

<p>（4）执行 Kong 迁移</p>
<p>执行以下命令：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kong migrations <span class="keyword">up</span> [-<span class="keyword">c</span> /path/<span class="keyword">to</span>/kong.<span class="keyword">conf</span>]</span><br></pre></td></tr></table></figure>

<p>注意：永远不应同时运行迁移；一个 Kong 节点应该只执行一次迁移。</p>
<p>（5）启动 Kong</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kong <span class="keyword">start</span> [-c /<span class="type">path</span>/<span class="keyword">to</span>/kong.conf]</span><br></pre></td></tr></table></figure>

<p>（6）测试启动成功</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>curl -i <span class="symbol">http:</span>/<span class="regexp">/localhost:8001/</span></span><br></pre></td></tr></table></figure>

<p>至此，安装配置完成。</p>
<h3 id="使用-Kong"><a href="#使用-Kong" class="headerlink" title="使用 Kong"></a>使用 Kong</h3><ul>
<li>启动（必须确保执行过 <code>kong migrations up</code>） - <code>kong start [-c /path/to/kong.conf]</code><ul>
<li><code>-c /path/to/kong.conf</code> 参数用来指定用户的配置</li>
</ul>
</li>
<li>停止 - <code>kong stop</code></li>
<li>重启 - <code>kong reload</code></li>
</ul>
<h3 id="配置服务"><a href="#配置服务" class="headerlink" title="配置服务"></a>配置服务</h3><p>（1）添加第一个服务</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl -i -X POST \</span><br><span class="line">  --url http://localhost:8001/services/ \</span><br><span class="line">  --data <span class="string">&#x27;name=example-service&#x27;</span> \</span><br><span class="line">  --data <span class="string">&#x27;url=http://mockbin.org&#x27;</span></span><br></pre></td></tr></table></figure>

<p>应答类似下面形式：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">201</span> Created</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"></span><br><span class="line"><span class="language-json"><span class="punctuation">&#123;</span></span></span><br><span class="line"><span class="language-json">   <span class="attr">&quot;host&quot;</span><span class="punctuation">:</span><span class="string">&quot;mockbin.org&quot;</span><span class="punctuation">,</span></span></span><br><span class="line"><span class="language-json">   <span class="attr">&quot;created_at&quot;</span><span class="punctuation">:</span><span class="number">1519130509</span><span class="punctuation">,</span></span></span><br><span class="line"><span class="language-json">   <span class="attr">&quot;connect_timeout&quot;</span><span class="punctuation">:</span><span class="number">60000</span><span class="punctuation">,</span></span></span><br><span class="line"><span class="language-json">   <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="string">&quot;92956672-f5ea-4e9a-b096-667bf55bc40c&quot;</span><span class="punctuation">,</span></span></span><br><span class="line"><span class="language-json">   <span class="attr">&quot;protocol&quot;</span><span class="punctuation">:</span><span class="string">&quot;http&quot;</span><span class="punctuation">,</span></span></span><br><span class="line"><span class="language-json">   <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;example-service&quot;</span><span class="punctuation">,</span></span></span><br><span class="line"><span class="language-json">   <span class="attr">&quot;read_timeout&quot;</span><span class="punctuation">:</span><span class="number">60000</span><span class="punctuation">,</span></span></span><br><span class="line"><span class="language-json">   <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span><span class="number">80</span><span class="punctuation">,</span></span></span><br><span class="line"><span class="language-json">   <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span></span><br><span class="line"><span class="language-json">   <span class="attr">&quot;updated_at&quot;</span><span class="punctuation">:</span><span class="number">1519130509</span><span class="punctuation">,</span></span></span><br><span class="line"><span class="language-json">   <span class="attr">&quot;retries&quot;</span><span class="punctuation">:</span><span class="number">5</span><span class="punctuation">,</span></span></span><br><span class="line"><span class="language-json">   <span class="attr">&quot;write_timeout&quot;</span><span class="punctuation">:</span><span class="number">60000</span></span></span><br><span class="line"><span class="language-json"><span class="punctuation">&#125;</span></span></span><br></pre></td></tr></table></figure>

<p>（2）为服务添加路由</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl -i -X POST \</span><br><span class="line">  --url http://localhost:8001/services/example-service/routes \</span><br><span class="line">  --data <span class="string">&#x27;hosts[]=example.com&#x27;</span></span><br></pre></td></tr></table></figure>

<p>应答类似下面形式：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">201</span> Created</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"></span><br><span class="line"><span class="language-json"><span class="punctuation">&#123;</span></span></span><br><span class="line"><span class="language-json">   <span class="attr">&quot;created_at&quot;</span><span class="punctuation">:</span><span class="number">1519131139</span><span class="punctuation">,</span></span></span><br><span class="line"><span class="language-json">   <span class="attr">&quot;strip_path&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span></span><br><span class="line"><span class="language-json">   <span class="attr">&quot;hosts&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span></span><br><span class="line"><span class="language-json">      <span class="string">&quot;example.com&quot;</span></span></span><br><span class="line"><span class="language-json">   <span class="punctuation">]</span><span class="punctuation">,</span></span></span><br><span class="line"><span class="language-json">   <span class="attr">&quot;preserve_host&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span></span><br><span class="line"><span class="language-json">   <span class="attr">&quot;regex_priority&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span></span></span><br><span class="line"><span class="language-json">   <span class="attr">&quot;updated_at&quot;</span><span class="punctuation">:</span><span class="number">1519131139</span><span class="punctuation">,</span></span></span><br><span class="line"><span class="language-json">   <span class="attr">&quot;paths&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span></span><br><span class="line"><span class="language-json">   <span class="attr">&quot;service&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span></span><br><span class="line"><span class="language-json">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="string">&quot;79d7ee6e-9fc7-4b95-aa3b-61d2e17e7516&quot;</span></span></span><br><span class="line"><span class="language-json">   <span class="punctuation">&#125;</span><span class="punctuation">,</span></span></span><br><span class="line"><span class="language-json">   <span class="attr">&quot;methods&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span></span><br><span class="line"><span class="language-json">   <span class="attr">&quot;protocols&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span></span><br><span class="line"><span class="language-json">      <span class="string">&quot;http&quot;</span><span class="punctuation">,</span></span></span><br><span class="line"><span class="language-json">      <span class="string">&quot;https&quot;</span></span></span><br><span class="line"><span class="language-json">   <span class="punctuation">]</span><span class="punctuation">,</span></span></span><br><span class="line"><span class="language-json">   <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="string">&quot;f9ce2ed7-c06e-4e16-bd5d-3a82daef3f9d&quot;</span></span></span><br><span class="line"><span class="language-json"><span class="punctuation">&#125;</span></span></span><br></pre></td></tr></table></figure>

<p>此时，Kong 已经关注这个服务，并准备代理请求。</p>
<p>（3）通过 Kong 转发请求</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl -i -X GET \</span><br><span class="line">  --url http://localhost:8000/ \</span><br><span class="line">  --header <span class="string">&#x27;Host: example.com&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://www.itcodemonkey.com/article/5980.html">https://www.itcodemonkey.com/article/5980.html</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/f7e766/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/f7e766/" class="post-title-link" itemprop="url">Linux 典型运维应用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-09-30 18:05:00" itemprop="dateCreated datePublished" datetime="2018-09-30T18:05:00+08:00">2018-09-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 11:20:34" itemprop="dateModified" datetime="2024-12-12T11:20:34+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Linux-典型运维应用"><a href="#Linux-典型运维应用" class="headerlink" title="Linux 典型运维应用"></a>Linux 典型运维应用</h1><blockquote>
<p>💡 如果没有特殊说明，本文的案例都是针对 Centos 发行版本。</p>
</blockquote>
<h2 id="网络操作"><a href="#网络操作" class="headerlink" title="网络操作"></a>网络操作</h2><h3 id="无法访问外网域名"><a href="#无法访问外网域名" class="headerlink" title="无法访问外网域名"></a>无法访问外网域名</h3><p>（1）在 hosts 中添加本机实际 IP 和本机实际域名的映射</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;192.168.0.1 hostname&quot; &gt;&gt; /etc/hosts</span><br></pre></td></tr></table></figure>

<p>如果不知道本机域名，使用 <code>hostname</code> 命令查一下；如果不知道本机实际 IP，使用 <code>ifconfig</code> 查一下。</p>
<p>（2）配置信赖的 DNS 服务器</p>
<p>执行 <code>vi /etc/resolv.conf</code> ，添加以下内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nameserver 114.114.114.114</span><br><span class="line">nameserver 8.8.8.8</span><br></pre></td></tr></table></figure>

<blockquote>
<p>114.114.114.114 是国内老牌 DNS</p>
<p>8.8.8.8 是 Google DNS</p>
<p>:point_right: 参考：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/32229915">公共 DNS 哪家强</a></p>
</blockquote>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/pages/f7e766/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/7daf0d/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/7daf0d/" class="post-title-link" itemprop="url">Java 开发环境</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-08-29 17:28:34" itemprop="dateCreated datePublished" datetime="2018-08-29T17:28:34+08:00">2018-08-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JavaSE/%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7/" itemprop="url" rel="index"><span itemprop="name">基础特性</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java-开发环境"><a href="#Java-开发环境" class="headerlink" title="Java 开发环境"></a>Java 开发环境</h1><blockquote>
<p>📌 <strong>关键词：</strong> JAVA_HOME、CLASSPATH、Path、环境变量、IDE</p>
</blockquote>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>进入 <a target="_blank" rel="noopener" href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">JDK 官方下载地址</a> ，根据自己的环境选择下载所需版本。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>windows 环境的 jdk 包是 exe 安装文件，启动后根据安装向导安装即可。</p>
<p>Linux 环境的 jdk 包，解压到本地即可。</p>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>计算机 &gt; 属性 &gt; 高级系统设置 &gt; 环境变量</p>
<p>添加以下环境变量：</p>
<p><code>JAVA_HOME</code>：<code>C:\Program Files (x86)\Java\jdk1.8.0_91</code> （根据自己的实际路径配置）</p>
<p><code>CLASSPATH</code>：<code>.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;</code> （注意前面有个”.”）</p>
<p><code>Path</code>：<code>%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;</code></p>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>执行 <code>vi /etc/profile</code> ，编辑环境变量文件</p>
<p>添加两行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=path/to/java</span><br><span class="line">export PATH=JAVA_HOME/bin:JAVA_HOME/jre/bin:</span><br></pre></td></tr></table></figure>

<p>执行 <code>source /etc/profile</code> ，立即生效。</p>
<h2 id="测试安装成功"><a href="#测试安装成功" class="headerlink" title="测试安装成功"></a>测试安装成功</h2><p>执行命令 <code>java -version</code> ，如果安装成功，会打印当前 java 的版本信息。</p>
<h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><p>工欲善其事，必先利其器。编写 Java 程序，当然有必要选择一个合适的 IDE。</p>
<p>IDE（Integrated Development Environment，即集成开发环境）是用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面等工具。</p>
<p>常见的 Java IDE 如下：</p>
<ul>
<li>Eclipse - 一个开放源代码的、基于 Java 的可扩展开发平台。</li>
<li>NetBeans - 开放源码的 Java 集成开发环境，适用于各种客户机和 Web 应用。</li>
<li>IntelliJ IDEA - 在代码自动提示、代码分析等方面的具有很好的功能。</li>
<li>MyEclipse - 由 Genuitec 公司开发的一款商业化软件，是应用比较广泛的 Java 应用程序集成开发环境。</li>
<li>EditPlus - 如果正确配置 Java 的编译器“Javac”以及解释器“Java”后，可直接使用 EditPlus 编译执行 Java 程序。</li>
</ul>
<h2 id="第一个程序：Hello-World"><a href="#第一个程序：Hello-World" class="headerlink" title="第一个程序：Hello World"></a>第一个程序：Hello World</h2><p>添加 HelloWorld.java 文件，内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行后，控制台输出：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Hello World</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/db33b0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/db33b0/" class="post-title-link" itemprop="url">Spring 面试</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-08-02 17:33:32" itemprop="dateCreated datePublished" datetime="2018-08-02T17:33:32+08:00">2018-08-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E6%A1%86%E6%9E%B6/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E6%A1%86%E6%9E%B6/Spring/Spring%E7%BB%BC%E5%90%88/" itemprop="url" rel="index"><span itemprop="name">Spring综合</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>14k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>12 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Spring-面试"><a href="#Spring-面试" class="headerlink" title="Spring 面试"></a>Spring 面试</h1><h2 id="综合篇"><a href="#综合篇" class="headerlink" title="综合篇"></a>综合篇</h2><h3 id="不同版本的-Spring-Framework-有哪些主要功能？"><a href="#不同版本的-Spring-Framework-有哪些主要功能？" class="headerlink" title="不同版本的 Spring Framework 有哪些主要功能？"></a>不同版本的 Spring Framework 有哪些主要功能？</h3><table>
<thead>
<tr>
<th>Version</th>
<th>Feature</th>
</tr>
</thead>
<tbody><tr>
<td>Spring 2.5</td>
<td>发布于 2007 年。这是第一个支持注解的版本。</td>
</tr>
<tr>
<td>Spring 3.0</td>
<td>发布于 2009 年。它完全利用了 Java5 中的改进，并为 JEE6 提供了支持。</td>
</tr>
<tr>
<td>Spring 4.0</td>
<td>发布于 2013 年。这是第一个完全支持 JAVA8 的版本。</td>
</tr>
</tbody></table>
<h3 id="什么是-Spring-Framework？"><a href="#什么是-Spring-Framework？" class="headerlink" title="什么是 Spring Framework？"></a>什么是 Spring Framework？</h3><ul>
<li>Spring 是一个开源应用框架，旨在降低应用程序开发的复杂度。</li>
<li>它是轻量级、松散耦合的。</li>
<li>它具有分层体系结构，允许用户选择组件，同时还为 J2EE 应用程序开发提供了一个有凝聚力的框架。</li>
<li>它可以集成其他框架，如 Structs、Hibernate、EJB 等，所以又称为框架的框架。</li>
</ul>
<h3 id="列举-Spring-Framework-的优点。"><a href="#列举-Spring-Framework-的优点。" class="headerlink" title="列举 Spring Framework 的优点。"></a>列举 Spring Framework 的优点。</h3><ul>
<li>由于 Spring Frameworks 的分层架构，用户可以自由选择自己需要的组件。</li>
<li>Spring Framework 支持 POJO(Plain Old Java Object) 编程，从而具备持续集成和可测试性。</li>
<li>由于依赖注入和控制反转，JDBC 得以简化。</li>
<li>它是开源免费的。</li>
</ul>
<h3 id="Spring-Framework-有哪些不同的功能？"><a href="#Spring-Framework-有哪些不同的功能？" class="headerlink" title="Spring Framework 有哪些不同的功能？"></a>Spring Framework 有哪些不同的功能？</h3><ul>
<li><strong>轻量级</strong> - Spring 在代码量和透明度方面都很轻便。</li>
<li><strong>IOC</strong> - 控制反转</li>
<li><strong>AOP</strong> - 面向切面编程可以将应用业务逻辑和系统服务分离，以实现高内聚。</li>
<li><strong>容器</strong> - Spring 负责创建和管理对象（Bean）的生命周期和配置。</li>
<li><strong>MVC</strong> - 对 web 应用提供了高度可配置性，其他框架的集成也十分方便。</li>
<li><strong>事务管理</strong> - 提供了用于事务管理的通用抽象层。Spring 的事务支持也可用于容器较少的环境。</li>
<li><strong>JDBC 异常</strong> - Spring 的 JDBC 抽象层提供了一个异常层次结构，简化了错误处理策略。</li>
</ul>
<h3 id="Spring-Framework-中有多少个模块，它们分别是什么？"><a href="#Spring-Framework-中有多少个模块，它们分别是什么？" class="headerlink" title="Spring Framework 中有多少个模块，它们分别是什么？"></a>Spring Framework 中有多少个模块，它们分别是什么？</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/spring/spring-framework.png" alt="img"></p>
<ul>
<li><strong>Spring 核心容器</strong> – 该层基本上是 Spring Framework 的核心。它包含以下模块：<ul>
<li>Spring Core</li>
<li>Spring Bean</li>
<li>SpEL (Spring Expression Language)</li>
<li>Spring Context</li>
</ul>
</li>
<li><strong>数据访问&#x2F;集成</strong> – 该层提供与数据库交互的支持。它包含以下模块：<ul>
<li>JDBC (Java DataBase Connectivity)</li>
<li>ORM (Object Relational Mapping)</li>
<li>OXM (Object XML Mappers)</li>
<li>JMS (Java Messaging Service)</li>
<li>Transaction</li>
</ul>
</li>
<li><strong>Web</strong> – 该层提供了创建 Web 应用程序的支持。它包含以下模块：<ul>
<li>Web</li>
<li>Web – Servlet</li>
<li>Web – Socket</li>
<li>Web – Portlet</li>
</ul>
</li>
<li><strong>AOP</strong> – 该层支持面向切面编程</li>
<li><strong>Instrumentation</strong> – 该层为类检测和类加载器实现提供支持。</li>
<li><strong>Test</strong> – 该层为使用 JUnit 和 TestNG 进行测试提供支持。</li>
<li><strong>几个杂项模块:</strong><ul>
<li>Messaging – 该模块为 STOMP 提供支持。它还支持注解编程模型，该模型用于从 WebSocket 客户端路由和处理 STOMP 消息。</li>
<li>Aspects – 该模块为与 AspectJ 的集成提供支持。</li>
</ul>
</li>
</ul>
<h3 id="什么是-Spring-配置文件？"><a href="#什么是-Spring-配置文件？" class="headerlink" title="什么是 Spring 配置文件？"></a>什么是 Spring 配置文件？</h3><p>Spring 配置文件是 XML 文件。该文件主要包含类信息。它描述了这些类是如何配置以及相互引入的。但是，XML 配置文件冗长且更加干净。如果没有正确规划和编写，那么在大项目中管理变得非常困难。</p>
<h3 id="Spring-应用程序有哪些不同组件？"><a href="#Spring-应用程序有哪些不同组件？" class="headerlink" title="Spring 应用程序有哪些不同组件？"></a>Spring 应用程序有哪些不同组件？</h3><p>Spring 应用一般有以下组件：</p>
<ul>
<li><strong>接口</strong> - 定义功能。</li>
<li><strong>Bean 类</strong> - 它包含属性，setter 和 getter 方法，函数等。</li>
<li><strong>Spring 面向切面编程（AOP）</strong> - 提供面向切面编程的功能。</li>
<li><strong>Bean 配置文件</strong> - 包含类的信息以及如何配置它们。</li>
<li><strong>用户程序</strong> - 它使用接口。</li>
</ul>
<h3 id="使用-Spring-有哪些方式？"><a href="#使用-Spring-有哪些方式？" class="headerlink" title="使用 Spring 有哪些方式？"></a>使用 Spring 有哪些方式？</h3><p>使用 Spring 有以下方式：</p>
<ul>
<li>作为一个成熟的 Spring Web 应用程序。</li>
<li>作为第三方 Web 框架，使用 Spring Frameworks 中间层。</li>
<li>用于远程使用。</li>
<li>作为企业级 Java Bean，它可以包装现有的 POJO（Plain Old Java Objects）。</li>
</ul>
<h2 id="核心篇"><a href="#核心篇" class="headerlink" title="核心篇"></a>核心篇</h2><h3 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h3><h4 id="什么是-IoC？什么是依赖注入？什么是-Spring-IoC？"><a href="#什么是-IoC？什么是依赖注入？什么是-Spring-IoC？" class="headerlink" title="什么是 IoC？什么是依赖注入？什么是 Spring IoC？"></a>什么是 IoC？什么是依赖注入？什么是 Spring IoC？</h4><p><strong>IoC</strong> 即<strong>控制反转</strong>（Inversion of Control，缩写为 IoC）。IoC 又称为<strong>依赖倒置原则</strong>（设计模式六大原则之一），它的要点在于：<strong>程序要依赖于抽象接口，不要依赖于具体实现</strong>。它的作用就是<strong>用于降低代码间的耦合度</strong>。</p>
<p>IoC 的实现方式有两种：</p>
<ul>
<li><strong>依赖注入</strong>（Dependency Injection，简称 DI）：不通过 <code>new()</code> 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造器、函数参数等方式传递（或注入）给类使用。</li>
<li><strong>依赖查找</strong>（Dependency Lookup）：容器中的受控对象通过容器的 API 来查找自己所依赖的资源和协作对象。</li>
</ul>
<p>Spring IoC 是 IoC 的一种实现。DI 是 Spring IoC 的主要实现原则。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20221005163639.png"></p>
<h4 id="依赖注入有哪些实现方式？"><a href="#依赖注入有哪些实现方式？" class="headerlink" title="依赖注入有哪些实现方式？"></a>依赖注入有哪些实现方式？</h4><p>依赖注入有如下方式：</p>
<table>
<thead>
<tr>
<th>依赖注入方式</th>
<th>配置元数据举例</th>
</tr>
</thead>
<tbody><tr>
<td>Setter 方法注入</td>
<td><code>&lt;proeprty name=&quot;user&quot; ref=&quot;userBean&quot;/&gt;</code></td>
</tr>
<tr>
<td>构造器注入</td>
<td><code>&lt;constructor-arg name=&quot;user&quot; ref=&quot;userBean&quot; /&gt;</code></td>
</tr>
<tr>
<td>字段注入</td>
<td><code>@Autowired User user;</code></td>
</tr>
<tr>
<td>方法注入</td>
<td><code>@Autowired public void user(User user) &#123; ... &#125;</code></td>
</tr>
<tr>
<td>接口回调注入</td>
<td><code>class MyBean implements BeanFactoryAware &#123; ... &#125;</code></td>
</tr>
</tbody></table>
<h4 id="构造器注入-VS-setter-注入"><a href="#构造器注入-VS-setter-注入" class="headerlink" title="构造器注入 VS. setter 注入"></a>构造器注入 VS. setter 注入</h4><table>
<thead>
<tr>
<th>构造器注入</th>
<th>setter 注入</th>
</tr>
</thead>
<tbody><tr>
<td>没有部分注入</td>
<td>有部分注入</td>
</tr>
<tr>
<td>不会覆盖 setter 属性</td>
<td>会覆盖 setter 属性</td>
</tr>
<tr>
<td>任意修改都会创建一个新实例</td>
<td>任意修改不会创建一个新实例</td>
</tr>
<tr>
<td>适用于设置很多属性</td>
<td>适用于设置少量属性</td>
</tr>
</tbody></table>
<p>官方推荐使用构造器注入。</p>
<h4 id="BeanFactory-VS-ApplicationContext"><a href="#BeanFactory-VS-ApplicationContext" class="headerlink" title="BeanFactory VS. ApplicationContext"></a>BeanFactory VS. ApplicationContext</h4><p>在 Spring 中，有两种 IoC 容器：<code>BeanFactory</code> 和 <code>ApplicationContext</code>。</p>
<ul>
<li><code>BeanFactory</code>：**<code>BeanFactory</code> 是 Spring 基础 IoC 容器**。<code>BeanFactory</code> 提供了 Spring 容器的配置框架和基本功能。</li>
<li><code>ApplicationContext</code>：**<code>ApplicationContext</code> 是具备应用特性的 <code>BeanFactory</code> 的子接口**。它还扩展了其他一些接口，以支持更丰富的功能，如：国际化、访问资源、事件机制、更方便的支持 AOP、在 web 应用中指定应用层上下文等。</li>
</ul>
<p>实际开发中，更推荐使用 <code>ApplicationContext</code> 作为 IoC 容器，因为它的功能远多于 <code>BeanFactory</code>。</p>
<h4 id="BeanFactory-VS-FactoryBean"><a href="#BeanFactory-VS-FactoryBean" class="headerlink" title="BeanFactory VS. FactoryBean"></a>BeanFactory VS. FactoryBean</h4><p><strong><code>BeanFactory</code> 是 Spring 基础 IoC 容器</strong>。</p>
<p><code>FactoryBean</code> 是创建 Bean 的一种方式，帮助实现复杂的初始化逻辑。</p>
<h4 id="Spring-IoC-启动时做了哪些准备"><a href="#Spring-IoC-启动时做了哪些准备" class="headerlink" title="Spring IoC 启动时做了哪些准备"></a>Spring IoC 启动时做了哪些准备</h4><p>IoC 配置元信息读取和解析</p>
<p>IoC 容器生命周期管理</p>
<p>Spring 事件发布</p>
<p>国际化</p>
<p>等等</p>
<h4 id="Spring-IoC-的实现机制是什么"><a href="#Spring-IoC-的实现机制是什么" class="headerlink" title="Spring IoC 的实现机制是什么"></a>Spring IoC 的实现机制是什么</h4><p>Spring 中的 IoC 的实现原理就是工厂模式加反射机制。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">implements</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Orange</span> <span class="keyword">implements</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Orange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title function_">getInstance</span><span class="params">(String ClassName)</span> &#123;</span><br><span class="line">        Fruit f=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            f=(Fruit)Class.forName(ClassName).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] a)</span> &#123;</span><br><span class="line">        Fruit f=Factory.getInstance(<span class="string">&quot;io.github.dunwu.spring.Apple&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(f!=<span class="literal">null</span>)&#123;</span><br><span class="line">            f.eat();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h3><h4 id="什么是-Spring-Bean"><a href="#什么是-Spring-Bean" class="headerlink" title="什么是 Spring Bean"></a>什么是 Spring Bean</h4><p>在 Spring 中，构成应用程序主体由 Spring IoC 容器管理的对象称为 Bean。<strong>Bean 是由 Spring IoC 容器实例化、装配和管理的对象</strong>。 Bean 以及它们之间的依赖关系反映在容器使用的配置元数据中。</p>
<p>Spring IoC 容器本身，并不能识别配置的元数据。为此，要将这些配置信息转为 Spring 能识别的格式——<code>BeanDefinition</code> 对象。</p>
<p><strong><code>BeanDefinition</code> 是 Spring 中定义 Bean 的配置元信息接口</strong>，它包含：</p>
<ul>
<li>Bean 类名</li>
<li>Bean 行为配置元素，如：作用域、自动绑定的模式、生命周期回调等</li>
<li>其他 Bean 引用，也可称为合作者（Collaborators）或依赖（Dependencies）</li>
<li>配置设置，如 Bean 属性（Properties）</li>
</ul>
<h4 id="如何注册-Spring-Bean"><a href="#如何注册-Spring-Bean" class="headerlink" title="如何注册 Spring Bean"></a>如何注册 Spring Bean</h4><p>通过 <code>BeanDefinition</code> 和外部单例对象来注册。</p>
<h4 id="spring-提供了哪些配置方式？"><a href="#spring-提供了哪些配置方式？" class="headerlink" title="spring 提供了哪些配置方式？"></a>spring 提供了哪些配置方式？</h4><ul>
<li>基于 xml 配置</li>
</ul>
<p>bean 所需的依赖项和服务在 XML 格式的配置文件中指定。这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项。它们通常以 bean 标签开头。例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;studentbean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.edureka.firstSpring.StudentBean&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Edureka&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>基于注解配置</li>
</ul>
<p>您可以通过在相关的类，方法或字段声明上使用注解，将 bean 配置为组件类本身，而不是使用 XML 来描述 bean 装配。默认情况下，Spring 容器中未打开注解装配。因此，您需要在使用它之前在 Spring 配置文件中启用它。例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- bean definitions go here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>基于 Java API 配置</li>
</ul>
<p>Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。</p>
<ol>
<li>@Bean 注解扮演与 <code>&lt;bean /&gt;</code> 元素相同的角色。</li>
<li>@Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。</li>
</ol>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> StudentBean <span class="title function_">myStudent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StudentBean</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="spring-支持集中-bean-scope？"><a href="#spring-支持集中-bean-scope？" class="headerlink" title="spring 支持集中 bean scope？"></a>spring 支持集中 bean scope？</h4><p>Spring bean 支持 5 种 scope：</p>
<ul>
<li><strong>Singleton</strong> - 每个 Spring IoC 容器仅有一个单实例。</li>
<li><strong>Prototype</strong> - 每次请求都会产生一个新的实例。</li>
<li><strong>Request</strong> - 每一次 HTTP 请求都会产生一个新的实例，并且该 bean 仅在当前 HTTP 请求内有效。</li>
<li><strong>Session</strong> - 每一次 HTTP 请求都会产生一个新的 bean，同时该 bean 仅在当前 HTTP session 内有效。</li>
<li><strong>Global-session</strong> - 类似于标准的 HTTP Session 作用域，不过它仅仅在基于 portlet 的 web 应用中才有意义。Portlet 规范定义了全局 Session 的概念，它被所有构成某个 portlet web 应用的各种不同的 portlet 所共享。在 global session 作用域中定义的 bean 被限定于全局 portlet Session 的生命周期范围内。如果你在 web 中使用 global session 作用域来标识 bean，那么 web 会自动当成 session 类型来使用。</li>
</ul>
<p>仅当用户使用支持 Web 的 ApplicationContext 时，最后三个才可用。</p>
<h4 id="Spring-Bean-的生命周期"><a href="#Spring-Bean-的生命周期" class="headerlink" title="Spring Bean 的生命周期"></a>Spring Bean 的生命周期</h4><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20211201102734.png"></p>
<p>spring bean 容器的生命周期如下：</p>
<ol>
<li><p>Spring 对 Bean 进行实例化（相当于 new XXX()）</p>
</li>
<li><p>Spring 将值和引用注入到 Bean 对应的属性中</p>
</li>
<li><p>如果 Bean 实现了 <code>BeanNameAware</code> 接口，Spring 将 Bean 的 ID 传递给 <code>setBeanName</code> 方法</p>
<ul>
<li>作用是通过 Bean 的引用来获得 Bean ID，一般业务中是很少有用到 Bean 的 ID 的</li>
</ul>
</li>
<li><p>如果 Bean 实现了 <code>BeanFactoryAware</code> 接口，Spring 将调用 <code>setBeanDactory</code> 方法，并把 <code>BeanFactory</code> 容器实例作为参数传入。</p>
<ul>
<li>作用是获取 Spring 容器，如 Bean 通过 Spring 容器发布事件等</li>
</ul>
</li>
<li><p>如果 Bean 实现了 <code>ApplicationContextAware</code> 接口，Spring 容器将调用 <code>setApplicationContext</code> 方法，把应用上下文作为参数传入</p>
<ul>
<li>作用与 <code>BeanFactory</code> 类似都是为了获取 Spring 容器，不同的是 Spring 容器在调用 <code>setApplicationContext</code> 方法时会把它自己作为 <code>setApplicationContext</code> 的参数传入，而 Spring 容器在调用 <code>setBeanFactory</code> 前需要使用者自己指定（注入）<code>setBeanFactory</code> 里的参数 <code>BeanFactory</code></li>
</ul>
</li>
<li><p>如果 Bean 实现了 <code>BeanPostProcess</code> 接口，Spring 将调用 <code>postProcessBeforeInitialization</code> 方法</p>
<ul>
<li>作用是在 Bean 实例创建成功后对其进行增强处理，如对 Bean 进行修改，增加某个功能</li>
</ul>
</li>
<li><p>如果 Bean 实现了 <code>InitializingBean</code> 接口，Spring 将调用 <code>afterPropertiesSet</code> 方法，作用与在配置文件中对 Bean 使用 <code>init-method</code> 声明初始化的作用一样，都是在 Bean 的全部属性设置成功后执行的初始化方法。</p>
</li>
<li><p>如果 Bean 实现了 <code>BeanPostProcess</code> 接口，Spring 将调用 <code>postProcessAfterInitialization</code> 方法</p>
<ul>
<li><code>postProcessBeforeInitialization</code> 是在 Bean 初始化前执行的，而 <code>postProcessAfterInitialization</code> 是在 Bean 初始化后执行的</li>
</ul>
</li>
<li><p>经过以上的工作后，Bean 将一直驻留在应用上下文中给应用使用，直到应用上下文被销毁</p>
</li>
<li><p>如果 Bean 实现了 <code>DispostbleBean</code> 接口，Spring 将调用它的 <code>destory</code> 方法，作用与在配置文件中对 Bean 使用 <code>destory-method</code> 属性的作用一样，都是在 Bean 实例销毁前执行的方法。</p>
</li>
</ol>
<h4 id="什么是-spring-的内部-bean？"><a href="#什么是-spring-的内部-bean？" class="headerlink" title="什么是 spring 的内部 bean？"></a>什么是 spring 的内部 bean？</h4><p>只有将 bean 用作另一个 bean 的属性时，才能将 bean 声明为内部 bean。为了定义 bean，Spring 的基于 XML 的配置元数据在 <code>&lt;property&gt;</code> 或 <code>&lt;constructor-arg&gt;</code> 中提供了 <code>&lt;bean&gt;</code> 元素的使用。内部 bean 总是匿名的，它们总是作为原型。</p>
<p>例如，假设我们有一个 Student 类，其中引用了 Person 类。这里我们将只创建一个 Person 类实例并在 Student 中使用它。</p>
<p>Student.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line">    <span class="comment">//Setters and Getters</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="comment">//Setters and Getters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bean.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">“StudentBean</span>&quot; <span class="attr">class</span>=<span class="string">&quot;com.edureka.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;person&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--This is inner bean --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.edureka.Person&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">“Scott</span>&quot;&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">value</span>=<span class="string">“Bangalore</span>&quot;&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="什么是-spring-装配"><a href="#什么是-spring-装配" class="headerlink" title="什么是 spring 装配"></a>什么是 spring 装配</h4><p>当 bean 在 Spring 容器中组合在一起时，它被称为装配或 bean 装配。 Spring 容器需要知道需要什么 bean 以及容器应该如何使用依赖注入来将 bean 绑定在一起，同时装配 bean。</p>
<h4 id="自动装配有哪些方式？"><a href="#自动装配有哪些方式？" class="headerlink" title="自动装配有哪些方式？"></a>自动装配有哪些方式？</h4><p>Spring 容器能够自动装配 bean。也就是说，可以通过检查 BeanFactory 的内容让 Spring 自动解析 bean 的协作者。</p>
<p>自动装配的不同模式：</p>
<ul>
<li><strong>no</strong> - 这是默认设置，表示没有自动装配。应使用显式 bean 引用进行装配。</li>
<li><strong>byName</strong> - 它根据 bean 的名称注入对象依赖项。它匹配并装配其属性与 XML 文件中由相同名称定义的 bean。</li>
<li><strong>byType</strong> - 它根据类型注入对象依赖项。如果属性的类型与 XML 文件中的一个 bean 名称匹配，则匹配并装配属性。</li>
<li><strong>构造器</strong> - 它通过调用类的构造器来注入依赖项。它有大量的参数。</li>
<li><strong>autodetect</strong> - 首先容器尝试通过构造器使用 autowire 装配，如果不能，则尝试通过 byType 自动装配。</li>
</ul>
<h4 id="自动装配有什么局限？"><a href="#自动装配有什么局限？" class="headerlink" title="自动装配有什么局限？"></a>自动装配有什么局限？</h4><ul>
<li>覆盖的可能性 - 您始终可以使用 <code>&lt;constructor-arg&gt;</code> 和 <code>&lt;property&gt;</code> 设置指定依赖项，这将覆盖自动装配。</li>
<li>基本元数据类型 - 简单属性（如原数据类型，字符串和类）无法自动装配。</li>
<li>令人困惑的性质 - 总是喜欢使用明确的装配，因为自动装配不太精确。</li>
</ul>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><h4 id="什么是-AOP？"><a href="#什么是-AOP？" class="headerlink" title="什么是 AOP？"></a>什么是 AOP？</h4><p>AOP(Aspect-Oriented Programming), 即 <strong>面向切面编程</strong>, 它与 OOP( Object-Oriented Programming, 面向对象编程) 相辅相成, 提供了与 OOP 不同的抽象软件结构的视角.<br>在 OOP 中, 我们以类(class)作为我们的基本单元, 而 AOP 中的基本单元是 <strong>Aspect(切面)</strong></p>
<h4 id="AOP-中的-Aspect、Advice、Pointcut、JointPoint-和-Advice-参数分别是什么？"><a href="#AOP-中的-Aspect、Advice、Pointcut、JointPoint-和-Advice-参数分别是什么？" class="headerlink" title="AOP 中的 Aspect、Advice、Pointcut、JointPoint 和 Advice 参数分别是什么？"></a>AOP 中的 Aspect、Advice、Pointcut、JointPoint 和 Advice 参数分别是什么？</h4><p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/spring/core/spring-aop.png" alt="img"></p>
<ul>
<li><strong>Aspect</strong> - Aspect 是一个实现交叉问题的类，例如事务管理。方面可以是配置的普通类，然后在 Spring Bean 配置文件中配置，或者我们可以使用 Spring AspectJ 支持使用 @Aspect 注解将类声明为 Aspect。</li>
<li><strong>Advice</strong> - Advice 是针对特定 JoinPoint 采取的操作。在编程方面，它们是在应用程序中达到具有匹配切入点的特定 JoinPoint 时执行的方法。您可以将 Advice 视为 Spring 拦截器（Interceptor）或 Servlet 过滤器（filter）。</li>
<li><strong>Advice Arguments</strong> - 我们可以在 advice 方法中传递参数。我们可以在切入点中使用 args() 表达式来应用于与参数模式匹配的任何方法。如果我们使用它，那么我们需要在确定参数类型的 advice 方法中使用相同的名称。</li>
<li><strong>Pointcut</strong> - Pointcut 是与 JoinPoint 匹配的正则表达式，用于确定是否需要执行 Advice。 Pointcut 使用与 JoinPoint 匹配的不同类型的表达式。Spring 框架使用 AspectJ Pointcut 表达式语言来确定将应用通知方法的 JoinPoint。</li>
<li><strong>JoinPoint</strong> - JoinPoint 是应用程序中的特定点，例如方法执行，异常处理，更改对象变量值等。在 Spring AOP 中，JoinPoint 始终是方法的执行器。</li>
</ul>
<h4 id="什么是通知（Advice）？"><a href="#什么是通知（Advice）？" class="headerlink" title="什么是通知（Advice）？"></a>什么是通知（Advice）？</h4><p>特定 JoinPoint 处的 Aspect 所采取的动作称为 Advice。Spring AOP 使用一个 Advice 作为拦截器，在 JoinPoint “周围”维护一系列的拦截器。</p>
<h4 id="有哪些类型的通知（Advice）？"><a href="#有哪些类型的通知（Advice）？" class="headerlink" title="有哪些类型的通知（Advice）？"></a>有哪些类型的通知（Advice）？</h4><ul>
<li><strong>Before</strong> - 这些类型的 Advice 在 joinpoint 方法之前执行，并使用 @Before 注解标记进行配置。</li>
<li><strong>After Returning</strong> - 这些类型的 Advice 在连接点方法正常执行后执行，并使用@AfterReturning 注解标记进行配置。</li>
<li><strong>After Throwing</strong> - 这些类型的 Advice 仅在 joinpoint 方法通过抛出异常退出并使用 @AfterThrowing 注解标记配置时执行。</li>
<li><strong>After (finally)</strong> - 这些类型的 Advice 在连接点方法之后执行，无论方法退出是正常还是异常返回，并使用 @After 注解标记进行配置。</li>
<li><strong>Around</strong> - 这些类型的 Advice 在连接点之前和之后执行，并使用 @Around 注解标记进行配置。</li>
</ul>
<h4 id="指出在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处。"><a href="#指出在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处。" class="headerlink" title="指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处。"></a>指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处。</h4><p>concern 是我们想要在应用程序的特定模块中定义的行为。它可以定义为我们想要实现的功能。</p>
<p>cross-cutting concern 是一个适用于整个应用的行为，这会影响整个应用程序。例如，日志记录，安全性和数据传输是应用程序几乎每个模块都需要关注的问题，因此它们是跨领域的问题。</p>
<h4 id="AOP-有哪些实现方式？"><a href="#AOP-有哪些实现方式？" class="headerlink" title="AOP 有哪些实现方式？"></a>AOP 有哪些实现方式？</h4><p>实现 AOP 的技术，主要分为两大类：</p>
<ul>
<li>静态代理 - 指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强；<ul>
<li>编译时编织（特殊编译器实现）</li>
<li>类加载时编织（特殊的类加载器实现）。</li>
</ul>
</li>
<li>动态代理 - 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。<ul>
<li>JDK 动态代理</li>
<li>CGLIB</li>
</ul>
</li>
</ul>
<h4 id="Spring-AOP-and-AspectJ-AOP-有什么区别？"><a href="#Spring-AOP-and-AspectJ-AOP-有什么区别？" class="headerlink" title="Spring AOP and AspectJ AOP 有什么区别？"></a>Spring AOP and AspectJ AOP 有什么区别？</h4><p>Spring AOP 基于动态代理方式实现；AspectJ 基于静态代理方式实现。<br>Spring AOP 仅支持方法级别的 PointCut；提供了完全的 AOP 支持，它还支持属性级别的 PointCut。</p>
<h4 id="如何理解-Spring-中的代理？"><a href="#如何理解-Spring-中的代理？" class="headerlink" title="如何理解 Spring 中的代理？"></a>如何理解 Spring 中的代理？</h4><p>将 Advice 应用于目标对象后创建的对象称为代理。在客户端对象的情况下，目标对象和代理对象是相同的。</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Advice + Target <span class="built_in">Object</span> = <span class="built_in">Proxy</span></span><br></pre></td></tr></table></figure>

<h4 id="什么是编织（Weaving）？"><a href="#什么是编织（Weaving）？" class="headerlink" title="什么是编织（Weaving）？"></a>什么是编织（Weaving）？</h4><p>为了创建一个 advice 对象而链接一个 aspect 和其它应用类型或对象，称为编织（Weaving）。在 Spring AOP 中，编织在运行时执行。请参考下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3101171-cfaa92f0e4115b4a.png" alt="img"></p>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="你用过哪些重要的-Spring-注解？"><a href="#你用过哪些重要的-Spring-注解？" class="headerlink" title="你用过哪些重要的 Spring 注解？"></a>你用过哪些重要的 Spring 注解？</h3><ul>
<li><strong>@Controller</strong> - 用于 Spring MVC 项目中的控制器类。</li>
<li><strong>@Service</strong> - 用于服务类。</li>
<li><strong>@RequestMapping</strong> - 用于在控制器处理程序方法中配置 URI 映射。</li>
<li><strong>@ResponseBody</strong> - 用于发送 Object 作为响应，通常用于发送 XML 或 JSON 数据作为响应。</li>
<li><strong>@PathVariable</strong> - 用于将动态值从 URI 映射到处理程序方法参数。</li>
<li><strong>@Autowired</strong> - 用于在 spring bean 中自动装配依赖项。</li>
<li><strong>@Qualifier</strong> - 使用 @Autowired 注解，以避免在存在多个 bean 类型实例时出现混淆。</li>
<li><strong>@Scope</strong> - 用于配置 spring bean 的范围。</li>
<li><strong>@Configuration</strong>，**@ComponentScan** 和 <strong>@Bean</strong> - 用于基于 java 的配置。</li>
<li><strong>@Aspect</strong>，**@Before<strong>，</strong>@After<strong>，</strong>@Around<strong>，</strong>@Pointcut** - 用于切面编程（AOP）。</li>
</ul>
<h3 id="如何在-spring-中启动注解装配？"><a href="#如何在-spring-中启动注解装配？" class="headerlink" title="如何在 spring 中启动注解装配？"></a>如何在 spring 中启动注解装配？</h3><p>默认情况下，Spring 容器中未打开注解装配。因此，要使用基于注解装配，我们必须通过配置<code>&lt;context：annotation-config /&gt;</code> 元素在 Spring 配置文件中启用它。</p>
<h3 id="Component-Controller-Repository-Service-有何区别？"><a href="#Component-Controller-Repository-Service-有何区别？" class="headerlink" title="@Component, @Controller, @Repository, @Service 有何区别？"></a>@Component, @Controller, @Repository, @Service 有何区别？</h3><ul>
<li>@Component：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。</li>
<li>@Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。</li>
<li>@Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。</li>
<li>@Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</li>
</ul>
<h3 id="Required-注解有什么用？"><a href="#Required-注解有什么用？" class="headerlink" title="@Required 注解有什么用？"></a>@Required 注解有什么用？</h3><p>@Required 应用于 bean 属性 setter 方法。此注解仅指示必须在配置时使用 bean 定义中的显式属性值或使用自动装配填充受影响的 bean 属性。如果尚未填充受影响的 bean 属性，则容器将抛出 BeanInitializationException。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Required</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> string <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Autowired-注解有什么用？"><a href="#Autowired-注解有什么用？" class="headerlink" title="@Autowired 注解有什么用？"></a>@Autowired 注解有什么用？</h3><p>@Autowired 可以更准确地控制应该在何处以及如何进行自动装配。此注解用于在 setter 方法，构造器，具有任意名称或多个参数的属性或方法上自动装配 bean。默认情况下，它是类型驱动的注入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> string <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Qualifier-注解有什么用？"><a href="#Qualifier-注解有什么用？" class="headerlink" title="@Qualifier 注解有什么用？"></a>@Qualifier 注解有什么用？</h3><p>当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。</p>
<p>例如，这里我们分别有两个类，Employee 和 EmpAccount。在 EmpAccount 中，使用@Qualifier 指定了必须装配 id 为 emp1 的 bean。</p>
<p>Employee.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> string <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EmpAccount.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmpAccount</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Employee emp;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(emp1)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showName</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(“Employee name : ”+emp.getName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RequestMapping-注解有什么用？"><a href="#RequestMapping-注解有什么用？" class="headerlink" title="@RequestMapping 注解有什么用？"></a>@RequestMapping 注解有什么用？</h3><p>@RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类&#x2F;方法。此注解可应用于两个级别：</p>
<ul>
<li>类级别：映射请求的 URL</li>
<li>方法级别：映射 URL 以及 HTTP 请求方法</li>
</ul>
<h2 id="数据篇"><a href="#数据篇" class="headerlink" title="数据篇"></a>数据篇</h2><h3 id="spring-DAO-有什么用？"><a href="#spring-DAO-有什么用？" class="headerlink" title="spring DAO 有什么用？"></a>spring DAO 有什么用？</h3><p>Spring DAO 使得 JDBC，Hibernate 或 JDO 这样的数据访问技术更容易以一种统一的方式工作。这使得用户容易在持久性技术之间切换。它还允许您在编写代码时，无需考虑捕获每种技术不同的异常。</p>
<h3 id="列举-Spring-DAO-抛出的异常。"><a href="#列举-Spring-DAO-抛出的异常。" class="headerlink" title="列举 Spring DAO 抛出的异常。"></a>列举 Spring DAO 抛出的异常。</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/spring/data-access/spring-data-access-exception.png" alt="img"></p>
<h3 id="spring-JDBC-API-中存在哪些类？"><a href="#spring-JDBC-API-中存在哪些类？" class="headerlink" title="spring JDBC API 中存在哪些类？"></a>spring JDBC API 中存在哪些类？</h3><ul>
<li>JdbcTemplate</li>
<li>SimpleJdbcTemplate</li>
<li>NamedParameterJdbcTemplate</li>
<li>SimpleJdbcInsert</li>
<li>SimpleJdbcCall</li>
</ul>
<h3 id="使用-Spring-访问-Hibernate-的方法有哪些？"><a href="#使用-Spring-访问-Hibernate-的方法有哪些？" class="headerlink" title="使用 Spring 访问 Hibernate 的方法有哪些？"></a>使用 Spring 访问 Hibernate 的方法有哪些？</h3><p>我们可以通过两种方式使用 Spring 访问 Hibernate：</p>
<ol>
<li>使用 Hibernate 模板和回调进行控制反转</li>
<li>扩展 HibernateDAOSupport 并应用 AOP 拦截器节点</li>
</ol>
<h3 id="列举-spring-支持的事务管理类型"><a href="#列举-spring-支持的事务管理类型" class="headerlink" title="列举 spring 支持的事务管理类型"></a>列举 spring 支持的事务管理类型</h3><p>Spring 支持两种类型的事务管理：</p>
<ol>
<li>程序化事务管理：在此过程中，在编程的帮助下管理事务。它为您提供极大的灵活性，但维护起来非常困难。</li>
<li>声明式事务管理：在此，事务管理与业务代码分离。仅使用注解或基于 XML 的配置来管理事务。</li>
</ol>
<h3 id="spring-支持哪些-ORM-框架"><a href="#spring-支持哪些-ORM-框架" class="headerlink" title="spring 支持哪些 ORM 框架"></a>spring 支持哪些 ORM 框架</h3><ul>
<li>Hibernate</li>
<li>iBatis</li>
<li>JPA</li>
<li>JDO</li>
<li>OJB</li>
</ul>
<h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><h3 id="Spring-MVC-框架有什么用？"><a href="#Spring-MVC-框架有什么用？" class="headerlink" title="Spring MVC 框架有什么用？"></a>Spring MVC 框架有什么用？</h3><p>Spring Web MVC 框架提供 <strong>模型-视图-控制器</strong> 架构和随时可用的组件，用于开发灵活且松散耦合的 Web 应用程序。 MVC 模式有助于分离应用程序的不同方面，如输入逻辑，业务逻辑和 UI 逻辑，同时在所有这些元素之间提供松散耦合。</p>
<h3 id="描述一下-DispatcherServlet-的工作流程"><a href="#描述一下-DispatcherServlet-的工作流程" class="headerlink" title="描述一下 DispatcherServlet 的工作流程"></a>描述一下 DispatcherServlet 的工作流程</h3><p>DispatcherServlet 的工作流程可以用一幅图来说明：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/spring/web/spring-dispatcher-servlet.png" alt="img"></p>
<ol>
<li>向服务器发送 HTTP 请求，请求被前端控制器 <code>DispatcherServlet</code> 捕获。</li>
<li><code>DispatcherServlet</code> 根据 <strong><code>&lt;servlet-name&gt;-servlet.xml</code></strong> 中的配置对请求的 URL 进行解析，得到请求资源标识符（URI）。然后根据该 URI，调用 <code>HandlerMapping</code> 获得该 Handler 配置的所有相关的对象（包括 Handler 对象以及 Handler 对象对应的拦截器），最后以<code>HandlerExecutionChain</code> 对象的形式返回。</li>
<li><code>DispatcherServlet</code> 根据获得的<code>Handler</code>，选择一个合适的 <code>HandlerAdapter</code>。（附注：如果成功获得<code>HandlerAdapter</code>后，此时将开始执行拦截器的 preHandler(…)方法）。</li>
<li>提取<code>Request</code>中的模型数据，填充<code>Handler</code>入参，开始执行<code>Handler</code>（<code>Controller</code>)。 在填充<code>Handler</code>的入参过程中，根据你的配置，Spring 将帮你做一些额外的工作：<ul>
<li>HttpMessageConveter： 将请求消息（如 Json、xml 等数据）转换成一个对象，将对象转换为指定的响应信息。</li>
<li>数据转换：对请求消息进行数据转换。如<code>String</code>转换成<code>Integer</code>、<code>Double</code>等。</li>
<li>数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等。</li>
<li>数据验证： 验证数据的有效性（长度、格式等），验证结果存储到<code>BindingResult</code>或<code>Error</code>中。</li>
</ul>
</li>
<li>Handler(Controller)执行完成后，向 <code>DispatcherServlet</code> 返回一个 <code>ModelAndView</code> 对象；</li>
<li>根据返回的<code>ModelAndView</code>，选择一个适合的 <code>ViewResolver</code>（必须是已经注册到 Spring 容器中的<code>ViewResolver</code>)返回给<code>DispatcherServlet</code>。</li>
<li><code>ViewResolver</code> 结合<code>Model</code>和<code>View</code>，来渲染视图。</li>
<li>视图负责将渲染结果返回给客户端。</li>
</ol>
<h3 id="介绍一下-WebApplicationContext"><a href="#介绍一下-WebApplicationContext" class="headerlink" title="介绍一下 WebApplicationContext"></a>介绍一下 WebApplicationContext</h3><p>WebApplicationContext 是 ApplicationContext 的扩展。它具有 Web 应用程序所需的一些额外功能。它与普通的 ApplicationContext 在解析主题和决定与哪个 servlet 关联的能力方面有所不同。</p>
<p>（完）</p>
<hr>
<p>:point_right: 想学习更多 Spring 内容可以访问我的 Spring 教程：**<a target="_blank" rel="noopener" href="https://github.com/dunwu/spring-notes">spring-notes</a>**</p>
<h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.edureka.co/blog/interview-questions/spring-interview-questions/">Top 50 Spring Interview Questions You Must Prepare In 2018</a></li>
<li><a target="_blank" rel="noopener" href="https://www.journaldev.com/2696/spring-interview-questions-and-answers">Spring Interview Questions and Answers</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/f9209d/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/f9209d/" class="post-title-link" itemprop="url">分布式面试总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-07-10 16:02:00" itemprop="dateCreated datePublished" datetime="2018-07-10T16:02:00+08:00">2018-07-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:53" itemprop="dateModified" datetime="2024-12-12T10:02:53+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%BC%E5%90%88/" itemprop="url" rel="index"><span itemprop="name">分布式综合</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>11 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="分布式面试总结"><a href="#分布式面试总结" class="headerlink" title="分布式面试总结"></a>分布式面试总结</h1><h2 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h2><h3 id="Redis-有什么数据类型？分别用于什么场景"><a href="#Redis-有什么数据类型？分别用于什么场景" class="headerlink" title="Redis 有什么数据类型？分别用于什么场景"></a>Redis 有什么数据类型？分别用于什么场景</h3><table>
<thead>
<tr>
<th>数据类型</th>
<th>可以存储的值</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>STRING</td>
<td>字符串、整数或者浮点数</td>
<td>对整个字符串或者字符串的其中一部分执行操作<br> 对整数和浮点数执行自增或者自减操作</td>
</tr>
<tr>
<td>LIST</td>
<td>列表</td>
<td>从两端压入或者弹出元素<br> 读取单个或者多个元素<br> 进行修剪，只保留一个范围内的元素</td>
</tr>
<tr>
<td>SET</td>
<td>无序集合</td>
<td>添加、获取、移除单个元素<br> 检查一个元素是否存在于集合中<br> 计算交集、并集、差集<br> 从集合里面随机获取元素</td>
</tr>
<tr>
<td>HASH</td>
<td>包含键值对的无序散列表</td>
<td>添加、获取、移除单个键值对<br> 获取所有键值对<br> 检查某个键是否存在</td>
</tr>
<tr>
<td>ZSET</td>
<td>有序集合</td>
<td>添加、获取、删除元素<br> 根据分值范围或者成员来获取元素<br> 计算一个键的排名</td>
</tr>
</tbody></table>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://redislabs.com/ebook/part-1-getting-started/chapter-1-getting-to-know-redis/1-2-what-redis-data-structures-look-like/">What Redis data structures look like</a></p>
</blockquote>
<h3 id="Redis-的主从复制是如何实现的"><a href="#Redis-的主从复制是如何实现的" class="headerlink" title="Redis 的主从复制是如何实现的"></a>Redis 的主从复制是如何实现的</h3><ol>
<li>从服务器连接主服务器，发送 SYNC 命令；</li>
<li>主服务器接收到 SYNC 命名后，开始执行 BGSAVE 命令生成 RDB 文件并使用缓冲区记录此后执行的所有写命令；</li>
<li>主服务器 BGSAVE 执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令；</li>
<li>从服务器收到快照文件后丢弃所有旧数据，载入收到的快照；</li>
<li>主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令；</li>
<li>从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；</li>
</ol>
<h3 id="Redis-的-key-是如何寻址的"><a href="#Redis-的-key-是如何寻址的" class="headerlink" title="Redis 的 key 是如何寻址的"></a>Redis 的 key 是如何寻址的</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>（1）redis 中的每一个数据库，都由一个 redisDb 的结构存储。其中：</p>
<ul>
<li>redisDb.id 存储着 redis 数据库以整数表示的号码。</li>
<li>redisDb.dict 存储着该库所有的键值对数据。</li>
<li>redisDb.expires 保存着每一个键的过期时间。</li>
</ul>
<p>（2）当 redis 服务器初始化时，会预先分配 16 个数据库（该数量可以通过配置文件配置），所有数据库保存到结构 redisServer 的一个成员 redisServer.db 数组中。当我们选择数据库 select number 时，程序直接通过 redisServer.db[number] 来切换数据库。有时候当程序需要知道自己是在哪个数据库时，直接读取 redisDb.id 即可。</p>
<p>（3）redis 的字典使用哈希表作为其底层实现。dict 类型使用的两个指向哈希表的指针，其中 0 号哈希表（ht[0]）主要用于存储数据库的所有键值，而 1 号哈希表主要用于程序对 0 号哈希表进行 rehash 时使用，rehash 一般是在添加新值时会触发，这里不做过多的赘述。所以 redis 中查找一个 key，其实就是对进行该 dict 结构中的 ht[0] 进行查找操作。</p>
<p>（4）既然是哈希，那么我们知道就会有哈希碰撞，那么当多个键哈希之后为同一个值怎么办呢？redis 采取链表的方式来存储多个哈希碰撞的键。也就是说，当根据 key 的哈希值找到该列表后，如果列表的长度大于 1，那么我们需要遍历该链表来找到我们所查找的 key。当然，一般情况下链表长度都为是 1，所以时间复杂度可看作 o(1)。</p>
<h4 id="寻址-key-的步骤"><a href="#寻址-key-的步骤" class="headerlink" title="寻址 key 的步骤"></a>寻址 key 的步骤</h4><ol>
<li>当拿到一个 key 后，redis 先判断当前库的 0 号哈希表是否为空，即：if (dict-&gt;ht[0].size &#x3D;&#x3D; 0)。如果为 true 直接返回 NULL。</li>
<li>判断该 0 号哈希表是否需要 rehash，因为如果在进行 rehash，那么两个表中者有可能存储该 key。如果正在进行 rehash，将调用一次<code>_dictRehashStep</code> 方法，<code>_dictRehashStep</code> 用于对数据库字典、以及哈希键的字典进行被动 rehash，这里不作赘述。</li>
<li>计算哈希表，根据当前字典与 key 进行哈希值的计算。</li>
<li>根据哈希值与当前字典计算哈希表的索引值。</li>
<li>根据索引值在哈希表中取出链表，遍历该链表找到 key 的位置。一般情况，该链表长度为 1。</li>
<li>当 ht[0] 查找完了之后，再进行了次 rehash 判断，如果未在 rehashing，则直接结束，否则对 ht[1]重复 345 步骤。</li>
</ol>
<h3 id="Redis-的集群模式是如何实现的？"><a href="#Redis-的集群模式是如何实现的？" class="headerlink" title="Redis 的集群模式是如何实现的？"></a>Redis 的集群模式是如何实现的？</h3><p>Redis Cluster 是 Redis 的分布式解决方案，在 Redis 3.0 版本正式推出的。</p>
<p>Redis Cluster 去中心化，每个节点保存数据和整个集群状态，每个节点都和其他所有节点连接。</p>
<h4 id="Redis-Cluster-节点分配"><a href="#Redis-Cluster-节点分配" class="headerlink" title="Redis Cluster 节点分配"></a>Redis Cluster 节点分配</h4><p>Redis Cluster 特点：</p>
<ol>
<li>所有的 redis 节点彼此互联(PING-PONG 机制)，内部使用二进制协议优化传输速度和带宽。</li>
<li>节点的 fail 是通过集群中超过半数的节点检测失效时才生效。</li>
<li>客户端与 redis 节点直连,不需要中间 proxy 层。客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可。</li>
<li>redis-cluster 把所有的物理节点映射到[0-16383] 哈希槽 (hash slot)上（不一定是平均分配）,cluster 负责维护 node&lt;-&gt;slot&lt;-&gt;value。</li>
<li>Redis 集群预分好 16384 个桶，当需要在 Redis 集群中放置一个 key-value 时，根据 CRC16(key) mod 16384 的值，决定将一个 key 放到哪个桶中。</li>
</ol>
<h4 id="Redis-Cluster-主从模式"><a href="#Redis-Cluster-主从模式" class="headerlink" title="Redis Cluster 主从模式"></a>Redis Cluster 主从模式</h4><p>Redis Cluster 为了保证数据的高可用性，加入了主从模式。</p>
<p>一个主节点对应一个或多个从节点，主节点提供数据存取，从节点则是从主节点拉取数据备份。当这个主节点挂掉后，就会有这个从节点选取一个来充当主节点，从而保证集群不会挂掉。所以，在集群建立的时候，一定要为每个主节点都添加了从节点。</p>
<h4 id="Redis-Sentinel"><a href="#Redis-Sentinel" class="headerlink" title="Redis Sentinel"></a>Redis Sentinel</h4><p>Redis Sentinel 用于管理多个 Redis 服务器，它有三个功能：</p>
<ul>
<li><strong>监控（Monitoring）</strong> - Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。</li>
<li><strong>提醒（Notification）</strong> - 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</li>
<li><strong>自动故障迁移（Automatic failover）</strong> - 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。</li>
</ul>
<p>Redis 集群中应该有奇数个节点，所以至少有三个节点。</p>
<p>哨兵监控集群中的主服务器出现故障时，需要根据 quorum 选举出一个哨兵来执行故障转移。选举需要 majority，即大多数哨兵是运行的（2 个哨兵的 majority&#x3D;2，3 个哨兵的 majority&#x3D;2，5 个哨兵的 majority&#x3D;3，4 个哨兵的 majority&#x3D;2）。</p>
<p>假设集群仅仅部署 2 个节点</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+----+         +----+</span><br><span class="line">|<span class="string"> M1 </span>|<span class="string">---------</span>|<span class="string"> R1 </span>|</span><br><span class="line">|<span class="string"> S1 </span>|<span class="string">         </span>|<span class="string"> S2 </span>|</span><br><span class="line">+----+         +----+</span><br></pre></td></tr></table></figure>

<p>如果 M1 和 S1 所在服务器宕机，则哨兵只有 1 个，无法满足 majority 来进行选举，就不能执行故障转移。</p>
<h3 id="Redis-如何实现分布式锁？ZooKeeper-如何实现分布式锁？比较二者优劣？"><a href="#Redis-如何实现分布式锁？ZooKeeper-如何实现分布式锁？比较二者优劣？" class="headerlink" title="Redis 如何实现分布式锁？ZooKeeper 如何实现分布式锁？比较二者优劣？"></a>Redis 如何实现分布式锁？ZooKeeper 如何实现分布式锁？比较二者优劣？</h3><p>分布式锁的三种实现：</p>
<ul>
<li>基于数据库实现分布式锁；</li>
<li>基于缓存（Redis 等）实现分布式锁；</li>
<li>基于 Zookeeper 实现分布式锁；</li>
</ul>
<h4 id="数据库实现"><a href="#数据库实现" class="headerlink" title="数据库实现"></a>数据库实现</h4><h4 id="Redis-实现"><a href="#Redis-实现" class="headerlink" title="Redis 实现"></a>Redis 实现</h4><ol>
<li>获取锁的时候，使用 setnx 加锁，并使用 expire 命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的 value 值为一个随机生成的 UUID，通过此在释放锁的时候进行判断。</li>
<li>获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。</li>
<li>释放锁的时候，通过 UUID 判断是不是该锁，若是该锁，则执行 delete 进行锁释放。</li>
</ol>
<h4 id="ZooKeeper-实现"><a href="#ZooKeeper-实现" class="headerlink" title="ZooKeeper 实现"></a>ZooKeeper 实现</h4><ol>
<li>创建一个目录 mylock；</li>
<li>线程 A 想获取锁就在 mylock 目录下创建临时顺序节点；</li>
<li>获取 mylock 目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；</li>
<li>线程 B 获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；</li>
<li>线程 A 处理完，删除自己的节点，线程 B 监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。</li>
</ol>
<h4 id="实现对比"><a href="#实现对比" class="headerlink" title="实现对比"></a>实现对比</h4><p>ZooKeeper 具备高可用、可重入、阻塞锁特性，可解决失效死锁问题。<br>但 ZooKeeper 因为需要频繁的创建和删除节点，性能上不如 Redis 方式。</p>
<h3 id="Redis-的持久化方式？有什么优缺点？持久化实现原理？"><a href="#Redis-的持久化方式？有什么优缺点？持久化实现原理？" class="headerlink" title="Redis 的持久化方式？有什么优缺点？持久化实现原理？"></a>Redis 的持久化方式？有什么优缺点？持久化实现原理？</h3><h4 id="RDB-快照（snapshot）"><a href="#RDB-快照（snapshot）" class="headerlink" title="RDB 快照（snapshot）"></a>RDB 快照（snapshot）</h4><p>将存在于某一时刻的所有数据都写入到硬盘中。</p>
<h5 id="快照的原理"><a href="#快照的原理" class="headerlink" title="快照的原理"></a>快照的原理</h5><p>在默认情况下，Redis 将数据库快照保存在名字为 dump.rdb 的二进制文件中。你可以对 Redis 进行设置， 让它在“N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动保存一次数据集。你也可以通过调用 SAVE 或者 BGSAVE，手动让 Redis 进行数据集保存操作。这种持久化方式被称为快照。</p>
<p>当 Redis 需要保存 dump.rdb 文件时， 服务器执行以下操作:</p>
<ul>
<li>Redis 创建一个子进程。</li>
<li>子进程将数据集写入到一个临时快照文件中。</li>
<li>当子进程完成对新快照文件的写入时，Redis 用新快照文件替换原来的快照文件，并删除旧的快照文件。</li>
</ul>
<p>这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益。</p>
<h5 id="快照的优点"><a href="#快照的优点" class="headerlink" title="快照的优点"></a>快照的优点</h5><ul>
<li>它保存了某个时间点的数据集，非常适用于数据集的备份。</li>
<li>很方便传送到另一个远端数据中心或者亚马逊的 S3（可能加密），非常适用于灾难恢复。</li>
<li>快照在保存 RDB 文件时父进程唯一需要做的就是 fork 出一个子进程，接下来的工作全部由子进程来做，父进程不需要再做其他 IO 操作，所以快照持久化方式可以最大化 redis 的性能。</li>
<li>与 AOF 相比，在恢复大的数据集的时候，DB 方式会更快一些。</li>
</ul>
<h5 id="快照的缺点"><a href="#快照的缺点" class="headerlink" title="快照的缺点"></a>快照的缺点</h5><ul>
<li>如果你希望在 redis 意外停止工作（例如电源中断）的情况下丢失的数据最少的话，那么快照不适合你。</li>
<li>快照需要经常 fork 子进程来保存数据集到硬盘上。当数据集比较大的时候，fork 的过程是非常耗时的，可能会导致 Redis 在一些毫秒级内不能响应客户端的请求。</li>
</ul>
<h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p>AOF 持久化方式记录每次对服务器执行的写操作。当服务器重启的时候会重新执行这些命令来恢复原始的数据。</p>
<h4 id="AOF-的原理"><a href="#AOF-的原理" class="headerlink" title="AOF 的原理"></a>AOF 的原理</h4><ul>
<li>Redis 创建一个子进程。</li>
<li>子进程开始将新 AOF 文件的内容写入到临时文件。</li>
<li>对于所有新执行的写入命令，父进程一边将它们累积到一个内存缓存中，一边将这些改动追加到现有 AOF 文件的末尾，这样样即使在重写的中途发生停机，现有的 AOF 文件也还是安全的。</li>
<li>当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据追加到新 AOF 文件的末尾。</li>
<li>搞定！现在 Redis 原子地用新文件替换旧文件，之后所有命令都会直接追加到新 AOF 文件的末尾。</li>
</ul>
<h4 id="AOF-的优点"><a href="#AOF-的优点" class="headerlink" title="AOF 的优点"></a>AOF 的优点</h4><ul>
<li>使用默认的每秒 fsync 策略，Redis 的性能依然很好(fsync 是由后台线程进行处理的,主线程会尽力处理客户端请求)，一旦出现故障，使用 AOF ，你最多丢失 1 秒的数据。</li>
<li>AOF 文件是一个只进行追加的日志文件，所以不需要写入 seek，即使由于某些原因(磁盘空间已满，写的过程中宕机等等)未执行完整的写入命令，你也也可使用 redis-check-aof 工具修复这些问题。</li>
<li>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写：重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。整个重写操作是绝对安全的。</li>
<li>AOF 文件有序地保存了对数据库执行的所有写入操作，这些写入操作以 Redis 协议的格式保存。因此 AOF 文件的内容非常容易被人读懂，对文件进行分析（parse）也很轻松。</li>
</ul>
<h4 id="AOF-的缺点"><a href="#AOF-的缺点" class="headerlink" title="AOF 的缺点"></a>AOF 的缺点</h4><ul>
<li>对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。</li>
<li>根据所使用的 fsync 策略，AOF 的速度可能会慢于快照。在一般情况下，每秒 fsync 的性能依然非常高，而关闭 fsync 可以让 AOF 的速度和快照一样快，即使在高负荷之下也是如此。不过在处理巨大的写入载入时，快照可以提供更有保证的最大延迟时间（latency）。</li>
</ul>
<h3 id="Redis-过期策略有哪些？"><a href="#Redis-过期策略有哪些？" class="headerlink" title="Redis 过期策略有哪些？"></a>Redis 过期策略有哪些？</h3><ul>
<li><strong>noeviction</strong> - 当内存使用达到阈值的时候，所有引起申请内存的命令会报错。</li>
<li><strong>allkeys-lru</strong> - 在主键空间中，优先移除最近未使用的 key。</li>
<li><strong>allkeys-random</strong> - 在主键空间中，随机移除某个 key。</li>
<li><strong>volatile-lru</strong> - 在设置了过期时间的键空间中，优先移除最近未使用的 key。</li>
<li><strong>volatile-random</strong> - 在设置了过期时间的键空间中，随机移除某个 key。</li>
<li><strong>volatile-ttl</strong> - 在设置了过期时间的键空间中，具有更早过期时间的 key 优先移除。</li>
</ul>
<h3 id="Redis-和-Memcached-有什么区别？"><a href="#Redis-和-Memcached-有什么区别？" class="headerlink" title="Redis 和 Memcached 有什么区别？"></a>Redis 和 Memcached 有什么区别？</h3><p>两者都是非关系型内存键值数据库。有以下主要不同：</p>
<p><strong>数据类型</strong></p>
<ul>
<li>Memcached 仅支持字符串类型；</li>
<li>而 Redis 支持五种不同种类的数据类型，使得它可以更灵活地解决问题。</li>
</ul>
<p><strong>数据持久化</strong></p>
<ul>
<li>Memcached 不支持持久化；</li>
<li>Redis 支持两种持久化策略：RDB 快照和 AOF 日志。</li>
</ul>
<p><strong>分布式</strong></p>
<ul>
<li>Memcached 不支持分布式，只能通过在客户端使用像一致性哈希这样的分布式算法来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。</li>
<li>Redis Cluster 实现了分布式的支持。</li>
</ul>
<p><strong>内存管理机制</strong></p>
<ul>
<li>Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题，但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。</li>
<li>在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘。而 Memcached 的数据则会一直在内存中。</li>
</ul>
<h3 id="为什么单线程的-Redis-性能反而优于多线程的-Memcached？"><a href="#为什么单线程的-Redis-性能反而优于多线程的-Memcached？" class="headerlink" title="为什么单线程的 Redis 性能反而优于多线程的 Memcached？"></a>为什么单线程的 Redis 性能反而优于多线程的 Memcached？</h3><p>Redis 快速的原因：</p>
<ol>
<li>绝大部分请求是纯粹的内存操作（非常快速）</li>
<li>采用单线程,避免了不必要的上下文切换和竞争条件</li>
<li>非阻塞 IO</li>
</ol>
<p>内部实现采用 epoll，采用了 epoll+自己实现的简单的事件框架。epoll 中的读、写、关闭、连接都转化成了事件，然后利用 epoll 的多路复用特性，绝不在 io 上浪费一点时间。</p>
<h2 id="分布式消息队列（MQ）"><a href="#分布式消息队列（MQ）" class="headerlink" title="分布式消息队列（MQ）"></a>分布式消息队列（MQ）</h2><h3 id="为什么使用-MQ？"><a href="#为什么使用-MQ？" class="headerlink" title="为什么使用 MQ？"></a>为什么使用 MQ？</h3><ul>
<li>异步处理 - 相比于传统的串行、并行方式，提高了系统吞吐量。</li>
<li>应用解耦 - 系统间通过消息通信，不用关心其他系统的处理。</li>
<li>流量削锋 - 可以通过消息队列长度控制请求量；可以缓解短时间内的高并发请求。</li>
<li>日志处理 - 解决大量日志传输。</li>
<li>消息通讯 - 消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。</li>
</ul>
<h3 id="如何保证-MQ-的高可用？"><a href="#如何保证-MQ-的高可用？" class="headerlink" title="如何保证 MQ 的高可用？"></a>如何保证 MQ 的高可用？</h3><h4 id="数据复制"><a href="#数据复制" class="headerlink" title="数据复制"></a>数据复制</h4><ol>
<li>将所有 Broker 和待分配的 Partition 排序</li>
<li>将第 i 个 Partition 分配到第（i mod n）个 Broker 上</li>
<li>将第 i 个 Partition 的第 j 个 Replica 分配到第（(i + j) mode n）个 Broker 上</li>
</ol>
<h4 id="选举主服务器"><a href="#选举主服务器" class="headerlink" title="选举主服务器"></a>选举主服务器</h4><h3 id="MQ-有哪些常见问题？如何解决这些问题？"><a href="#MQ-有哪些常见问题？如何解决这些问题？" class="headerlink" title="MQ 有哪些常见问题？如何解决这些问题？"></a>MQ 有哪些常见问题？如何解决这些问题？</h3><p>MQ 的常见问题有：</p>
<ol>
<li>消息的顺序问题</li>
<li>消息的重复问题</li>
</ol>
<h4 id="消息的顺序问题"><a href="#消息的顺序问题" class="headerlink" title="消息的顺序问题"></a>消息的顺序问题</h4><p>消息有序指的是可以按照消息的发送顺序来消费。</p>
<p>假如生产者产生了 2 条消息：M1、M2，假定 M1 发送到 S1，M2 发送到 S2，如果要保证 M1 先于 M2 被消费，怎么做？</p>
<div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-23145c8b554a0f2f.jpg"/></div>
解决方案：

<p>（1）保证生产者 - MQServer - 消费者是一对一对一的关系</p>
<div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-034106d7e04c062d.jpg"/></div>
缺陷：

<ul>
<li>并行度就会成为消息系统的瓶颈（吞吐量不够）</li>
<li>更多的异常处理，比如：只要消费端出现问题，就会导致整个处理流程阻塞，我们不得不花费更多的精力来解决阻塞的问题。</li>
</ul>
<p>（2）通过合理的设计或者将问题分解来规避。</p>
<ul>
<li>不关注乱序的应用实际大量存在</li>
<li>队列无序并不意味着消息无序</li>
</ul>
<p>所以从业务层面来保证消息的顺序而不仅仅是依赖于消息系统，是一种更合理的方式。</p>
<h4 id="消息的重复问题"><a href="#消息的重复问题" class="headerlink" title="消息的重复问题"></a>消息的重复问题</h4><p>造成消息重复的根本原因是：网络不可达。</p>
<p>所以解决这个问题的办法就是绕过这个问题。那么问题就变成了：如果消费端收到两条一样的消息，应该怎样处理？</p>
<p>消费端处理消息的业务逻辑保持幂等性。只要保持幂等性，不管来多少条重复消息，最后处理的结果都一样。<br>保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现。利用一张日志表来记录已经处理成功的消息的 ID，如果新到的消息 ID 已经在日志表中，那么就不再处理这条消息。</p>
<h3 id="Kafka-ActiveMQ-RabbitMQ-RocketMQ-各有什么优缺点？"><a href="#Kafka-ActiveMQ-RabbitMQ-RocketMQ-各有什么优缺点？" class="headerlink" title="Kafka, ActiveMQ, RabbitMQ, RocketMQ 各有什么优缺点？"></a>Kafka, ActiveMQ, RabbitMQ, RocketMQ 各有什么优缺点？</h3><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-c26f4a3048c38af4.jpg"/></div>
## 分布式服务（RPC）

<h3 id="Dubbo-的实现过程？"><a href="#Dubbo-的实现过程？" class="headerlink" title="Dubbo 的实现过程？"></a>Dubbo 的实现过程？</h3><div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/distributed/rpc/dubbo/dubbo基本架构.png" width="500"/>
</div>

<p>节点角色：</p>
<table>
<thead>
<tr>
<th>节点</th>
<th>角色说明</th>
</tr>
</thead>
<tbody><tr>
<td>Provider</td>
<td>暴露服务的服务提供方</td>
</tr>
<tr>
<td>Consumer</td>
<td>调用远程服务的服务消费方</td>
</tr>
<tr>
<td>Registry</td>
<td>服务注册与发现的注册中心</td>
</tr>
<tr>
<td>Monitor</td>
<td>统计服务的调用次数和调用时间的监控中心</td>
</tr>
<tr>
<td>Container</td>
<td>服务运行容器</td>
</tr>
</tbody></table>
<p>调用关系：</p>
<ol>
<li>务容器负责启动，加载，运行服务提供者。</li>
<li>服务提供者在启动时，向注册中心注册自己提供的服务。</li>
<li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li>
<li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li>
<li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li>
<li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li>
</ol>
<h3 id="Dubbo-负载均衡策略有哪些？"><a href="#Dubbo-负载均衡策略有哪些？" class="headerlink" title="Dubbo 负载均衡策略有哪些？"></a>Dubbo 负载均衡策略有哪些？</h3><h5 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h5><ul>
<li>随机，按权重设置随机概率。</li>
<li>在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</li>
</ul>
<h5 id="RoundRobin"><a href="#RoundRobin" class="headerlink" title="RoundRobin"></a>RoundRobin</h5><ul>
<li>轮循，按公约后的权重设置轮循比率。</li>
<li>存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</li>
</ul>
<h5 id="LeastActive"><a href="#LeastActive" class="headerlink" title="LeastActive"></a>LeastActive</h5><ul>
<li>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。</li>
<li>使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</li>
</ul>
<h5 id="ConsistentHash"><a href="#ConsistentHash" class="headerlink" title="ConsistentHash"></a>ConsistentHash</h5><ul>
<li>一致性 Hash，相同参数的请求总是发到同一提供者。</li>
<li>当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</li>
<li>算法参见：<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Consistent_hashing">http://en.wikipedia.org/wiki/Consistent_hashing</a></li>
<li>缺省只对第一个参数 Hash，如果要修改，请配置 <code>&lt;dubbo:parameter key=&quot;hash.arguments&quot; value=&quot;0,1&quot; /&gt;</code></li>
<li>缺省用 160 份虚拟节点，如果要修改，请配置 <code>&lt;dubbo:parameter key=&quot;hash.nodes&quot; value=&quot;320&quot; /&gt;</code></li>
</ul>
<h3 id="Dubbo-集群容错策略-？"><a href="#Dubbo-集群容错策略-？" class="headerlink" title="Dubbo 集群容错策略 ？"></a>Dubbo 集群容错策略 ？</h3><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/distributed/rpc/dubbo/dubbo%E9%9B%86%E7%BE%A4%E5%AE%B9%E9%94%99.jpg"/></div>
- **Failover** - 失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries="2" 来设置重试次数(不含第一次)。
- **Failfast** - 快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。
- **Failsafe** - 失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。
- **Failback** - 失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。
- **Forking** - 并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks="2" 来设置最大并行数。
- **Broadcast** - 播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。

<h3 id="动态代理策略？"><a href="#动态代理策略？" class="headerlink" title="动态代理策略？"></a>动态代理策略？</h3><p>Dubbo 作为 RPC 框架，首先要完成的就是跨系统，跨网络的服务调用。消费方与提供方遵循统一的接口定义，消费方调用接口时，Dubbo 将其转换成统一格式的数据结构，通过网络传输，提供方根据规则找到接口实现，通过反射完成调用。也就是说，消费方获取的是对远程服务的一个代理(Proxy)，而提供方因为要支持不同的接口实现，需要一个包装层(Wrapper)。调用的过程大概是这样：</p>
<div align="center"><img src="https://oscimg.oschina.net/oscnet/bef19cd5a31b5ae13aff35a8cb4898faaf0.jpg"/></div>
消费方的 Proxy 和提供方的 Wrapper 得以让 Dubbo 构建出复杂、统一的体系。而这种动态代理与包装也是通过基于 SPI 的插件方式实现的，它的接口就是**ProxyFactory**。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI(&quot;javassist&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProxyFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive(&#123;Constants.PROXY_KEY&#125;)</span></span><br><span class="line">    &lt;T&gt; T <span class="title function_">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive(&#123;Constants.PROXY_KEY&#125;)</span></span><br><span class="line">    &lt;T&gt; Invoker&lt;T&gt; <span class="title function_">getInvoker</span><span class="params">(T proxy, Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ProxyFactory 有两种实现方式，一种是基于 JDK 的代理实现，一种是基于 javassist 的实现。ProxyFactory 接口上定义了@SPI(“javassist”)，默认为 javassist 的实现。</p>
<h3 id="Dubbo-支持哪些序列化协议？Hessian？Hessian-的数据结构？"><a href="#Dubbo-支持哪些序列化协议？Hessian？Hessian-的数据结构？" class="headerlink" title="Dubbo 支持哪些序列化协议？Hessian？Hessian 的数据结构？"></a>Dubbo 支持哪些序列化协议？Hessian？Hessian 的数据结构？</h3><ol>
<li>dubbo 序列化，阿里尚不成熟的 java 序列化实现。</li>
<li>hessian2 序列化：hessian 是一种跨语言的高效二进制的序列化方式，但这里实际不是原生的 hessian2 序列化，而是阿里修改过的 hessian lite，它是 dubbo RPC 默认启用的序列化方式。</li>
<li>json 序列化：目前有两种实现，一种是采用的阿里的 fastjson 库，另一种是采用 dubbo 中自已实现的简单 json 库，一般情况下，json 这种文本序列化性能不如二进制序列化。</li>
<li>java 序列化：主要是采用 JDK 自带的 java 序列化实现，性能很不理想。</li>
<li>Kryo 和 FST：Kryo 和 FST 的性能依然普遍优于 hessian 和 dubbo 序列化。</li>
</ol>
<p>Hessian 序列化与 Java 默认的序列化区别？</p>
<p>Hessian 是一个轻量级的 remoting on http 工具，采用的是 Binary RPC 协议，所以它很适合于发送二进制数据，同时又具有防火墙穿透能力。</p>
<ol>
<li>Hessian 支持跨语言串行</li>
<li>比 java 序列化具有更好的性能和易用性</li>
<li>支持的语言比较多</li>
</ol>
<h3 id="Protoco-Buffer-是什么？"><a href="#Protoco-Buffer-是什么？" class="headerlink" title="Protoco Buffer 是什么？"></a>Protoco Buffer 是什么？</h3><p>Protocol Buffer 是 Google 出品的一种轻量 &amp; 高效的结构化数据存储格式，性能比 Json、XML 真的强！太！多！</p>
<p>Protocol Buffer 的序列化 &amp; 反序列化简单 &amp; 速度快的原因是：</p>
<ol>
<li>编码 &#x2F; 解码 方式简单（只需要简单的数学运算 &#x3D; 位移等等）</li>
<li>采用 Protocol Buffer 自身的框架代码 和 编译器 共同完成</li>
</ol>
<p>Protocol Buffer 的数据压缩效果好（即序列化后的数据量体积小）的原因是：</p>
<ol>
<li>采用了独特的编码方式，如 Varint、Zigzag 编码方式等等</li>
<li>采用 T - L - V 的数据存储方式：减少了分隔符的使用 &amp; 数据存储得紧凑</li>
</ol>
<h3 id="注册中心挂了可以继续通信吗？"><a href="#注册中心挂了可以继续通信吗？" class="headerlink" title="注册中心挂了可以继续通信吗？"></a>注册中心挂了可以继续通信吗？</h3><p>可以。Dubbo 消费者在应用启动时会从注册中心拉取已注册的生产者的地址接口，并缓存在本地。每次调用时，按照本地存储的地址进行调用。</p>
<h3 id="ZooKeeper-原理是什么？ZooKeeper-有什么用？"><a href="#ZooKeeper-原理是什么？ZooKeeper-有什么用？" class="headerlink" title="ZooKeeper 原理是什么？ZooKeeper 有什么用？"></a>ZooKeeper 原理是什么？ZooKeeper 有什么用？</h3><p>ZooKeeper 是一个分布式应用协调系统，已经用到了许多分布式项目中，用来完成统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等工作。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/distributed/rpc/zookeeper/zookeeper-service.png" />
</div>

<ol>
<li>每个 Server 在内存中存储了一份数据；</li>
<li>Zookeeper 启动时，将从实例中选举一个 leader（Paxos 协议）；</li>
<li>Leader 负责处理数据更新等操作（Zab 协议）；</li>
<li>一个更新操作成功，当且仅当大多数 Server 在内存中成功修改数据。</li>
</ol>
<h3 id="Netty-有什么用？NIO-BIO-AIO-有什么用？有什么区别？"><a href="#Netty-有什么用？NIO-BIO-AIO-有什么用？有什么区别？" class="headerlink" title="Netty 有什么用？NIO&#x2F;BIO&#x2F;AIO 有什么用？有什么区别？"></a>Netty 有什么用？NIO&#x2F;BIO&#x2F;AIO 有什么用？有什么区别？</h3><p>Netty 是一个“网络通讯框架”。</p>
<p>Netty 进行事件处理的流程。<code>Channel</code>是连接的通道，是 ChannelEvent 的产生者，而<code>ChannelPipeline</code>可以理解为 ChannelHandler 的集合。</p>
<div align="center"><img src="https://camo.githubusercontent.com/5f7331d15c79fba29474c5be6e9e86db465637c3/687474703a2f2f7374617469632e6f736368696e612e6e65742f75706c6f6164732f73706163652f323031332f303932312f3137343033325f313872625f3139303539312e706e67"/></div>
> 参考：https://github.com/code4craft/netty-learning/blob/master/posts/ch1-overview.md

<p>IO 的方式通常分为几种：</p>
<ul>
<li>同步阻塞的 BIO</li>
<li>同步非阻塞的 NIO</li>
<li>异步非阻塞的 AIO</li>
</ul>
<p>在使用同步 I&#x2F;O 的网络应用中，如果要同时处理多个客户端请求，或是在客户端要同时和多个服务器进行通讯，就必须使用多线程来处理。</p>
<p>NIO 基于 Reactor，当 socket 有流可读或可写入 socket 时，操作系统会相应的通知引用程序进行处理，应用再将流读取到缓冲区或写入操作系统。也就是说，这个时候，已经不是一个连接就要对应一个处理线程了，而是有效的请求，对应一个线程，当连接没有数据时，是没有工作线程来处理的。</p>
<p>与 NIO 不同，当进行读写操作时，只须直接调用 API 的 read 或 write 方法即可。这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入 read 方法的缓冲区，并通知应用程序；对于写操作而言，当操作系统将 write 方法传递的流写入完毕时，操作系统主动通知应用程序。 即可以理解为，read&#x2F;write 方法都是异步的，完成后会主动调用回调函数。</p>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/skiof007/article/details/52873421">https://blog.csdn.net/skiof007/article/details/52873421</a></p>
</blockquote>
<h3 id="为什么要进行系统拆分？拆分不用-Dubbo-可以吗？"><a href="#为什么要进行系统拆分？拆分不用-Dubbo-可以吗？" class="headerlink" title="为什么要进行系统拆分？拆分不用 Dubbo 可以吗？"></a>为什么要进行系统拆分？拆分不用 Dubbo 可以吗？</h3><p>系统拆分从资源角度分为：应用拆分和数据库拆分。</p>
<p>从采用的先后顺序可分为：水平扩展、垂直拆分、业务拆分、水平拆分。</p>
<div align="center"><img src="http://misc.linkedkeeper.com/misc/img/blog/201804/linkedkeeper0_9c2ed2ed-6156-40f7-ad08-20af067047ca.jpg"/></div>
是否使用服务依据实际业务场景来决定。

<p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。</p>
<p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。</p>
<h3 id="Dubbo-和-Thrift-有什么区别？"><a href="#Dubbo-和-Thrift-有什么区别？" class="headerlink" title="Dubbo 和 Thrift 有什么区别？"></a>Dubbo 和 Thrift 有什么区别？</h3><ul>
<li>Thrift 是跨语言的 RPC 框架。</li>
<li>Dubbo 支持服务治理，而 Thrift 不支持。</li>
</ul>
<h2 id="分布式锁基本原理"><a href="#分布式锁基本原理" class="headerlink" title="分布式锁基本原理"></a>分布式锁基本原理</h2><blockquote>
<p>分布式锁有几种实现方式？实现的要点是什么？</p>
<p>分布式锁各方案有什么利弊？如何选择方案？为什么？</p>
<p>Redis 分布式锁如何保证可重入性？</p>
<p>详细内容请参考：<a href="../11.%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E5%90%8C/01.%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E5%90%8C%E7%BB%BC%E5%90%88/06.%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.md">分布式锁</a></p>
</blockquote>
<p>【答题思路】</p>
<p>实现方式一般有：</p>
<ul>
<li>基于数据库实现：<ul>
<li>建一张表（t_dlock），关键字段有：<code>id</code>、<code>method_name</code>、<code>time</code>。</li>
<li>向表中插入记录成功，即为获取锁成功。需要注意的是，获取锁一般是通过自旋方式，并设置尝试次数，超过最大尝试次数，才判定获取锁失败。</li>
<li>删除记录，即为释放锁。</li>
<li>因为数据库没有淘汰机制，为了避免获取锁永不释放，应用需要自身实现定期检查，删除过期记录（根据 time 判断）。</li>
</ul>
</li>
<li>基于 Redis 实现<ul>
<li>生成一个分布式 ID 作为 key，通过 <code>setnx</code> 写入</li>
<li>写入成功，即为获取锁成功。需要注意的是，获取锁一般是通过自旋方式，并设置尝试次数，超过最大尝试次数，才判定获取锁失败。</li>
<li>删除 key，即为获取锁失败。</li>
<li>Redis 自身有内存淘汰策略，所以只要设置 expire，就可以让 key 自动过期。</li>
</ul>
</li>
<li>基于 ZooKeeper 实现<ul>
<li>创建一个节点，所有节点都 Watch 此节点。</li>
<li>任意节点的任意线程只要向这个节点创建临时子节点成功，即为获取锁成功。</li>
<li>由于创建临时子节点是原子性的，不存在竞态，不需要自旋尝试，性能很好。</li>
<li>因为 ZooKeeper 只要和节点断开会话，就会自动删除临时节点。即为删除锁。所以无需过期机制。</li>
</ul>
</li>
</ul>
<p>从实现方式可以看出，三种方案的对比：</p>
<ul>
<li>Mysql 方案性能最差，并且影响 Mysql 吞吐量。而且还要程序保证容错处理。不建议采用这种方案。</li>
<li>Redis 方案需要不断自旋尝试获取锁，应用会消耗一些性能开销。而且为了保证分布式锁的可重入性，需要设置对于所有节点、所有线程都唯一的分布式 ID，生成 ID 也需要一定的 CPU 开销。</li>
<li>ZooKeeper 方案实现最简单，最稳定。是推荐的方案。但是它也有一个问题：ZooKeeper 的主从架构，所有写都由 Master 节点负责，所以 ZooKeeper 自身有一定的性能瓶颈。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/8cbae8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/8cbae8/" class="post-title-link" itemprop="url">大型系统核心技术</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-07-09 00:00:00" itemprop="dateCreated datePublished" datetime="2018-07-09T00:00:00+08:00">2018-07-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">设计</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">架构</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1/%E6%9E%B6%E6%9E%84/%E7%BB%BC%E5%90%88/" itemprop="url" rel="index"><span itemprop="name">综合</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="大型系统核心技术"><a href="#大型系统核心技术" class="headerlink" title="大型系统核心技术"></a>大型系统核心技术</h1><blockquote>
<p>大型系统的设计目标就是为了快速、高效、稳定的处理海量的数据以及高并发的请求。</p>
<p>单机服务受限于硬件，客观存在着资源瓶颈，难以应对不断增长的数据量和请求量，为了打破瓶颈，大型系统基本上都被设计为分布式系统。</p>
<p>分布式系统由于其面临的共性问题，在很多场景下的解决方案往往也存在着共性。因此，我们会发现，很多优秀的大型系统在设计方案上存在着很多的共同点。</p>
<p>本文主要讨论应对分布式系统共性问题的解决方案，这既可以加深对分布式系统运作原理的理解，也可以作为设计大型分布式系统时的借鉴。</p>
</blockquote>
<h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>Java 原生 API 虽然有并发锁，但并没有提供分布式锁的能力，所以针对分布式场景中的锁需要解决的方案。</p>
<p>分布式锁的解决方案大致有以下几种：</p>
<ul>
<li>基于数据库实现</li>
<li>基于缓存（redis，memcached 等）实现</li>
<li>基于 Zookeeper 实现</li>
</ul>
<h3 id="基于数据库实现分布式锁"><a href="#基于数据库实现分布式锁" class="headerlink" title="基于数据库实现分布式锁"></a>基于数据库实现分布式锁</h3><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `methodLock` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">  `method_name` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;锁定的方法名&#x27;</span>,</span><br><span class="line">  `<span class="keyword">desc</span>` <span class="type">varchar</span>(<span class="number">1024</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;备注信息&#x27;</span>,</span><br><span class="line">  `update_time` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;保存数据时间，自动生成&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uidx_method_name` (`method_name `) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;锁定中的方法&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h5 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h5><p>想要锁住某个方法时，执行以下 SQL：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> methodLock(method_name,<span class="keyword">desc</span>) <span class="keyword">values</span> (‘method_name’,‘<span class="keyword">desc</span>’)</span><br></pre></td></tr></table></figure>

<p>因为我们对 <code>method_name</code> 做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。</p>
<p>成功插入则获取锁。</p>
<h5 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h5><p>当方法执行完毕之后，想要释放锁的话，需要执行以下 Sql:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> methodLock <span class="keyword">where</span> method_name <span class="operator">=</span><span class="string">&#x27;method_name&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol>
<li>这把锁强依赖数据库的可用性。如果数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。</li>
<li>这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。</li>
<li>这把锁只能是非阻塞的，因为数据的 insert 操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。</li>
<li>这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。</li>
</ol>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><ol>
<li>单点问题可以用多数据库实例，同时塞 N 个表，N&#x2F;2+1 个成功就任务锁定成功</li>
<li>写一个定时任务，隔一段时间清除一次过期的数据。</li>
<li>写一个 while 循环，不断的重试插入，直到成功。</li>
<li>在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。</li>
</ol>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>优点: 直接借助数据库，容易理解。</li>
<li>缺点: 会有各种各样的问题，在解决问题的过程中会使整个方案变得越来越复杂。操作数据库需要一定的开销，性能问题需要考虑。</li>
</ul>
<h3 id="基于-Redis-实现分布式锁"><a href="#基于-Redis-实现分布式锁" class="headerlink" title="基于 Redis 实现分布式锁"></a>基于 Redis 实现分布式锁</h3><p>相比于用数据库来实现分布式锁，基于缓存实现的分布式锁的性能会更好一些。目前有很多成熟的分布式产品，包括 Redis、memcache、Tair 等。这里以 Redis 举例。</p>
<h4 id="Redis-命令"><a href="#Redis-命令" class="headerlink" title="Redis 命令"></a>Redis 命令</h4><ul>
<li>setnx - setnx key val：当且仅当 key 不存在时，set 一个 key 为 val 的字符串，返回 1；若 key 存在，则什么都不做，返回 0。</li>
<li>expire - expire key timeout：为 key 设置一个超时时间，单位为 second，超过这个时间锁会自动释放，避免死锁。</li>
<li>delete - delete key：删除 key</li>
</ul>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>单点实现步骤：</p>
<ol>
<li>获取锁的使用，使用 setnx 加锁，锁的 value 值为一个随机生成的 UUID，再使用 expire 设置一个过期值。</li>
<li>获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。</li>
<li>释放锁的时候，通过 UUID 判断是不是该锁，若是该锁，则执行 delete 进行锁释放。</li>
</ol>
<h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><ul>
<li>单点问题。如果单机 redis 挂掉了，那么程序会跟着出错。</li>
<li>如果转移使用 slave 节点，复制不是同步复制，会出现多个程序获取锁的情况</li>
</ul>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>可以考虑使用 <a target="_blank" rel="noopener" href="https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8">redisson 的解决方案</a>。</p>
<h3 id="基于-ZooKeeper-实现分布式锁"><a href="#基于-ZooKeeper-实现分布式锁" class="headerlink" title="基于 ZooKeeper 实现分布式锁"></a>基于 ZooKeeper 实现分布式锁</h3><h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><p>这也是 ZooKeeper 客户端 curator 的分布式锁实现。</p>
<ol>
<li>创建一个目录 mylock；</li>
<li>线程 A 想获取锁就在 mylock 目录下创建临时顺序节点；</li>
<li>获取 mylock 目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；</li>
<li>线程 B 获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；</li>
<li>线程 A 处理完，删除自己的节点，线程 B 监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。</li>
</ol>
<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>ZooKeeper 版本的分布式锁问题相对比较来说少。</p>
<ul>
<li>锁的占用时间限制：redis 就有占用时间限制，而 ZooKeeper 则没有，最主要的原因是 redis 目前没有办法知道已经获取锁的客户端的状态，是已经挂了呢还是正在执行耗时较长的业务逻辑。而 ZooKeeper 通过临时节点就能清晰知道，如果临时节点存在说明还在执行业务逻辑，如果临时节点不存在说明已经执行完毕释放锁或者是挂了。由此看来 redis 如果能像 ZooKeeper 一样添加一些与客户端绑定的临时键，也是一大好事。</li>
<li>是否单点故障：redis 本身有很多中玩法，如客户端一致性 hash，服务器端 sentinel 方案或者 cluster 方案，很难做到一种分布式锁方式能应对所有这些方案。而 ZooKeeper 只有一种玩法，多台机器的节点数据是一致的，没有 redis 的那么多的麻烦因素要考虑。</li>
</ul>
<p>总体上来说 ZooKeeper 实现分布式锁更加的简单，可靠性更高。但 ZooKeeper 因为需要频繁的创建和删除节点，性能上不如 Redis 方式。</p>
<h2 id="分布式-Session"><a href="#分布式-Session" class="headerlink" title="分布式 Session"></a>分布式 Session</h2><p>在分布式场景下，一个用户的 Session 如果只存储在一个服务器上，那么当负载均衡器把用户的下一个请求转发到另一个服务器上，该服务器没有用户的 Session，就可能导致用户需要重新进行登录等操作。</p>
<p>分布式 Session 的几种实现策略：</p>
<ol>
<li>粘性 session</li>
<li>应用服务器间的 session 复制共享</li>
<li>基于 cache DB 缓存的 session 共享</li>
</ol>
<h3 id="Sticky-Sessions"><a href="#Sticky-Sessions" class="headerlink" title="Sticky Sessions"></a>Sticky Sessions</h3><p>需要配置负载均衡器，使得一个用户的所有请求都路由到一个服务器节点上，这样就可以把用户的 Session 存放在该服务器节点中。</p>
<p>缺点：当服务器节点宕机时，将丢失该服务器节点上的所有 Session。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/architecture/MultiNode-StickySessions.jpg" />
</div>

<h3 id="Session-Replication"><a href="#Session-Replication" class="headerlink" title="Session Replication"></a>Session Replication</h3><p>在服务器节点之间进行 Session 同步操作，这样的话用户可以访问任何一个服务器节点。</p>
<p>缺点：占用过多内存；同步过程占用网络带宽以及服务器处理器时间。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/architecture/MultiNode-SessionReplication.jpg" />
</div>

<h3 id="Session-Server"><a href="#Session-Server" class="headerlink" title="Session Server"></a>Session Server</h3><p>使用一个单独的服务器存储 Session 数据，可以存在 MySQL 数据库上，也可以存在 Redis 或者 Memcached 这种内存型数据库。</p>
<p>缺点：需要去实现存取 Session 的代码。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/architecture/MultiNode-SpringSession.jpg" />
</div>

<h2 id="分布式存储"><a href="#分布式存储" class="headerlink" title="分布式存储"></a>分布式存储</h2><p>通常有两种解决方案：</p>
<ol>
<li>数据分布：就是把数据分块存在不同的服务器上（分库分表）。</li>
<li>数据复制：让所有的服务器都有相同的数据，提供相当的服务。</li>
</ol>
<h2 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h2><p>使用缓存的好处：</p>
<ul>
<li>提升数据读取速度</li>
<li>提升系统扩展能力，通过扩展缓存，提升系统承载能力</li>
<li>降低存储成本，Cache+DB 的方式可以承担原有需要多台 DB 才能承担的请求量，节省机器成本</li>
</ul>
<p>根据业务场景，通常缓存有以下几种使用方式</p>
<ul>
<li>懒汉式(读时触发)：写入 DB 后, 然后把相关的数据也写入 Cache</li>
<li>饥饿式(写时触发)：先查询 DB 里的数据, 然后把相关的数据写入 Cache</li>
<li>定期刷新：适合周期性的跑数据的任务，或者列表型的数据，而且不要求绝对实时性</li>
</ul>
<p>缓存分类：</p>
<ul>
<li>应用内缓存：如：EHCache</li>
<li>分布式缓存：如：Memached、Redis</li>
</ul>
<h2 id="分布式计算"><a href="#分布式计算" class="headerlink" title="分布式计算"></a>分布式计算</h2><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="轮询（Round-Robin）"><a href="#轮询（Round-Robin）" class="headerlink" title="轮询（Round Robin）"></a>轮询（Round Robin）</h4><p>轮询算法把每个请求轮流发送到每个服务器上。下图中，一共有 6 个客户端产生了 6 个请求，这 6 个请求按 (1, 2, 3, 4, 5, 6) 的顺序发送。最后，(1, 3, 5) 的请求会被发送到服务器 1，(2, 4, 6) 的请求会被发送到服务器 2。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/architecture/负载均衡算法之轮询-01.jpg" width="640"/>
</div>

<p>该算法比较适合每个服务器的性能差不多的场景，如果有性能存在差异的情况下，那么性能较差的服务器可能无法承担过大的负载（下图的 Server 2）。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/architecture/负载均衡算法之轮询-02.jpg" width="640"/>
</div>

<h4 id="加权轮询（Weighted-Round-Robbin）"><a href="#加权轮询（Weighted-Round-Robbin）" class="headerlink" title="加权轮询（Weighted Round Robbin）"></a>加权轮询（Weighted Round Robbin）</h4><p>加权轮询是在轮询的基础上，根据服务器的性能差异，为服务器赋予一定的权值。例如下图中，服务器 1 被赋予的权值为 5，服务器 2 被赋予的权值为 1，那么 (1, 2, 3, 4, 5) 请求会被发送到服务器 1，(6) 请求会被发送到服务器 2。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/architecture/负载均衡算法之加权轮询.jpg" width="640"/>
</div>

<h4 id="最少连接（least-Connections）"><a href="#最少连接（least-Connections）" class="headerlink" title="最少连接（least Connections）"></a>最少连接（least Connections）</h4><p>由于每个请求的连接时间不一样，使用轮询或者加权轮询算法的话，可能会让一台服务器当前连接数过大，而另一台服务器的连接过小，造成负载不均衡。例如下图中，(1, 3, 5) 请求会被发送到服务器 1，但是 (1, 3) 很快就断开连接，此时只有 (5) 请求连接服务器 1；(2, 4, 6) 请求被发送到服务器 2，只有 (2) 的连接断开。该系统继续运行时，服务器 2 会承担过大的负载。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/architecture/负载均衡算法之最少连接-01.jpg" width="640"/>
</div>

<p>最少连接算法就是将请求发送给当前最少连接数的服务器上。例如下图中，服务器 1 当前连接数最小，那么新到来的请求 6 就会被发送到服务器 1 上。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/architecture/负载均衡算法之最少连接-02.jpg" width="640"/>
</div>

<h4 id="加权最少连接（Weighted-Least-Connection）"><a href="#加权最少连接（Weighted-Least-Connection）" class="headerlink" title="加权最少连接（Weighted Least Connection）"></a>加权最少连接（Weighted Least Connection）</h4><p>在最少连接的基础上，根据服务器的性能为每台服务器分配权重，再根据权重计算出每台服务器能处理的连接数。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/architecture/负载均衡算法之加权最少连接.jpg" width="640"/>
</div>

<h4 id="随机算法（Random）"><a href="#随机算法（Random）" class="headerlink" title="随机算法（Random）"></a>随机算法（Random）</h4><p>把请求随机发送到服务器上。和轮询算法类似，该算法比较适合服务器性能差不多的场景。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/architecture/负载均衡算法之随机.jpg" width="640"/>
</div>

<h4 id="源地址哈希法-IP-Hash"><a href="#源地址哈希法-IP-Hash" class="headerlink" title="源地址哈希法 (IP Hash)"></a>源地址哈希法 (IP Hash)</h4><p>源地址哈希通过对客户端 IP 哈希计算得到的一个数值，用该数值对服务器数量进行取模运算，取模结果便是目标服务器的序号。</p>
<ul>
<li>优点：保证同一 IP 的客户端都会被 hash 到同一台服务器上。</li>
<li>缺点：不利于集群扩展，后台服务器数量变更都会影响 hash 结果。可以采用一致性 Hash 改进。</li>
</ul>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/architecture/负载均衡算法之IpHash.jpg" width="640"/>
</div>

<h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><h4 id="HTTP-重定向"><a href="#HTTP-重定向" class="headerlink" title="HTTP 重定向"></a>HTTP 重定向</h4><p>HTTP 重定向负载均衡服务器收到 HTTP 请求之后会返回服务器的地址，并将该地址写入 HTTP 重定向响应中返回给浏览器，浏览器收到后需要再次发送请求。</p>
<p>缺点：</p>
<ul>
<li>用户访问的延迟会增加；</li>
<li>如果负载均衡器宕机，就无法访问该站点。</li>
</ul>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/architecture/Http重定向.png" width="640"/>
</div>

<h4 id="DNS-重定向"><a href="#DNS-重定向" class="headerlink" title="DNS 重定向"></a>DNS 重定向</h4><p>使用 DNS 作为负载均衡器，根据负载情况返回不同服务器的 IP 地址。大型网站基本使用了这种方式做为第一级负载均衡手段，然后在内部使用其它方式做第二级负载均衡。</p>
<p>缺点：</p>
<ul>
<li>DNS 查找表可能会被客户端缓存起来，那么之后的所有请求都会被重定向到同一个服务器。</li>
</ul>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/architecture/Dns重定向.png" width="640"/>
</div>

<h4 id="修改-MAC-地址"><a href="#修改-MAC-地址" class="headerlink" title="修改 MAC 地址"></a>修改 MAC 地址</h4><p>使用 LVS（Linux Virtual Server）这种链路层负载均衡器，根据负载情况修改请求的 MAC 地址。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/architecture/修改Mac地址.png" width="640"/>
</div>

<h4 id="修改-IP-地址"><a href="#修改-IP-地址" class="headerlink" title="修改 IP 地址"></a>修改 IP 地址</h4><p>在网络层修改请求的目的 IP 地址。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/architecture/修改IP地址.png" width="640"/>
</div>

<h4 id="代理自动配置"><a href="#代理自动配置" class="headerlink" title="代理自动配置"></a>代理自动配置</h4><p>正向代理与反向代理的区别：</p>
<ul>
<li>正向代理：发生在客户端，是由用户主动发起的。比如翻墙，客户端通过主动访问代理服务器，让代理服务器获得需要的外网数据，然后转发回客户端。</li>
<li>反向代理：发生在服务器端，用户不知道代理的存在。</li>
</ul>
<p>PAC 服务器是用来判断一个请求是否要经过代理。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/design/architecture/代理自动配置.jpg" width="640"/>
</div>

<h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html">https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90.md">https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90.md</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/453c6e7ff81c">https://www.jianshu.com/p/453c6e7ff81c</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5a20cd8bf265da43163cdd9a">https://juejin.im/post/5a20cd8bf265da43163cdd9a</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8">https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/L316476844/distributed-session">https://github.com/L316476844/distributed-session</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/entry/57e39e320e3dd90058021bff">分布式缓存架构基础</a></li>
<li><a target="_blank" rel="noopener" href="https://www.toutiao.com/i6533812974807679495/?tt_from=weixin&utm_campaign=client_share&from=singlemessage&timestamp=1521281305&app=news_article&utm_source=weixin&iid=28128279343&utm_medium=toutiao_android&weixin_list=1&wxshare_count=2&pbid=6517746516513195523">阿里 P8 技术专家细究分布式缓存问题</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/98a1c1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/98a1c1/" class="post-title-link" itemprop="url">深入浅出负载均衡</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-07-05 15:50:00" itemprop="dateCreated datePublished" datetime="2018-07-05T15:50:00+08:00">2018-07-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:53" itemprop="dateModified" datetime="2024-12-12T10:02:53+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E8%B0%83%E5%BA%A6/" itemprop="url" rel="index"><span itemprop="name">分布式调度</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>21k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>19 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="深入浅出负载均衡"><a href="#深入浅出负载均衡" class="headerlink" title="深入浅出负载均衡"></a>深入浅出负载均衡</h1><h2 id="负载均衡简介"><a href="#负载均衡简介" class="headerlink" title="负载均衡简介"></a>负载均衡简介</h2><h3 id="大型系统面临的挑战"><a href="#大型系统面临的挑战" class="headerlink" title="大型系统面临的挑战"></a>大型系统面临的挑战</h3><p>大型系统通常要面对高并发、高可用、海量数据等挑战。</p>
<p>为了提升系统整体的性能，可以采用垂直扩展和水平扩展两种方式。</p>
<ul>
<li><strong>垂直扩展</strong>：在网站发展早期，可以从单机的角度通过<strong>提升硬件处理能力</strong>，比如 CPU 处理能力，内存容量，磁盘等方面，实现机器处理能力的提升。但是，单机是有性能瓶颈的，一旦触及瓶颈，再想提升，付出的成本和代价会极高。通俗来说，就三个字：<strong>得加钱</strong>！这显然不能满足大型分布式系统（网站）所有应对的大流量，高并发，海量数据等挑战。</li>
<li><strong>水平扩展</strong>：通过集群来分担大型网站的流量。集群中的应用机器（节点）通常被设计成无状态，用户可以请求任何一个节点，这些节点共同分担访问压力。水平扩展有两个要点：<ul>
<li><strong>集群化、分区化</strong>：将一个完整的应用化整为零，如果是无状态应用，可以直接集群化部署；如果是有状态应用，可以将状态数据分区（分片），然后部署到多台机器上。</li>
<li><strong>负载均衡</strong>：集群化、分区化后，要解决的问题是，请求应该被分发（寻址）到哪台机器上。这就需要通过某种策略来控制分发，这种技术就是负载均衡。</li>
</ul>
</li>
</ul>
<h3 id="什么是负载均衡"><a href="#什么是负载均衡" class="headerlink" title="什么是负载均衡"></a>什么是负载均衡</h3><p><strong>“负载均衡（Load Balance，简称 LB）”是一种技术，用来在多个计算机、网络连接、CPU、磁盘驱动器或其他资源中分配负载，以达到优化资源利用率、最大化吞吐率、最小化响应时间、同时避免过载的目的</strong>。</p>
<p>负载均衡的主要作用如下：</p>
<ul>
<li><strong>高并发</strong>：负载均衡可以优化资源使用率，通过算法调整负载，尽力均匀的分配资源，以此提高资源利用率、从而提升整体吞吐量。</li>
<li><strong>伸缩性</strong>：发生增减资源时，负载均衡可以自动调整分发，使得应用集群具备伸缩性。</li>
<li><strong>高可用</strong>：负载均衡器可以监控候选机器，当某机器不可用时，自动跳过，将请求分发给可用的机器。这使得应用集群具备高可用的特性。</li>
<li><strong>安全防护</strong>：有些负载均衡软件或硬件提供了安全性功能，如：黑白名单、防火墙，防 DDos 攻击等。</li>
</ul>
<h2 id="负载均衡的分类"><a href="#负载均衡的分类" class="headerlink" title="负载均衡的分类"></a>负载均衡的分类</h2><p>支持负载均衡的技术很多，我们可以通过不同维度去进行分类。</p>
<h3 id="载体维度分类"><a href="#载体维度分类" class="headerlink" title="载体维度分类"></a>载体维度分类</h3><p>从支持负载均衡的载体来看，可以将负载均衡分为两类：</p>
<ul>
<li>硬件负载均衡</li>
<li>软件负载均衡</li>
</ul>
<h4 id="硬件负载均衡"><a href="#硬件负载均衡" class="headerlink" title="硬件负载均衡"></a>硬件负载均衡</h4><p>硬件负载均衡，一般是在定制处理器上运行的独立负载均衡服务器，<strong>价格昂贵，土豪专属</strong>。</p>
<p>硬件负载均衡的<strong>主流产品</strong>有：<a target="_blank" rel="noopener" href="https://f5.com/zh">F5</a> 和 <a target="_blank" rel="noopener" href="https://www.a10networks.com.cn/">A10</a>。</p>
<p>硬件负载均衡的<strong>优点</strong>：</p>
<ul>
<li><strong>功能强大</strong>：支持全局负载均衡并提供较全面的、复杂的负载均衡算法。</li>
<li><strong>性能强悍</strong>：硬件负载均衡由于是在专用处理器上运行，因此吞吐量大，可支持单机百万以上的并发。</li>
<li><strong>安全性高</strong>：往往具备防火墙，防 DDos 攻击等安全功能。</li>
</ul>
<p>硬件负载均衡的<strong>缺点</strong>：</p>
<ul>
<li><strong>成本昂贵</strong>：购买和维护硬件负载均衡的成本都很高。</li>
<li><strong>扩展性差</strong>：当访问量突增时，超过限度不能动态扩容。</li>
</ul>
<h4 id="软件负载均衡"><a href="#软件负载均衡" class="headerlink" title="软件负载均衡"></a>软件负载均衡</h4><p>软件负载均衡，<strong>应用最广泛</strong>，无论大公司还是小公司都会使用。</p>
<p>软件负载均衡从软件层面实现负载均衡，一般可以在任何标准物理设备上运行。</p>
<p>软件负载均衡的 <strong>主流产品</strong> 有：<a target="_blank" rel="noopener" href="https://www.nginx.com/">Nginx</a>、<a target="_blank" rel="noopener" href="http://www.haproxy.org/">HAProxy</a>、<a target="_blank" rel="noopener" href="https://github.com/alibaba/LVS">LVS</a>。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/alibaba/LVS">LVS</a> 可以作为四层负载均衡器。其负载均衡的性能要优于 Nginx。</li>
<li><a target="_blank" rel="noopener" href="http://www.haproxy.org/">HAProxy</a> 可以作为 HTTP 和 TCP 负载均衡器。</li>
<li><a target="_blank" rel="noopener" href="https://www.nginx.com/">Nginx</a>、<a target="_blank" rel="noopener" href="http://www.haproxy.org/">HAProxy</a> 可以作为四层或七层负载均衡器。</li>
</ul>
<p>软件负载均衡的 <strong>优点</strong>：</p>
<ul>
<li><strong>扩展性好</strong>：适应动态变化，可以通过添加软件负载均衡实例，动态扩展到超出初始容量的能力。</li>
<li><strong>成本低廉</strong>：软件负载均衡可以在任何标准物理设备上运行，降低了购买和运维的成本。</li>
</ul>
<p>软件负载均衡的 <strong>缺点</strong>：</p>
<ul>
<li><strong>性能略差</strong>：相比于硬件负载均衡，软件负载均衡的性能要略低一些。</li>
</ul>
<h3 id="网络通信分类"><a href="#网络通信分类" class="headerlink" title="网络通信分类"></a>网络通信分类</h3><p>软件负载均衡从通信层面来看，又可以分为四层和七层负载均衡。</p>
<ul>
<li>七层负载均衡：就是可以根据访问用户的 HTTP 请求头、URL 信息将请求转发到特定的主机。<ul>
<li>DNS 重定向</li>
<li>HTTP 重定向</li>
<li>反向代理</li>
</ul>
</li>
<li>四层负载均衡：基于 IP 地址和端口进行请求的转发。<ul>
<li>修改 IP 地址</li>
<li>修改 MAC 地址</li>
</ul>
</li>
</ul>
<h4 id="DNS-负载均衡"><a href="#DNS-负载均衡" class="headerlink" title="DNS 负载均衡"></a>DNS 负载均衡</h4><p>DNS 负载均衡一般用于互联网公司，复杂的业务系统不适合使用。大型网站一般使用 DNS 负载均衡作为 <strong>第一级负载均衡手段</strong>，然后在内部使用其它方式做第二级负载均衡。DNS 负载均衡属于七层负载均衡。</p>
<p>DNS 即 <strong>域名解析服务</strong>，是 OSI 第七层网络协议。DNS 被设计为一个树形结构的分布式应用，自上而下依次为：根域名服务器，一级域名服务器，二级域名服务器，… ，本地域名服务器。显然，如果所有数据都存储在根域名服务器，那么 DNS 查询的负载和开销会非常庞大。</p>
<p>因此，DNS 查询相对于 DNS 层级结构，是一个逆向的递归流程，DNS 客户端依次请求本地 DNS 服务器，上一级 DNS 服务器，上上一级 DNS 服务器，… ，根 DNS 服务器（又叫权威 DNS 服务器），一旦命中，立即返回。为了减少查询次数，每一级 DNS 服务器都会设置 DNS 查询缓存。</p>
<p>DNS 负载均衡的工作原理就是：<strong>基于 DNS 查询缓存，按照负载情况返回不同服务器的 IP 地址</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310250643409.png"></p>
<p>DNS 重定向的 <strong>优点</strong>：</p>
<ul>
<li><strong>使用简单</strong>：负载均衡工作，交给 DNS 服务器处理，省掉了负载均衡服务器维护的麻烦</li>
<li><strong>提高性能</strong>：可以支持基于地址的域名解析，解析成距离用户最近的服务器地址（类似 CDN 的原理），可以加快访问速度，改善性能；</li>
</ul>
<p>DNS 重定向的 <strong>缺点</strong>：</p>
<ul>
<li><strong>可用性差</strong>：DNS 解析是多级解析，新增&#x2F;修改 DNS 后，解析时间较长；解析过程中，用户访问网站将失败；</li>
<li><strong>扩展性差</strong>：DNS 负载均衡的控制权在域名商那里，无法对其做更多的改善和扩展；</li>
<li><strong>维护性差</strong>：也不能反映服务器的当前运行状态；支持的算法少；不能区分服务器的差异（不能根据系统与服务的状态来判断负载）</li>
</ul>
<h4 id="HTTP-负载均衡"><a href="#HTTP-负载均衡" class="headerlink" title="HTTP 负载均衡"></a>HTTP 负载均衡</h4><p><strong>HTTP 负载均衡是基于 HTTP 重定向实现的</strong>。HTTP 负载均衡属于七层负载均衡。</p>
<p>HTTP 重定向原理是：<strong>根据用户的 HTTP 请求计算出一个真实的服务器地址，将该服务器地址写入 HTTP 重定向响应中，返回给浏览器，由浏览器重新进行访问</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310250643410.png"></p>
<p>HTTP 重定向的 <strong>优点</strong>：<strong>方案简单</strong>。</p>
<p>HTTP 重定向的 <strong>缺点</strong>：</p>
<ul>
<li><strong>额外的转发开销</strong>：每次访问需要两次请求服务器，增加了访问的延迟。</li>
<li><strong>降低搜索排名</strong>：使用重定向后，搜索引擎会视为 SEO 作弊。</li>
<li>如果负载均衡器宕机，就无法访问该站点。</li>
</ul>
<p>由于其缺点比较明显，所以这种负载均衡策略实际应用较少。</p>
<h4 id="反向代理负载均衡"><a href="#反向代理负载均衡" class="headerlink" title="反向代理负载均衡"></a>反向代理负载均衡</h4><p>反向代理（Reverse Proxy）方式是指以 <strong>代理服务器</strong> 来接受网络请求，然后 <strong>将请求转发给内网中的服务器</strong>，并将从内网中的服务器上得到的结果返回给网络请求的客户端。反向代理负载均衡属于七层负载均衡。</p>
<p>反向代理服务的主流产品：<strong>Nginx</strong>、<strong>Apache</strong>。</p>
<p>正向代理与反向代理有什么区别？</p>
<ul>
<li>正向代理：发生在 <strong>客户端</strong>，是由用户主动发起的。翻墙软件就是典型的正向代理，客户端通过主动访问代理服务器，让代理服务器获得需要的外网数据，然后转发回客户端。</li>
<li>反向代理：发生在 <strong>服务端</strong>，用户不知道代理的存在。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310250643411.png"></p>
<p>反向代理是如何实现负载均衡的呢？以 Nginx 为例，如下所示：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/web/nginx/nginx-load-balance.png" alt="img"></p>
<p>首先，在代理服务器上设定好负载均衡规则。然后，当收到客户端请求，反向代理服务器拦截指定的域名或 IP 请求，根据负载均衡算法，将请求分发到候选服务器上。其次，如果某台候选服务器宕机，反向代理服务器会有容错处理，比如分发请求失败 3 次以上，将请求分发到其他候选服务器上。</p>
<p>反向代理的 <strong>优点</strong>：</p>
<ul>
<li><strong>多种负载均衡算法</strong>：支持多种负载均衡算法，以应对不同的场景需求。</li>
<li><strong>可以监控服务器</strong>：基于 HTTP 协议，可以监控转发服务器的状态，如：系统负载、响应时间、是否可用、连接数、流量等，从而根据这些数据调整负载均衡的策略。</li>
</ul>
<p>反向代理的 <strong>缺点</strong>：</p>
<ul>
<li><p><strong>额外的转发开销</strong>：反向代理的转发操作本身是有性能开销的，可能会包括创建连接，等待连接响应，分析响应结果等操作。</p>
</li>
<li><p><strong>增加系统复杂度</strong>：反向代理常用于做分布式应用的水平扩展，但反向代理服务存在以下问题，为了解决以下问题会给系统整体增加额外的复杂度和运维成本：</p>
</li>
<li><p>反向代理服务如果自身宕机，就无法访问站点，所以需要有 <strong>高可用</strong> 方案，常见的方案有：主备模式（一主一备）、双主模式（互为主备）。</p>
<ul>
<li>反向代理服务自身也存在性能瓶颈，随着需要转发的请求量不断攀升，需要有 <strong>可扩展</strong> 方案。</li>
</ul>
</li>
</ul>
<h4 id="IP-负载均衡"><a href="#IP-负载均衡" class="headerlink" title="IP 负载均衡"></a>IP 负载均衡</h4><p>IP 负载均衡是在网络层通过修改请求目的地址进行负载均衡。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310250643413.png"></p>
<p>如上图所示，IP 均衡处理流程大致为：</p>
<ol>
<li>客户端请求 192.168.137.10，由负载均衡服务器接收到报文。</li>
<li>负载均衡服务器根据算法选出一个服务节点 192.168.0.1，然后将报文请求地址改为该节点的 IP。</li>
<li>真实服务节点收到请求报文，处理后，返回响应数据到负载均衡服务器。</li>
<li>负载均衡服务器将响应数据的源地址改负载均衡服务器地址，返回给客户端。</li>
</ol>
<p>IP 负载均衡在内核进程完成数据分发，较反向代理负载均衡有更好的处理性能。但是，由于所有请求响应都要经过负载均衡服务器，集群的吞吐量受制于负载均衡服务器的带宽。</p>
<h4 id="数据链路层负载均衡"><a href="#数据链路层负载均衡" class="headerlink" title="数据链路层负载均衡"></a>数据链路层负载均衡</h4><p>数据链路层负载均衡是指在通信协议的数据链路层修改 mac 地址进行负载均衡。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310250643412.png"></p>
<p>在 Linux 平台上最好的链路层负载均衡开源产品是 LVS (Linux Virtual Server)。</p>
<p>LVS 是基于 Linux 内核中 netfilter 框架实现的负载均衡系统。netfilter 是内核态的 Linux 防火墙机制，可以在数据包流经过程中，根据规则设置若干个关卡（hook 函数）来执行相关的操作。</p>
<p>LVS 的工作流程大致如下：</p>
<ul>
<li>当用户访问 <a target="_blank" rel="noopener" href="http://www.sina.com.cn/">www.sina.com.cn</a> 时，用户数据通过层层网络，最后通过交换机进入 LVS 服务器网卡，并进入内核网络层。</li>
<li>进入 PREROUTING 后经过路由查找，确定访问的目的 VIP 是本机 IP 地址，所以数据包进入到 INPUT 链上</li>
<li>IPVS 是工作在 INPUT 链上，会根据访问的 <code>vip+port</code> 判断请求是否 IPVS 服务，如果是则调用注册的 IPVS HOOK 函数，进行 IPVS 相关主流程，强行修改数据包的相关数据，并将数据包发往 POSTROUTING 链上。</li>
<li>POSTROUTING 上收到数据包后，根据目标 IP 地址（后端服务器），通过路由选路，将数据包最终发往后端的服务器上。</li>
</ul>
<p>开源 LVS 版本有 3 种工作模式，每种模式工作原理截然不同，说各种模式都有自己的优缺点，分别适合不同的应用场景，不过最终本质的功能都是能实现均衡的流量调度和良好的扩展性。主要包括三种模式：DR 模式、NAT 模式、Tunnel 模式。</p>
<h2 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h2><p>负载均衡器的实现可以分为两个部分：</p>
<ul>
<li>根据负载均衡算法在候选机器列表选出一个机器；</li>
<li>将请求数据发送到该机器上。</li>
</ul>
<p>负载均衡算法是负载均衡服务核心中的核心。负载均衡产品多种多样，但是各种负载均衡算法原理是共性的。</p>
<p>负载均衡算法有很多种，分别适用于不同的应用场景。本章节将由浅入深的，逐一讲解各种负载均衡算法的策略和特性，并根据算法之间的互补关系将它们串联起来。</p>
<blockquote>
<p>注：负载均衡算法的实现，推荐阅读 <a target="_blank" rel="noopener" href="https://dubbo.apache.org/zh/docs/v2.7/dev/source/loadbalance/">Dubbo 官方负载均衡算法说明</a> ，源码讲解非常详细，非常值得借鉴。</p>
<p>下文中的各种算法的可执行示例已归档在 Github 仓库：<a target="_blank" rel="noopener" href="https://github.com/dunwu/java-tutorial/tree/master/codes/java-distributed/java-load-balance%EF%BC%8C%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E6%89%A7%E8%A1%8C">https://github.com/dunwu/java-tutorial/tree/master/codes/java-distributed/java-load-balance，可以通过执行</a> <code>io.github.dunwu.javatech.LoadBalanceDemo</code> 查看各算法执行效果。</p>
</blockquote>
<h3 id="轮询算法"><a href="#轮询算法" class="headerlink" title="轮询算法"></a>轮询算法</h3><p><strong>“轮询算法（Round Robin）”的策略是：将请求“依次”分发到候选机器</strong>。</p>
<p>如下图所示，轮询负载均衡器收到来自客户端的 6 个请求，编号为 1、4 的请求会被发送到服务端 0；编号为 2、5 的请求会被发送到服务端 1；编号为 3、6 的请求会被发送到服务端 2。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310250648178.png"></p>
<p><strong>轮询算法适合的场景需要满足：各机器处理能力相近，且每个请求工作量差异不大</strong>。</p>
<p>【示例】轮询负载均衡算法实现示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoundRobinLoadBalance</span>&lt;N <span class="keyword">extends</span> <span class="title class_">Node</span>&gt; <span class="keyword">extends</span> <span class="title class_">BaseLoadBalance</span>&lt;N&gt; <span class="keyword">implements</span> <span class="title class_">LoadBalance</span>&lt;N&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">position</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> N <span class="title function_">doSelect</span><span class="params">(List&lt;N&gt; nodes, String ip)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nodes.size();</span><br><span class="line">        <span class="comment">// 如果位置值已经等于节点数，重置为 0</span></span><br><span class="line">        position.compareAndSet(length, <span class="number">0</span>);</span><br><span class="line">        <span class="type">N</span> <span class="variable">node</span> <span class="operator">=</span> nodes.get(position.get());</span><br><span class="line">        position.getAndIncrement();</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="随机算法"><a href="#随机算法" class="headerlink" title="随机算法"></a>随机算法</h3><p><strong>“随机算法（Random）” 将请求“随机”分发到候选机器</strong>。</p>
<p>如下图所示，随机负载均衡器收到来自客户端的 6 个请求，会随机分发请求，可能会出现：编号为 1、5 的请求会被发送到服务端 0；编号为 2、4 的请求会被发送到服务端 1；编号为 3、6 的请求会被发送到服务端 2。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310250648899.png"></p>
<p><strong>随机算法适合的场景需要满足：各机器处理能力相近，且每个请求工作量差异不大</strong>。</p>
<p>学习过概率论的都知道，调用量较小的时候，可能负载并不均匀，<strong>调用量越大，负载越均衡</strong>。</p>
<p>【示例】随机负载均衡算法实现示例</p>
<p>负载均衡接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LoadBalance</span>&lt;N <span class="keyword">extends</span> <span class="title class_">Node</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">    N <span class="title function_">select</span><span class="params">(List&lt;N&gt; nodes, String ip)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>负载均衡抽象类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseLoadBalance</span>&lt;N <span class="keyword">extends</span> <span class="title class_">Node</span>&gt; <span class="keyword">implements</span> <span class="title class_">LoadBalance</span>&lt;N&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> N <span class="title function_">select</span><span class="params">(List&lt;N&gt; nodes, String ip)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtil.isEmpty(nodes)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 nodes 列表中仅有一个 node，直接返回即可，无需进行负载均衡</span></span><br><span class="line">        <span class="keyword">if</span> (nodes.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> doSelect(nodes, ip);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> N <span class="title function_">doSelect</span><span class="params">(List&lt;N&gt; nodes, String ip)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>机器节点类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Node&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String url;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Integer weight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Integer active;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随机算法实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomLoadBalance</span>&lt;N <span class="keyword">extends</span> <span class="title class_">Node</span>&gt; <span class="keyword">extends</span> <span class="title class_">BaseLoadBalance</span>&lt;N&gt; <span class="keyword">implements</span> <span class="title class_">LoadBalance</span>&lt;N&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> N <span class="title function_">doSelect</span><span class="params">(List&lt;N&gt; nodes, String ip)</span> &#123;</span><br><span class="line">        <span class="comment">// 在列表中随机选取一个节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> random.nextInt(nodes.size());</span><br><span class="line">        <span class="keyword">return</span> nodes.get(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="加权轮询-随机算法"><a href="#加权轮询-随机算法" class="headerlink" title="加权轮询&#x2F;随机算法"></a>加权轮询&#x2F;随机算法</h3><p>轮询&#x2F;随机算法适合的场景都需要满足：各机器处理能力相近，且每个请求工作量差异不大。</p>
<p>在理想状况下，假设每个机器的硬件条件相同，如：CPU、内存、网络 IO 等配置都相同；并且每个请求的耗时一样（请求传输时间、请求访问数据时间、计算时间等），这时轮询算法才能真正做到负载均衡。显然，要满足以上条件都相同是几乎不可能的，更不要说实际的网络通信中还有更多复杂的情况。</p>
<p>以上，如果有一点不能满足，都无法做到真正的负载均衡。个体存在较大差异，当请求量较大时，处理较慢的机器可能会逐渐积压请求，从而导致过载甚至宕机。</p>
<p>如下图所示，假设存在这样的场景：</p>
<ul>
<li>服务端 1 的处理能力远低于服务端 0 和服务端 2；</li>
<li>轮询&#x2F;随机算法可以保证将请求尽量均匀的分发给两个机器；</li>
<li>编号为 1、4 的请求被发送到服务端 0；编号为 3、6 的请求被发送到服务端 2；二者处理能力强，应对游刃有余；</li>
<li>编号为 2、5 的请求被发送到服务端 1，服务端 1 处理能力弱，应对捉襟见肘，导致过载。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310250649920.png"></p>
<p>《蜘蛛侠》电影中有一句经典台词：<strong>能力越大，责任越大</strong>。显然，以上情况不符合这句话，处理能力强的机器并没有被分发到更多的请求，它的处理能力被闲置了。那么，如何解决这个问题呢？</p>
<p>一种比较容易想到的思路是：引入权重属性，可以根据机器的硬件条件为其设置合理的权重值，负载均衡时，优先将请求分发到权重较高的机器。</p>
<p>“加权轮询算法（Weighted Round Robbin）” 和“加权随机算法（Weighted Random）” 都采用了加权的思路，在轮询&#x2F;随机算法的基础上，引入了权重属性，优先将请求分发到权重较高的机器。这样，就可以针对性能高、处理速度快的机器设置较高的权重，让其处理更多的请求；而针对性能低、处理速度慢的机器则与之相反。一言以蔽之，加权策略强调了——能力越大，责任越大。</p>
<p>如下图所示，服务端 0 设置权重为 3，服务端 1 设置权重为 1，服务端 2 设置权重为 2。负载均衡器收到来自客户端的 6 个请求，那么编号为 1、2、5 的请求会被发送到服务端 0，编号为 4 的请求会被发送到服务端 1，编号为 3、6 的请求会被发送到机器 2。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310250649943.png"></p>
<p>【示例】加权随机负载均衡算法实现示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeightRandomLoadBalance</span>&lt;N <span class="keyword">extends</span> <span class="title class_">Node</span>&gt; <span class="keyword">extends</span> <span class="title class_">BaseLoadBalance</span>&lt;N&gt; <span class="keyword">implements</span> <span class="title class_">LoadBalance</span>&lt;N&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> ThreadLocalRandom.current();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> N <span class="title function_">doSelect</span><span class="params">(List&lt;N&gt; nodes, String ip)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nodes.size();</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">totalWeight</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (N node : nodes) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">weight</span> <span class="operator">=</span> node.getWeight();</span><br><span class="line">            totalWeight.getAndAdd(weight);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (totalWeight.get() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> random.nextInt(totalWeight.get());</span><br><span class="line">            <span class="keyword">for</span> (N node : nodes) &#123;</span><br><span class="line">                <span class="comment">// 让随机值 offset 减去权重值</span></span><br><span class="line">                offset -= node.getWeight();</span><br><span class="line">                <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 返回相应的 Node</span></span><br><span class="line">                    <span class="keyword">return</span> node;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 直接随机返回一个</span></span><br><span class="line">        <span class="keyword">return</span> nodes.get(random.nextInt(length));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【示例】加权轮询负载均衡算法实现示例</p>
<p>以下实现基于 Dubbo 加权轮询算法做了一些简化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeightRoundRobinLoadBalance</span>&lt;N <span class="keyword">extends</span> <span class="title class_">Node</span>&gt; <span class="keyword">extends</span> <span class="title class_">BaseLoadBalance</span>&lt;N&gt; <span class="keyword">implements</span> <span class="title class_">LoadBalance</span>&lt;N&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 60秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RECYCLE_PERIOD</span> <span class="operator">=</span> <span class="number">60000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Node hashcode 到 WeightedRoundRobin 的映射关系</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ConcurrentMap&lt;Integer, WeightedRoundRobin&gt; weightMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 原子更新锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicBoolean</span> <span class="variable">updateLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> N <span class="title function_">doSelect</span><span class="params">(List&lt;N&gt; nodes, String ip)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">totalWeight</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">maxCurrent</span> <span class="operator">=</span> Long.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">N</span> <span class="variable">selectedNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">WeightedRoundRobin</span> <span class="variable">selectedWRR</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面这个循环主要做了这样几件事情：</span></span><br><span class="line">        <span class="comment">//   1. 遍历 Node 列表，检测当前 Node 是否有相应的 WeightedRoundRobin，没有则创建</span></span><br><span class="line">        <span class="comment">//   2. 检测 Node 权重是否发生了变化，若变化了，则更新 WeightedRoundRobin 的 weight 字段</span></span><br><span class="line">        <span class="comment">//   3. 让 current 字段加上自身权重，等价于 current += weight</span></span><br><span class="line">        <span class="comment">//   4. 设置 lastUpdate 字段，即 lastUpdate = now</span></span><br><span class="line">        <span class="comment">//   5. 寻找具有最大 current 的 Node，以及 Node 对应的 WeightedRoundRobin，</span></span><br><span class="line">        <span class="comment">//      暂存起来，留作后用</span></span><br><span class="line">        <span class="comment">//   6. 计算权重总和</span></span><br><span class="line">        <span class="keyword">for</span> (N node : nodes) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">hashCode</span> <span class="operator">=</span> node.hashCode();</span><br><span class="line">            <span class="type">WeightedRoundRobin</span> <span class="variable">weightedRoundRobin</span> <span class="operator">=</span> weightMap.get(hashCode);</span><br><span class="line">            <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> node.getWeight();</span><br><span class="line">            <span class="keyword">if</span> (weight &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                weight = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检测当前 Node 是否有对应的 WeightedRoundRobin，没有则创建</span></span><br><span class="line">            <span class="keyword">if</span> (weightedRoundRobin == <span class="literal">null</span>) &#123;</span><br><span class="line">                weightedRoundRobin = <span class="keyword">new</span> <span class="title class_">WeightedRoundRobin</span>();</span><br><span class="line">                <span class="comment">// 设置 Node 权重</span></span><br><span class="line">                weightedRoundRobin.setWeight(weight);</span><br><span class="line">                <span class="comment">// 存储 url 唯一标识 identifyString 到 weightedRoundRobin 的映射关系</span></span><br><span class="line">                weightMap.putIfAbsent(hashCode, weightedRoundRobin);</span><br><span class="line">                weightedRoundRobin = weightMap.get(hashCode);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Node 权重不等于 WeightedRoundRobin 中保存的权重，说明权重变化了，此时进行更新</span></span><br><span class="line">            <span class="keyword">if</span> (weight != weightedRoundRobin.getWeight()) &#123;</span><br><span class="line">                weightedRoundRobin.setWeight(weight);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 让 current 加上自身权重，等价于 current += weight</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> weightedRoundRobin.increaseCurrent();</span><br><span class="line">            <span class="comment">// 设置 lastUpdate，表示近期更新过</span></span><br><span class="line">            weightedRoundRobin.setLastUpdate(now);</span><br><span class="line">            <span class="comment">// 找出最大的 current</span></span><br><span class="line">            <span class="keyword">if</span> (current &gt; maxCurrent) &#123;</span><br><span class="line">                maxCurrent = current;</span><br><span class="line">                <span class="comment">// 将具有最大 current 权重的 Node 赋值给 selectedNode</span></span><br><span class="line">                selectedNode = node;</span><br><span class="line">                <span class="comment">// 将 Node 对应的 weightedRoundRobin 赋值给 selectedWRR，留作后用</span></span><br><span class="line">                selectedWRR = weightedRoundRobin;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算权重总和</span></span><br><span class="line">            totalWeight += weight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对 weightMap 进行检查，过滤掉长时间未被更新的节点。</span></span><br><span class="line">        <span class="comment">// 该节点可能挂了，nodes 中不包含该节点，所以该节点的 lastUpdate 长时间无法被更新。</span></span><br><span class="line">        <span class="comment">// 若未更新时长超过阈值后，就会被移除掉，默认阈值为60秒。</span></span><br><span class="line">        <span class="keyword">if</span> (!updateLock.get() &amp;&amp; nodes.size() != weightMap.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (updateLock.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 遍历修改，即移除过期记录</span></span><br><span class="line">                    weightMap.entrySet().removeIf(item -&gt; now - item.getValue().getLastUpdate() &gt; RECYCLE_PERIOD);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    updateLock.set(<span class="literal">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (selectedNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 让 current 减去权重总和，等价于 current -= totalWeight</span></span><br><span class="line">            selectedWRR.decreaseCurrent(totalWeight);</span><br><span class="line">            <span class="comment">// 返回具有最大 current 的 Node</span></span><br><span class="line">            <span class="keyword">return</span> selectedNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// should not happen here</span></span><br><span class="line">        <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WeightedRoundRobin</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 服务提供者权重</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> weight;</span><br><span class="line">        <span class="comment">// 当前权重</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">AtomicLong</span> <span class="variable">current</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 最后一次更新时间</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">long</span> lastUpdate;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">increaseCurrent</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// current = current + weight；</span></span><br><span class="line">            <span class="keyword">return</span> current.addAndGet(weight);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">decreaseCurrent</span><span class="params">(<span class="type">int</span> total)</span> &#123;</span><br><span class="line">            <span class="comment">// current = current - total;</span></span><br><span class="line">            <span class="keyword">return</span> current.addAndGet(-<span class="number">1</span> * total);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> weight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWeight</span><span class="params">(<span class="type">int</span> weight)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.weight = weight;</span><br><span class="line">            <span class="comment">// 初始情况下，current = 0</span></span><br><span class="line">            current.set(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> AtomicLong <span class="title function_">getCurrent</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCurrent</span><span class="params">(AtomicLong current)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.current = current;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getLastUpdate</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> lastUpdate;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLastUpdate</span><span class="params">(<span class="type">long</span> lastUpdate)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.lastUpdate = lastUpdate;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最少连接数算法"><a href="#最少连接数算法" class="headerlink" title="最少连接数算法"></a>最少连接数算法</h3><p>加权轮询&#x2F;随机算法虽然一定程度上解决了机器处理能力不同时的负载均衡场景，但它最大的问题在于不能动态应对网络中负载不均的场景。加权的思路是在负载均衡处理的事前，预设好不同机器的权重，然后分发。然而，每个请求的连接时长不同，负载均衡器也不可能准确预估出请求的连接时长。因此，采用加权轮询&#x2F;随机算法算法，都无法动态应对连接时长不均的网络场景，可能会出现<strong>某些机器当前连接数过多，而另一些机器的连接过少</strong>的情况，即并非真正的流量负载均衡。</p>
<p>如下图所示，假设存在这样的场景：</p>
<ul>
<li>3 个服务端的处理能力相同；</li>
<li>编号为 1、4 的请求被发送到服务端 0，但是 1 很快就断开连接，此时只有 4 请求连接服务端 0；</li>
<li>编号为 2、5 的请求被发送到服务端 1，但是 2 始终保持长连接；该系统继续运行时，服务端 1 发生过载；</li>
<li>编号为 3、6 的请求被发送到服务端 2，但是 3 很快就断开连接，此时只有 6 请求连接服务端 2；</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310250650176.png"></p>
<p>既然，请求的连接时长不同，会导致有的服务端处理慢，积压大量连接数；而有的服务端处理快，保持的连接数少。那么，我们不妨想一下，如果负载均衡器监控一下服务端当前所持有的连接数，优先将请求分发给连接数少的服务端，不就能有效提高分发效率了吗？最少连接数算法正是采用这个思路去设计的。</p>
<p><strong>“最少连接数算法（Least Connections）” 将请求分发到连接数&#x2F;请求数最少的候选机器</strong>。</p>
<p>要根据机器连接数分发，显然要先维护机器的连接数。因此，<strong>最少连接数算法需要实时追踪每个候选机器的活跃连接数；然后，动态选出连接数最少的机器，优先分发请求</strong>。最少连接数算法会记录当前时刻，每个候选节点正在处理的连接数，然后选择连接数最小的节点。该策略能够动态、实时地反应机器的当前状况，较为合理地将负责分配均匀，适用于对当前系统负载较为敏感的场景。</p>
<p>由此可见，<strong>最少连接数算法适用于对系统负载较为敏感且请求连接时长相差较大的场景</strong>。</p>
<p>如下图所示，假设存在这样的场景：</p>
<ul>
<li>服务端 0 和服务端 1 的处理能力相同；</li>
<li>编号为 1、3 的请求被发送到服务端 0，但是 1、3 很快就断开连接；</li>
<li>编号为 2、4 的请求被发送到服务端 1，但是 2、4 保持长连接；</li>
<li>由于服务端 0 当前连接数最少，编号为 5、6 的请求被分发到服务端 0。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310250650852.png"></p>
<p>“加权最少连接数算法（Weighted Least Connection）”在最少连接数算法的基础上，根据机器的性能为每台机器分配权重，再根据权重计算出每台机器能处理的连接数。</p>
<p>【示例】最少连接数算法实现</p>
<p>最少连接数算法实现要点：活跃调用数越小，表明该服务节点处理能力越高，单位时间内可处理更多的请求，应优先将请求分发给该服务。在具体实现中，每个服务节点对应一个活跃数 active。初始情况下，所有服务提供者活跃数均为 0。每收到一个请求，活跃数加 1，完成请求后则将活跃数减 1。在服务运行一段时间后，性能好的服务提供者处理请求的速度更快，因此活跃数下降的也越快，此时这样的服务提供者能够优先获取到新的服务请求、这就是最少连接数负载均衡算法的基本思想。</p>
<p>以下实现基于 Dubbo 最少连接数负载均衡算法做了些许改动。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeastActiveLoadBalance</span>&lt;N <span class="keyword">extends</span> <span class="title class_">Node</span>&gt; <span class="keyword">extends</span> <span class="title class_">BaseLoadBalance</span>&lt;N&gt; <span class="keyword">implements</span> <span class="title class_">LoadBalance</span>&lt;N&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> N <span class="title function_">doSelect</span><span class="params">(List&lt;N&gt; nodes, String ip)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nodes.size();</span><br><span class="line">        <span class="comment">// 最小的活跃数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leastActive</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 具有相同“最少连接数”的服务者提供者（以下用 Node 代称）数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leastCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// leastIndexs 用于记录具有相同“最少连接数”的 Node 在 nodes 列表中的下标信息</span></span><br><span class="line">        <span class="type">int</span>[] leastIndexs = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalWeight</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 第一个最少连接数的 Node 权重值，用于与其他具有相同最少连接数的 Node 的权重进行对比，</span></span><br><span class="line">        <span class="comment">// 以检测是否“所有具有相同最少连接数的 Node 的权重”均相等</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">firstWeight</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">sameWeight</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历 nodes 列表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="type">N</span> <span class="variable">node</span> <span class="operator">=</span> nodes.get(i);</span><br><span class="line">            <span class="comment">// 发现更小的活跃数，重新开始</span></span><br><span class="line">            <span class="keyword">if</span> (leastActive == -<span class="number">1</span> || node.getActive() &lt; leastActive) &#123;</span><br><span class="line">                <span class="comment">// 使用当前活跃数更新最少连接数 leastActive</span></span><br><span class="line">                leastActive = node.getActive();</span><br><span class="line">                <span class="comment">// 更新 leastCount 为 1</span></span><br><span class="line">                leastCount = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 记录当前下标值到 leastIndexs 中</span></span><br><span class="line">                leastIndexs[<span class="number">0</span>] = i;</span><br><span class="line">                totalWeight = node.getWeight();</span><br><span class="line">                firstWeight = node.getWeight();</span><br><span class="line">                sameWeight = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 当前 Node 的活跃数 node.getActive() 与最少连接数 leastActive 相同</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.getActive() == leastActive) &#123;</span><br><span class="line">                <span class="comment">// 在 leastIndexs 中记录下当前 Node 在 nodes 集合中的下标</span></span><br><span class="line">                leastIndexs[leastCount++] = i;</span><br><span class="line">                <span class="comment">// 累加权重</span></span><br><span class="line">                totalWeight += node.getWeight();</span><br><span class="line">                <span class="comment">// 检测当前 Node 的权重与 firstWeight 是否相等，</span></span><br><span class="line">                <span class="comment">// 不相等则将 sameWeight 置为 false</span></span><br><span class="line">                <span class="keyword">if</span> (sameWeight &amp;&amp; i &gt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; node.getWeight() != firstWeight) &#123;</span><br><span class="line">                    sameWeight = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当只有一个 Node 具有最少连接数，此时直接返回该 Node 即可</span></span><br><span class="line">        <span class="keyword">if</span> (leastCount == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nodes.get(leastIndexs[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有多个 Node 具有相同的最少连接数，但它们之间的权重不同</span></span><br><span class="line">        <span class="keyword">if</span> (!sameWeight &amp;&amp; totalWeight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 随机生成一个 [0, totalWeight) 之间的数字</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">offsetWeight</span> <span class="operator">=</span> random.nextInt(totalWeight);</span><br><span class="line">            <span class="comment">// 循环让随机数减去具有最少连接数的 Node 的权重值，</span></span><br><span class="line">            <span class="comment">// 当 offset 小于等于0时，返回相应的 Node</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; leastCount; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">leastIndex</span> <span class="operator">=</span> leastIndexs[i];</span><br><span class="line">                <span class="comment">// 获取权重值，并让随机数减去权重值</span></span><br><span class="line">                offsetWeight -= nodes.get(leastIndex).getWeight();</span><br><span class="line">                <span class="keyword">if</span> (offsetWeight &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> nodes.get(leastIndex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果权重相同或权重为0时，随机返回一个 Node</span></span><br><span class="line">        <span class="keyword">return</span> nodes.get(leastIndexs[random.nextInt(leastCount)]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最少响应时间算法"><a href="#最少响应时间算法" class="headerlink" title="最少响应时间算法"></a>最少响应时间算法</h3><p><strong>“最少响应时间算法（Least Time）” 将请求分发到响应时间最短的候选机器</strong>。最少响应时间算法和最少连接数算法二者的目标其实是殊途同归，都是动态调整，将请求尽量分发到处理能力强的机器上。不同点在于，最少连接数关注的维度是机器持有的连接数，而最少响应时间关注的维度是机器上一次响应时间哪个最短。理论上来说，持有的连接数少，响应时间短，都可以表明机器潜在的处理能力比较强。</p>
<p><strong>最少响应时间算法具有高度的敏感性、自适应性</strong>。但是，由于它需要持续监控候选机器的响应时延，相比于监控候选机器的连接数，会显著增加监控的开销。此外，请求的响应时延并不一定能完全反应机器的处理能力，有可能某机器上一次处理的请求恰好是一个开销非常小的请求。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310250650334.png"></p>
<h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><p>前面提到的负载均衡算法，都只适用于无状态应用。所谓无状态应用，意味着：请求无论分发到集群中的任意机器上，得到的响应都是相同的：然而，有状态服务则不然：请求分发到不同的机器上，得到的结果是不一样的。典型的无状态应用是普通的 Web 服务器；典型的有状态应用是各种分布式数据库（如：Redis、ElasticSearch 等），这些数据库存储了大量，乃至海量的数据，无法全部存储在一台机器上，为了提高整体容量以及吞吐量，采用了分区（分片）的设计，将数据化整为零的存储在不同机器上。</p>
<p>对于有状态应用，不仅仅需要保证负载的均衡，更为重要的是，需要保证针对相同数据的请求始终访问的是相同的机器，否则，就无法获取到正确的数据。</p>
<p>那么，如何解决有状态应用的负载均衡呢？有一种方案是哈希算法。</p>
<p><strong>“哈希算法（Hash）” 根据一个 key （可以是唯一 ID、IP、URL 等），通过哈希函数计算得到一个数值，用该数值在候选机器列表的进行取模运算，得到的结果便是选中的机器</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310250652913.png"></p>
<p>这种算法可以保证，同一关键字（IP 或 URL 等）的请求，始终会被转发到同一台机器上。哈希负载均衡算法常被用于实现会话粘滞（Sticky Session）。</p>
<p>但是 ，哈希算法的问题是：当增减节点时，由于哈希取模函数的基数发生变化，会影响大部分的映射关系，从而导致之前的数据不可访问。要解决这个问题，就必须根据新的计算公式迁移数据。显然，如果数据量很大的情况下，迁移成本很高；并且，在迁移过程中，要保证业务平滑过渡，需要使用数据双写等较为复杂的技术手段。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310250653034.png"></p>
<p>【示例】源地址哈希算法实现示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IpHashLoadBalance</span>&lt;N <span class="keyword">extends</span> <span class="title class_">Node</span>&gt; <span class="keyword">extends</span> <span class="title class_">BaseLoadBalance</span>&lt;N&gt; <span class="keyword">implements</span> <span class="title class_">LoadBalance</span>&lt;N&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> N <span class="title function_">doSelect</span><span class="params">(List&lt;N&gt; nodes, String ip)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(ip)) &#123;</span><br><span class="line">            ip = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nodes.size();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> hash(ip) % length;</span><br><span class="line">        <span class="keyword">return</span> nodes.get(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> HashUtil.fnvHash(text);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h3><p>哈希算法的缺点是：当集群中出现增减节点时，由于哈希取模函数的基数发生变化，会导致大量集群中的机器不可用；需要通过代价高昂的数据迁移，来解决问题。那么，我们自然会希望有一种更优化的方案，来尽量减少影响的机器数。一致性哈希算法就是为了这个目标而应运而生。</p>
<p>一致性哈希算法对哈希算法进行了改良。<strong>“一致性哈希算法（Consistent Hash）”，根据哈希算法将对应的 key 哈希到一个具有 2^32 个桶的空间，并且头尾相连（0 到 2^32-1），即一个闭合的环形，这个圆环被称为“哈希环”</strong>。哈希算法是对节点的数量进行取模运算；而一致性哈希算法则是对 2^32 进行取模运算。</p>
<p><strong>哈希环的空间是按顺时针方向组织的</strong>，需要对指定 key 的数据进行读写时，会执行两步：</p>
<ol>
<li>先对 key 进行哈希计算，以确定 key 在环上的位置；</li>
<li>然后根据这个位置，顺时针找到的第一个节点，就是 key 对应的节点。</li>
</ol>
<p>所以，<strong>一致性哈希是将“存储节点”和“数据”都映射到一个顺时针排序的哈希环上</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310250653412.png"></p>
<p>一致性哈希算法会尽可能保证，相同的请求被分发到相同的机器上。<strong>当出现增减节点时，只影响哈希环中顺时针方向的相邻的节点，对其他节点无影响，不会引起剧烈变动</strong>。</p>
<ul>
<li><strong>相同的请求</strong>是指：一般在使用一致性哈希时，需要指定一个 key 用于 hash 计算，可能是：用户 ID、请求方 IP、请求服务名称，参数列表构成的串</li>
<li><strong>尽可能</strong>是指：哈希环上出现增减节点时，少数机器的变化不应该影响大多数的请求。</li>
</ul>
<p>（1）增加节点</p>
<p>如下图所示，假设，哈希环中新增了一个节点 S4，新增节点经过哈希计算映射到图中位置：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310250653974.png"></p>
<p>此时，只有 K1 收到影响；而 K0、K2 均不受影响。</p>
<p>（2）减少节点</p>
<p>如下图所示，假设，哈希环中减少了一个节点 S0：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310250653207.png"></p>
<p>此时，只有 K0 收到影响；而 K1、K2 均不受影响。</p>
<p><strong>一致性哈希算法并不保证节点能够在哈希环上分布均匀</strong>，由此而产生一个问题，哈希环上可能有大量的请求集中在一个节点上。从概率角度来看，<strong>哈希环上的节点越多，分布就越均匀</strong>。正因为如此，一致性哈希算法不适用于节点数过少的场景。</p>
<p>如下图所示：极端情况下，可能由于节点在哈希环上分布不均，有大量请求计算得到的 key 会被集中映射到少数节点，甚至某一个节点上。此外，节点分布不均匀的情况下，进行容灾与扩容时，哈希环上的相邻节点容易受到过大影响，从而引发雪崩式的连锁反应。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310250654770.png"></p>
<p>【示例】一致性哈希算法示例</p>
<p>以下示例基于 Dubbo 的一致性哈希负载均衡算法做了一些简化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsistentHashLoadBalance</span>&lt;N <span class="keyword">extends</span> <span class="title class_">Node</span>&gt; <span class="keyword">extends</span> <span class="title class_">BaseLoadBalance</span>&lt;N&gt; <span class="keyword">implements</span> <span class="title class_">LoadBalance</span>&lt;N&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, ConsistentHashSelector&lt;?&gt;&gt; selectors = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> N <span class="title function_">doSelect</span><span class="params">(List&lt;N&gt; nodes, String ip)</span> &#123;</span><br><span class="line">        <span class="comment">// 分片数，这里设为节点数的 4 倍</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">replicaNum</span> <span class="operator">=</span> nodes.size() * <span class="number">4</span>;</span><br><span class="line">        <span class="comment">// 获取 nodes 原始的 hashcode[11.分布式协同](..%2F11.%B7%D6%B2%BC%CA%BD%D0%AD%CD%AC)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">identityHashCode</span> <span class="operator">=</span> System.identityHashCode(nodes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 nodes 是一个新的 List 对象，意味着节点数量发生了变化</span></span><br><span class="line">        <span class="comment">// 此时 selector.identityHashCode != identityHashCode 条件成立</span></span><br><span class="line">        ConsistentHashSelector&lt;N&gt; selector = (ConsistentHashSelector&lt;N&gt;) selectors.get(ip);</span><br><span class="line">        <span class="keyword">if</span> (selector == <span class="literal">null</span> || selector.identityHashCode != identityHashCode) &#123;</span><br><span class="line">            <span class="comment">// 创建新的 ConsistentHashSelector</span></span><br><span class="line">            selectors.put(ip, <span class="keyword">new</span> <span class="title class_">ConsistentHashSelector</span>&lt;&gt;(nodes, identityHashCode, replicaNum));</span><br><span class="line">            selector = (ConsistentHashSelector&lt;N&gt;) selectors.get(ip);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用 ConsistentHashSelector 的 select 方法选择 Node</span></span><br><span class="line">        <span class="keyword">return</span> selector.select(ip);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一致性哈希选择器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ConsistentHashSelector</span>&lt;N <span class="keyword">extends</span> <span class="title class_">Node</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 存储虚拟节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> TreeMap&lt;Long, N&gt; virtualNodes;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> identityHashCode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 构造器</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> nodes            节点列表</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> identityHashCode hashcode</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> replicaNum       分片数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ConsistentHashSelector(List&lt;N&gt; nodes, <span class="type">int</span> identityHashCode, Integer replicaNum) &#123;</span><br><span class="line">            <span class="built_in">this</span>.virtualNodes = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">            <span class="built_in">this</span>.identityHashCode = identityHashCode;</span><br><span class="line">            <span class="comment">// 获取虚拟节点数，默认为 100</span></span><br><span class="line">            <span class="keyword">if</span> (replicaNum == <span class="literal">null</span>) &#123;</span><br><span class="line">                replicaNum = <span class="number">100</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (N node : nodes) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; replicaNum / <span class="number">4</span>; i++) &#123;</span><br><span class="line">                    <span class="comment">// 对 url 进行 md5 运算，得到一个长度为16的字节数组</span></span><br><span class="line">                    <span class="type">byte</span>[] digest = md5(node.getUrl());</span><br><span class="line">                    <span class="comment">// 对 digest 部分字节进行 4 次 hash 运算，得到四个不同的 long 型正整数</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                        <span class="comment">// h = 0 时，取 digest 中下标为 0 ~ 3 的4个字节进行位运算</span></span><br><span class="line">                        <span class="comment">// h = 1 时，取 digest 中下标为 4 ~ 7 的4个字节进行位运算</span></span><br><span class="line">                        <span class="comment">// h = 2, h = 3 时过程同上</span></span><br><span class="line">                        <span class="type">long</span> <span class="variable">m</span> <span class="operator">=</span> hash(digest, j);</span><br><span class="line">                        <span class="comment">// 将 hash 到 node 的映射关系存储到 virtualNodes 中，</span></span><br><span class="line">                        <span class="comment">// virtualNodes 需要提供高效的查询操作，因此选用 TreeMap 作为存储结构</span></span><br><span class="line">                        virtualNodes.put(m, node);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> N <span class="title function_">select</span><span class="params">(String key)</span> &#123;</span><br><span class="line">            <span class="comment">// 对参数 key 进行 md5 运算</span></span><br><span class="line">            <span class="type">byte</span>[] digest = md5(key);</span><br><span class="line">            <span class="comment">// 取 digest 数组的前四个字节进行 hash 运算，再将 hash 值传给 selectForKey 方法，</span></span><br><span class="line">            <span class="comment">// 寻找合适的 Node</span></span><br><span class="line">            <span class="keyword">return</span> selectForKey(hash(digest, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> N <span class="title function_">selectForKey</span><span class="params">(<span class="type">long</span> hash)</span> &#123;</span><br><span class="line">            <span class="comment">// 查找第一个大于或等于当前 hash 的节点</span></span><br><span class="line">            Map.Entry&lt;Long, N&gt; entry = virtualNodes.ceilingEntry(hash);</span><br><span class="line">            <span class="comment">// 如果 hash 大于 Node 在哈希环上最大的位置，此时 entry = null，</span></span><br><span class="line">            <span class="comment">// 需要将 TreeMap 的头节点赋值给 entry</span></span><br><span class="line">            <span class="keyword">if</span> (entry == <span class="literal">null</span>) &#123;</span><br><span class="line">                entry = virtualNodes.firstEntry();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 返回 Node</span></span><br><span class="line">            <span class="keyword">return</span> entry.getValue();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算 hash 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">hash</span><span class="params">(<span class="type">byte</span>[] digest, <span class="type">int</span> number)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (((<span class="type">long</span>) (digest[<span class="number">3</span> + number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">24</span>)</span><br><span class="line">            | ((<span class="type">long</span>) (digest[<span class="number">2</span> + number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">16</span>)</span><br><span class="line">            | ((<span class="type">long</span>) (digest[<span class="number">1</span> + number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">            | (digest[number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>))</span><br><span class="line">            &amp; <span class="number">0xFFFFFFFFL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算 MD5 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] md5(String value) &#123;</span><br><span class="line">        MessageDigest md5;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            md5 = MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        md5.reset();</span><br><span class="line">        <span class="type">byte</span>[] bytes = value.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        md5.update(bytes);</span><br><span class="line">        <span class="keyword">return</span> md5.digest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="虚拟一致性哈希算法"><a href="#虚拟一致性哈希算法" class="headerlink" title="虚拟一致性哈希算法"></a>虚拟一致性哈希算法</h3><p>在一致性哈希算法中，如果节点数过少，可能会分布不均，从而导致负载不均衡。在实际生产环境中，一个分布式系统应该具备良好的伸缩性，既能从容的扩展到大规模的集群，也要能支持小规模的集群。为此，又产生了虚拟哈希算法，进一步对一致性哈希算法进行了改良。</p>
<p>虚拟哈希算法的解决思路是：虽然实际的集群可能节点数较少，但是在哈希环上引入大量的虚拟哈希节点。具体来说，<strong>“虚拟哈希算法”有二次映射：先将虚拟节点映射到哈希环上，再将虚拟节点映射到实际节点上。</strong></p>
<p>如下图所示，假设存在这样的场景：</p>
<ul>
<li>分布式集群中有 4 个真实节点，分别是：S0、S1、S2、S3；</li>
<li>我们不妨先假定分配给哈希环 12 个虚拟节点，并将虚拟节点映射到真实节点上，映射关系如下：<ul>
<li>S0 - S0_0、S0_1、S0_2、S0_3</li>
<li>S1 - S1_0、S1_1、S1_2、S1_3</li>
<li>S2 - S2_0、S2_1、S2_2、S2_3</li>
<li>S3 - S3_0、S3_1、S3_2、S3_3</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310250654220.png"></p>
<p>通过引入虚拟哈希节点，是的哈希环上的节点分布相对均匀了。举例来说，假如此时，某请求的 key 哈希取模后，先映射到哈希环的 [S3_2, S0_0]、[S3_0, S0_1]、[S3_1, S0_2] 这三个区间的任意一点；接下来的二次映射都会匹配到真实节点 S0。</p>
<p>在实际应用中，虚拟哈希节点数一般都比较大（例如：Redis 的虚拟哈希槽有 16384 个），较大的数量保证了虚拟哈希环上的节点分布足够均匀。</p>
<p>虚拟节点除了会提高节点的均衡度，还会提高系统的稳定性。<strong>当节点变化时，会有不同的节点共同分担系统的变化，因此稳定性更高</strong>。例如，当某个节点被移除时，分配给该节点的多个虚拟节点会被一并移除，而这些虚拟节点按顺时针方向的下一个虚拟节点，可能会对应不同的真实节点，即这些不同的真实节点共同分担了节点变化导致的压力。</p>
<p>此外，有了虚拟节点后，可以通过调整分配给真实节点的虚拟节点数，来达到设置权重一样的效果，使得负载均衡更加灵活。</p>
<p>综上所述，<strong>虚拟一致性哈希算法不仅适合硬件配置不同的节点的场景，而且适合节点规模会发生变化的场景</strong>。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>下面通过一张思维导图对介绍的负载均衡算法做一个小结：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310250658009.png"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?reload=9&app=desktop&v=iqOTT7_7qXY">Comparing Load Balancing Algorithms</a> - YouTube 上介绍常见负载均衡算法的视频</li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=dBmxNsS3BGE">Top 6 Load Balancing Algorithms Every Developer Should Know</a> - YouTube 上介绍 6 种常见负载均衡算法的视频</li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=UF9Iqmg94tk">Consistent Hashing | Algorithms You Should Know</a> - YouTube 上的一致性哈希算法视频</li>
<li><a target="_blank" rel="noopener" href="https://item.jd.com/11322972.html">《大型网站技术架构：核心原理与案例分析》</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/32841479">什么是负载均衡</a></li>
<li><a target="_blank" rel="noopener" href="https://cn.dubbo.apache.org/zh-cn/overview/core-features/load-balance/">Dubbo 官方文档之负载均衡</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000004492447">负载均衡算法及手段</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000002578457">利用 dns 解析来实现网站的负载均衡</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/39/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/39/">39</a><span class="page-number current">40</span><a class="page-number" href="/page/41/">41</a><span class="space">&hellip;</span><a class="page-number" href="/page/47/">47</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/41/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备2021160229号 </a>
  </div>
  <div class="copyright">
    &copy; 2015 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">李狗蛋</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">3.5m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">53:28</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/yiyirushi/" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.1/dist/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  




<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>

</body>
</html>
