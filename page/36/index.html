<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/uploads/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/uploads/favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.ligoudan.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="天气不错哇，你看这大冰雹下得">
<meta property="og:type" content="website">
<meta property="og:title" content="LIGOUDAN">
<meta property="og:url" content="https://www.ligoudan.cn/page/36/index.html">
<meta property="og:site_name" content="LIGOUDAN">
<meta property="og:description" content="天气不错哇，你看这大冰雹下得">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="李狗蛋">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://www.ligoudan.cn/page/36/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/36/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>LIGOUDAN</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">LIGOUDAN</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">好好学习，天天向上</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">326</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">137</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">461</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="李狗蛋"
      src="/uploads/ligoudan.png">
  <p class="site-author-name" itemprop="name">李狗蛋</p>
  <div class="site-description" itemprop="description">天气不错哇，你看这大冰雹下得</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">461</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">137</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">326</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/yiyirushi" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yiyirushi" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yuanhaohoo@163.com" title="E-Mail → mailto:yuanhaohoo@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/80d4a7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/80d4a7/" class="post-title-link" itemprop="url">Spark 简介</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-05-07 20:19:25" itemprop="dateCreated datePublished" datetime="2019-05-07T20:19:25+08:00">2019-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:53" itemprop="dateModified" datetime="2024-12-12T10:02:53+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/" itemprop="url" rel="index"><span itemprop="name">大数据</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/spark/" itemprop="url" rel="index"><span itemprop="name">spark</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h1><h2 id="Spark-简介"><a href="#Spark-简介" class="headerlink" title="Spark 简介"></a>Spark 简介</h2><h3 id="Spark-概念"><a href="#Spark-概念" class="headerlink" title="Spark 概念"></a>Spark 概念</h3><ul>
<li>大规模分布式通用计算引擎<ul>
<li>Spark Core：核心计算框架</li>
<li>Spark SQL：结构化数据查询</li>
<li>Spark Streaming：实时流处理</li>
<li>Spark MLib：机器学习</li>
<li>Spark GraphX：图计算</li>
</ul>
</li>
<li>具有高吞吐、低延时、通用易扩展、高容错等特点</li>
<li>采用 Scala 语言开发</li>
<li>提供多种运行模式</li>
</ul>
<h3 id="Spark-特点"><a href="#Spark-特点" class="headerlink" title="Spark 特点"></a>Spark 特点</h3><ul>
<li>计算高效<ul>
<li>利用内存计算、Cache 缓存机制，支持迭代计算和数据共享，减少数据读取的 IO 开销</li>
<li>利用 DAG 引擎，减少中间计算结果写入 HDFS 的开销</li>
<li>利用多线程池模型，减少任务启动开销，避免 Shuffle 中不必要的排序和磁盘 IO 操作</li>
</ul>
</li>
<li>通用易用<ul>
<li>适用于批处理、流处理、交互式计算、机器学习算法等场景</li>
<li>提供了丰富的开发 API，支持 Scala、Java、Python、R 等</li>
</ul>
</li>
<li>运行模式多样<ul>
<li>Local 模式</li>
<li>Standalone 模式</li>
<li>YARN&#x2F;Mesos 模式</li>
</ul>
</li>
<li>计算高效<ul>
<li>利用内存计算、Cache 缓存机制，支持迭代计算和数据共享，减少数据读取的 IO 开销</li>
<li>利用 DAG 引擎，减少中间计算结果写入 HDFS 的开销</li>
<li>利用多线程池模型，减少任务启动开销，避免 Shuffle 中不必要的排序和磁盘 IO 操作</li>
</ul>
</li>
<li>通用易用<ul>
<li>适用于批处理、流处理、交互式计算、机器学习等场景</li>
<li>提供了丰富的开发 API，支持 Scala、Java、Python、R 等</li>
</ul>
</li>
</ul>
<h2 id="Spark-原理"><a href="#Spark-原理" class="headerlink" title="Spark 原理"></a>Spark 原理</h2><h3 id="编程模型"><a href="#编程模型" class="headerlink" title="编程模型"></a>编程模型</h3><h4 id="RDD"><a href="#RDD" class="headerlink" title="RDD"></a>RDD</h4><ul>
<li>弹性分布式数据集（Resilient Distributed Datesets）<ul>
<li>分布在集群中的只读对象集合</li>
<li>由多个 Partition 组成</li>
<li>通过转换操作构造</li>
<li>失效后自动重构（弹性）</li>
<li>存储在内存或磁盘中</li>
</ul>
</li>
<li>Spark 基于 RDD 进行计算</li>
</ul>
<h4 id="RDD-操作（Operator）"><a href="#RDD-操作（Operator）" class="headerlink" title="RDD 操作（Operator）"></a>RDD 操作（Operator）</h4><ul>
<li>Transformation（转换）<ul>
<li>将 Scala 集合或 Hadoop 输入数据构造成一个新 RDD</li>
<li>通过已有的 RDD 产生新 RDD</li>
<li>惰性执行：只记录转换关系，不触发计算</li>
<li>例如：map、filter、flatmap、union、distinct、sortbykey</li>
</ul>
</li>
<li>Action（动作）<ul>
<li>通过 RDD 计算得到一个值或一组值</li>
<li>真正触发计算</li>
<li>例如：first、count、collect、foreach、saveAsTextFile</li>
</ul>
</li>
</ul>
<h4 id="RDD-依赖（Dependency）"><a href="#RDD-依赖（Dependency）" class="headerlink" title="RDD 依赖（Dependency）"></a>RDD 依赖（Dependency）</h4><ul>
<li>窄依赖（Narrow Dependency）<ul>
<li>父 RDD 中的分区最多只能被一个子 RDD 的一个分区使用</li>
<li>子 RDD 如果有部分分区数据丢失或损坏，只需从对应的父 RDD 重新计算恢复</li>
<li>例如：map、filter、union</li>
</ul>
</li>
<li>宽依赖（Shuffle&#x2F;Wide Dependency ）<ul>
<li>子 RDD 分区依赖父 RDD 的所有分区</li>
<li>子 RDD 如果部分或全部分区数据丢失或损坏，必须从所有父 RDD 分区重新计算</li>
<li>相对于窄依赖，宽依赖付出的代价要高很多，尽量避免使用</li>
<li>例如：groupByKey、reduceByKey、sortByKey</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/406588/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/406588/" class="post-title-link" itemprop="url">YARN</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-05-07 20:19:25" itemprop="dateCreated datePublished" datetime="2019-05-07T20:19:25+08:00">2019-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:53" itemprop="dateModified" datetime="2024-12-12T10:02:53+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/" itemprop="url" rel="index"><span itemprop="name">大数据</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/hadoop/" itemprop="url" rel="index"><span itemprop="name">hadoop</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="YARN"><a href="#YARN" class="headerlink" title="YARN"></a>YARN</h1><blockquote>
<p>YARN 的目标是解决 MapReduce 的缺陷。</p>
</blockquote>
<h2 id="MapReduce-的缺陷（Hadoop-1-x）"><a href="#MapReduce-的缺陷（Hadoop-1-x）" class="headerlink" title="MapReduce 的缺陷（Hadoop 1.x）"></a>MapReduce 的缺陷（Hadoop 1.x）</h2><ul>
<li>身兼两职：计算框架 + 资源管理框架</li>
<li>JobTracker<ul>
<li>既做资源管理，又做任务调度</li>
<li>任务太重，开销过大</li>
<li>存在单点故障</li>
</ul>
</li>
<li>资源描述模型过于简单，资源利用率较低<ul>
<li>仅把 Task 数量看作资源，没有考虑 CPU 和内存</li>
<li>强制把资源分成 Map Task Slot 和 Reduce Task Slot</li>
</ul>
</li>
<li>扩展性较差，集群规模上限 4K</li>
<li>源码难于理解，升级维护困难</li>
</ul>
<h2 id="YARN-简介"><a href="#YARN-简介" class="headerlink" title="YARN 简介"></a>YARN 简介</h2><p>YARN(Yet Another Resource Negotiator，另一种资源管理器)是一个<strong>分布式通用资源管理系统</strong>。</p>
<p>设计目标：聚焦资源管理、通用（适用各种计算框架）、高可用、高扩展。</p>
<h2 id="YARN-系统架构"><a href="#YARN-系统架构" class="headerlink" title="YARN 系统架构"></a>YARN 系统架构</h2><ul>
<li>主从结构（master&#x2F;slave）</li>
<li>将 JobTracker 的资源管理、任务调度功能分离</li>
<li>三种角色：<ul>
<li>ResourceManager（Master） - 集群资源的统一管理和分配</li>
<li>NodeManager（Slave） - 管理节点资源，以及容器的生命周期</li>
<li>ApplicationMaster（新角色） - 管理应用程序实例，包括任务调度和资源申请</li>
</ul>
</li>
</ul>
<h3 id="ResourceManager（RM）"><a href="#ResourceManager（RM）" class="headerlink" title="ResourceManager（RM）"></a>ResourceManager（RM）</h3><p><strong>主要功能</strong></p>
<ul>
<li>统一管理集群的所有资源</li>
<li>将资源按照一定策略分配给各个应用（ApplicationMaster）</li>
<li>接收 NodeManager 的资源上报信息</li>
</ul>
<p><strong>核心组件</strong></p>
<ul>
<li>用户交互服务（User Service）</li>
<li>NodeManager 管理</li>
<li>ApplicationMaster 管理</li>
<li>Application 管理</li>
<li>安全管理</li>
<li>资源管理</li>
</ul>
<h3 id="NodeManager（NM）"><a href="#NodeManager（NM）" class="headerlink" title="NodeManager（NM）"></a>NodeManager（NM）</h3><p><strong>主要功能</strong></p>
<ul>
<li>管理单个节点的资源</li>
<li>向 ResourceManager 汇报节点资源使用情况</li>
<li>管理 Container 的生命周期</li>
</ul>
<p><strong>核心组件</strong></p>
<ul>
<li>NodeStatusUpdater</li>
<li>ContainerManager</li>
<li>ContainerExecutor</li>
<li>NodeHealthCheckerService</li>
<li>Security</li>
<li>WebServer</li>
</ul>
<h3 id="ApplicationMaster（AM）"><a href="#ApplicationMaster（AM）" class="headerlink" title="ApplicationMaster（AM）"></a>ApplicationMaster（AM）</h3><p><strong>主要功能</strong></p>
<ul>
<li>管理应用程序实例</li>
<li>向 ResourceManager 申请任务执行所需的资源</li>
<li>任务调度和监管</li>
</ul>
<p><strong>实现方式</strong></p>
<ul>
<li>需要为每个应用开发一个 AM 组件</li>
<li>YARN 提供 MapReduce 的 ApplicationMaster 实现</li>
<li>采用基于事件驱动的异步编程模型，由中央事件调度器统一管理所有事件</li>
<li>每种组件都是一种事件处理器，在中央事件调度器中注册</li>
</ul>
<h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><ul>
<li>概念：Container 封装了节点上进程的相关资源，是 YARN 中资源的抽象</li>
<li>分类：运行 ApplicationMaster 的 Container 、运行应用任务的 Container</li>
</ul>
<h2 id="YARN-高可用"><a href="#YARN-高可用" class="headerlink" title="YARN 高可用"></a>YARN 高可用</h2><p>ResourceManager 高可用</p>
<ul>
<li>1 个 Active RM、多个 Standby RM</li>
<li>宕机后自动实现主备切换</li>
<li>ZooKeeper 的核心作用<ul>
<li>Active 节点选举</li>
<li>恢复 Active RM 的原有状态信息</li>
</ul>
</li>
<li>重启 AM，杀死所有运行中的 Container</li>
<li>切换方式：手动、自动</li>
</ul>
<h2 id="YARN-资源调度策略"><a href="#YARN-资源调度策略" class="headerlink" title="YARN 资源调度策略"></a>YARN 资源调度策略</h2><h3 id="FIFO-Scheduler（先进先出调度器）"><a href="#FIFO-Scheduler（先进先出调度器）" class="headerlink" title="FIFO Scheduler（先进先出调度器）"></a>FIFO Scheduler（先进先出调度器）</h3><p><strong>调度策略</strong></p>
<p>将所有任务放入一个队列，先进队列的先获得资源，排在后面的任务只有等待</p>
<p><strong>缺点</strong></p>
<ul>
<li>资源利用率低，无法交叉运行任务</li>
<li>灵活性差，如：紧急任务无法插队，耗时长的任务拖慢耗时短的任务</li>
</ul>
<h3 id="Capacity-Scheduler（容量调度器）"><a href="#Capacity-Scheduler（容量调度器）" class="headerlink" title="Capacity Scheduler（容量调度器）"></a>Capacity Scheduler（容量调度器）</h3><p><strong>核心思想</strong> - 提前<strong>做预算</strong>，在预算指导下分享集群资源。</p>
<p><strong>调度策略</strong></p>
<ul>
<li>集群资源由多个队列分享</li>
<li>每个队列都要预设资源分配的比例（提前做预算）</li>
<li>空闲资源优先分配给“实际资源&#x2F;预算资源”比值最低的队列</li>
<li>队列内部采用 FIFO 调度策略</li>
</ul>
<p><strong>特点</strong></p>
<ul>
<li>层次化的队列设计：子队列可使用父队列资源</li>
<li>容量保证：每个队列都要预设资源占比，防止资源独占</li>
<li>弹性分配：空闲资源可以分配给任何队列，当多个队列争用时，会按比例进行平衡</li>
<li>支持动态管理：可以动态调整队列的容量、权限等参数，也可动态增加、暂停队列</li>
<li>访问控制：用户只能向自己的队列中提交任务，不能访问其他队列</li>
<li>多租户：多用户共享集群资源</li>
</ul>
<h3 id="Fair-Scheduler（公平调度器）"><a href="#Fair-Scheduler（公平调度器）" class="headerlink" title="Fair Scheduler（公平调度器）"></a>Fair Scheduler（公平调度器）</h3><p><strong>调度策略</strong></p>
<ul>
<li>多队列公平共享集群资源</li>
<li>通过平分的方式，动态分配资源，无需预先设定资源分配比例</li>
<li>队列内部可配置调度策略：FIFO、Fair（默认）</li>
</ul>
<p><strong>资源抢占</strong></p>
<ul>
<li>终止其他队列的任务，使其让出所占资源，然后将资源分配给占用资源量少于最小资源量限制的队列</li>
</ul>
<p><strong>队列权重</strong></p>
<ul>
<li>当队列中有任务等待，并且集群中有空闲资源时，每个队列可以根据权重获得不同比例的空闲资源</li>
</ul>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/ac5a41/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/ac5a41/" class="post-title-link" itemprop="url">Flume</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-05-07 20:19:25" itemprop="dateCreated datePublished" datetime="2019-05-07T20:19:25+08:00">2019-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:53" itemprop="dateModified" datetime="2024-12-12T10:02:53+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/" itemprop="url" rel="index"><span itemprop="name">大数据</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%85%B6%E4%BB%96/" itemprop="url" rel="index"><span itemprop="name">其他</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Flume"><a href="#Flume" class="headerlink" title="Flume"></a>Flume</h1><blockquote>
<p><strong>Sqoop 是一个主要在 Hadoop 和关系数据库之间进行批量数据迁移的工具。</strong></p>
</blockquote>
<h2 id="Flume-简介"><a href="#Flume-简介" class="headerlink" title="Flume 简介"></a>Flume 简介</h2><h3 id="什么是-Flume-？"><a href="#什么是-Flume-？" class="headerlink" title="什么是 Flume ？"></a>什么是 Flume ？</h3><p>Flume 是一个分布式海量数据采集、聚合和传输系统。</p>
<p>特点</p>
<ul>
<li>基于事件的海量数据采集</li>
<li>数据流模型：Source -&gt; Channel -&gt; Sink</li>
<li>事务机制：支持重读重写，保证消息传递的可靠性</li>
<li>内置丰富插件：轻松与各种外部系统集成</li>
<li>高可用：Agent 主备切换</li>
<li>Java 实现：开源，优秀的系统设计</li>
</ul>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h2 id="Flume-原理"><a href="#Flume-原理" class="headerlink" title="Flume 原理"></a>Flume 原理</h2><h3 id="Flume-基本概念"><a href="#Flume-基本概念" class="headerlink" title="Flume 基本概念"></a>Flume 基本概念</h3><ul>
<li>Event：事件，最小数据传输单元，由 Header 和 Body 组成。</li>
<li>Agent：代理，JVM 进程，最小运行单元，由 Source、Channel、Sink 三个基本组件构成，负责将外部数据源产生的数据以 Event 的形式传输到目的地<ul>
<li>Source：负责对接各种外部数据源，将采集到的数据封装成 Event，然后写入 Channel</li>
<li>Channel：Event 暂存容器，负责保存 Source 发送的 Event，直至被 Sink 成功读取</li>
<li>Sink：负责从 Channel 读取 Event，然后将其写入外部存储，或传输给下一阶段的 Agent</li>
<li>映射关系：1 个 Source -&gt; 多个 Channel，1 个 Channel -&gt; 多个 Sink，1 个 Sink -&gt; 1 个 Channel</li>
</ul>
</li>
</ul>
<h3 id="Flume-基本组件"><a href="#Flume-基本组件" class="headerlink" title="Flume 基本组件"></a>Flume 基本组件</h3><h4 id="Source-组件"><a href="#Source-组件" class="headerlink" title="Source 组件"></a>Source 组件</h4><ul>
<li>对接各种外部数据源，将采集到的数据封装成 Event，然后写入 Channel</li>
<li>一个 Source 可向多个 Channel 发送 Event</li>
<li>Flume 内置类型丰富的 Source，同时用户可自定义 Source</li>
</ul>
<h4 id="Channel-组件"><a href="#Channel-组件" class="headerlink" title="Channel 组件"></a>Channel 组件</h4><ul>
<li>Event 中转暂存区，存储 Source 采集但未被 Sink 读取的 Event</li>
<li>为了平衡 Source 采集、Sink 读取的速度，可视为 Flume 内部的消息队列</li>
<li>线程安全并具有事务性，支持 Source 写失败重写和 Sink 读失败重读</li>
</ul>
<h4 id="Sink-组件"><a href="#Sink-组件" class="headerlink" title="Sink 组件"></a>Sink 组件</h4><ul>
<li>从 Channel 读取 Event，将其写入外部存储，或传输到下一阶段的 Agent</li>
<li>一个 Sink 只能从一个 Channel 中读取 Event</li>
<li>Sink 成功读取 Event 后，向 Channel 提交事务，Event 被删除，否则 Channel 会等待 Sink 重新读取</li>
</ul>
<h3 id="Flume-数据流"><a href="#Flume-数据流" class="headerlink" title="Flume 数据流"></a>Flume 数据流</h3><p>单层架构</p>
<p>优点：架构简单，使用方便，占用资源较少<br>缺点<br>如果采集的数据源或 Agent 较多，将 Event 写入到 HDFS 会产生很多小文件<br>外部存储升级维护或发生故障，需对采集层的所有 Agent 做处理，人力成本较高，系统稳定性较差<br>系统安全性较差<br>数据源管理较混乱</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/f808fc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/f808fc/" class="post-title-link" itemprop="url">HBase 运维</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-05-07 20:19:25" itemprop="dateCreated datePublished" datetime="2019-05-07T20:19:25+08:00">2019-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%88%97%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">列式数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%88%97%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/HBase/" itemprop="url" rel="index"><span itemprop="name">HBase</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="HBase-运维"><a href="#HBase-运维" class="headerlink" title="HBase 运维"></a>HBase 运维</h1><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><ul>
<li><code>backup-masters</code> - 默认情况下不存在。列出主服务器应在其上启动备份主进程的主机，每行一个主机。</li>
<li><code>hadoop-metrics2-hbase.properties</code> - 用于连接 HBase Hadoop 的 Metrics2 框架。</li>
<li><code>hbase-env.cmd</code> and hbase-env.sh - 用于 Windows 和 Linux &#x2F; Unix 环境的脚本，用于设置 HBase 的工作环境，包括 Java，Java 选项和其他环境变量的位置。</li>
<li><code>hbase-policy.xml</code> - RPC 服务器用于对客户端请求进行授权决策的默认策略配置文件。仅在启用 HBase 安全性时使用。</li>
<li><code>hbase-site.xml</code> - 主要的 HBase 配置文件。此文件指定覆盖 HBase 默认配置的配置选项。您可以在 docs &#x2F; hbase-default.xml 中查看（但不要编辑）默认配置文件。您还可以在 HBase Web UI 的 HBase 配置选项卡中查看群集的整个有效配置（默认值和覆盖）。</li>
<li><code>log4j.properties</code> - log4j 日志配置。</li>
<li><code>regionservers</code> - 包含应在 HBase 集群中运行 RegionServer 的主机列表。默认情况下，此文件包含单个条目 localhost。它应包含主机名或 IP 地址列表，每行一个，并且如果群集中的每个节点将在其 localhost 接口上运行 RegionServer，则应仅包含 localhost。</li>
</ul>
<h2 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h2><ul>
<li>Java<ul>
<li>HBase 2.0+ 要求 JDK8+</li>
<li>HBase 1.2+ 要求 JDK7+</li>
</ul>
</li>
<li>SSH - 环境要支持 SSH</li>
<li>DNS - 环境中要在 hosts 配置本机 hostname 和本机 IP</li>
<li>NTP - HBase 集群的时间要同步，可以配置统一的 NTP</li>
<li>平台 - 生产环境不推荐部署在 Windows 系统中</li>
<li>Hadoop - 依赖 Hadoop 配套版本</li>
<li>Zookeeper - 依赖 Zookeeper 配套版本</li>
</ul>
<h2 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a>运行模式</h2><h3 id="单点"><a href="#单点" class="headerlink" title="单点"></a>单点</h3><p>hbase-site.xml 配置如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://namenode.example.org:8020/hbase<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.cluster.distributed<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><p>hbase-site.xm 配置如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://namenode.example.org:8020/hbase<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.cluster.distributed<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.quorum<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>node-a.example.com,node-b.example.com,node-c.example.com<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="引用和引申"><a href="#引用和引申" class="headerlink" title="引用和引申"></a>引用和引申</h2><h3 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h3><ul>
<li><a target="_blank" rel="noopener" href="http://hbase.apache.org/book.html#configuration">Apache HBase Configuration</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/f6b642/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/f6b642/" class="post-title-link" itemprop="url">Java并发简介</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-05-06 15:33:13" itemprop="dateCreated datePublished" datetime="2019-05-06T15:33:13+08:00">2019-05-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JavaSE/%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">并发</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>11k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>10 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java-并发简介"><a href="#Java-并发简介" class="headerlink" title="Java 并发简介"></a>Java 并发简介</h1><blockquote>
<p><strong>关键词</strong>：<code>进程</code>、<code>线程</code>、<code>安全性</code>、<code>活跃性</code>、<code>性能</code>、<code>死锁</code>、<code>饥饿</code>、<code>上下文切换</code></p>
<p><strong>摘要</strong>：并发编程并非 Java 语言所独有，而是一种成熟的编程范式，Java 只是用自己的方式实现了并发工作模型。学习 Java 并发编程，应该先熟悉并发的基本概念，然后进一步了解并发的特性以及其特性所面临的问题。掌握了这些，当学习 Java 并发工具时，才会明白它们各自是为了解决什么问题，为什么要这样设计。通过这样由点到面的学习方式，更容易融会贯通，将并发知识形成体系化。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200701113445.png" alt="img"></p>
<h2 id="并发概念"><a href="#并发概念" class="headerlink" title="并发概念"></a>并发概念</h2><p>并发编程中有很多术语概念相近，容易让人混淆。本节内容通过对比分析，力求让读者清晰理解其概念以及差异。</p>
<h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><p>并发和并行是最容易让新手费解的概念，那么如何理解二者呢？其最关键的差异在于：是否是<strong>同时</strong>发生：</p>
<ul>
<li><strong>并发</strong>：是指具备处理多个任务的能力，但不一定要同时。</li>
<li><strong>并行</strong>：是指具备同时处理多个任务的能力。</li>
</ul>
<p>下面是我见过最生动的说明，摘自 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/33515481/answer/58849148">并发与并行的区别是什么？——知乎的高票答案</a>：</p>
<ul>
<li>你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。</li>
<li>你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。</li>
<li>你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。</li>
</ul>
<h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><ul>
<li><strong>同步</strong>：是指在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。</li>
<li><strong>异步</strong>：则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。</li>
</ul>
<p>举例来说明：</p>
<ul>
<li>同步就像是打电话：不挂电话，通话不会结束。</li>
<li>异步就像是发短信：发完短信后，就可以做其他事；当收到回复短信时，手机会通过铃声或振动来提醒。</li>
</ul>
<h3 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h3><p>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态：</p>
<ul>
<li><strong>阻塞</strong>：是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。</li>
<li><strong>非阻塞</strong>：是指在不能立刻得到结果之前，该调用不会阻塞当前线程。</li>
</ul>
<p>举例来说明：</p>
<ul>
<li>阻塞调用就像是打电话，通话不结束，不能放下。</li>
<li>非阻塞调用就像是发短信，发完短信后，就可以做其他事，短信来了，手机会提醒。</li>
</ul>
<h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><ul>
<li><strong>进程</strong>：进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动。进程是操作系统进行资源分配的基本单位。进程可视为一个正在运行的程序。</li>
<li><strong>线程</strong>：线程是操作系统进行调度的基本单位。</li>
</ul>
<p>进程和线程的差异：</p>
<ul>
<li>一个程序至少有一个进程，一个进程至少有一个线程。</li>
<li>线程比进程划分更细，所以执行开销更小，并发性更高</li>
<li>进程是一个实体，拥有独立的资源；而同一个进程中的多个线程共享进程的资源。</li>
</ul>
<p align="center">
  <img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/concurrent/processes-vs-threads.jpg">
</p>

<p>JVM 在单个进程中运行，JVM 中的线程共享属于该进程的堆。这就是为什么几个线程可以访问同一个对象。线程共享堆并拥有自己的堆栈空间。这是一个线程如何调用一个方法以及它的局部变量是如何保持线程安全的。但是堆不是线程安全的并且为了线程安全必须进行同步。</p>
<h3 id="竞态条件和临界区"><a href="#竞态条件和临界区" class="headerlink" title="竞态条件和临界区"></a>竞态条件和临界区</h3><ul>
<li><p><strong>竞态条件（Race Condition）</strong>：当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。</p>
</li>
<li><p><strong>临界区（Critical Sections）</strong>：导致竞态条件发生的代码区称作临界区。</p>
</li>
</ul>
<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>管程（Monitor），是指管理共享变量以及对共享变量的操作过程，让他们支持并发。</p>
<p>Java 采用的是管程技术，synchronized 关键字及 wait()、notify()、notifyAll() 这三个方法都是管程的组成部分。而<strong>管程和信号量是等价的，所谓等价指的是用管程能够实现信号量，也能用信号量实现管程</strong>。</p>
<h2 id="并发的特点"><a href="#并发的特点" class="headerlink" title="并发的特点"></a>并发的特点</h2><p>技术在进步，CPU、内存、I&#x2F;O 设备的性能也在不断提高。但是，始终存在一个核心矛盾：<strong>CPU、内存、I&#x2F;O 设备存在速度差异</strong>。CPU 远快于内存，内存远快于 I&#x2F;O 设备。</p>
<p>木桶短板理论告诉我们：一只木桶能装多少水，取决于最短的那块木板。同理，程序整体性能取决于最慢的操作（即 I&#x2F;O 操作），所以单方面提高 CPU、内存的性能是无效的。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20201225170052.jpg" alt="img"></p>
<p>为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系机构、操作系统、编译程序都做出了贡献，主要体现为：</p>
<ul>
<li><strong>CPU 增加了缓存</strong>，以均衡与内存的速度差异；</li>
<li><strong>操作系统增加了进程、线程</strong>，以分时复用 CPU，进而均衡 CPU 与 I&#x2F;O 设备的速度差异；</li>
<li><strong>编译程序优化指令执行次序</strong>，使得缓存能够得到更加合理地利用。</li>
</ul>
<p>其中，进程、线程使得计算机、程序有了并发处理任务的能力。</p>
<p>并发的优点在于：</p>
<ul>
<li>提升资源利用率</li>
<li>程序响应更快</li>
</ul>
<h3 id="提升资源利用率"><a href="#提升资源利用率" class="headerlink" title="提升资源利用率"></a>提升资源利用率</h3><p>想象一下，一个应用程序需要从本地文件系统中读取和处理文件的情景。比方说，从磁盘读取一个文件需要 5 秒，处理一个文件需要 2 秒。处理两个文件则需要：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5秒读取文件A</span><br><span class="line">2秒处理文件A</span><br><span class="line">5秒读取文件B</span><br><span class="line"><span class="section">2秒处理文件B</span></span><br><span class="line"><span class="section">---------------------</span></span><br><span class="line">总共需要14秒</span><br></pre></td></tr></table></figure>

<p>从磁盘中读取文件的时候，大部分的 CPU 时间用于等待磁盘去读取数据。在这段时间里，CPU 非常的空闲。它可以做一些别的事情。通过改变操作的顺序，就能够更好的使用 CPU 资源。看下面的顺序：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5秒读取文件A</span><br><span class="line">5秒读取文件B + 2秒处理文件A</span><br><span class="line"><span class="section">2秒处理文件B</span></span><br><span class="line"><span class="section">---------------------</span></span><br><span class="line">总共需要12秒</span><br></pre></td></tr></table></figure>

<p>CPU 等待第一个文件被读取完。然后开始读取第二个文件。当第二文件在被读取的时候，CPU 会去处理第一个文件。记住，在等待磁盘读取文件的时候，CPU 大 部分时间是空闲的。</p>
<p>总的说来，CPU 能够在等待 IO 的时候做一些其他的事情。这个不一定就是磁盘 IO。它也可以是网络的 IO，或者用户输入。通常情况下，网络和磁盘的 IO 比 CPU 和内存的 IO 慢的多。</p>
<h3 id="程序响应更快"><a href="#程序响应更快" class="headerlink" title="程序响应更快"></a>程序响应更快</h3><p>将一个单线程应用程序变成多线程应用程序的另一个常见的目的是实现一个响应更快的应用程序。设想一个服务器应用，它在某一个端口监听进来的请求。当一个请求到来时，它去处理这个请求，然后再返回去监听。</p>
<p>服务器的流程如下所述：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(server is active) &#123;</span><br><span class="line">    listen <span class="keyword">for</span> request</span><br><span class="line">    process request</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个请求需要占用大量的时间来处理，在这段时间内新的客户端就无法发送请求给服务端。只有服务器在监听的时候，请求才能被接收。另一种设计是，监听线程把请求传递给工作者线程(worker thread)，然后立刻返回去监听。而工作者线程则能够处理这个请求并发送一个回复给客户端。这种设计如下所述：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(server is active) &#123;</span><br><span class="line">    listen <span class="keyword">for</span> request</span><br><span class="line">    hand request to worker thread</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式，服务端线程迅速地返回去监听。因此，更多的客户端能够发送请求给服务端。这个服务也变得响应更快。</p>
<p>桌面应用也是同样如此。如果你点击一个按钮开始运行一个耗时的任务，这个线程既要执行任务又要更新窗口和按钮，那么在任务执行的过程中，这个应用程序看起来好像没有反应一样。相反，任务可以传递给工作者线程（worker thread)。当工作者线程在繁忙地处理任务的时候，窗口线程可以自由地响应其他用户的请求。当工作者线程完成任务的时候，它发送信号给窗口线程。窗口线程便可以更新应用程序窗口，并显示任务的结果。对用户而言，这种具有工作者线程设计的程序显得响应速度更快。</p>
<h3 id="并发的问题"><a href="#并发的问题" class="headerlink" title="并发的问题"></a>并发的问题</h3><p>任何事物都有利弊，并发也不例外。</p>
<p>我们知道了并发带来的好处：提升资源利用率、程序响应更快，同时也要认识到并发带来的问题，主要有：</p>
<ul>
<li>安全性问题</li>
<li>活跃性问题</li>
<li>性能问题</li>
</ul>
<p>下面会一一讲解。</p>
<h2 id="安全性问题"><a href="#安全性问题" class="headerlink" title="安全性问题"></a>安全性问题</h2><p>并发最重要的问题是并发安全问题。</p>
<p><strong>并发安全</strong>：是指保证程序的正确性，使得并发处理结果符合预期。</p>
<p>并发安全需要保证几个基本特性：</p>
<ul>
<li><strong>可见性</strong> - 是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，<code>volatile</code> 就是负责保证可见性的。</li>
<li><strong>原子性</strong> - 简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制（加锁：<code>sychronized</code>、<code>Lock</code>）实现。</li>
<li><strong>有序性</strong> - 是保证线程内串行语义，避免指令重排等。</li>
</ul>
<h3 id="缓存导致的可见性问题"><a href="#缓存导致的可见性问题" class="headerlink" title="缓存导致的可见性问题"></a>缓存导致的可见性问题</h3><blockquote>
<p>一个线程对共享变量的修改，另外一个线程能够立刻看到，称为 <strong>可见性</strong>。</p>
</blockquote>
<p>在单核时代，所有的线程都是在一颗 CPU 上执行，CPU 缓存与内存的数据一致性容易解决。因为所有线程都是操作同一个 CPU 的缓存，一个线程对缓存的写，对另外一个线程来说一定是可见的。例如在下面的图中，线程 A 和线程 B 都是操作同一个 CPU 里面的缓存，所以线程 A 更新了变量 V 的值，那么线程 B 之后再访问变量 V，得到的一定是 V 的最新值（线程 A 写过的值）。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200701110313.png" alt="img"></p>
<p>多核时代，每颗 CPU 都有自己的缓存，这时 CPU 缓存与内存的数据一致性就没那么容易解决了，当多个线程在不同的 CPU 上执行时，这些线程操作的是不同的 CPU 缓存。比如下图中，线程 A 操作的是 CPU-1 上的缓存，而线程 B 操作的是 CPU-2 上的缓存，很明显，这个时候线程 A 对变量 V 的操作对于线程 B 而言就不具备可见性了。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200701110431.png" alt="img"></p>
<p>【示例】线程不安全的示例</p>
<p>下面我们再用一段代码来验证一下多核场景下的可见性问题。下面的代码，每执行一次 add10K() 方法，都会循环 10000 次 count+&#x3D;1 操作。在 calc() 方法中我们创建了两个线程，每个线程调用一次 add10K() 方法，我们来想一想执行 calc() 方法得到的结果应该是多少呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add10K</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(idx++ &lt; <span class="number">10000</span>) &#123;</span><br><span class="line">      count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">calc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    <span class="comment">// 创建两个线程，执行 add() 操作</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">th1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">      test.add10K();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">th2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">      test.add10K();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 启动两个线程</span></span><br><span class="line">    th1.start();</span><br><span class="line">    th2.start();</span><br><span class="line">    <span class="comment">// 等待两个线程执行结束</span></span><br><span class="line">    th1.join();</span><br><span class="line">    th2.join();</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直觉告诉我们应该是 20000，因为在单线程里调用两次 add10K() 方法，count 的值就是 20000，但实际上 calc() 的执行结果是个 10000 到 20000 之间的随机数。为什么呢？</p>
<p>我们假设线程 A 和线程 B 同时开始执行，那么第一次都会将 count&#x3D;0 读到各自的 CPU 缓存里，执行完 count+&#x3D;1 之后，各自 CPU 缓存里的值都是 1，同时写入内存后，我们会发现内存中是 1，而不是我们期望的 2。之后由于各自的 CPU 缓存里都有了 count 的值，两个线程都是基于 CPU 缓存里的 count 值来计算，所以导致最终 count 的值都是小于 20000 的。这就是缓存的可见性问题。</p>
<p>循环 10000 次 count+&#x3D;1 操作如果改为循环 1 亿次，你会发现效果更明显，最终 count 的值接近 1 亿，而不是 2 亿。如果循环 10000 次，count 的值接近 20000，原因是两个线程不是同时启动的，有一个时差。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200701110615.png" alt="img"></p>
<h3 id="线程切换带来的原子性问题"><a href="#线程切换带来的原子性问题" class="headerlink" title="线程切换带来的原子性问题"></a>线程切换带来的原子性问题</h3><p>由于 IO 太慢，早期的操作系统就发明了多进程，操作系统允许某个进程执行一小段时间（称为 <strong>时间片</strong>）。</p>
<p>在一个时间片内，如果一个进程进行一个 IO 操作，例如读个文件，这个时候该进程可以把自己标记为“休眠状态”并出让 CPU 的使用权，待文件读进内存，操作系统会把这个休眠的进程唤醒，唤醒后的进程就有机会重新获得 CPU 的使用权了。</p>
<p>这里的进程在等待 IO 时之所以会释放 CPU 使用权，是为了让 CPU 在这段等待时间里可以做别的事情，这样一来 CPU 的使用率就上来了；此外，如果这时有另外一个进程也读文件，读文件的操作就会排队，磁盘驱动在完成一个进程的读操作后，发现有排队的任务，就会立即启动下一个读操作，这样 IO 的使用率也上来了。</p>
<p>早期的操作系统基于进程来调度 CPU，不同进程间是不共享内存空间的，所以进程要做任务切换就要切换内存映射地址，而一个进程创建的所有线程，都是共享一个内存空间的，所以线程做任务切换成本就很低了。现代的操作系统都基于更轻量的线程来调度，现在我们提到的“任务切换”都是指“线程切换”。</p>
<p>Java 并发程序都是基于多线程的，自然也会涉及到任务切换，也许你想不到，任务切换竟然也是并发编程里诡异 Bug 的源头之一。任务切换的时机大多数是在时间片结束的时候，我们现在基本都使用高级语言编程，高级语言里一条语句往往需要多条 CPU 指令完成，例如上面代码中的 <code>count += 1</code>，至少需要三条 CPU 指令。</p>
<ul>
<li>指令 1：首先，需要把变量 count 从内存加载到 CPU 的寄存器；</li>
<li>指令 2：之后，在寄存器中执行 +1 操作；</li>
<li>指令 3：最后，将结果写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。</li>
</ul>
<p>操作系统做任务切换，可以发生在任何一条<strong>CPU 指令</strong>执行完，是的，是 CPU 指令，而不是高级语言里的一条语句。对于上面的三条指令来说，我们假设 count&#x3D;0，如果线程 A 在指令 1 执行完后做线程切换，线程 A 和线程 B 按照下图的序列执行，那么我们会发现两个线程都执行了 count+&#x3D;1 的操作，但是得到的结果不是我们期望的 2，而是 1。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200701110946.png" alt="img"></p>
<p>我们潜意识里面觉得 count+&#x3D;1 这个操作是一个不可分割的整体，就像一个原子一样，线程的切换可以发生在 count+&#x3D;1 之前，也可以发生在 count+&#x3D;1 之后，但就是不会发生在中间。<strong>我们把一个或者多个操作在 CPU 执行的过程中不被中断的特性称为原子性</strong>。CPU 能保证的原子操作是 CPU 指令级别的，而不是高级语言的操作符，这是违背我们直觉的地方。因此，很多时候我们需要在高级语言层面保证操作的原子性。</p>
<h3 id="编译优化带来的有序性问题"><a href="#编译优化带来的有序性问题" class="headerlink" title="编译优化带来的有序性问题"></a>编译优化带来的有序性问题</h3><p>那并发编程里还有没有其他有违直觉容易导致诡异 Bug 的技术呢？有的，就是有序性。顾名思义，有序性指的是程序按照代码的先后顺序执行。编译器为了优化性能，有时候会改变程序中语句的先后顺序，例如程序中：“a&#x3D;6；b&#x3D;7；”编译器优化后可能变成“b&#x3D;7；a&#x3D;6；”，在这个例子中，编译器调整了语句的顺序，但是不影响程序的最终结果。不过有时候编译器及解释器的优化可能导致意想不到的 Bug。</p>
<p>在 Java 领域一个经典的案例就是利用双重检查创建单例对象，例如下面的代码：在获取实例 getInstance() 的方法中，我们首先判断 instance 是否为空，如果为空，则锁定 Singleton.class 并再次检查 instance 是否为空，如果还为空则创建 Singleton 的一个实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> Singleton instance;</span><br><span class="line">  <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">          instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设有两个线程 A、B 同时调用 getInstance() 方法，他们会同时发现 <code>instance == null</code> ，于是同时对 Singleton.class 加锁，此时 JVM 保证只有一个线程能够加锁成功（假设是线程 A），另外一个线程则会处于等待状态（假设是线程 B）；线程 A 会创建一个 Singleton 实例，之后释放锁，锁释放后，线程 B 被唤醒，线程 B 再次尝试加锁，此时是可以加锁成功的，加锁成功后，线程 B 检查 <code>instance == null</code> 时会发现，已经创建过 Singleton 实例了，所以线程 B 不会再创建一个 Singleton 实例。</p>
<p>这看上去一切都很完美，无懈可击，但实际上这个 getInstance() 方法并不完美。问题出在哪里呢？出在 new 操作上，我们以为的 new 操作应该是：</p>
<ol>
<li>分配一块内存 M；</li>
<li>在内存 M 上初始化 Singleton 对象；</li>
<li>然后 M 的地址赋值给 instance 变量。</li>
</ol>
<p>但是实际上优化后的执行路径却是这样的：</p>
<ol>
<li>分配一块内存 M；</li>
<li>将 M 的地址赋值给 instance 变量；</li>
<li>最后在内存 M 上初始化 Singleton 对象。</li>
</ol>
<p>优化后会导致什么问题呢？我们假设线程 A 先执行 getInstance() 方法，当执行完指令 2 时恰好发生了线程切换，切换到了线程 B 上；如果此时线程 B 也执行 getInstance() 方法，那么线程 B 在执行第一个判断时会发现 <code>instance != null</code> ，所以直接返回 instance，而此时的 instance 是没有初始化过的，如果我们这个时候访问 instance 的成员变量就可能触发空指针异常。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200701111050.png" alt="img"></p>
<h3 id="保证并发安全的思路"><a href="#保证并发安全的思路" class="headerlink" title="保证并发安全的思路"></a>保证并发安全的思路</h3><h4 id="互斥同步（阻塞同步）"><a href="#互斥同步（阻塞同步）" class="headerlink" title="互斥同步（阻塞同步）"></a>互斥同步（阻塞同步）</h4><p>互斥同步是最常见的并发正确性保障手段。</p>
<p><strong>同步是指在多线程并发访问共享数据时，保证共享数据在同一时刻只能被一个线程访问</strong>。</p>
<p>互斥是实现同步的一种手段。临界区（Critical Sections）、互斥量（Mutex）和信号量（Semaphore）都是主要的互斥实现方式。</p>
<p>最典型的案例是使用 <code>synchronized</code> 或 <code>Lock</code> 。</p>
<p><strong>互斥同步最主要的问题是线程阻塞和唤醒所带来的性能问题</strong>，互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。</p>
<h4 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h4><p>随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。</p>
<p>为什么说乐观锁需要 <strong>硬件指令集的发展</strong> 才能进行？因为需要操作和冲突检测这两个步骤具备原子性。而这点是由硬件来完成，如果再使用互斥同步来保证就失去意义了。</p>
<p>这类乐观锁指令常见的有：</p>
<ul>
<li>测试并设置（Test-and-Set）</li>
<li>获取并增加（Fetch-and-Increment）</li>
<li>交换（Swap）</li>
<li>比较并交换（CAS）</li>
<li>加载链接、条件存储（Load-linked &#x2F; Store-Conditional）</li>
</ul>
<p>Java 典型应用场景：J.U.C 包中的原子类（基于 <code>Unsafe</code> 类的 CAS 操作）</p>
<h4 id="无同步"><a href="#无同步" class="headerlink" title="无同步"></a>无同步</h4><p>要保证线程安全，不一定非要进行同步。同步只是保证共享数据争用时的正确性，如果一个方法本来就不涉及共享数据，那么自然无须同步。</p>
<p>Java 中的 <strong>无同步方案</strong> 有：</p>
<ul>
<li><strong>可重入代码</strong> - 也叫纯代码。如果一个方法，它的 <strong>返回结果是可以预测的</strong>，即只要输入了相同的数据，就能返回相同的结果，那它就满足可重入性，当然也是线程安全的。</li>
<li><strong>线程本地存储</strong> - 使用 <strong><code>ThreadLocal</code> 为共享变量在每个线程中都创建了一个本地副本</strong>，这个副本只能被当前线程访问，其他线程无法访问，那么自然是线程安全的。</li>
</ul>
<h2 id="活跃性问题"><a href="#活跃性问题" class="headerlink" title="活跃性问题"></a>活跃性问题</h2><h3 id="死锁（Deadlock）"><a href="#死锁（Deadlock）" class="headerlink" title="死锁（Deadlock）"></a>死锁（Deadlock）</h3><h4 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h4><p>多个线程互相等待对方释放锁。</p>
<p>死锁是当线程进入无限期等待状态时发生的情况，因为所请求的锁被另一个线程持有，而另一个线程又等待第一个线程持有的另一个锁。</p>
<p align="center">
  <img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/concurrent/deadlock.png">
</p>

<h4 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h4><p>（1）按序加锁</p>
<p>当多个线程需要相同的一些锁，但是按照不同的顺序加锁，死锁就很容易发生。</p>
<p>如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生。</p>
<p>按照顺序加锁是一种有效的死锁预防机制。但是，这种方式需要你事先知道所有可能会用到的锁(译者注：并对这些锁做适当的排序)，但总有些时候是无法预知的。</p>
<p>（2）超时释放锁</p>
<p>另外一个可以避免死锁的方法是在尝试获取锁的时候加一个超时时间，这也就意味着在尝试获取锁的过程中若超过了这个时限该线程则放弃对该锁请求。若一个线程没有在给定的时限内成功获得所有需要的锁，则会进行回退并释放所有已经获得的锁，然后等待一段随机的时间再重试。这段随机的等待时间让其它线程有机会尝试获取相同的这些锁，并且让该应用在没有获得锁的时候可以继续运行(译者注：加锁超时后可以先继续运行干点其它事情，再回头来重复之前加锁的逻辑)。</p>
<p>（3）死锁检测</p>
<p>死锁检测是一个更好的死锁预防机制，它主要是针对那些不可能实现按序加锁并且锁超时也不可行的场景。</p>
<p>每当一个线程获得了锁，会在线程和锁相关的数据结构中（map、graph 等等）将其记下。除此之外，每当有线程请求锁，也需要记录在这个数据结构中。</p>
<p>当一个线程请求锁失败时，这个线程可以遍历锁的关系图看看是否有死锁发生。</p>
<p>如果检测出死锁，有两种处理手段：</p>
<ul>
<li>释放所有锁，回退，并且等待一段随机的时间后重试。这个和简单的加锁超时类似，不一样的是只有死锁已经发生了才回退，而不会是因为加锁的请求超时了。虽然有回退和等待，但是如果有大量的线程竞争同一批锁，它们还是会重复地死锁（编者注：原因同超时类似，不能从根本上减轻竞争）。</li>
<li>一个更好的方案是给这些线程设置优先级，让一个（或几个）线程回退，剩下的线程就像没发生死锁一样继续保持着它们需要的锁。如果赋予这些线程的优先级是固定不变的，同一批线程总是会拥有更高的优先级。为避免这个问题，可以在死锁发生的时候设置随机的优先级。</li>
</ul>
<h3 id="活锁（Livelock）"><a href="#活锁（Livelock）" class="headerlink" title="活锁（Livelock）"></a>活锁（Livelock）</h3><h4 id="什么是活锁"><a href="#什么是活锁" class="headerlink" title="什么是活锁"></a>什么是活锁</h4><p>活锁是一个递归的情况，两个或更多的线程会不断重复一个特定的代码逻辑。预期的逻辑通常为其他线程提供机会继续支持’this’线程。</p>
<p>想象这样一个例子：两个人在狭窄的走廊里相遇，二者都很礼貌，试图移到旁边让对方先通过。但是他们最终在没有取得任何进展的情况下左右摇摆，因为他们都在同一时间向相同的方向移动。</p>
<p align="center">
  <img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/concurrent/livelock.png">
</p>

<p>如图所示：两个线程想要通过一个 Worker 对象访问共享公共资源的情况，但是当他们看到另一个 Worker（在另一个线程上调用）也是“活动的”时，它们会尝试将该资源交给其他工作者并等待为它完成。如果最初我们让两名工作人员都活跃起来，他们将会面临活锁问题。</p>
<h4 id="避免活锁"><a href="#避免活锁" class="headerlink" title="避免活锁"></a>避免活锁</h4><p>解决“<strong>活锁</strong>”的方案很简单，谦让时，尝试等待一个随机的时间就可以了。由于等待的时间是随机的，所以同时相撞后再次相撞的概率就很低了。“等待一个随机时间”的方案虽然很简单，却非常有效，Raft 这样知名的分布式一致性算法中也用到了它。</p>
<h3 id="饥饿（Starvation）"><a href="#饥饿（Starvation）" class="headerlink" title="饥饿（Starvation）"></a>饥饿（Starvation）</h3><h4 id="什么是饥饿"><a href="#什么是饥饿" class="headerlink" title="什么是饥饿"></a>什么是饥饿</h4><ul>
<li>高优先级线程吞噬所有的低优先级线程的 CPU 时间。</li>
<li>线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。</li>
<li>线程在等待一个本身(在其上调用 wait())也处于永久等待完成的对象，因为其他线程总是被持续地获得唤醒。</li>
</ul>
<p align="center">
  <img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/concurrent/starvation-and-fairness.png">
</p>

<p>饥饿问题最经典的例子就是哲学家问题。如图所示：有五个哲学家用餐，每个人要获得两把叉子才可以就餐。当 2、4 就餐时，1、3、5 永远无法就餐，只能看着盘中的美食饥饿的等待着。</p>
<h4 id="解决饥饿"><a href="#解决饥饿" class="headerlink" title="解决饥饿"></a>解决饥饿</h4><p>Java 不可能实现 100% 的公平性，我们依然可以通过同步结构在线程间实现公平性的提高。</p>
<p>有三种方案：</p>
<ul>
<li>保证资源充足</li>
<li>公平地分配资源</li>
<li>避免持有锁的线程长时间执行</li>
</ul>
<p>这三个方案中，方案一和方案三的适用场景比较有限，因为很多场景下，资源的稀缺性是没办法解决的，持有锁的线程执行的时间也很难缩短。倒是方案二的适用场景相对来说更多一些。</p>
<p>那如何公平地分配资源呢？在并发编程里，主要是使用<strong>公平锁</strong>。所谓公平锁，是一种先来后到的方案，线程的等待是有顺序的，排在等待队列前面的线程会优先获得资源。</p>
<h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><p>并发执行一定比串行执行快吗？线程越多执行越快吗？</p>
<p>答案是：<strong>并发不一定比串行快</strong>。因为有创建线程和线程上下文切换的开销。</p>
<h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><h4 id="什么是上下文切换？"><a href="#什么是上下文切换？" class="headerlink" title="什么是上下文切换？"></a>什么是上下文切换？</h4><p>当 CPU 从执行一个线程切换到执行另一个线程时，CPU 需要保存当前线程的本地数据，程序指针等状态，并加载下一个要执行的线程的本地数据，程序指针等。这个开关被称为“上下文切换”。</p>
<h4 id="减少上下文切换的方法"><a href="#减少上下文切换的方法" class="headerlink" title="减少上下文切换的方法"></a>减少上下文切换的方法</h4><ul>
<li>无锁并发编程 - 多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的 ID 按照 Hash 算法取模分段，不同的线程处理不同段的数据。</li>
<li>CAS 算法 - Java 的 Atomic 包使用 CAS 算法来更新数据，而不需要加锁。</li>
<li>使用最少线程 - 避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态。</li>
<li>使用协程 - 在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。</li>
</ul>
<h3 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h3><h4 id="什么是资源限制"><a href="#什么是资源限制" class="headerlink" title="什么是资源限制"></a>什么是资源限制</h4><p>资源限制是指在进行并发编程时，程序的执行速度受限于计算机硬件资源或软件资源。</p>
<h4 id="资源限制引发的问题"><a href="#资源限制引发的问题" class="headerlink" title="资源限制引发的问题"></a>资源限制引发的问题</h4><p>在并发编程中，将代码执行速度加快的原则是将代码中串行执行的部分变成并发执行，但是如果将某段串行的代码并发执行，因为受限于资源，仍然在串行执行，这时候程序不仅不会加快执行，反而会更慢，因为增加了上下文切换和资源调度的时间。</p>
<h4 id="如何解决资源限制的问题"><a href="#如何解决资源限制的问题" class="headerlink" title="如何解决资源限制的问题"></a>如何解决资源限制的问题</h4><p>在资源限制情况下进行并发编程，根据不同的资源限制调整程序的并发度。</p>
<ul>
<li>对于硬件资源限制，可以考虑使用集群并行执行程序。</li>
<li>对于软件资源限制，可以考虑使用资源池将资源复用。</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>并发编程可以总结为三个核心问题：分工、同步、互斥。</p>
<ul>
<li><strong>分工</strong>：是指如何高效地拆解任务并分配给线程。</li>
<li><strong>同步</strong>：是指线程之间如何协作。</li>
<li><strong>互斥</strong>：是指保证同一时刻只允许一个线程访问共享资源。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/10484692/">《Java 并发编程实战》</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/26591326/">《Java 并发编程的艺术》</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/34907497/">《深入理解 Java 虚拟机》</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100023901">《Java 并发编程实战》</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/benefits.html">http://tutorials.jenkov.com/java-concurrency/benefits.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.logicbig.com/tutorials/core-java-tutorial/java-multi-threading/thread-deadlock.html">https://www.logicbig.com/tutorials/core-java-tutorial/java-multi-threading/thread-deadlock.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.logicbig.com/tutorials/core-java-tutorial/java-multi-threading/thread-livelock.html">https://www.logicbig.com/tutorials/core-java-tutorial/java-multi-threading/thread-livelock.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.logicbig.com/tutorials/core-java-tutorial/java-multi-threading/thread-starvation.html">https://www.logicbig.com/tutorials/core-java-tutorial/java-multi-threading/thread-starvation.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/33515481">https://www.zhihu.com/question/33515481</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/yaosiming2011/article/details/44280797">https://blog.csdn.net/yaosiming2011/article/details/44280797</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/55d693/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/55d693/" class="post-title-link" itemprop="url">深入理解 Java 基本数据类型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-05-06 15:02:02" itemprop="dateCreated datePublished" datetime="2019-05-06T15:02:02+08:00">2019-05-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JavaSE/%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7/" itemprop="url" rel="index"><span itemprop="name">基础特性</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>16k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>14 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="深入理解-Java-基本数据类型"><a href="#深入理解-Java-基本数据类型" class="headerlink" title="深入理解 Java 基本数据类型"></a>深入理解 Java 基本数据类型</h1><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220408172602.png" alt="img"></p>
<h2 id="数据类型分类"><a href="#数据类型分类" class="headerlink" title="数据类型分类"></a>数据类型分类</h2><p>Java 中的数据类型有两类：</p>
<ul>
<li>值类型（又叫内置数据类型，基本数据类型）</li>
<li>引用类型（除值类型以外，都是引用类型，包括 <code>String</code>、数组）</li>
</ul>
<h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><p>Java 语言提供了 <strong>8</strong> 种基本类型，大致分为 <strong>4</strong> 类</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>分类</th>
<th>比特数</th>
<th>默认值</th>
<th>取值范围</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><strong>布尔型</strong></td>
<td>8 位</td>
<td><code>false</code></td>
<td>{false, true}</td>
<td></td>
</tr>
<tr>
<td><code>char</code></td>
<td><strong>字符型</strong></td>
<td>16 位</td>
<td><code>&#39;\u0000&#39;</code></td>
<td>[0, $2^{16} - 1$]</td>
<td>存储 Unicode 码，用单引号赋值</td>
</tr>
<tr>
<td><code>byte</code></td>
<td><strong>整数型</strong></td>
<td>8 位</td>
<td><code>0</code></td>
<td>[-$2^7$, $2^7 - 1$]</td>
<td></td>
</tr>
<tr>
<td><code>short</code></td>
<td><strong>整数型</strong></td>
<td>16 位</td>
<td><code>0</code></td>
<td>[-$2^{15}$, $2^{15} - 1$]</td>
<td></td>
</tr>
<tr>
<td><code>int</code></td>
<td><strong>整数型</strong></td>
<td>32 位</td>
<td><code>0</code></td>
<td>[-$2^{31}$, $2^{31} - 1$]</td>
<td></td>
</tr>
<tr>
<td><code>long</code></td>
<td><strong>整数型</strong></td>
<td>64 位</td>
<td><code>0L</code></td>
<td>[-$2^{63}$, $2^{63} - 1$]</td>
<td>赋值时一般在数字后加上 <code>l</code> 或 <code>L</code></td>
</tr>
<tr>
<td><code>float</code></td>
<td><strong>浮点型</strong></td>
<td>32 位</td>
<td><code>+0.0F</code></td>
<td>[$2^{-149}$, $2^{128} - 1$]</td>
<td>赋值时必须在数字后加上 <code>f</code> 或 <code>F</code></td>
</tr>
<tr>
<td><code>double</code></td>
<td><strong>浮点型</strong></td>
<td>64 位</td>
<td><code>+0.0D</code></td>
<td>[$2^{-1074}$, $2^{1024} - 1$]</td>
<td>赋值时一般在数字后加 <code>d</code> 或 <code>D</code></td>
</tr>
</tbody></table>
<p>尽管各种数据类型的默认值看起来不一样，但在内存中都是 0。</p>
<p>在这些基本类型中，<code>boolean</code> 和 <code>char</code> 是唯二的无符号类型。</p>
<h3 id="值类型和引用类型的区别"><a href="#值类型和引用类型的区别" class="headerlink" title="值类型和引用类型的区别"></a>值类型和引用类型的区别</h3><ul>
<li>从概念方面来说<ul>
<li>基本类型：变量名指向具体的数值。</li>
<li>引用类型：变量名指向存数据对象的内存地址。</li>
</ul>
</li>
<li>从内存方面来说<ul>
<li>基本类型：变量在声明之后，Java 就会立刻分配给他内存空间。</li>
<li>引用类型：它以特殊的方式（类似 C 指针）向对象实体（具体的值），这类变量声明时不会分配内存，只是存储了一个内存地址。</li>
</ul>
</li>
<li>从使用方面来说<ul>
<li>基本类型：使用时需要赋具体值,判断时使用 <code>==</code> 号。</li>
<li>引用类型：使用时可以赋 null，判断时使用 <code>equals</code> 方法。</li>
</ul>
</li>
</ul>
<blockquote>
<p>👉 扩展阅读：<a target="_blank" rel="noopener" href="https://juejin.im/post/59cd71835188255d3448faf6">Java 基本数据类型和引用类型</a></p>
<p>这篇文章对于基本数据类型和引用类型的内存存储讲述比较生动。</p>
</blockquote>
<h2 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h2><p>Java 中，数据类型转换有两种方式：</p>
<ul>
<li>自动转换</li>
<li>强制转换</li>
</ul>
<h3 id="自动转换"><a href="#自动转换" class="headerlink" title="自动转换"></a>自动转换</h3><p>一般情况下，定义了某数据类型的变量，就不能再随意转换。但是 JAVA 允许用户对基本类型做<strong>有限度</strong>的类型转换。</p>
<p>如果符合以下条件，则 JAVA 将会自动做类型转换：</p>
<ul>
<li><p><strong>由小数据转换为大数据</strong></p>
<p>显而易见的是，“小”数据类型的数值表示范围小于“大”数据类型的数值表示范围，即精度小于“大”数据类型。</p>
<p>所以，如果“大”数据向“小”数据转换，会丢失数据精度。比如：long 转为 int，则超出 int 表示范围的数据将会丢失，导致结果的不确定性。</p>
<p>反之，“小”数据向“大”数据转换，则不会存在数据丢失情况。由于这个原因，这种类型转换也称为<strong>扩大转换</strong>。</p>
<p>这些类型由“小”到“大”分别为：(byte，short，char) &lt; int &lt; long &lt; float &lt; double。</p>
<p>这里我们所说的“大”与“小”，并不是指占用字节的多少，而是指表示值的范围的大小。</p>
</li>
<li><p><strong>转换前后的数据类型要兼容</strong></p>
<p>由于 boolean 类型只能存放 true 或 false，这与整数或字符是不兼容的，因此不可以做类型转换。</p>
</li>
<li><p><strong>整型类型和浮点型进行计算后，结果会转为浮点类型</strong></p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">14.3f</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;x/y = &quot;</span> + x/y);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">x</span>/y = <span class="number">1</span>.<span class="number">9607843</span></span><br></pre></td></tr></table></figure>

<p>可见 long 虽然精度大于 float 类型，但是结果为浮点数类型。</p>
<h3 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h3><p>在不符合自动转换条件时或者根据用户的需要，可以对数据类型做强制的转换。</p>
<p><strong>强制转换使用括号 <code>()</code> 。</strong></p>
<p>引用类型也可以使用强制转换。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">25.5f</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (<span class="type">int</span>)f;</span><br><span class="line">System.out.println(<span class="string">&quot;x = &quot;</span> + x);</span><br></pre></td></tr></table></figure>

<h2 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h2><h3 id="包装类、装箱、拆箱"><a href="#包装类、装箱、拆箱" class="headerlink" title="包装类、装箱、拆箱"></a>包装类、装箱、拆箱</h3><p>Java 中为每一种基本数据类型提供了相应的包装类，如下：</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">B<span class="function"><span class="title">yte</span> &lt;-&gt;</span> byte</span><br><span class="line">S<span class="function"><span class="title">hort</span> &lt;-&gt;</span> short</span><br><span class="line">I<span class="function"><span class="title">nteger</span> &lt;-&gt;</span> int</span><br><span class="line">L<span class="function"><span class="title">ong</span> &lt;-&gt;</span> long</span><br><span class="line">F<span class="function"><span class="title">loat</span> &lt;-&gt;</span> float</span><br><span class="line">D<span class="function"><span class="title">ouble</span> &lt;-&gt;</span> double</span><br><span class="line">C<span class="function"><span class="title">haracter</span> &lt;-&gt;</span> char</span><br><span class="line">B<span class="function"><span class="title">oolean</span> &lt;-&gt;</span> <span class="keyword">boolean</span></span><br></pre></td></tr></table></figure>

<p><strong>引入包装类的目的</strong>就是：提供一种机制，使得<strong>基本数据类型可以与引用类型互相转换</strong>。</p>
<p>基本数据类型与包装类的转换被称为<code>装箱</code>和<code>拆箱</code>。</p>
<ul>
<li><strong><code>装箱</code>（boxing）是将值类型转换为引用类型</strong>。例如：<code>int</code> 转 <code>Integer</code><ul>
<li>装箱过程是通过调用包装类的 <code>valueOf</code> 方法实现的。</li>
</ul>
</li>
<li><strong><code>拆箱</code>（unboxing）是将引用类型转换为值类型</strong>。例如：<code>Integer</code> 转 <code>int</code><ul>
<li>拆箱过程是通过调用包装类的 <code>xxxValue</code> 方法实现的。（xxx 代表对应的基本数据类型）。</li>
</ul>
</li>
</ul>
<h3 id="自动装箱、自动拆箱"><a href="#自动装箱、自动拆箱" class="headerlink" title="自动装箱、自动拆箱"></a>自动装箱、自动拆箱</h3><p>基本数据（Primitive）型的自动装箱（boxing）拆箱（unboxing）自 JDK 5 开始提供的功能。</p>
<p>自动装箱与拆箱的机制可以让我们在 Java 的变量赋值或者是方法调用等情况下使用原始类型或者对象类型更加简单直接。<br>因为自动装箱会隐式地创建对象，如果在一个循环体中，会创建无用的中间对象，这样会增加 GC 压力，拉低程序的性能。所以在写循环时一定要注意代码，避免引入不必要的自动装箱操作。</p>
<p>JDK 5 之前的形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>); <span class="comment">// 非自动装箱</span></span><br></pre></td></tr></table></figure>

<p>JDK 5 之后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 自动装箱</span></span><br></pre></td></tr></table></figure>

<p>Java 对于自动装箱和拆箱的设计，依赖于一种叫做享元模式的设计模式（有兴趣的朋友可以去了解一下源码，这里不对设计模式展开详述）。</p>
<blockquote>
<p>👉 扩展阅读：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/dolphin0520/p/3780005.html">深入剖析 Java 中的装箱和拆箱</a></p>
<p>结合示例，一步步阐述装箱和拆箱原理。</p>
</blockquote>
<h3 id="装箱、拆箱的应用和注意点"><a href="#装箱、拆箱的应用和注意点" class="headerlink" title="装箱、拆箱的应用和注意点"></a>装箱、拆箱的应用和注意点</h3><h4 id="装箱、拆箱应用场景"><a href="#装箱、拆箱应用场景" class="headerlink" title="装箱、拆箱应用场景"></a>装箱、拆箱应用场景</h4><ul>
<li>一种最普通的场景是：调用一个<strong>含类型为 <code>Object</code> 参数的方法</strong>，该 <code>Object</code> 可支持任意类型（因为 <code>Object</code> 是所有类的父类），以便通用。当你需要将一个值类型（如 int）传入时，需要使用 <code>Integer</code> 装箱。</li>
<li>另一种用法是：一个<strong>非泛型的容器</strong>，同样是为了保证通用，而将元素类型定义为 <code>Object</code>。于是，要将值类型数据加入容器时，需要装箱。</li>
<li>当 <code>==</code> 运算符的两个操作，一个操作数是包装类，另一个操作数是表达式（即包含算术运算）则比较的是数值（即会触发自动拆箱的过程）。</li>
</ul>
<p>【示例】装箱、拆箱示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 自动装箱</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>); <span class="comment">// 非自动装箱</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> Integer.valueOf(<span class="number">10</span>); <span class="comment">// 非自动装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>); <span class="comment">// 自动拆箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i5</span> <span class="operator">=</span> i2.intValue(); <span class="comment">// 非自动拆箱</span></span><br><span class="line">System.out.println(<span class="string">&quot;i1 = [&quot;</span> + i1 + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;i2 = [&quot;</span> + i2 + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;i3 = [&quot;</span> + i3 + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;i4 = [&quot;</span> + i4 + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;i5 = [&quot;</span> + i5 + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;i1 == i2 is [&quot;</span> + (i1 == i2) + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;i1 == i4 is [&quot;</span> + (i1 == i4) + <span class="string">&quot;]&quot;</span>); <span class="comment">// 自动拆箱</span></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// i1 = [10]</span></span><br><span class="line"><span class="comment">// i2 = [10]</span></span><br><span class="line"><span class="comment">// i3 = [10]</span></span><br><span class="line"><span class="comment">// i4 = [10]</span></span><br><span class="line"><span class="comment">// i5 = [10]</span></span><br><span class="line"><span class="comment">// i1 == i2 is [false]</span></span><br><span class="line"><span class="comment">// i1 == i4 is [true]</span></span><br></pre></td></tr></table></figure>

<p>【说明】</p>
<p>上面的例子，虽然简单，但却隐藏了自动装箱、拆箱和非自动装箱、拆箱的应用。从例子中可以看到，明明所有变量都初始化为数值 10 了，但为何会出现 <code>i1 == i2 is [false</code> 而 <code>i1 == i4 is [true]</code> ？</p>
<p>原因在于：</p>
<ul>
<li>i1、i2 都是包装类，使用 <code>==</code> 时，Java 将它们当做两个对象，而非两个 int 值来比较，所以两个对象自然是不相等的。正确的比较操作应该使用 <code>equals</code> 方法。</li>
<li>i1 是包装类，i4 是基础数据类型，使用 <code>==</code> 时，Java 会将两个 i1 这个包装类对象自动拆箱为一个 <code>int</code> 值，再代入到 <code>==</code> 运算表达式中计算；最终，相当于两个 <code>int</code> 进行比较，由于值相同，所以结果相等。</li>
</ul>
<p>【示例】包装类判等问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">127</span>; <span class="comment">//Integer.valueOf(127)</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">127</span>; <span class="comment">//Integer.valueOf(127)</span></span><br><span class="line">log.info(<span class="string">&quot;\nInteger a = 127;\nInteger b = 127;\na == b ? &#123;&#125;&quot;</span>, a == b);    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">128</span>; <span class="comment">//Integer.valueOf(128)</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">128</span>; <span class="comment">//Integer.valueOf(128)</span></span><br><span class="line">log.info(<span class="string">&quot;\nInteger c = 128;\nInteger d = 128;\nc == d ? &#123;&#125;&quot;</span>, c == d);   <span class="comment">//false</span></span><br><span class="line"><span class="comment">//设置-XX:AutoBoxCacheMax=1000再试试</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">e</span> <span class="operator">=</span> <span class="number">127</span>; <span class="comment">//Integer.valueOf(127)</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">127</span>); <span class="comment">//new instance</span></span><br><span class="line">log.info(<span class="string">&quot;\nInteger e = 127;\nInteger f = new Integer(127);\ne == f ? &#123;&#125;&quot;</span>, e == f);   <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">127</span>); <span class="comment">//new instance</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">127</span>); <span class="comment">//new instance</span></span><br><span class="line">log.info(<span class="string">&quot;\nInteger g = new Integer(127);\nInteger h = new Integer(127);\ng == h ? &#123;&#125;&quot;</span>, g == h);  <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">128</span>; <span class="comment">//unbox</span></span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">log.info(<span class="string">&quot;\nInteger i = 128;\nint j = 128;\ni == j ? &#123;&#125;&quot;</span>, i == j); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>通过运行结果可以看到，虽然看起来永远是在对 127 和 127、128 和 128 判等，但 &#x3D;&#x3D; 却并非总是返回 true。</p>
<h4 id="装箱、拆箱应用注意点"><a href="#装箱、拆箱应用注意点" class="headerlink" title="装箱、拆箱应用注意点"></a>装箱、拆箱应用注意点</h4><ol>
<li>装箱操作会创建对象，频繁的装箱操作会造成不必要的内存消耗，影响性能。所以<strong>应该尽量避免装箱。</strong></li>
<li>基础数据类型的比较操作使用 <code>==</code>，包装类的比较操作使用 <code>equals</code> 方法。</li>
</ol>
<h2 id="判等问题"><a href="#判等问题" class="headerlink" title="判等问题"></a>判等问题</h2><p>Java 中，通常使用 <code>equals</code> 或 <code>==</code> 进行判等操作。<code>equals</code> 是方法而 <code>==</code> 是操作符。此外，二者使用也是有区别的：</p>
<ul>
<li>对<strong>基本类型</strong>，比如 <code>int</code>、<code>long</code>，进行判等，<strong>只能使用 <code>==</code>，比较的是字面值</strong>。因为基本类型的值就是其数值。</li>
<li>对<strong>引用类型</strong>，比如 <code>Integer</code>、<code>Long</code> 和 <code>String</code>，进行判等，<strong>需要使用 <code>equals</code> 进行内容判等</strong>。因为引用类型的直接值是指针，使用 <code>==</code> 的话，比较的是指针，也就是两个对象在内存中的地址，即比较它们是不是同一个对象，而不是比较对象的内容。</li>
</ul>
<h3 id="包装类的判等"><a href="#包装类的判等" class="headerlink" title="包装类的判等"></a>包装类的判等</h3><p>我们通过一个示例来深入研究一下判等问题。</p>
<p>【示例】包装类的判等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">127</span>; <span class="comment">//Integer.valueOf(127)</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">127</span>; <span class="comment">//Integer.valueOf(127)</span></span><br><span class="line">log.info(<span class="string">&quot;\nInteger a = 127;\nInteger b = 127;\na == b ? &#123;&#125;&quot;</span>, a == b);    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">128</span>; <span class="comment">//Integer.valueOf(128)</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">128</span>; <span class="comment">//Integer.valueOf(128)</span></span><br><span class="line">log.info(<span class="string">&quot;\nInteger c = 128;\nInteger d = 128;\nc == d ? &#123;&#125;&quot;</span>, c == d);   <span class="comment">//false</span></span><br><span class="line"><span class="comment">//设置-XX:AutoBoxCacheMax=1000再试试</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">e</span> <span class="operator">=</span> <span class="number">127</span>; <span class="comment">//Integer.valueOf(127)</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">127</span>); <span class="comment">//new instance</span></span><br><span class="line">log.info(<span class="string">&quot;\nInteger e = 127;\nInteger f = new Integer(127);\ne == f ? &#123;&#125;&quot;</span>, e == f);   <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">127</span>); <span class="comment">//new instance</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">127</span>); <span class="comment">//new instance</span></span><br><span class="line">log.info(<span class="string">&quot;\nInteger g = new Integer(127);\nInteger h = new Integer(127);\ng == h ? &#123;&#125;&quot;</span>, g == h);  <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">128</span>; <span class="comment">//unbox</span></span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">log.info(<span class="string">&quot;\nInteger i = 128;\nint j = 128;\ni == j ? &#123;&#125;&quot;</span>, i == j); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>第一个案例中，编译器会把 Integer a &#x3D; 127 转换为 Integer.valueOf(127)。查看源码可以发现，这个转换在内部其实做了缓存，使得两个 Integer 指向同一个对象，所以 &#x3D;&#x3D; 返回 true。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个案例中，之所以同样的代码 128 就返回 false 的原因是，默认情况下会缓存[-128,127]的数值，而 128 处于这个区间之外。设置 JVM 参数加上 -XX:AutoBoxCacheMax&#x3D;1000 再试试，是不是就返回 true 了呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">integerCacheHighPropValue</span> <span class="operator">=</span></span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> <span class="title class_">Integer</span>[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> <span class="title class_">Integer</span>(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">IntegerCache</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三和第四个案例中，New 出来的 Integer 始终是不走缓存的新对象。比较两个新对象，或者比较一个新对象和一个来自缓存的对象，结果肯定不是相同的对象，因此返回 false。</p>
<p>第五个案例中，我们把装箱的 Integer 和基本类型 int 比较，前者会先拆箱再比较，比较的肯定是数值而不是引用，因此返回 true。</p>
<blockquote>
<p>【总结】综上，我们可以得出结论：**包装类需要使用 <code>equals</code> 进行内容判等，而不能使用 <code>==</code>**。</p>
</blockquote>
<h3 id="String-的判等"><a href="#String-的判等" class="headerlink" title="String 的判等"></a>String 的判等</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">log.info(<span class="string">&quot;\nString a = \&quot;1\&quot;;\nString b = \&quot;1\&quot;;\na == b ? &#123;&#125;&quot;</span>, a == b); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">log.info(<span class="string">&quot;\nString c = new String(\&quot;2\&quot;);\nString d = new String(\&quot;2\&quot;);\nc == d ? &#123;&#125;&quot;</span>, c == d); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;3&quot;</span>).intern();</span><br><span class="line"><span class="type">String</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;3&quot;</span>).intern();</span><br><span class="line">log.info(<span class="string">&quot;\nString e = new String(\&quot;3\&quot;).intern();\nString f = new String(\&quot;3\&quot;).intern();\ne == f ? &#123;&#125;&quot;</span>, e == f); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;4&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">log.info(<span class="string">&quot;\nString g = new String(\&quot;4\&quot;);\nString h = new String(\&quot;4\&quot;);\ng == h ? &#123;&#125;&quot;</span>, g.equals(h)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>在 JVM 中，当代码中出现双引号形式创建字符串对象时，JVM 会先对这个字符串进行检查，如果字符串常量池中存在相同内容的字符串对象的引用，则将这个引用返回；否则，创建新的字符串对象，然后将这个引用放入字符串常量池，并返回该引用。这种机制，就是字符串驻留或池化。</p>
<p>第一个案例返回 true，因为 Java 的字符串驻留机制，直接使用双引号声明出来的两个 String 对象指向常量池中的相同字符串。</p>
<p>第二个案例，new 出来的两个 String 是不同对象，引用当然不同，所以得到 false 的结果。</p>
<p>第三个案例，使用 String 提供的 intern 方法也会走常量池机制，所以同样能得到 true。</p>
<p>第四个案例，通过 equals 对值内容判等，是正确的处理方式，当然会得到 true。</p>
<p>虽然使用 new 声明的字符串调用 intern 方法，也可以让字符串进行驻留，但在业务代码中滥用 intern，可能会产生性能问题。</p>
<p>【示例】String#intern 性能测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-XX:+PrintStringTableStatistics</span></span><br><span class="line"><span class="comment">//-XX:StringTableSize=10000000</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">list = IntStream.rangeClosed(<span class="number">1</span>, <span class="number">10000000</span>)</span><br><span class="line">    .mapToObj(i -&gt; String.valueOf(i).intern())</span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line">System.out.println(<span class="string">&quot;size:&quot;</span> + list.size());</span><br><span class="line">System.out.println(<span class="string">&quot;time:&quot;</span> + (System.currentTimeMillis() - begin));</span><br></pre></td></tr></table></figure>

<p>上面的示例执行时间会比较长。原因在于：字符串常量池是一个固定容量的 Map。如果容量太小（Number of<br>buckets&#x3D;60013）、字符串太多（1000 万个字符串），那么每一个桶中的字符串数量会非常多，所以搜索起来就很慢。输出结果中的 Average bucket size&#x3D;167，代表了 Map 中桶的平均长度是 167。</p>
<p>解决方法是：设置 JVM 参数 -XX:StringTableSize&#x3D;10000000，指定更多的桶。</p>
<p>为了方便观察，可以在启动程序时设置 JVM 参数 -XX:+PrintStringTableStatistic，程序退出时可以打印出字符串常量表的统计信息。</p>
<p>执行结果比不设置 -XX:StringTableSize 要快很多。</p>
<blockquote>
<p>【总结】<strong>没事别轻易用 intern，如果要用一定要注意控制驻留的字符串的数量，并留意常量表的各项指标</strong>。</p>
</blockquote>
<h3 id="实现-equals"><a href="#实现-equals" class="headerlink" title="实现 equals"></a>实现 equals</h3><p>如果看过 Object 类源码，你可能就知道，equals 的实现其实是比较对象引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之所以 Integer 或 String 能通过 equals 实现内容判等，是因为它们都覆写了这个方法。</p>
<p>对于自定义类型，如果不覆写 equals 的话，默认就是使用 Object 基类的按引用的比较方式。</p>
<p>实现一个更好的 equals 应该注意的点：</p>
<ul>
<li>考虑到性能，可以先进行指针判等，如果对象是同一个那么直接返回 true；</li>
<li>需要对另一方进行判空，空对象和自身进行比较，结果一定是 fasle；</li>
<li>需要判断两个对象的类型，如果类型都不同，那么直接返回 false；</li>
<li>确保类型相同的情况下再进行类型强制转换，然后逐一判断所有字段。</li>
</ul>
<p>【示例】自定义 equals 示例</p>
<p>自定义类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义 equals：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Point</span> <span class="variable">that</span> <span class="operator">=</span> (Point) o;</span><br><span class="line">    <span class="keyword">return</span> x == that.x &amp;&amp; y == that.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="hashCode-和-equals-要配对实现"><a href="#hashCode-和-equals-要配对实现" class="headerlink" title="hashCode 和 equals 要配对实现"></a>hashCode 和 equals 要配对实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Point</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="type">Point</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">HashSet&lt;PointWrong&gt; points = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">points.add(p1);</span><br><span class="line">log.info(<span class="string">&quot;points.contains(p2) ? &#123;&#125;&quot;</span>, points.contains(p2));</span><br></pre></td></tr></table></figure>

<p>按照改进后的 equals 方法，这 2 个对象可以认为是同一个，Set 中已经存在了 p1 就应该包含 p2，但结果却是 false。</p>
<p>出现这个 Bug 的原因是，散列表需要使用 hashCode 来定位元素放到哪个桶。如果自定义对象没有实现自定义的 hashCode 方法，就会使用 Object 超类的默认实现，得到的两个 hashCode 是不同的，导致无法满足需求。</p>
<p>要自定义 hashCode，我们可以直接使用 Objects.hash 方法来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hash(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="compareTo-和-equals-的逻辑一致性"><a href="#compareTo-和-equals-的逻辑一致性" class="headerlink" title="compareTo 和 equals 的逻辑一致性"></a>compareTo 和 equals 的逻辑一致性</h3><p>【示例】自定义 compareTo 出错示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student other)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.compare(other.id, id);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">0</span>) &#123; log.info(<span class="string">&quot;this &#123;&#125; == other &#123;&#125;&quot;</span>, <span class="built_in">this</span>, other); &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">1</span>, <span class="string">&quot;zhang&quot;</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">2</span>, <span class="string">&quot;wang&quot;</span>));</span><br><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">2</span>, <span class="string">&quot;li&quot;</span>);</span><br><span class="line"></span><br><span class="line">log.info(<span class="string">&quot;ArrayList.indexOf&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">index1</span> <span class="operator">=</span> list.indexOf(student);</span><br><span class="line">Collections.sort(list);</span><br><span class="line">log.info(<span class="string">&quot;Collections.binarySearch&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">index2</span> <span class="operator">=</span> Collections.binarySearch(list, student);</span><br><span class="line"></span><br><span class="line">log.info(<span class="string">&quot;index1 = &quot;</span> + index1);</span><br><span class="line">log.info(<span class="string">&quot;index2 = &quot;</span> + index2);</span><br></pre></td></tr></table></figure>

<p>binarySearch 方法内部调用了元素的 compareTo 方法进行比较；</p>
<ul>
<li>indexOf 的结果没问题，列表中搜索不到 id 为 2、name 是 li 的学生；</li>
<li>binarySearch 返回了索引 1，代表搜索到的结果是 id 为 2，name 是 wang 的学生。</li>
</ul>
<p>修复方式很简单，确保 compareTo 的比较逻辑和 equals 的实现一致即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StudentRight</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;StudentRight&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(StudentRight other)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Comparator.comparing(StudentRight::getName)</span><br><span class="line">            .thenComparingInt(StudentRight::getId)</span><br><span class="line">            .compare(<span class="built_in">this</span>, other);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小心-Lombok-生成代码的“坑”"><a href="#小心-Lombok-生成代码的“坑”" class="headerlink" title="小心 Lombok 生成代码的“坑”"></a>小心 Lombok 生成代码的“坑”</h3><p>Lombok 的 @Data 注解会帮我们实现 equals 和 hashcode 方法，但是有继承关系时，<br>Lombok 自动生成的方法可能就不是我们期望的了。</p>
<p>@EqualsAndHashCode 默认实现没有使用父类属性。为解决这个问题，我们可以手动设置 callSuper 开关为 true，来覆盖这种默认行为。</p>
<h2 id="数值计算"><a href="#数值计算" class="headerlink" title="数值计算"></a>数值计算</h2><h3 id="浮点数计算问题"><a href="#浮点数计算问题" class="headerlink" title="浮点数计算问题"></a>浮点数计算问题</h3><p>计算机是把数值保存在了变量中，不同类型的数值变量能保存的数值范围不同，当数值超过类型能表达的数值上限则会发生溢出问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">0.1</span> + <span class="number">0.2</span>); <span class="comment">// 0.30000000000000004</span></span><br><span class="line">System.out.println(<span class="number">1.0</span> - <span class="number">0.8</span>); <span class="comment">// 0.19999999999999996</span></span><br><span class="line">System.out.println(<span class="number">4.015</span> * <span class="number">100</span>); <span class="comment">// 401.49999999999994</span></span><br><span class="line">System.out.println(<span class="number">123.3</span> / <span class="number">100</span>); <span class="comment">// 1.2329999999999999</span></span><br><span class="line"><span class="type">double</span> <span class="variable">amount1</span> <span class="operator">=</span> <span class="number">2.15</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">amount2</span> <span class="operator">=</span> <span class="number">1.10</span>;</span><br><span class="line">System.out.println(amount1 - amount2); <span class="comment">// 1.0499999999999998</span></span><br></pre></td></tr></table></figure>

<p>上面的几个示例，输出结果和我们预期的很不一样。为什么会是这样呢？</p>
<p>出现这种问题的主要原因是，计算机是以二进制存储数值的，浮点数也不例外。Java 采用了 IEEE 754 标准实现浮点数的表达和运算，你可以通过这里查看数值转化为二进制的结果。</p>
<p>比如，0.1 的二进制表示为 0.0 0011 0011 0011… （0011 无限循环)，再转换为十进制就是 0.1000000000000000055511151231257827021181583404541015625。对于计算机而言，0.1 无法精确表达，这是浮点数计算造成精度损失的根源。</p>
<p><strong>浮点数无法精确表达和运算的场景，一定要使用 BigDecimal 类型</strong>。</p>
<p>使用 BigDecimal 时，有个细节要格外注意。让我们来看一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">0.1</span>).add(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">0.2</span>)));</span><br><span class="line"><span class="comment">// Output: 0.3000000000000000166533453693773481063544750213623046875</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">1.0</span>).subtract(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">0.8</span>)));</span><br><span class="line"><span class="comment">// Output: 0.1999999999999999555910790149937383830547332763671875</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">4.015</span>).multiply(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">100</span>)));</span><br><span class="line"><span class="comment">// Output: 401.49999999999996802557689079549163579940795898437500</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">123.3</span>).divide(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">100</span>)));</span><br><span class="line"><span class="comment">// Output: 1.232999999999999971578290569595992565155029296875</span></span><br></pre></td></tr></table></figure>

<p>为什么输出结果仍然不符合预期呢？</p>
<p><strong>使用 BigDecimal 表示和计算浮点数，且务必使用字符串的构造方法来初始化 BigDecimal</strong>。</p>
<h3 id="浮点数精度和格式化"><a href="#浮点数精度和格式化" class="headerlink" title="浮点数精度和格式化"></a>浮点数精度和格式化</h3><p><strong>浮点数的字符串格式化也要通过 BigDecimal 进行</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">wrong1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">3.35</span>;</span><br><span class="line">    <span class="type">float</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">3.35f</span>;</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;%.1f&quot;</span>, num1)); <span class="comment">// 3.4</span></span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;%.1f&quot;</span>, num2)); <span class="comment">// 3.3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">wrong2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">3.35</span>;</span><br><span class="line">    <span class="type">float</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">3.35f</span>;</span><br><span class="line">    <span class="type">DecimalFormat</span> <span class="variable">format</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;#.##&quot;</span>);</span><br><span class="line">    format.setRoundingMode(RoundingMode.DOWN);</span><br><span class="line">    System.out.println(format.format(num1)); <span class="comment">// 3.35</span></span><br><span class="line">    format.setRoundingMode(RoundingMode.DOWN);</span><br><span class="line">    System.out.println(format.format(num2)); <span class="comment">// 3.34</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">right</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;3.35&quot;</span>);</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">num2</span> <span class="operator">=</span> num1.setScale(<span class="number">1</span>, BigDecimal.ROUND_DOWN);</span><br><span class="line">    System.out.println(num2); <span class="comment">// 3.3</span></span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">num3</span> <span class="operator">=</span> num1.setScale(<span class="number">1</span>, BigDecimal.ROUND_HALF_UP);</span><br><span class="line">    System.out.println(num3); <span class="comment">// 3.4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BigDecimal-判等问题"><a href="#BigDecimal-判等问题" class="headerlink" title="BigDecimal 判等问题"></a>BigDecimal 判等问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">wrong</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>).equals(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1&quot;</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">right</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>).compareTo(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1&quot;</span>)) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BigDecimal 的 equals 方法的注释中说明了原因，equals 比较的是 BigDecimal 的 value 和 scale，1.0 的 scale 是 1，1 的 scale 是 0，所以结果一定是 false。</p>
<p><strong>如果我们希望只比较 BigDecimal 的 value，可以使用 compareTo 方法</strong>。</p>
<p>BigDecimal 的 equals 和 hashCode 方法会同时考虑 value 和 scale，如果结合 HashSet 或 HashMap 使用的话就可能会出现麻烦。比如，我们把值为 1.0 的 BigDecimal 加入 HashSet，然后判断其是否存在值为 1 的 BigDecimal，得到的结果是 false。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;BigDecimal&gt; hashSet1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">hashSet1.add(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>));</span><br><span class="line">System.out.println(hashSet1.contains(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1&quot;</span>)));<span class="comment">//返回false</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解决办法有两个：</p>
<p>第一个方法是，使用 TreeSet 替换 HashSet。TreeSet 不使用 hashCode 方法，也不使用 equals 比较元素，而是使用 compareTo 方法，所以不会有问题。</p>
<p>第二个方法是，把 BigDecimal 存入 HashSet 或 HashMap 前，先使用 stripTrailingZeros 方法去掉尾部的零，比较的时候也去掉尾部的 0，确保 value 相同的 BigDecimal，scale 也是一致的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;BigDecimal&gt; hashSet2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">hashSet2.add(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>).stripTrailingZeros());</span><br><span class="line">System.out.println(hashSet2.contains(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.000&quot;</span>).stripTrailingZeros()));<span class="comment">//返回true</span></span><br><span class="line"></span><br><span class="line">Set&lt;BigDecimal&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">treeSet.add(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>));</span><br><span class="line">System.out.println(treeSet.contains(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1&quot;</span>)));<span class="comment">//返回true</span></span><br></pre></td></tr></table></figure>

<h3 id="数值溢出"><a href="#数值溢出" class="headerlink" title="数值溢出"></a>数值溢出</h3><p>数值计算还有一个要小心的点是溢出，不管是 int 还是 long，所有的基本数值类型都有超出表达范围的可能性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> Long.MAX_VALUE;</span><br><span class="line">System.out.println(l + <span class="number">1</span>); <span class="comment">// -9223372036854775808</span></span><br><span class="line">System.out.println(l + <span class="number">1</span> == Long.MIN_VALUE); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>显然这是发生了溢出，而且是默默的溢出，并没有任何异常</strong>。这类问题非常容易被忽略，改进方式有下面 2 种。</p>
<p>方法一是，考虑使用 Math 类的 addExact、subtractExact 等 xxExact 方法进行数值运算，这些方法可以在数值溢出时主动抛出异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> Long.MAX_VALUE;</span><br><span class="line">    System.out.println(Math.addExact(l, <span class="number">1</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    ex.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二是，使用大数类 BigInteger。BigDecimal 是处理浮点数的专家，而 BigInteger 则是对大数进行科学计算的专家。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(String.valueOf(Long.MAX_VALUE));</span><br><span class="line">System.out.println(i.add(BigInteger.ONE).toString());</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> i.add(BigInteger.ONE).longValueExact();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    ex.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/2130190/">《Java 编程思想（Thinking in java）》</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/26880667/">《Java 核心技术 卷 I 基础知识》</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100047701">《Java 业务开发常见错误 100 例》</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/59cd71835188255d3448faf6">Java 基本数据类型和引用类型</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dolphin0520/p/3780005.html">深入剖析 Java 中的装箱和拆箱</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/7a3ffc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/7a3ffc/" class="post-title-link" itemprop="url">深入理解 Java 方法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-05-06 15:02:02" itemprop="dateCreated datePublished" datetime="2019-05-06T15:02:02+08:00">2019-05-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JavaSE/%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7/" itemprop="url" rel="index"><span itemprop="name">基础特性</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="深入理解-Java-方法"><a href="#深入理解-Java-方法" class="headerlink" title="深入理解 Java 方法"></a>深入理解 Java 方法</h1><blockquote>
<p><strong>方法（有的人喜欢叫函数）是一段可重用的代码段。</strong></p>
</blockquote>
<h2 id="方法的使用"><a href="#方法的使用" class="headerlink" title="方法的使用"></a>方法的使用</h2><h3 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h3><p>方法定义语法格式：</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] 返回值类型 方法名([参数类型 参数名])&#123;</span><br><span class="line">    ...</span><br><span class="line">    方法体</span><br><span class="line">    ...</span><br><span class="line">    return 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法包含一个方法头和一个方法体。下面是一个方法的所有部分：</p>
<ul>
<li><strong>修饰符</strong> - 修饰符是可选的，它告诉编译器如何调用该方法。定义了该方法的访问类型。</li>
<li><strong>返回值类型</strong> - 返回值类型表示方法执行结束后，返回结果的数据类型。如果没有返回值，应设为 void。</li>
<li><strong>方法名</strong> - 是方法的实际名称。方法名和参数表共同构成方法签名。</li>
<li><strong>参数类型</strong> - 参数像是一个占位符。当方法被调用时，传递值给参数。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。</li>
<li><strong>方法体</strong> - 方法体包含具体的语句，定义该方法的功能。</li>
<li><strong>return</strong> - 必须返回声明方法时返回值类型相同的数据类型。在 void 方法中，return 语句可有可无，如果要写 return，则只能是 <code>return;</code> 这种形式。</li>
</ul>
<h3 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h3><p>当程序调用一个方法时，程序的控制权交给了被调用的方法。当被调用方法的返回语句执行或者到达方法体闭括号时候交还控制权给程序。</p>
<p>Java 支持两种调用方法的方式，根据方法是否有返回值来选择。</p>
<ul>
<li>有返回值方法 - 有返回值方法通常被用来给一个变量赋值或代入到运算表达式中进行计算。</li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">int</span> larger = max(<span class="number">30</span>, <span class="number">40</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>无返回值方法 - 无返回值方法只能是一条语句。</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;Hello World&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="递归调用"><a href="#递归调用" class="headerlink" title="递归调用"></a>递归调用</h4><p>Java 支持方法的递归调用（即方法调用自身）。</p>
<blockquote>
<p>🔔 注意：</p>
<ul>
<li>递归方法必须有明确的结束条件。</li>
<li>尽量避免使用递归调用。因为递归调用如果处理不当，可能导致栈溢出。</li>
</ul>
</blockquote>
<p>斐波那契数列（一个典型的递归算法）示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecursionMethodDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">1</span> || num == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fib(num - <span class="number">2</span>) + fib(num - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.print(fib(i) + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h2><p>在 C&#x2F;C++ 等编程语言中，方法的参数传递一般有两种形式：</p>
<ul>
<li>值传递 - 值传递的参数被称为形参。值传递时，传入的参数，在方法中的修改，不会在方法外部生效。</li>
<li>引用传递 - 引用传递的参数被称为实参。引用传递时，传入的参数，在方法中的修改，会在方法外部生效。</li>
</ul>
<p>那么，Java 中是怎样的呢？</p>
<p><strong>Java 中只有值传递。</strong></p>
<p>示例一：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodParamDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        value =  value + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        method(num);</span><br><span class="line">        System.out.println(<span class="string">&quot;num = [&quot;</span> + num + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        method(num);</span><br><span class="line">        System.out.println(<span class="string">&quot;num = [&quot;</span> + num + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// num = [0]</span></span><br><span class="line"><span class="comment">// num = [0]</span></span><br></pre></td></tr></table></figure>

<p>示例二：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodParamDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(StringBuilder sb)</span> &#123;</span><br><span class="line">        sb = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;sb = [&quot;</span> + sb.toString() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        method(sb);</span><br><span class="line">        System.out.println(<span class="string">&quot;sb = [&quot;</span> + sb.toString() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        sb = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;sb = [&quot;</span> + sb.toString() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// sb = [A]</span></span><br><span class="line"><span class="comment">// sb = [A]</span></span><br><span class="line"><span class="comment">// sb = [C]</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>以上两个示例，无论向方法中传入的是基础数据类型，还是引用类型，在方法中修改的值，在外部都未生效。</p>
<p>Java 对于基本数据类型，会直接拷贝值传递到方法中；对于引用数据类型，拷贝当前对象的引用地址，然后把该地址传递过去，所以也是值传递。</p>
<blockquote>
<p>扩展阅读：</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/24556934?refer=dreawer">图解 Java 中的参数传递</a></p>
</blockquote>
<h2 id="方法修饰符"><a href="#方法修饰符" class="headerlink" title="方法修饰符"></a>方法修饰符</h2><p>前面提到了，Java 方法的修饰符是可选的，它告诉编译器如何调用该方法。定义了该方法的访问类型。</p>
<p>Java 方法有好几个修饰符，让我们一一来认识一下：</p>
<h3 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h3><p>访问权限控制的等级，从最大权限到最小权限依次为：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &gt; <span class="keyword">protected</span> &gt; 包访问权限（没有任何关键字）&gt; <span class="keyword">private</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>public</code> - 表示任何类都可以访问；</li>
<li><code>包访问权限</code> - 包访问权限，没有任何关键字。它表示当前包中的所有其他类都可以访问，但是其它包的类无法访问。</li>
<li><code>protected</code> - 表示子类可以访问，此外，同一个包内的其他类也可以访问，即使这些类不是子类。</li>
<li><code>private</code> - 表示其它任何类都无法访问。</li>
</ul>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p><strong>被 <code>static</code> 修饰的方法被称为静态方法。</strong></p>
<p>静态方法相比于普通的实例方法，主要有以下区别：</p>
<ul>
<li><p>在外部调用静态方法时，可以使用 <code>类名.方法名</code> 的方式，也可以使用 <code>对象名.方法名</code> 的方式。而实例方法只有后面这种方式。也就是说，<strong>调用静态方法可以无需创建对象</strong>。</p>
</li>
<li><p><strong>静态方法在访问本类的成员时，只允许访问静态成员</strong>（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。</p>
</li>
</ul>
<p>静态方法常被用于各种工具类、工厂方法类。</p>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>被 <code>final</code> 修饰的方法不能被子类覆写（Override）。</p>
<p>final 方法示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalMethodDemo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;call Father print()&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;call print()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Father</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        demo.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译时会报错</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：</p>
<p>上面示例中，父类 Father 中定义了一个 <code>final</code> 方法 <code>print()</code>，则其子类不能 Override 这个 final 方法，否则会编译报错。</p>
</blockquote>
<h3 id="default"><a href="#default" class="headerlink" title="default"></a>default</h3><p>JDK8 开始，支持在接口 <code>Interface</code> 中定义 <code>default</code> 方法。**<code>default</code> 方法只能出现在接口 <code>Interface</code> 中**。</p>
<p><strong>接口中被 <code>default</code> 修饰的方法被称为默认方法，实现此接口的类如果没 Override 此方法，则直接继承这个方法，不再强制必须实现此方法。</strong></p>
<p>default 方法语法的出现，是为了既有的成千上万的 Java 类库的类增加新的功能， 且不必对这些类重新进行设计。 举例来说，JDK8 中 <code>Collection</code> 类中有一个非常方便的 <code>stream()</code> 方法，就是被修饰为 <code>default</code>，Collection 的一大堆 List、Set 子类就直接继承了这个方法 I，不必再为每个子类都注意添加这个方法。</p>
<p><code>default</code> 方法示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultMethodDemo</span> &#123;</span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">        <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">MyInterface</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyInterface</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        obj.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// Hello World</span></span><br></pre></td></tr></table></figure>

<h3 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h3><p><strong>被 <code>abstract</code> 修饰的方法被称为抽象方法，方法不能有实体。抽象方法只能出现抽象类中。</strong></p>
<p>抽象方法示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractMethodDemo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">        <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;call print()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AbstractClass</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteClass</span>();</span><br><span class="line">        demo.print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Outpu:</span></span><br><span class="line"><span class="comment">// call print()</span></span><br></pre></td></tr></table></figure>

<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p><code>synchronized</code> 用于并发编程。<strong>被 <code>synchronized</code> 修饰的方法在一个时刻，只允许一个线程执行。</strong></p>
<p>在 Java 的同步容器（Vector、Stack、HashTable）中，你会见到大量的 synchronized 方法。不过，请记住：在 Java 并发编程中，synchronized 方法并不是一个好的选择，大多数情况下，我们会选择更加轻量级的锁 。</p>
<h2 id="特殊方法"><a href="#特殊方法" class="headerlink" title="特殊方法"></a>特殊方法</h2><p>Java 中，有一些较为特殊的方法，分别使用于特殊的场景。</p>
<h3 id="main-方法"><a href="#main-方法" class="headerlink" title="main 方法"></a>main 方法</h3><p>Java 中的 main 方法是一种特殊的静态方法，因为所有的 Java 程序都是由 <code>public static void main(String[] args)</code> 方法开始执行。</p>
<p>有很多新手虽然一直用 main 方法，却不知道 main 方法中的 args 有什么用。实际上，这是用来接收接收命令行输入参数的。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainMethodDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String arg : args) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;arg = [&quot;</span> + arg + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>依次执行</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">javac </span>MainMethodDemo.<span class="keyword">java</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">java </span>MainMethodDemo A <span class="keyword">B </span>C</span><br></pre></td></tr></table></figure>

<p>控制台会打印输出参数：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">arg</span> <span class="operator">=</span> [A]</span><br><span class="line"><span class="attribute">arg</span> <span class="operator">=</span> [B]</span><br><span class="line"><span class="attribute">arg</span> <span class="operator">=</span> [C]</span><br></pre></td></tr></table></figure>

<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>任何类都有构造方法，构造方法的作用就是在初始化类实例时，设置实例的状态。</p>
<p>每个类都有构造方法。如果没有显式地为类定义任何构造方法，Java 编译器将会为该类提供一个默认构造方法。</p>
<p>在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstructorMethodDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;person name is &quot;</span> + person.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，构造方法除了使用 public，也可以使用 private 修饰，这种情况下，类无法调用此构造方法去实例化对象，这常常用于设计模式中的单例模式。</p>
<h3 id="变参方法"><a href="#变参方法" class="headerlink" title="变参方法"></a>变参方法</h3><p>JDK5 开始，Java 支持传递同类型的可变参数给一个方法。在方法声明中，在指定参数类型后加一个省略号 <code>...</code>。一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。</p>
<p>变参方法示例：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VarargsDemo</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span>(<span class="params">String... <span class="keyword">params</span></span>)</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;params.length = &quot;</span> + <span class="keyword">params</span>.length);</span><br><span class="line">        <span class="keyword">for</span> (String param : <span class="keyword">params</span>) &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;params = [&quot;</span> + param + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        method(<span class="string">&quot;red&quot;</span>);</span><br><span class="line">        method(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;yellow&quot;</span>);</span><br><span class="line">        method(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;blue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// params.length = 1</span></span><br><span class="line"><span class="comment">// params = [red]</span></span><br><span class="line"><span class="comment">// params.length = 2</span></span><br><span class="line"><span class="comment">// params = [red]</span></span><br><span class="line"><span class="comment">// params = [yellow]</span></span><br><span class="line"><span class="comment">// params.length = 3</span></span><br><span class="line"><span class="comment">// params = [red]</span></span><br><span class="line"><span class="comment">// params = [yellow]</span></span><br><span class="line"><span class="comment">// params = [blue]</span></span><br></pre></td></tr></table></figure>

<h3 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize() 方法"></a>finalize() 方法</h3><p><code>finalize</code> 在对象被垃圾收集器析构(回收)之前调用，用来清除回收对象。</p>
<p><code>finalize</code> 是在 <code>java.lang.Object</code> 里定义的，也就是说每一个对象都有这么个方法。这个方法在 GC 启动，该对象被回收的时候被调用。</p>
<p>finalizer() 通常是不可预测的，也是很危险的，一般情况下是不必要的。使用终结方法会导致行为不稳定、降低性能，以及可移植性问题。</p>
<p><strong>请记住：应该尽量避免使用 <code>finalizer()</code><strong>。千万不要把它当成是 C&#x2F;C++ 中的析构函数来用。原因是：</strong>Finalizer 线程会和我们的主线程进行竞争，不过由于它的优先级较低，获取到的 CPU 时间较少，因此它永远也赶不上主线程的步伐。所以最后可能会发生 OutOfMemoryError 异常。</strong></p>
<blockquote>
<p>扩展阅读：</p>
<p>下面两篇文章比较详细的讲述了 finalizer() 可能会造成的问题及原因。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/benwu/articles/5812903.html">Java 的 Finalizer 引发的内存溢出</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/27850176">重载 Finalize 引发的内存泄露</a></li>
</ul>
</blockquote>
<h2 id="覆写和重载"><a href="#覆写和重载" class="headerlink" title="覆写和重载"></a>覆写和重载</h2><p><strong>覆写（Override）是指子类定义了与父类中同名的方法，但是在方法覆写时必须考虑到访问权限，子类覆写的方法不能拥有比父类更加严格的访问权限。</strong></p>
<p>子类要覆写的方法如果要访问父类的方法，可以使用 <code>super</code> 关键字。</p>
<p>覆写示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodOverrideDemo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;会动&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.move();</span><br><span class="line">            System.out.println(<span class="string">&quot;会跑&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        dog.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// 会动</span></span><br><span class="line"><span class="comment">// 会跑</span></span><br></pre></td></tr></table></figure>

<p><strong>方法的重载（Overload）是指方法名称相同，但参数的类型或参数的个数不同。通过传递参数的个数及类型的不同可以完成不同功能的方法调用。</strong></p>
<blockquote>
<p>🔔 注意：</p>
<p>重载一定是方法的参数不完全相同。如果方法的参数完全相同，仅仅是返回值不同，Java 是无法编译通过的。</p>
</blockquote>
<p>重载示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodOverloadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;x + y = &quot;</span> + (x + y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;x + y = &quot;</span> + (x + y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        add(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">        add(<span class="number">1.0</span>, <span class="number">2.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// x + y = 30</span></span><br><span class="line"><span class="comment">// x + y = 3.0</span></span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/1553767582595.png" alt="img"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/2130190/">Java 编程思想</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/3146174/">Java 核心技术（卷 1）</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/4496038/">Head First Java</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/24556934?refer=dreawer">图解 Java 中的参数传递</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/benwu/articles/5812903.html">Java 的 Finalizer 引发的内存溢出</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/27850176">重载 Finalize 引发的内存泄露</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/979887/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/979887/" class="post-title-link" itemprop="url">深入理解 Java 枚举</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-05-06 15:02:02" itemprop="dateCreated datePublished" datetime="2019-05-06T15:02:02+08:00">2019-05-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JavaSE/%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7/" itemprop="url" rel="index"><span itemprop="name">基础特性</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>13k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>11 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="深入理解-Java-枚举"><a href="#深入理解-Java-枚举" class="headerlink" title="深入理解 Java 枚举"></a>深入理解 Java 枚举</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>enum</code> 的全称为 enumeration， 是 JDK5 中引入的特性。</p>
<p>在 Java 中，被 <code>enum</code> 关键字修饰的类型就是枚举类型。形式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">ColorEn</span> &#123; RED, GREEN, BLUE &#125;</span><br></pre></td></tr></table></figure>

<p><strong>枚举的好处</strong>：可以将常量组织起来，统一进行管理。</p>
<p><strong>枚举的典型应用场景</strong>：错误码、状态机等。</p>
<h2 id="枚举的本质"><a href="#枚举的本质" class="headerlink" title="枚举的本质"></a>枚举的本质</h2><p><code>java.lang.Enum</code>类声明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Enum</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;E&gt;, Serializable &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>新建一个 ColorEn.java 文件，内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.dunwu.javacore.enumeration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ColorEn</span> &#123;</span><br><span class="line">    RED,YELLOW,BLUE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行 <code>javac ColorEn.java</code> 命令，生成 ColorEn.class 文件。</p>
<p>然后执行 <code>javap ColorEn.class</code> 命令，输出如下内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">&quot;ColorEn.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">io</span>.github.dunwu.javacore.enumeration.ColorEn <span class="keyword">extends</span> <span class="title class_">java</span>.lang.Enum&lt;io.github.dunwu.javacore.enumeration.ColorEn&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> io.github.dunwu.javacore.enumeration.ColorEn RED;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> io.github.dunwu.javacore.enumeration.ColorEn YELLOW;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> io.github.dunwu.javacore.enumeration.ColorEn BLUE;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> io.github.dunwu.javacore.enumeration.ColorEn[] values();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> io.github.dunwu.javacore.enumeration.ColorEn <span class="title function_">valueOf</span><span class="params">(java.lang.String)</span>;</span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>💡 说明：</p>
<p>从上面的例子可以看出：</p>
<p><strong>枚举的本质是 <code>java.lang.Enum</code> 的子类。</strong></p>
<p>尽管 <code>enum</code> 看起来像是一种新的数据类型，事实上，<strong>enum 是一种受限制的类，并且具有自己的方法</strong>。枚举这种特殊的类因为被修饰为 <code>final</code>，所以不能继承其他类。</p>
<p>定义的枚举值，会被默认修饰为 <code>public static final</code> ，从修饰关键字，即可看出枚举值本质上是静态常量。</p>
</blockquote>
<h2 id="枚举的方法"><a href="#枚举的方法" class="headerlink" title="枚举的方法"></a>枚举的方法</h2><p>在 enum 中，提供了一些基本方法：</p>
<ul>
<li><code>values()</code>：返回 enum 实例的数组，而且该数组中的元素严格保持在 enum 中声明时的顺序。</li>
<li><code>name()</code>：返回实例名。</li>
<li><code>ordinal()</code>：返回实例声明时的次序，从 0 开始。</li>
<li><code>getDeclaringClass()</code>：返回实例所属的 enum 类型。</li>
<li><code>equals()</code> ：判断是否为同一个对象。</li>
</ul>
<p>可以使用 <code>==</code> 来比较<code>enum</code>实例。</p>
<p>此外，<code>java.lang.Enum</code>实现了<code>Comparable</code>和 <code>Serializable</code> 接口，所以也提供 <code>compareTo()</code> 方法。</p>
<p><strong>例：展示 enum 的基本方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumMethodDemo</span> &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Color</span> &#123;RED, GREEN, BLUE;&#125;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Size</span> &#123;BIG, MIDDLE, SMALL;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=========== Print all Color ===========&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Color c : Color.values()) &#123;</span><br><span class="line">            System.out.println(c + <span class="string">&quot; ordinal: &quot;</span> + c.ordinal());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;=========== Print all Size ===========&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Size s : Size.values()) &#123;</span><br><span class="line">            System.out.println(s + <span class="string">&quot; ordinal: &quot;</span> + s.ordinal());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Color</span> <span class="variable">green</span> <span class="operator">=</span> Color.GREEN;</span><br><span class="line">        System.out.println(<span class="string">&quot;green name(): &quot;</span> + green.name());</span><br><span class="line">        System.out.println(<span class="string">&quot;green getDeclaringClass(): &quot;</span> + green.getDeclaringClass());</span><br><span class="line">        System.out.println(<span class="string">&quot;green hashCode(): &quot;</span> + green.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;green compareTo Color.GREEN: &quot;</span> + green.compareTo(Color.GREEN));</span><br><span class="line">        System.out.println(<span class="string">&quot;green equals Color.GREEN: &quot;</span> + green.equals(Color.GREEN));</span><br><span class="line">        System.out.println(<span class="string">&quot;green equals Size.MIDDLE: &quot;</span> + green.equals(Size.MIDDLE));</span><br><span class="line">        System.out.println(<span class="string">&quot;green equals 1: &quot;</span> + green.equals(<span class="number">1</span>));</span><br><span class="line">        System.out.format(<span class="string">&quot;green == Color.BLUE: %b\n&quot;</span>, green == Color.BLUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">===========</span> <span class="string">Print</span> <span class="string">all</span> <span class="string">Color</span> <span class="string">===========</span></span><br><span class="line"><span class="attr">RED ordinal:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">GREEN ordinal:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">BLUE ordinal:</span> <span class="number">2</span></span><br><span class="line"><span class="string">===========</span> <span class="string">Print</span> <span class="string">all</span> <span class="string">Size</span> <span class="string">===========</span></span><br><span class="line"><span class="attr">BIG ordinal:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">MIDDLE ordinal:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">SMALL ordinal:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">green name():</span> <span class="string">GREEN</span></span><br><span class="line"><span class="attr">green getDeclaringClass():</span> <span class="string">class</span> <span class="string">org.zp.javase.enumeration.EnumDemo$Color</span></span><br><span class="line"><span class="attr">green hashCode():</span> <span class="number">460141958</span></span><br><span class="line"><span class="attr">green compareTo Color.GREEN:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">green equals Color.GREEN:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">green equals Size.MIDDLE:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">green equals 1:</span> <span class="literal">false</span></span><br><span class="line"><span class="string">green</span> <span class="string">==</span> <span class="attr">Color.BLUE:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h2 id="枚举的特性"><a href="#枚举的特性" class="headerlink" title="枚举的特性"></a>枚举的特性</h2><p>枚举的特性，归结起来就是一句话：</p>
<blockquote>
<p><strong>除了不能继承，基本上可以将 <code>enum</code> 看做一个常规的类</strong>。</p>
</blockquote>
<p>但是这句话需要拆分去理解，让我们细细道来。</p>
<h3 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h3><p><strong>如果枚举中没有定义方法，也可以在最后一个实例后面加逗号、分号或什么都不加。</strong></p>
<p>如果枚举中没有定义方法，<strong>枚举值默认为从 0 开始的有序数值</strong>。以 Color 枚举类型举例，它的枚举常量依次为 <code>RED：0，GREEN：1，BLUE：2</code>。</p>
<h3 id="枚举可以添加方法"><a href="#枚举可以添加方法" class="headerlink" title="枚举可以添加方法"></a>枚举可以添加方法</h3><p>在概念章节提到了，<strong>枚举值默认为从 0 开始的有序数值</strong> 。那么问题来了：如何为枚举显式的赋值。</p>
<p>（1）<strong>Java 不允许使用 <code>=</code> 为枚举常量赋值</strong></p>
<p>如果你接触过 C&#x2F;C++，你肯定会很自然的想到赋值符号 <code>=</code> 。在 C&#x2F;C++语言中的 enum，可以用赋值符号<code>=</code>显式的为枚举常量赋值；但是 ，很遗憾，<strong>Java 语法中却不允许使用赋值符号 <code>=</code> 为枚举常量赋值</strong>。</p>
<p><strong>例：C&#x2F;C++ 语言中的枚举声明</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    ONE = <span class="number">1</span>,</span><br><span class="line">    TWO,</span><br><span class="line">    THREE = <span class="number">3</span>,</span><br><span class="line">    TEN = <span class="number">10</span></span><br><span class="line">&#125; Number;</span><br></pre></td></tr></table></figure>

<p>（2）<strong>枚举可以添加普通方法、静态方法、抽象方法、构造方法</strong></p>
<p>Java 虽然不能直接为实例赋值，但是它有更优秀的解决方案：<strong>为 enum 添加方法来间接实现显式赋值</strong>。</p>
<p>创建 <code>enum</code> 时，可以为其添加多种方法，甚至可以为其添加构造方法。</p>
<p><strong>注意一个细节：如果要为 enum 定义方法，那么必须在 enum 的最后一个实例尾部添加一个分号。此外，在 enum 中，必须先定义实例，不能将字段或方法定义在实例前面。否则，编译器会报错。</strong></p>
<p><strong>例：全面展示如何在枚举中定义普通方法、静态方法、抽象方法、构造方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ErrorCodeEn</span> &#123;</span><br><span class="line">    OK(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;成功&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ERROR_A(<span class="number">100</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;错误A&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ERROR_B(<span class="number">200</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;错误B&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法：enum的构造方法只能被声明为private权限或不声明权限</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ErrorCodeEn</span><span class="params">(<span class="type">int</span> number)</span> &#123; <span class="comment">// 构造方法</span></span><br><span class="line">        <span class="built_in">this</span>.code = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123; <span class="comment">// 普通方法</span></span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125; <span class="comment">// 普通方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getDescription</span><span class="params">()</span>; <span class="comment">// 抽象方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123; <span class="comment">// 静态方法</span></span><br><span class="line">        <span class="keyword">for</span> (ErrorCodeEn s : ErrorCodeEn.values()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;code: &quot;</span> + s.getCode() + <span class="string">&quot;, description: &quot;</span> + s.getDescription());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// code: 0, description: 成功</span></span><br><span class="line"><span class="comment">// code: 100, description: 错误A</span></span><br><span class="line"><span class="comment">// code: 200, description: 错误B</span></span><br></pre></td></tr></table></figure>

<p>注：上面的例子并不可取，仅仅是为了展示枚举支持定义各种方法。正确的例子情况<a href="#%E9%94%99%E8%AF%AF%E7%A0%81">错误码示例</a></p>
<h3 id="枚举可以实现接口"><a href="#枚举可以实现接口" class="headerlink" title="枚举可以实现接口"></a>枚举可以实现接口</h3><p><strong><code>enum</code> 可以像一般类一样实现接口。</strong></p>
<p>同样是实现上一节中的错误码枚举类，通过实现接口，可以约束它的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">INumberEnum</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getDescription</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ErrorCodeEn2</span> <span class="keyword">implements</span> <span class="title class_">INumberEnum</span> &#123;</span><br><span class="line">    OK(<span class="number">0</span>, <span class="string">&quot;成功&quot;</span>),</span><br><span class="line">    ERROR_A(<span class="number">100</span>, <span class="string">&quot;错误A&quot;</span>),</span><br><span class="line">    ERROR_B(<span class="number">200</span>, <span class="string">&quot;错误B&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ErrorCodeEn2(<span class="type">int</span> number, String description) &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = number;</span><br><span class="line">        <span class="built_in">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="枚举不可以继承"><a href="#枚举不可以继承" class="headerlink" title="枚举不可以继承"></a>枚举不可以继承</h3><p><strong>enum 不可以继承另外一个类，当然，也不能继承另一个 enum 。</strong></p>
<p>因为 <code>enum</code> 实际上都继承自 <code>java.lang.Enum</code> 类，而 Java 不支持多重继承，所以 <code>enum</code> 不能再继承其他类，当然也不能继承另一个 <code>enum</code>。</p>
<h2 id="枚举的应用"><a href="#枚举的应用" class="headerlink" title="枚举的应用"></a>枚举的应用</h2><h3 id="组织常量"><a href="#组织常量" class="headerlink" title="组织常量"></a>组织常量</h3><p>在 JDK5 之前，在 Java 中定义常量都是<code>public static final TYPE a;</code> 这样的形式。有了枚举，你可以将有关联关系的常量组织起来，使代码更加易读、安全，并且还可以使用枚举提供的方法。</p>
<p>下面三种声明方式是等价的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; RED, GREEN, BLUE &#125;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; RED, GREEN, BLUE, &#125;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; RED, GREEN, BLUE; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="switch-状态机"><a href="#switch-状态机" class="headerlink" title="switch 状态机"></a>switch 状态机</h3><p>我们经常使用 switch 语句来写状态机。JDK7 以后，switch 已经支持 <code>int</code>、<code>char</code>、<code>String</code>、<code>enum</code> 类型的参数。这几种类型的参数比较起来，使用枚举的 switch 代码更具有可读性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StateMachineDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Signal</span> &#123;</span><br><span class="line">        GREEN, YELLOW, RED</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getTrafficInstruct</span><span class="params">(Signal signal)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">instruct</span> <span class="operator">=</span> <span class="string">&quot;信号灯故障&quot;</span>;</span><br><span class="line">        <span class="keyword">switch</span> (signal) &#123;</span><br><span class="line">            <span class="keyword">case</span> RED:</span><br><span class="line">                instruct = <span class="string">&quot;红灯停&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> YELLOW:</span><br><span class="line">                instruct = <span class="string">&quot;黄灯请注意&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> GREEN:</span><br><span class="line">                instruct = <span class="string">&quot;绿灯行&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instruct;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(getTrafficInstruct(Signal.RED));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// 红灯停</span></span><br></pre></td></tr></table></figure>

<h3 id="错误码"><a href="#错误码" class="headerlink" title="错误码"></a>错误码</h3><p>枚举常被用于定义程序错误码。下面是一个简单示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorCodeEnumDemo</span> &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">ErrorCodeEn</span> &#123;</span><br><span class="line">        OK(<span class="number">0</span>, <span class="string">&quot;成功&quot;</span>),</span><br><span class="line">        ERROR_A(<span class="number">100</span>, <span class="string">&quot;错误A&quot;</span>),</span><br><span class="line">        ERROR_B(<span class="number">200</span>, <span class="string">&quot;错误B&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ErrorCodeEn(<span class="type">int</span> number, String msg) &#123;</span><br><span class="line">            <span class="built_in">this</span>.code = number;</span><br><span class="line">            <span class="built_in">this</span>.msg = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line">        <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> code;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getMsg</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;ErrorCodeEn&#123;&quot;</span> + <span class="string">&quot;code=&quot;</span> + code + <span class="string">&quot;, msg=&#x27;&quot;</span> + msg + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">toStringAll</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            sb.append(<span class="string">&quot;ErrorCodeEn All Elements: [&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (ErrorCodeEn code : ErrorCodeEn.values()) &#123;</span><br><span class="line">                sb.append(code.getCode()).append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(ErrorCodeEn.toStringAll());</span><br><span class="line">        <span class="keyword">for</span> (ErrorCodeEn s : ErrorCodeEn.values()) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// ErrorCodeEn All Elements: [0, 100, 200, ]</span></span><br><span class="line"><span class="comment">// ErrorCodeEn&#123;code=0, msg=&#x27;成功&#x27;&#125;</span></span><br><span class="line"><span class="comment">// ErrorCodeEn&#123;code=100, msg=&#x27;错误A&#x27;&#125;</span></span><br><span class="line"><span class="comment">// ErrorCodeEn&#123;code=200, msg=&#x27;错误B&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="组织枚举"><a href="#组织枚举" class="headerlink" title="组织枚举"></a>组织枚举</h3><p>可以将类型相近的枚举通过接口或类组织起来，但是一般用接口方式进行组织。</p>
<p>原因是：Java 接口在编译时会自动为 enum 类型加上<code>public static</code>修饰符；Java 类在编译时会自动为 <code>enum</code> 类型加上 static 修饰符。看出差异了吗？没错，就是说，在类中组织 <code>enum</code>，如果你不给它修饰为 <code>public</code>，那么只能在本包中进行访问。</p>
<p><strong>例：在接口中组织 enum</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumInInterfaceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">INumberEnum</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span>;</span><br><span class="line">        String <span class="title function_">getDescription</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Plant</span> &#123;</span><br><span class="line">        <span class="keyword">enum</span> <span class="title class_">Vegetable</span> <span class="keyword">implements</span> <span class="title class_">INumberEnum</span> &#123;</span><br><span class="line">            POTATO(<span class="number">0</span>, <span class="string">&quot;土豆&quot;</span>),</span><br><span class="line">            TOMATO(<span class="number">0</span>, <span class="string">&quot;西红柿&quot;</span>);</span><br><span class="line"></span><br><span class="line">            Vegetable(<span class="type">int</span> number, String description) &#123;</span><br><span class="line">                <span class="built_in">this</span>.code = number;</span><br><span class="line">                <span class="built_in">this</span>.description = description;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line">            <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.code;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.description;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">enum</span> <span class="title class_">Fruit</span> <span class="keyword">implements</span> <span class="title class_">INumberEnum</span> &#123;</span><br><span class="line">            APPLE(<span class="number">0</span>, <span class="string">&quot;苹果&quot;</span>),</span><br><span class="line">            ORANGE(<span class="number">0</span>, <span class="string">&quot;桔子&quot;</span>),</span><br><span class="line">            BANANA(<span class="number">0</span>, <span class="string">&quot;香蕉&quot;</span>);</span><br><span class="line"></span><br><span class="line">            Fruit(<span class="type">int</span> number, String description) &#123;</span><br><span class="line">                <span class="built_in">this</span>.code = number;</span><br><span class="line">                <span class="built_in">this</span>.description = description;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line">            <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.code;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.description;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Plant.Fruit f : Plant.Fruit.values()) &#123;</span><br><span class="line">            System.out.println(f.getDescription());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// 苹果</span></span><br><span class="line"><span class="comment">// 桔子</span></span><br><span class="line"><span class="comment">// 香蕉</span></span><br></pre></td></tr></table></figure>

<p><strong>例：在类中组织 enum</strong></p>
<p>本例和上例效果相同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumInClassDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">INumberEnum</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span>;</span><br><span class="line">        String <span class="title function_">getDescription</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Plant2</span> &#123;</span><br><span class="line">        <span class="keyword">enum</span> <span class="title class_">Vegetable</span> <span class="keyword">implements</span> <span class="title class_">INumberEnum</span> &#123;</span><br><span class="line">            <span class="comment">// 略，与上面完全相同</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">enum</span> <span class="title class_">Fruit</span> <span class="keyword">implements</span> <span class="title class_">INumberEnum</span> &#123;</span><br><span class="line">            <span class="comment">// 略，与上面完全相同</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 略</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// 土豆</span></span><br><span class="line"><span class="comment">// 西红柿</span></span><br></pre></td></tr></table></figure>

<h3 id="策略枚举"><a href="#策略枚举" class="headerlink" title="策略枚举"></a>策略枚举</h3><p>Effective Java 中展示了一种策略枚举。这种枚举通过枚举嵌套枚举的方式，将枚举常量分类处理。</p>
<p>这种做法虽然没有 switch 语句简洁，但是更加安全、灵活。</p>
<p><strong>例：EffectvieJava 中的策略枚举范例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">PayrollDay</span> &#123;</span><br><span class="line">    MONDAY(PayType.WEEKDAY), TUESDAY(PayType.WEEKDAY), WEDNESDAY(</span><br><span class="line">            PayType.WEEKDAY), THURSDAY(PayType.WEEKDAY), FRIDAY(PayType.WEEKDAY), SATURDAY(</span><br><span class="line">            PayType.WEEKEND), SUNDAY(PayType.WEEKEND);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PayType payType;</span><br><span class="line"></span><br><span class="line">    PayrollDay(PayType payType) &#123;</span><br><span class="line">        <span class="built_in">this</span>.payType = payType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> <span class="title function_">pay</span><span class="params">(<span class="type">double</span> hoursWorked, <span class="type">double</span> payRate)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> payType.pay(hoursWorked, payRate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 策略枚举</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> <span class="title class_">PayType</span> &#123;</span><br><span class="line">        WEEKDAY &#123;</span><br><span class="line">            <span class="type">double</span> <span class="title function_">overtimePay</span><span class="params">(<span class="type">double</span> hours, <span class="type">double</span> payRate)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> hours &lt;= HOURS_PER_SHIFT ? <span class="number">0</span> : (hours - HOURS_PER_SHIFT)</span><br><span class="line">                        * payRate / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        WEEKEND &#123;</span><br><span class="line">            <span class="type">double</span> <span class="title function_">overtimePay</span><span class="params">(<span class="type">double</span> hours, <span class="type">double</span> payRate)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> hours * payRate / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HOURS_PER_SHIFT</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">overtimePay</span><span class="params">(<span class="type">double</span> hrs, <span class="type">double</span> payRate)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> <span class="title function_">pay</span><span class="params">(<span class="type">double</span> hoursWorked, <span class="type">double</span> payRate)</span> &#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">basePay</span> <span class="operator">=</span> hoursWorked * payRate;</span><br><span class="line">            <span class="keyword">return</span> basePay + overtimePay(hoursWorked, payRate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;时薪100的人在周五工作8小时的收入：&quot;</span> + PayrollDay.FRIDAY.pay(<span class="number">8.0</span>, <span class="number">100</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;时薪100的人在周六工作8小时的收入：&quot;</span> + PayrollDay.SATURDAY.pay(<span class="number">8.0</span>, <span class="number">100</span>));</span><br></pre></td></tr></table></figure>

<h3 id="枚举实现单例模式"><a href="#枚举实现单例模式" class="headerlink" title="枚举实现单例模式"></a>枚举实现单例模式</h3><p>单例模式是最常用的设计模式。</p>
<p>单例模式在并发环境下存在线程安全问题。</p>
<p>为了线程安全问题，传统做法有以下几种：</p>
<ul>
<li>饿汉式加载</li>
<li>懒汉式 synchronize 和双重检查</li>
<li>利用 java 的静态加载机制</li>
</ul>
<p>相比上述的方法，使用枚举也可以实现单例，而且还更加简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleEnumDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SingleEn</span> &#123;</span><br><span class="line"></span><br><span class="line">        INSTANCE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SingleEn.INSTANCE.setName(<span class="string">&quot;zp&quot;</span>);</span><br><span class="line">        System.out.println(SingleEn.INSTANCE.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>扩展阅读：<a target="_blank" rel="noopener" href="https://blog.csdn.net/javazejian/article/details/71333103#enumset%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90">深入理解 Java 枚举类型(enum)</a></p>
<p>这篇文章对于 Java 枚举的特性讲解很仔细，其中对于枚举实现单例和传统单例实现方式说的尤为细致。</p>
</blockquote>
<h2 id="枚举工具类"><a href="#枚举工具类" class="headerlink" title="枚举工具类"></a>枚举工具类</h2><p>Java 中提供了两个方便操作 enum 的工具类——<code>EnumSet</code> 和 <code>EnumMap</code>。</p>
<h3 id="EnumSet"><a href="#EnumSet" class="headerlink" title="EnumSet"></a>EnumSet</h3><p><code>EnumSet</code> 是枚举类型的高性能 <code>Set</code> 实现。它要求放入它的枚举常量必须属于同一枚举类型。</p>
<p>主要接口：</p>
<ul>
<li><code>noneOf</code> - 创建一个具有指定元素类型的空 EnumSet</li>
<li><code>allOf</code> - 创建一个指定元素类型并包含所有枚举值的 EnumSet</li>
<li><code>range</code> - 创建一个包括枚举值中指定范围元素的 EnumSet</li>
<li><code>complementOf</code> - 初始集合包括指定集合的补集</li>
<li><code>of</code> - 创建一个包括参数中所有元素的 EnumSet</li>
<li><code>copyOf</code> - 创建一个包含参数容器中的所有元素的 EnumSet</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumSetDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;EnumSet展示&quot;</span>);</span><br><span class="line">        EnumSet&lt;ErrorCodeEn&gt; errSet = EnumSet.allOf(ErrorCodeEn.class);</span><br><span class="line">        <span class="keyword">for</span> (ErrorCodeEn e : errSet) &#123;</span><br><span class="line">            System.out.println(e.name() + <span class="string">&quot; : &quot;</span> + e.ordinal());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="EnumMap"><a href="#EnumMap" class="headerlink" title="EnumMap"></a>EnumMap</h3><p><code>EnumMap</code> 是专门为枚举类型量身定做的 <code>Map</code> 实现。虽然使用其它的 Map 实现（如 HashMap）也能完成枚举类型实例到值得映射，但是使用 EnumMap 会更加高效：它只能接收同一枚举类型的实例作为键值，并且由于枚举类型实例的数量相对固定并且有限，所以 EnumMap 使用数组来存放与枚举类型对应的值。这使得 EnumMap 的效率非常高。</p>
<p>主要接口：</p>
<ul>
<li><code>size</code> - 返回键值对数</li>
<li><code>containsValue</code> - 是否存在指定的 value</li>
<li><code>containsKey</code> - 是否存在指定的 key</li>
<li><code>get</code> - 根据指定 key 获取 value</li>
<li><code>put</code> - 取出指定的键值对</li>
<li><code>remove</code> - 删除指定 key</li>
<li><code>putAll</code> - 批量取出键值对</li>
<li><code>clear</code> - 清除数据</li>
<li><code>keySet</code> - 获取 key 集合</li>
<li><code>values</code> - 返回所有</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumMapDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Signal</span> &#123;</span><br><span class="line">        GREEN, YELLOW, RED</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;EnumMap展示&quot;</span>);</span><br><span class="line">        EnumMap&lt;Signal, String&gt; errMap = <span class="keyword">new</span> <span class="title class_">EnumMap</span>(Signal.class);</span><br><span class="line">        errMap.put(Signal.RED, <span class="string">&quot;红灯&quot;</span>);</span><br><span class="line">        errMap.put(Signal.YELLOW, <span class="string">&quot;黄灯&quot;</span>);</span><br><span class="line">        errMap.put(Signal.GREEN, <span class="string">&quot;绿灯&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;Map.Entry&lt;Signal, String&gt;&gt; iter = errMap.entrySet().iterator(); iter.hasNext();) &#123;</span><br><span class="line">            Map.Entry&lt;Signal, String&gt; entry = iter.next();</span><br><span class="line">            System.out.println(entry.getKey().name() + <span class="string">&quot; : &quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>扩展阅读：<a target="_blank" rel="noopener" href="https://blog.csdn.net/javazejian/article/details/71333103#enumset%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90">深入理解 Java 枚举类型(enum)</a></p>
<p>这篇文章中对 EnumSet 和 EnumMap 原理做了较为详细的介绍。</p>
</blockquote>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/1553002212154.png" alt="img"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/2130190/">Java 编程思想</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/3146174/">Java 核心技术（卷 1）</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/3360807/">Effective java</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/javazejian/article/details/71333103#enumset%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90">深入理解 Java 枚举类型(enum)</a></li>
<li><a target="_blank" rel="noopener" href="https://droidyue.com/blog/2016/11/29/dive-into-enum/">https://droidyue.com/blog/2016/11/29/dive-into-enum/</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/155518/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/155518/" class="post-title-link" itemprop="url">深入理解 Java 数组</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-05-06 15:02:02" itemprop="dateCreated datePublished" datetime="2019-05-06T15:02:02+08:00">2019-05-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JavaSE/%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7/" itemprop="url" rel="index"><span itemprop="name">基础特性</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="深入理解-Java-数组"><a href="#深入理解-Java-数组" class="headerlink" title="深入理解 Java 数组"></a>深入理解 Java 数组</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="数组的特性"><a href="#数组的特性" class="headerlink" title="数组的特性"></a>数组的特性</h3><p>数组对于每一门编程语言来说都是重要的数据结构之一，当然不同语言对数组的实现及处理也不尽相同。几乎所有程序设计语言都支持数组。</p>
<p>数组代表一系列对象或者基本数据类型，所有相同的类型都封装到一起，采用一个统一的标识符名称。</p>
<p><strong>数组的定义和使用需要通过方括号 <code>[]</code>。</strong></p>
<blockquote>
<p><strong>Java 中，数组是一种引用类型。</strong></p>
<p><strong>Java 中，数组是用来存储固定大小的同类型元素。</strong></p>
</blockquote>
<h3 id="数组和容器"><a href="#数组和容器" class="headerlink" title="数组和容器"></a>数组和容器</h3><p>Java 中，既然有了强大的容器，是不是就不需要数组了？</p>
<p>答案是不。</p>
<p>诚然，大多数情况下，应该选择容器存储数据。</p>
<p>但是，数组也不是毫无是处：</p>
<ul>
<li>Java 中，数组是一种效率最高的存储和随机访问对象引用序列的方式。<strong>数组的效率要高于容器</strong>（如 <code>ArrayList</code>）。</li>
<li><strong>数组可以持有值类型，而容器则不能</strong>（这时，就必须用到包装类）。</li>
</ul>
<h3 id="Java-数组的本质是对象"><a href="#Java-数组的本质是对象" class="headerlink" title="Java 数组的本质是对象"></a>Java 数组的本质是对象</h3><p><strong>Java 数组的本质是对象</strong>。它具有 Java 中其他对象的一些基本特点：封装了一些数据，可以访问属性，也可以调用方法。所以，数组是对象。</p>
<p>如果有两个类 A 和 B，如果 B 继承（extends）了 A，那么 A[] 类型的引用就可以指向 B[] 类型的对象。</p>
<blockquote>
<p>扩展阅读：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zhangjg_blog/article/details/16116613#t1">Java 中数组的特性</a></p>
<p>如果想要论证 <strong>Java 数组本质是对象</strong>，不妨一读这篇文章。</p>
</blockquote>
<h3 id="Java-数组和内存"><a href="#Java-数组和内存" class="headerlink" title="Java 数组和内存"></a>Java 数组和内存</h3><p>Java 数组在内存中的存储是这样的：</p>
<p>数组对象（这里可以看成一个指针）存储在栈中。</p>
<p>数组元素存储在堆中。</p>
<p>如下图所示：只有当 JVM 执行 <code>new String[]</code> 时，才会在堆中开辟相应的内存区域。数组对象 array 可以视为一个指针，指向这块内存的存储地址。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/1552473482942.png" alt="img"></p>
<h2 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h2><p>声明数组变量的语法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr1; <span class="comment">// 推荐风格</span></span><br><span class="line"><span class="type">int</span> arr2[]; <span class="comment">// 效果相同</span></span><br></pre></td></tr></table></figure>

<h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><p>Java 语言使用 <code>new</code> 操作符来创建数组。有两种创建数组方式：</p>
<ul>
<li>指定数组维度<ul>
<li>为数组开辟指定大小的数组维度。</li>
<li>如果数组元素是基础数据类型，会将每个元素设为默认值；如果是引用类型，元素值为 <code>null</code>。</li>
</ul>
</li>
<li>不指定数组维度<ul>
<li>用花括号中的实际元素初始化数组，数组大小与元素数相同。</li>
</ul>
</li>
</ul>
<p>示例 1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] array1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>]; <span class="comment">// 指定数组维度</span></span><br><span class="line">        <span class="type">int</span>[] array2 = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span> &#125;; <span class="comment">// 不指定数组维度</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;array1 size is &quot;</span> + array1.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> item : array1) &#123;</span><br><span class="line">            System.out.println(item);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;array2 size is &quot;</span> + array1.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> item : array2) &#123;</span><br><span class="line">            System.out.println(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// array1 size is 2</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// array2 size is 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>💡 <strong>说明</strong><br>请注意数组 array1 中的元素虽然没有初始化，但是 length 和指定的数组维度是一样的。这表明<strong>指定数组维度后，无论后面是否初始化数组中的元素，数组都已经开辟了相应的内存</strong>。</p>
<p>数组 array1 中的元素都被设为默认值。</p>
</blockquote>
<p>示例 2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        User[] array1 = <span class="keyword">new</span> <span class="title class_">User</span>[<span class="number">2</span>]; <span class="comment">// 指定数组维度</span></span><br><span class="line">        User[] array2 = <span class="keyword">new</span> <span class="title class_">User</span>[] &#123;<span class="keyword">new</span> <span class="title class_">User</span>(), <span class="keyword">new</span> <span class="title class_">User</span>()&#125;; <span class="comment">// 不指定数组维度</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;array1: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (User item : array1) &#123;</span><br><span class="line">            System.out.println(item);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;array2: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (User item : array2) &#123;</span><br><span class="line">            System.out.println(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// array1:</span></span><br><span class="line"><span class="comment">// null</span></span><br><span class="line"><span class="comment">// null</span></span><br><span class="line"><span class="comment">// array2:</span></span><br><span class="line"><span class="comment">// io.github.dunwu.javacore.array.ArrayDemo2$User@4141d797</span></span><br><span class="line"><span class="comment">// io.github.dunwu.javacore.array.ArrayDemo2$User@68f7aae2</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>💡 <strong>说明</strong></p>
<p>请将本例与示例 1 比较，可以发现：如果使用指定数组维度方式创建数组，且数组元素为引用类型，则数组中的元素元素值为 <code>null</code>。</p>
</blockquote>
<h3 id="数组维度的形式"><a href="#数组维度的形式" class="headerlink" title="数组维度的形式"></a>数组维度的形式</h3><p>创建数组时，指定的数组维度可以有多种形式：</p>
<ul>
<li>数组维度可以是整数、字符。</li>
<li>数组维度可以是整数型、字符型变量。</li>
<li>数组维度可以是计算结果为整数或字符的表达式。</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDemo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="comment">// 放开被注掉的代码，编译器会报错</span></span><br><span class="line">        <span class="comment">// int[] array = new int[4.0];</span></span><br><span class="line">        <span class="comment">// int[] array2 = new int[&quot;test&quot;];</span></span><br><span class="line">        <span class="type">int</span>[] array3 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="type">int</span>[] array4 = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">        <span class="type">int</span>[] array5 = <span class="keyword">new</span> <span class="title class_">int</span>[length + <span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span>[] array6 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="string">&#x27;a&#x27;</span> + <span class="number">2</span>];</span><br><span class="line">        <span class="comment">// int[] array7 = new int[length + 2.1];</span></span><br><span class="line">        System.out.println(<span class="string">&quot;array3.length = [&quot;</span> + array3.length + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;array4.length = [&quot;</span> + array4.length + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;array5.length = [&quot;</span> + array5.length + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;array6.length = [&quot;</span> + array6.length + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// array3.length = [97]</span></span><br><span class="line"><span class="comment">// array4.length = [3]</span></span><br><span class="line"><span class="comment">// array5.length = [5]</span></span><br><span class="line"><span class="comment">// array6.length = [99]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>💡 <strong>说明</strong></p>
<p>当指定的数组维度是字符时，Java 会将其转为整数。如字符 <code>a</code> 的 ASCII 码是 97。</p>
<p>综上，<strong>Java 数组的数组维度可以是常量、变量、表达式，只要转换为整数即可</strong>。</p>
<p>请留意，有些编程语言则不支持这点，如 C&#x2F;C++ 语言，只允许数组维度是常量。</p>
</blockquote>
<h3 id="数组维度的大小"><a href="#数组维度的大小" class="headerlink" title="数组维度的大小"></a>数组维度的大小</h3><p><strong>数组维度并非没有上限的，如果数值过大，编译时会报错。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">6553612431</span>]; <span class="comment">// 数组维度过大，编译报错</span></span><br></pre></td></tr></table></figure>

<p>此外，<strong>数组过大，可能会导致栈溢出</strong>。</p>
<h2 id="访问数组"><a href="#访问数组" class="headerlink" title="访问数组"></a>访问数组</h2><p><strong>Java 中，可以通过在 <code>[]</code> 中指定下标，访问数组元素，下标位置从 0 开始。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDemo4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            array[i]++;</span><br><span class="line">            System.out.println(String.format(<span class="string">&quot;array[%d] = %d&quot;</span>, i, array[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// array[0] = 2</span></span><br><span class="line"><span class="comment">// array[1] = 3</span></span><br><span class="line"><span class="comment">// array[2] = 4</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>💡 <strong>说明</strong></p>
<p>上面的示例中，从 0 开始，使用下标遍历数组 array 的所有元素，为每个元素值加 1 。</p>
</blockquote>
<h2 id="数组的引用"><a href="#数组的引用" class="headerlink" title="数组的引用"></a>数组的引用</h2><p><strong>Java 中，数组类型是一种引用类型</strong>。</p>
<p>因此，它可以作为引用，被 Java 函数<strong>作为函数入参或返回值</strong>。</p>
<p>数组作为函数入参的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayRefDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : array) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        fun(array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// 1	3	5</span></span><br></pre></td></tr></table></figure>

<p>数组作为函数返回值的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayRefDemo2</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回一个数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] fun() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] array = fun();</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// [1, 3, 5]</span></span><br></pre></td></tr></table></figure>

<h2 id="泛型和数组"><a href="#泛型和数组" class="headerlink" title="泛型和数组"></a>泛型和数组</h2><p>通常，数组和泛型不能很好地结合。你不能实例化具有参数化类型的数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Peel&lt;Banana&gt;[] peels = <span class="keyword">new</span> <span class="title class_">Pell</span>&lt;Banana&gt;[<span class="number">10</span>]; <span class="comment">// 这行代码非法</span></span><br></pre></td></tr></table></figure>

<p>Java 中不允许直接创建泛型数组。但是，可以通过创建一个类型擦除的数组，然后转型的方式来创建泛型数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericArrayDemo</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">GenericArray</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> T[] array;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">GenericArray</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">            array = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[num];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> index, T item)</span> &#123;</span><br><span class="line">            array[index] = item;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123; <span class="keyword">return</span> array[index]; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> T[] array() &#123; <span class="keyword">return</span> array; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        GenericArray&lt;Integer&gt; genericArray = <span class="keyword">new</span> <span class="title class_">GenericArray</span>&lt;Integer&gt;(<span class="number">4</span>);</span><br><span class="line">        genericArray.put(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        genericArray.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        Object[] array = genericArray.array();</span><br><span class="line">        System.out.println(Arrays.deepToString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// [0, 1, null, null]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>扩展阅读：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/jiangzhaowei/p/7399522.html">https://www.cnblogs.com/jiangzhaowei/p/7399522.html</a></p>
<p>我认为，对于泛型数组的理解，点到为止即可。实际上，真的需要存储泛型，还是使用容器更合适。</p>
</blockquote>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组。</p>
<p>Java 可以支持二维数组、三维数组、四维数组、五维数组。。。</p>
<p>但是，以正常人的理解能力，一般也就最多能理解三维数组。所以，请不要做反人类的事，去定义过多维度的数组。</p>
<p>多维数组使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiArrayDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Integer[][] a1 = &#123; <span class="comment">// 自动装箱</span></span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,&#125;,</span><br><span class="line">            &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,&#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">        Double[][][] a2 = &#123; <span class="comment">// 自动装箱</span></span><br><span class="line">            &#123; &#123;<span class="number">1.1</span>, <span class="number">2.2</span>&#125;, &#123;<span class="number">3.3</span>, <span class="number">4.4</span>&#125; &#125;,</span><br><span class="line">            &#123; &#123;<span class="number">5.5</span>, <span class="number">6.6</span>&#125;, &#123;<span class="number">7.7</span>, <span class="number">8.8</span>&#125; &#125;,</span><br><span class="line">            &#123; &#123;<span class="number">9.9</span>, <span class="number">1.2</span>&#125;, &#123;<span class="number">2.3</span>, <span class="number">3.4</span>&#125; &#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">        String[][] a3 = &#123;</span><br><span class="line">            &#123;<span class="string">&quot;The&quot;</span>, <span class="string">&quot;Quick&quot;</span>, <span class="string">&quot;Sly&quot;</span>, <span class="string">&quot;Fox&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;Jumped&quot;</span>, <span class="string">&quot;Over&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;The&quot;</span>, <span class="string">&quot;Lazy&quot;</span>, <span class="string">&quot;Brown&quot;</span>, <span class="string">&quot;Dog&quot;</span>, <span class="string">&quot;and&quot;</span>, <span class="string">&quot;friend&quot;</span>&#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;a1: &quot;</span> + Arrays.deepToString(a1));</span><br><span class="line">        System.out.println(<span class="string">&quot;a2: &quot;</span> + Arrays.deepToString(a2));</span><br><span class="line">        System.out.println(<span class="string">&quot;a3: &quot;</span> + Arrays.deepToString(a3));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// a1: [[1, 2, 3], [4, 5, 6]]</span></span><br><span class="line"><span class="comment">// a2: [[[1.1, 2.2], [3.3, 4.4]], [[5.5, 6.6], [7.7, 8.8]], [[9.9, 1.2], [2.3, 3.4]]]</span></span><br><span class="line"><span class="comment">// a3: [[The, Quick, Sly, Fox], [Jumped, Over], [The, Lazy, Brown, Dog, and, friend]]</span></span><br></pre></td></tr></table></figure>

<h2 id="Arrays-类"><a href="#Arrays-类" class="headerlink" title="Arrays 类"></a>Arrays 类</h2><p>Java 中，提供了一个很有用的数组工具类：Arrays。</p>
<p>它提供的主要操作有：</p>
<ul>
<li><code>sort</code> - 排序</li>
<li><code>binarySearch</code> - 查找</li>
<li><code>equals</code> - 比较</li>
<li><code>fill</code> - 填充</li>
<li><code>asList</code> - 转列表</li>
<li><code>hash</code> - 哈希</li>
<li><code>toString</code> - 转字符串</li>
</ul>
<blockquote>
<p>扩展阅读：<a target="_blank" rel="noopener" href="https://juejin.im/post/5a6ade5c518825733e60acb8">https://juejin.im/post/5a6ade5c518825733e60acb8</a></p>
</blockquote>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/1553753908349.png" alt="img"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/2130190/">Java 编程思想</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/3146174/">Java 核心技术（卷 1）</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhangjg_blog/article/details/16116613#t1">Java 中数组的特性</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/59cae3de6fb9a00a4551915b">https://juejin.im/post/59cae3de6fb9a00a4551915b</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jiangzhaowei/p/7399522.html">https://www.cnblogs.com/jiangzhaowei/p/7399522.html</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5a6ade5c518825733e60acb8">https://juejin.im/post/5a6ade5c518825733e60acb8</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/37415c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/37415c/" class="post-title-link" itemprop="url">深入理解 Java 异常</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-05-06 15:02:02" itemprop="dateCreated datePublished" datetime="2019-05-06T15:02:02+08:00">2019-05-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JavaSE/" itemprop="url" rel="index"><span itemprop="name">JavaSE</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JavaSE/%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7/" itemprop="url" rel="index"><span itemprop="name">基础特性</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>10k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="深入理解-Java-异常"><a href="#深入理解-Java-异常" class="headerlink" title="深入理解 Java 异常"></a>深入理解 Java 异常</h1><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/1553752019030.png" alt="img"></p>
<h2 id="异常框架"><a href="#异常框架" class="headerlink" title="异常框架"></a>异常框架</h2><h3 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h3><p><strong><code>Throwable</code> 是 Java 语言中所有错误（<code>Error</code>）和异常（<code>Exception</code>）的超类。</strong>在 Java 中只有 <code>Throwable</code> 类型的实例才可以被抛出（<code>throw</code>）或者捕获（<code>catch</code>），它是异常处理机制的基本组成类型。</p>
<p><code>Throwable</code> 包含了其线程创建时线程执行堆栈的快照，它提供了 <code>printStackTrace()</code> 等接口用于获取堆栈跟踪数据等信息。</p>
<p>主要方法：</p>
<ul>
<li><code>fillInStackTrace</code> - 用当前的调用栈层次填充 <code>Throwable</code> 对象栈层次，添加到栈层次任何先前信息中。</li>
<li><code>getMessage</code> - 返回关于发生的异常的详细信息。这个消息在 <code>Throwable</code> 类的构造函数中初始化了。</li>
<li><code>getCause</code> - 返回一个 <code>Throwable</code> 对象代表异常原因。</li>
<li><code>getStackTrace</code> - 返回一个包含堆栈层次的数组。下标为 0 的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。</li>
<li><code>printStackTrace</code> - 打印 <code>toString()</code> 结果和栈层次到 <code>System.err</code>，即错误输出流。</li>
<li><code>toString</code> - 使用 <code>getMessage</code> 的结果返回代表 <code>Throwable</code> 对象的字符串。</li>
</ul>
<h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><p><code>Error</code> 是 <code>Throwable</code> 的一个子类。**<code>Error</code> 表示正常情况下，不大可能出现的严重问题<strong>。</strong>编译器不会检查 <code>Error</code>**。绝大部分的 Error 都会导致程序（比如 JVM 自身）处于非正常的、不可恢复状态。既然是非正常情况，所以不便于也不需要捕获，常见的比如 OutOfMemoryError 之类，都是 Error 的子类。</p>
<p>常见 <code>Error</code>：</p>
<ul>
<li><code>AssertionError</code> - 断言错误。</li>
<li><code>VirtualMachineError</code> - 虚拟机错误。</li>
<li><code>UnsupportedClassVersionError</code> - Java 类版本错误。</li>
<li><code>StackOverflowError</code> - 栈溢出错误。</li>
<li><code>OutOfMemoryError</code> - 内存溢出错误。</li>
</ul>
<h3 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h3><p><code>Exception</code> 是 <code>Throwable</code> 的一个子类。**<code>Exception</code> 表示合理的应用程序可能想要捕获的条件。**Exception 是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理。</p>
<p>Exception 又分为可检查（checked）异常和不检查（unchecked）异常，可检查异常在源代码里必须显式地进行捕获处理，这是编译期检查的一部分。</p>
<p><strong>编译器会检查 <code>Exception</code> 异常。</strong>此类异常，要么通过 <code>throws</code> 进行声明抛出，要么通过 <code>try catch</code> 进行捕获处理，否则不能通过编译。</p>
<p>常见 <code>Exception</code>：</p>
<ul>
<li><code>ClassNotFoundException</code> - 应用程序试图加载类时，找不到相应的类，抛出该异常。</li>
<li><code>CloneNotSupportedException</code> - 当调用 Object 类中的 clone 方法克隆对象，但该对象的类无法实现 Cloneable 接口时，抛出该异常。</li>
<li><code>IllegalAccessException</code> - 拒绝访问一个类的时候，抛出该异常。</li>
<li><code>InstantiationException</code> - 当试图使用 Class 类中的 newInstance 方法创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象类而无法实例化时，抛出该异常。</li>
<li><code>InterruptedException</code> - 一个线程被另一个线程中断，抛出该异常。</li>
<li><code>NoSuchFieldException</code> - 请求的变量不存在。</li>
<li><code>NoSuchMethodException</code> - 请求的方法不存在。</li>
</ul>
<p>【示例】<code>Exception</code> 示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> String.class.getMethod(<span class="string">&quot;toString&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>试图编译运行时会报错：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error:(<span class="number">7</span>, <span class="number">47</span>) java: 未报告的异常错误java.lang.NoSuchMethodException; 必须对其进行捕获或声明以便抛出</span><br></pre></td></tr></table></figure>

<h3 id="RuntimeException"><a href="#RuntimeException" class="headerlink" title="RuntimeException"></a>RuntimeException</h3><p><code>RuntimeException</code> 是 <code>Exception</code> 的一个子类。<code>RuntimeException</code> 是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。</p>
<p><strong>编译器不会检查 <code>RuntimeException</code> 异常。</strong>当程序中可能出现这类异常时，倘若既没有通过 <code>throws</code> 声明抛出它，也没有用 <code>try catch</code> 语句捕获它，程序还是会编译通过。</p>
<p>【示例】<code>RuntimeException</code> 示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuntimeExceptionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 此处产生了异常</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;两个数字相除的结果：&quot;</span> + result);</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>运行时输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.ArithmeticException: / by zero</span><br><span class="line">	at io.github.dunwu.javacore.exception.RumtimeExceptionDemo01.main(RumtimeExceptionDemo01.java:<span class="number">6</span>)</span><br></pre></td></tr></table></figure>

<p>常见 <code>RuntimeException</code>：</p>
<ul>
<li><code>ArrayIndexOutOfBoundsException</code> - 用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引。</li>
<li><code>ArrayStoreException</code> - 试图将错误类型的对象存储到一个对象数组时抛出的异常。</li>
<li><code>ClassCastException</code> - 当试图将对象强制转换为不是实例的子类时，抛出该异常。</li>
<li><code>IllegalArgumentException</code> - 抛出的异常表明向方法传递了一个不合法或不正确的参数。</li>
<li><code>IllegalMonitorStateException</code> - 抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程。</li>
<li><code>IllegalStateException</code> - 在非法或不适当的时间调用方法时产生的信号。换句话说，即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下。</li>
<li><code>IllegalThreadStateException</code> - 线程没有处于请求操作所要求的适当状态时抛出的异常。</li>
<li><code>IndexOutOfBoundsException</code> - 指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。</li>
<li><code>NegativeArraySizeException</code> - 如果应用程序试图创建大小为负的数组，则抛出该异常。</li>
<li><code>NullPointerException</code> - 当应用程序试图在需要对象的地方使用 null 时，抛出该异常</li>
<li><code>NumberFormatException</code> - 当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。</li>
<li><code>SecurityException</code> - 由安全管理器抛出的异常，指示存在安全侵犯。</li>
<li><code>StringIndexOutOfBoundsException</code> - 此异常由 String 方法抛出，指示索引或者为负，或者超出字符串的大小。</li>
<li><code>UnsupportedOperationException</code> - 当不支持请求的操作时，抛出该异常。</li>
</ul>
<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/1553752795010.png" alt="img"></p>
<p><strong>自定义一个异常类，只需要继承 <code>Exception</code> 或 <code>RuntimeException</code> 即可。</strong></p>
<p>【示例】自定义异常示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyExceptionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;自定义异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> io.github.dunwu.javacore.exception.MyExceptionDemo$MyException: 自定义异常</span><br><span class="line">	at io.github.dunwu.javacore.exception.MyExceptionDemo.main(MyExceptionDemo.java:<span class="number">9</span>)</span><br></pre></td></tr></table></figure>

<h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><p>如果想在程序中明确地抛出异常，需要用到 <code>throw</code> 和 <code>throws</code> 。</p>
<p>如果一个方法没有捕获一个检查性异常，那么该方法必须使用 <code>throws</code> 关键字来声明。<code>throws</code> 关键字放在方法签名的尾部。</p>
<p>【示例】<code>throw</code> 示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThrowDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;抛出一个异常&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java<span class="selector-class">.lang</span><span class="selector-class">.RuntimeException</span>: 抛出一个异常</span><br></pre></td></tr></table></figure>

<p>也可以使用 <code>throw</code> 关键字抛出一个异常，无论它是新实例化的还是刚捕获到的。</p>
<p>【示例】<code>throws</code> 示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThrowsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, NoSuchFieldException &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> Integer.class.getDeclaredField(<span class="string">&quot;digits&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (field != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;反射获取 digits 方法成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> String.class.getMethod(<span class="string">&quot;toString&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line">        <span class="keyword">if</span> (method != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;反射获取 toString 方法成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用 f1 处，如果不用 try catch ，编译时会报错</span></span><br><span class="line">            f1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        f2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反射获取 digits 方法成功</span></span><br><span class="line">java.lang.NoSuchMethodException: java.lang.String.toString(<span class="type">int</span>)</span><br><span class="line">	at java.lang.Class.getMethod(Class.java:<span class="number">1786</span>)</span><br><span class="line">	at io.github.dunwu.javacore.exception.ThrowsDemo.f1(ThrowsDemo.java:<span class="number">12</span>)</span><br><span class="line">	at io.github.dunwu.javacore.exception.ThrowsDemo.f2(ThrowsDemo.java:<span class="number">21</span>)</span><br><span class="line">	at io.github.dunwu.javacore.exception.ThrowsDemo.main(ThrowsDemo.java:<span class="number">30</span>)</span><br></pre></td></tr></table></figure>

<p><code>throw</code> 和 <code>throws</code> 的区别：</p>
<ul>
<li><code>throws</code> 使用在函数上，<code>throw</code> 使用在函数内。</li>
<li><code>throws</code> 后面跟异常类，可以跟多个，用逗号区别；<code>throw</code> 后面跟的是异常对象。</li>
</ul>
<h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><p><strong>使用 try 和 catch 关键字可以捕获异常</strong>。<code>try catch</code> 代码块放在异常可能发生的地方。</p>
<p>它的语法形式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能会发生异常的代码块</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">    <span class="comment">// 捕获并处理try抛出的异常类型Exception</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception2 e2) &#123;</span><br><span class="line">    <span class="comment">// 捕获并处理try抛出的异常类型Exception2</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 无论是否发生异常，都将执行的代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，JDK7 以后，<code>catch</code> 多种异常时，也可以像下面这样简化代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能会发生异常的代码块</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception | Exception2 e) &#123;</span><br><span class="line">    <span class="comment">// 捕获并处理try抛出的异常类型</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 无论是否发生异常，都将执行的代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>try</code>、<code>catch</code>、<code>finally</code> 使用要点如下：</p>
<ul>
<li><p><code>try</code> - <strong><code>try</code> 语句用于监听</strong>。将要被监听的代码(可能抛出异常的代码)放在 <code>try</code> 语句块之内，当 <code>try</code> 语句块内发生异常时，异常就被抛出。</p>
</li>
<li><p><code>catch</code> - <strong><code>catch</code> 语句包含要捕获异常类型的声明</strong>。当保护代码块中发生一个异常时，<code>try</code> 后面的 <code>catch</code> 块就会被检查。</p>
</li>
<li><p><code>finally</code> - <strong><code>finally</code> 语句块总是会被执行，无论是否出现异常。</strong><code>try catch</code> 语句后不一定非要 <code>finally</code> 语句。<code>finally</code> 常用于这样的场景：由于 <code>finally</code> 语句块总是会被执行，所以那些在 <code>try</code> 代码块中打开的，并且必须回收的物理资源(如数据库连接、网络连接和文件)，一般会放在 <code>finally</code> 语句块中释放资源。</p>
</li>
<li><p><strong><code>try</code>、<code>catch</code>、<code>finally</code> 三个代码块中的局部变量不可共享使用</strong>。</p>
</li>
<li><p><code>catch</code> 块尝试捕获异常时，是按照 <code>catch</code> 块的声明顺序依次寻找的，一旦匹配，就不会再向下执行。因此，如果同一个 <code>try</code> 块下的多个 <code>catch</code> 异常类型有父子关系，应该将子类异常放在前面，父类异常放在后面。</p>
</li>
</ul>
<p>【示例】<code>try</code>、<code>catch</code>、<code>finally</code> 使用示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TryCatchFinallyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 此处产生了异常</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;两个数字相除的结果：&quot;</span> + temp);</span><br><span class="line">            System.out.println(<span class="string">&quot;----------------------------&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;出现异常了：&quot;</span> + e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不管是否出现异常，都执行此代码&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>运行时输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 出现异常了：java.lang.ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">// 不管是否出现异常，都执行此代码</span></span><br></pre></td></tr></table></figure>

<h2 id="异常链"><a href="#异常链" class="headerlink" title="异常链"></a>异常链</h2><p>异常链是以一个异常对象为参数构造新的异常对象，新的异常对象将包含先前异常的信息。</p>
<p>通过使用异常链，我们可以提高代码的可理解性、系统的可维护性和友好性。</p>
<p>我们有两种方式处理异常，一是 <code>throws</code> 抛出交给上级处理，二是 <code>try…catch</code> 做具体处理。<code>try…catch</code> 的 <code>catch</code> 块我们可以不需要做任何处理，仅仅只用 throw 这个关键字将我们封装异常信息主动抛出来。然后在通过关键字 <code>throws</code> 继续抛出该方法异常。它的上层也可以做这样的处理，以此类推就会产生一条由异常构成的异常链。</p>
<p>【示例】异常链示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionChainDemo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyException1</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyException1</span><span class="params">(String message)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyException2</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyException2</span><span class="params">(String message, Throwable cause)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(message, cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> <span class="keyword">throws</span> MyException1 &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException1</span>(<span class="string">&quot;出现 MyException1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span> <span class="keyword">throws</span> MyException2 &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            f1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MyException1 e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException2</span>(<span class="string">&quot;出现 MyException2&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MyException2 &#123;</span><br><span class="line">        f2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> io.github.dunwu.javacore.exception.ExceptionChainDemo$MyException2: 出现 MyException2</span><br><span class="line">	at io.github.dunwu.javacore.exception.ExceptionChainDemo.f2(ExceptionChainDemo.java:<span class="number">29</span>)</span><br><span class="line">	at io.github.dunwu.javacore.exception.ExceptionChainDemo.main(ExceptionChainDemo.java:<span class="number">34</span>)</span><br><span class="line">Caused by: io.github.dunwu.javacore.exception.ExceptionChainDemo$MyException1: 出现 MyException1</span><br><span class="line">	at io.github.dunwu.javacore.exception.ExceptionChainDemo.f1(ExceptionChainDemo.java:<span class="number">22</span>)</span><br><span class="line">	at io.github.dunwu.javacore.exception.ExceptionChainDemo.f2(ExceptionChainDemo.java:<span class="number">27</span>)</span><br><span class="line">	... <span class="number">1</span> more</span><br></pre></td></tr></table></figure>

<blockquote>
<p>扩展阅读：<a target="_blank" rel="noopener" href="https://juejin.im/post/5b6d61e55188251b38129f9a#heading-10">https://juejin.im/post/5b6d61e55188251b38129f9a#heading-10</a></p>
<p>这篇文章中对于异常链讲解比较详细。</p>
</blockquote>
<h2 id="异常注意事项"><a href="#异常注意事项" class="headerlink" title="异常注意事项"></a>异常注意事项</h2><h3 id="finally-覆盖异常"><a href="#finally-覆盖异常" class="headerlink" title="finally 覆盖异常"></a>finally 覆盖异常</h3><p>Java 异常处理中 <code>finally</code> 中的 <code>return</code> 会覆盖 <code>catch</code> 代码块中的 <code>return</code> 语句和 <code>throw</code> 语句，所以<strong>不建议在 <code>finally</code> 中使用 <code>return</code> 语句</strong>。</p>
<p>此外 <code>finally</code> 中的 <code>throw</code> 语句也会覆盖 <code>catch</code> 代码块中的 <code>return</code> 语句和 <code>throw</code> 语句。</p>
<p>【示例】<code>finally</code> 覆盖示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinallyOverrideExceptionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            f();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：C</span></span><br></pre></td></tr></table></figure>

<h3 id="覆盖抛出异常的方法"><a href="#覆盖抛出异常的方法" class="headerlink" title="覆盖抛出异常的方法"></a>覆盖抛出异常的方法</h3><p>当子类重写父类带有 <code>throws</code> 声明的函数时，其 <code>throws</code> 声明的异常必须在父类异常的可控范围内；用于处理父类的 <code>throws</code> 方法的异常处理器，必须也适用于子类的这个带 <code>throws</code> 方法——这是为了支持多态。</p>
<p>【示例】覆盖抛出异常示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionOverrideDemo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SQLException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Father</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Father</span>();</span><br><span class="line">        <span class="type">Father</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            obj1.start();</span><br><span class="line">            obj2.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的示例编译时会报错，原因在于：</p>
<p>因为 Son 类抛出异常的实质是 <code>SQLException</code>，而 <code>IOException</code> 无法处理它。那么这里的 try catch 就不能处理 Son 中的异常了。多态就不能实现了。</p>
</blockquote>
<h3 id="异常和线程"><a href="#异常和线程" class="headerlink" title="异常和线程"></a>异常和线程</h3><p>如果 Java 程序只有一个线程，那么没有被任何代码处理的异常会导致程序终止。如果 Java 程序是多线程的，那么没有被任何代码处理的异常仅仅会导致异常所在的线程结束。</p>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ul>
<li>对可恢复的情况使用检查性异常 <code>Exception</code>；对编程错误使用运行时异常<code>RuntimeException</code>。</li>
<li>优先使用 Java 标准的异常。</li>
<li>抛出与抽象相对应的异常。</li>
<li>在细节消息中包含能捕获失败的信息。</li>
<li>尽可能减少 try 代码块的大小。</li>
<li>尽量缩小异常范围。例如，如果明知尝试捕获的是一个 <code>ArithmeticException</code>，就应该 <code>catch</code> <code>ArithmeticException</code>，而不是 <code>catch</code> 范围较大的 <code>RuntimeException</code>，甚至是 <code>Exception</code>。</li>
<li>尽量不要在 <code>finally</code> 块抛出异常或者返回值。</li>
<li>不要忽略异常，一旦捕获异常，就应该处理，而非丢弃。</li>
<li>异常处理效率很低，所以不要用异常进行业务逻辑处理。</li>
<li>各类异常必须要有单独的日志记录，将异常分级，分类管理，因为有的时候仅仅想给第三方运维看到逻辑异常，而不是更细节的信息。如何对异常进行分类：<ul>
<li><strong>逻辑异常</strong> - 这类异常用于描述业务无法按照预期的情况处理下去，属于用户制造的意外。</li>
<li><strong>代码错误</strong> - 这类异常用于描述开发的代码错误，例如 NPE，ILLARG，都属于程序员制造的 BUG。</li>
<li><strong>专有异常</strong> - 多用于特定业务场景，用于描述指定作业出现意外情况无法预先处理。</li>
</ul>
</li>
</ul>
<blockquote>
<p>扩展阅读：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/3360807/">Effective java 中文版 之 第九章 异常</a></li>
<li><a target="_blank" rel="noopener" href="https://my.oschina.net/c5ms/blog/1827907">优雅的处理你的 Java 异常</a></li>
</ul>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/2130190/">Java 编程思想</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/3146174/">Java 核心技术（卷 1）</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/3360807/">Effective java 中文版 之 第九章 异常</a></li>
<li><a target="_blank" rel="noopener" href="https://my.oschina.net/c5ms/blog/1827907">优雅的处理你的 Java 异常</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5b6d61e55188251b38129f9a#heading-17">https://juejin.im/post/5b6d61e55188251b38129f9a#heading-17</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/skywang12345/p/3544168.html">https://www.cnblogs.com/skywang12345/p/3544168.html</a></li>
<li><a target="_blank" rel="noopener" href="http://www.importnew.com/26613.html">http://www.importnew.com/26613.html</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/35/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/35/">35</a><span class="page-number current">36</span><a class="page-number" href="/page/37/">37</a><span class="space">&hellip;</span><a class="page-number" href="/page/47/">47</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/37/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2015 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">李狗蛋</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">3.5m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">53:28</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/yiyirushi/" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.1/dist/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  




<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>

</body>
</html>
