<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/uploads/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/uploads/favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.ligoudan.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="天气不错哇，你看这大冰雹下得">
<meta property="og:type" content="website">
<meta property="og:title" content="LIGOUDAN">
<meta property="og:url" content="https://www.ligoudan.cn/page/13/index.html">
<meta property="og:site_name" content="LIGOUDAN">
<meta property="og:description" content="天气不错哇，你看这大冰雹下得">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="李狗蛋">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://www.ligoudan.cn/page/13/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/13/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>LIGOUDAN</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">LIGOUDAN</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">好好学习，天天向上</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">326</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">137</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">461</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="李狗蛋"
      src="/uploads/ligoudan.png">
  <p class="site-author-name" itemprop="name">李狗蛋</p>
  <div class="site-description" itemprop="description">天气不错哇，你看这大冰雹下得</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">461</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">137</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">326</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/yiyirushi" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yiyirushi" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yuanhaohoo@163.com" title="E-Mail → mailto:yuanhaohoo@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/5f7893/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/5f7893/" class="post-title-link" itemprop="url">Ehcache 快速入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-17 22:34:30" itemprop="dateCreated datePublished" datetime="2022-02-17T22:34:30+08:00">2022-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">中间件</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E7%BC%93%E5%AD%98/" itemprop="url" rel="index"><span itemprop="name">缓存</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>11 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Ehcache-快速入门"><a href="#Ehcache-快速入门" class="headerlink" title="Ehcache 快速入门"></a>Ehcache 快速入门</h1><blockquote>
<p>EhCache 是一个纯 Java 的进程内缓存框架，具有快速、精干等特点，是 Hibernate 中默认的 CacheProvider。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/technology/cache/ehcache-architecture.png" alt="img"></p>
<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><blockquote>
<p>Ehcache 虽然也支持分布式模式，但是分布式方案不是很好好，建议只将其作为单机的进程内缓存使用。</p>
</blockquote>
<h3 id="Ehcache-特性"><a href="#Ehcache-特性" class="headerlink" title="Ehcache 特性"></a>Ehcache 特性</h3><p>优点</p>
<ul>
<li>快速、简单</li>
<li>支持多种缓存策略：LRU、LFU、FIFO 淘汰算法</li>
<li>缓存数据有两级：内存和磁盘，因此无需担心容量问题</li>
<li>缓存数据会在虚拟机重启的过程中写入磁盘</li>
<li>可以通过 RMI、可插入 API 等方式进行分布式缓存</li>
<li>具有缓存和缓存管理器的侦听接口</li>
<li>支持多缓存管理器实例，以及一个实例的多个缓存区域</li>
<li>提供 Hibernate 的缓存实现</li>
</ul>
<p>缺点</p>
<ul>
<li><strong>使用磁盘 Cache 的时候非常占用磁盘空间</strong></li>
<li><strong>不保证数据的安全</strong></li>
<li>虽然支持分布式缓存，但效率不高（通过组播方式，在不同节点之间同步数据）。</li>
</ul>
<h3 id="Ehcache-集群"><a href="#Ehcache-集群" class="headerlink" title="Ehcache 集群"></a>Ehcache 集群</h3><p>Ehcache 目前支持五种集群方式：</p>
<ul>
<li>RMI</li>
<li>JMS</li>
<li>JGroup</li>
<li>Terracotta</li>
<li>Ehcache Server</li>
</ul>
<h4 id="RMI"><a href="#RMI" class="headerlink" title="RMI"></a>RMI</h4><p>使用组播方式通知所有节点同步数据。</p>
<p>如果网络有问题，或某台服务宕机，则存在数据无法同步的可能，导致数据不一致。</p>
<p><img src="https://www.ehcache.org/images/documentation/rmi_replication.png" alt="Ehcache Image"></p>
<h4 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h4><p>JMS 类似 MQ，所有节点订阅消息，当某节点缓存发生变化，就向 JMS 发消息，其他节点感知变化后，同步数据。</p>
<p><img src="https://www.ehcache.org/images/documentation/jms_replication.png" alt="Ehcache Image"></p>
<h4 id="Cache-Server"><a href="#Cache-Server" class="headerlink" title="Cache Server"></a>Cache Server</h4><p><img src="https://www.ehcache.org/images/documentation/loadbalancer_hashing.png" alt="Ehcache Image"></p>
<h2 id="二、快速入门"><a href="#二、快速入门" class="headerlink" title="二、快速入门"></a>二、快速入门</h2><h3 id="引入-Ehcache"><a href="#引入-Ehcache" class="headerlink" title="引入 Ehcache"></a>引入 Ehcache</h3><p>如果你的项目使用 maven 管理，添加以下依赖到你的 pom.xml 中。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sf.ehcache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果你的项目不使用 maven 管理，请在 <a target="_blank" rel="noopener" href="http://www.ehcache.org/downloads/">Ehcache 官网下载地址</a> 下载 jar 包。</p>
<p>Spring 提供了对于 Ehcache 接口的封装，可以更简便的使用其功能。接入方式如下：</p>
<p>如果你的项目使用 maven 管理，添加以下依赖到你的<em>pom.xml</em>中。</p>
<p><code>spring-context-support</code>这个 jar 包中含有 Spring 对于缓存功能的抽象封装接口。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-support<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="添加配置文件"><a href="#添加配置文件" class="headerlink" title="添加配置文件"></a>添加配置文件</h3><p>（1）在 classpath 下添加 <code>ehcache.xml</code><br>添加一个名为 <em>helloworld</em> 的缓存。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">&quot;http://ehcache.org/ehcache.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 磁盘缓存位置 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">&quot;java.io.tmpdir/ehcache&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 默认缓存 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">defaultCache</span></span></span><br><span class="line"><span class="tag">          <span class="attr">maxEntriesLocalHeap</span>=<span class="string">&quot;10000&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">maxEntriesLocalDisk</span>=<span class="string">&quot;10000000&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">&quot;LRU&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- helloworld缓存 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">&quot;helloworld&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">maxElementsInMemory</span>=<span class="string">&quot;1000&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;5&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;5&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">overflowToDisk</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">&quot;LRU&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Ehcache-工作示例"><a href="#Ehcache-工作示例" class="headerlink" title="Ehcache 工作示例"></a>Ehcache 工作示例</h3><p>Ehcache 会自动加载 <code>classpath</code> 根目录下名为 <code>ehcache.xml</code> 文件。</p>
<p>EhcacheDemo 的工作步骤如下：</p>
<ol>
<li>在 EhcacheDemo 中，我们引用 <code>ehcache.xml</code> 声明的名为 <em>helloworld</em> 的缓存来创建<code>Cache</code>对象；</li>
<li>然后我们用一个键值对来实例化<code>Element</code>对象；</li>
<li>将<code>Element</code>对象添加到<code>Cache</code>；</li>
<li>然后用<code>Cache</code>的 get 方法获取<code>Element</code>对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EhcacheDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// Create a cache manager</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">CacheManager</span> <span class="variable">cacheManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CacheManager</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create the cache called &quot;helloworld&quot;</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Cache</span> <span class="variable">cache</span> <span class="operator">=</span> cacheManager.getCache(<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create a key to map the data to</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;greeting&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a data element</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Element</span> <span class="variable">putGreeting</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Element</span>(key, <span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Put the element into the data store</span></span><br><span class="line">        cache.put(putGreeting);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Retrieve the data element</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Element</span> <span class="variable">getGreeting</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Print the value</span></span><br><span class="line">        System.out.println(getGreeting.getObjectValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Hello,</span> World!</span><br></pre></td></tr></table></figure>

<h2 id="三、Ehcache-API"><a href="#三、Ehcache-API" class="headerlink" title="三、Ehcache API"></a>三、Ehcache API</h2><p><code>Element</code>、<code>Cache</code>、<code>CacheManager</code>是 Ehcache 最重要的 API。</p>
<ul>
<li><code>Element</code> - 缓存的元素，它维护着一个键值对。</li>
<li><code>Cache</code> - 它是 Ehcache 的核心类，它有多个<code>Element</code>，并被<code>CacheManager</code>管理。它实现了对缓存的逻辑行为。</li>
<li><code>CacheManager</code> - <code>Cache</code>的容器对象，并管理着<code>Cache</code>的生命周期。CacheManager 支持两种创建模式：单例（Singleton mode）和实例（InstanceMode）。</li>
</ul>
<h3 id="创建-CacheManager"><a href="#创建-CacheManager" class="headerlink" title="创建 CacheManager"></a>创建 CacheManager</h3><p>下面的代码列举了创建 <code>CacheManager</code> 的五种方式。</p>
<p>使用静态方法<code>create()</code>会以默认配置来创建单例的<code>CacheManager</code>实例。</p>
<p><code>newInstance()</code>方法是一个工厂方法，以默认配置创建一个新的<code>CacheManager</code>实例。</p>
<p>此外，<code>newInstance()</code>还有几个重载函数，分别可以通过传入<code>String</code>、<code>URL</code>、<code>InputStream</code>参数来加载配置文件，然后创建<code>CacheManager</code>实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Ehcache默认配置获取单例的CacheManager实例</span></span><br><span class="line">CacheManager.create();</span><br><span class="line">String[] cacheNames = CacheManager.getInstance().getCacheNames();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Ehcache默认配置新建一个CacheManager实例</span></span><br><span class="line">CacheManager.newInstance();</span><br><span class="line">String[] cacheNames = manager.getCacheNames();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用不同的配置文件分别创建一个CacheManager实例</span></span><br><span class="line"><span class="type">CacheManager</span> <span class="variable">manager1</span> <span class="operator">=</span> CacheManager.newInstance(<span class="string">&quot;src/config/ehcache1.xml&quot;</span>);</span><br><span class="line"><span class="type">CacheManager</span> <span class="variable">manager2</span> <span class="operator">=</span> CacheManager.newInstance(<span class="string">&quot;src/config/ehcache2.xml&quot;</span>);</span><br><span class="line">String[] cacheNamesForManager1 = manager1.getCacheNames();</span><br><span class="line">String[] cacheNamesForManager2 = manager2.getCacheNames();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于classpath下的配置文件创建CacheManager实例</span></span><br><span class="line"><span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> getClass().getResource(<span class="string">&quot;/anotherconfigurationname.xml&quot;</span>);</span><br><span class="line"><span class="type">CacheManager</span> <span class="variable">manager</span> <span class="operator">=</span> CacheManager.newInstance(url);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于文件流得到配置文件，并创建CacheManager实例</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span></span><br><span class="line">(<span class="string">&quot;src/config/ehcache.xml&quot;</span>).getAbsolutePath());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="type">CacheManager</span> <span class="variable">manager</span> <span class="operator">=</span> CacheManager.newInstance(fis);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"> fis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加缓存"><a href="#添加缓存" class="headerlink" title="添加缓存"></a>添加缓存</h3><p><strong>需要强调一点，<code>Cache</code>对象在用<code>addCache</code>方法添加到<code>CacheManager</code>之前，是无效的。</strong></p>
<p>使用 CacheManager 的 addCache 方法可以根据缓存名将 ehcache.xml 中声明的 cache 添加到容器中；它也可以直接将 Cache 对象添加到缓存容器中。</p>
<p><code>Cache</code>有多个构造函数，提供了不同方式去加载缓存的配置参数。</p>
<p>有时候，你可能需要使用 API 来动态的添加缓存，下面的例子就提供了这样的范例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 除了可以使用xml文件中配置的缓存，你也可以使用API动态增删缓存</span></span><br><span class="line"><span class="comment">// 添加缓存</span></span><br><span class="line">manager.addCache(cacheName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用默认配置添加缓存</span></span><br><span class="line"><span class="type">CacheManager</span> <span class="variable">singletonManager</span> <span class="operator">=</span> CacheManager.create();</span><br><span class="line">singletonManager.addCache(<span class="string">&quot;testCache&quot;</span>);</span><br><span class="line"><span class="type">Cache</span> <span class="variable">test</span> <span class="operator">=</span> singletonManager.getCache(<span class="string">&quot;testCache&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用自定义配置添加缓存，注意缓存未添加进CacheManager之前并不可用</span></span><br><span class="line"><span class="type">CacheManager</span> <span class="variable">singletonManager</span> <span class="operator">=</span> CacheManager.create();</span><br><span class="line"><span class="type">Cache</span> <span class="variable">memoryOnlyCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cache</span>(<span class="string">&quot;testCache&quot;</span>, <span class="number">5000</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line">singletonManager.addCache(memoryOnlyCache);</span><br><span class="line"><span class="type">Cache</span> <span class="variable">test</span> <span class="operator">=</span> singletonManager.getCache(<span class="string">&quot;testCache&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用特定的配置添加缓存</span></span><br><span class="line"><span class="type">CacheManager</span> <span class="variable">manager</span> <span class="operator">=</span> CacheManager.create();</span><br><span class="line"><span class="type">Cache</span> <span class="variable">testCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cache</span>(</span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">CacheConfiguration</span>(<span class="string">&quot;testCache&quot;</span>, maxEntriesLocalHeap)</span><br><span class="line"> .memoryStoreEvictionPolicy(MemoryStoreEvictionPolicy.LFU)</span><br><span class="line"> .eternal(<span class="literal">false</span>)</span><br><span class="line"> .timeToLiveSeconds(<span class="number">60</span>)</span><br><span class="line"> .timeToIdleSeconds(<span class="number">30</span>)</span><br><span class="line"> .diskExpiryThreadIntervalSeconds(<span class="number">0</span>)</span><br><span class="line"> .persistence(<span class="keyword">new</span> <span class="title class_">PersistenceConfiguration</span>().strategy(Strategy.LOCALTEMPSWAP)));</span><br><span class="line"> manager.addCache(testCache);</span><br></pre></td></tr></table></figure>

<h3 id="删除缓存"><a href="#删除缓存" class="headerlink" title="删除缓存"></a>删除缓存</h3><p>删除缓存比较简单，你只需要将指定的缓存名传入<code>removeCache</code>方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CacheManager</span> <span class="variable">singletonManager</span> <span class="operator">=</span> CacheManager.create();</span><br><span class="line">singletonManager.removeCache(<span class="string">&quot;sampleCache1&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="基本缓存操作"><a href="#基本缓存操作" class="headerlink" title="基本缓存操作"></a>基本缓存操作</h3><p>Cache 最重要的两个方法就是 put 和 get，分别用来添加 Element 和获取 Element。</p>
<p>Cache 还提供了一系列的 get、set 方法来设置或获取缓存参数，这里不一一列举，更多 API 操作可参考<a target="_blank" rel="noopener" href="http://www.ehcache.org/generated/2.10.2/pdf/Ehcache_API_Developer_Guide.pdf">官方 API 开发手册</a>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试：使用默认配置或使用指定配置来创建CacheManager</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Zhang Peng</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheOperationTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(CacheOperationTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用Ehcache默认配置(classpath下的ehcache.xml)获取单例的CacheManager实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CacheManager</span> <span class="variable">manager</span> <span class="operator">=</span> CacheManager.newInstance(<span class="string">&quot;src/test/resources/ehcache/ehcache.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得Cache的引用</span></span><br><span class="line">        <span class="type">Cache</span> <span class="variable">cache</span> <span class="operator">=</span> manager.getCache(<span class="string">&quot;userCache&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将一个Element添加到Cache</span></span><br><span class="line">        cache.put(<span class="keyword">new</span> <span class="title class_">Element</span>(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取Element，Element类支持序列化，所以下面两种方法都可以用</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">element1</span> <span class="operator">=</span> cache.get(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取非序列化的值</span></span><br><span class="line">        log.debug(<span class="string">&quot;key:&#123;&#125;, value:&#123;&#125;&quot;</span>, element1.getObjectKey(), element1.getObjectValue());</span><br><span class="line">        <span class="comment">// 获取序列化的值</span></span><br><span class="line">        log.debug(<span class="string">&quot;key:&#123;&#125;, value:&#123;&#125;&quot;</span>, element1.getKey(), element1.getValue());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新Cache中的Element</span></span><br><span class="line">        cache.put(<span class="keyword">new</span> <span class="title class_">Element</span>(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value2&quot;</span>));</span><br><span class="line">        <span class="type">Element</span> <span class="variable">element2</span> <span class="operator">=</span> cache.get(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;key:&#123;&#125;, value:&#123;&#125;&quot;</span>, element2.getObjectKey(), element2.getObjectValue());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取Cache的元素数</span></span><br><span class="line">        log.debug(<span class="string">&quot;cache size:&#123;&#125;&quot;</span>, cache.getSize());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取MemoryStore的元素数</span></span><br><span class="line">        log.debug(<span class="string">&quot;MemoryStoreSize:&#123;&#125;&quot;</span>, cache.getMemoryStoreSize());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取DiskStore的元素数</span></span><br><span class="line">        log.debug(<span class="string">&quot;DiskStoreSize:&#123;&#125;&quot;</span>, cache.getDiskStoreSize());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移除Element</span></span><br><span class="line">        cache.remove(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;cache size:&#123;&#125;&quot;</span>, cache.getSize());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭当前CacheManager对象</span></span><br><span class="line">        manager.shutdown();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭CacheManager单例实例</span></span><br><span class="line">        CacheManager.getInstance().shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、Ehcache-配置"><a href="#四、Ehcache-配置" class="headerlink" title="四、Ehcache 配置"></a>四、Ehcache 配置</h2><blockquote>
<p>Ehcache 支持通过 xml 文件和 API 两种方式进行配置。</p>
<p>详情参考：<a target="_blank" rel="noopener" href="http://www.ehcache.org/documentation/3.8/xml.html">Ehcache 官方 XML 配置手册</a></p>
</blockquote>
<h3 id="xml-配置方式"><a href="#xml-配置方式" class="headerlink" title="xml 配置方式"></a>xml 配置方式</h3><p>Ehcache 的<code>CacheManager</code>构造函数或工厂方法被调用时，会默认加载 classpath 下名为<em>ehcache.xml</em>的配置文件。如果加载失败，会加载 Ehcache jar 包中的<em>ehcache-failsafe.xml</em>文件，这个文件中含有简单的默认配置。<br><strong>ehcache.xml 配置参数说明：</strong></p>
<ul>
<li><strong>name</strong>：缓存名称。</li>
<li><strong>maxElementsInMemory</strong>：缓存最大个数。</li>
<li><strong>eternal</strong>：缓存中对象是否为永久的，如果是，超时设置将被忽略，对象从不过期。</li>
<li><strong>timeToIdleSeconds</strong>：置对象在失效前的允许闲置时间（单位：秒）。仅当 eternal&#x3D;false 对象不是永久有效时使用，可选属性，默认值是 0，也就是可闲置时间无穷大。</li>
<li><strong>timeToLiveSeconds</strong>：缓存数据的生存时间（TTL），也就是一个元素从构建到消亡的最大时间间隔值，这只能在元素不是永久驻留时有效，如果该值是 0 就意味着元素可以停顿无穷长的时间。</li>
<li><strong>maxEntriesLocalDisk</strong>：当内存中对象数量达到 maxElementsInMemory 时，Ehcache 将会对象写到磁盘中。</li>
<li><strong>overflowToDisk</strong>：内存不足时，是否启用磁盘缓存。</li>
<li><strong>diskSpoolBufferSizeMB</strong>：这个参数设置 DiskStore（磁盘缓存）的缓存区大小。默认是 30MB。每个 Cache 都应该有自己的一个缓冲区。</li>
<li><strong>maxElementsOnDisk</strong>：硬盘最大缓存个数。</li>
<li><strong>diskPersistent</strong>：是否在 VM 重启时存储硬盘的缓存数据。默认值是 false。</li>
<li><strong>diskExpiryThreadIntervalSeconds</strong>：磁盘失效线程运行时间间隔，默认是 120 秒。</li>
<li><strong>memoryStoreEvictionPolicy</strong>：当达到 maxElementsInMemory 限制时，Ehcache 将会根据指定的策略去清理内存。默认策略是 LRU（最近最少使用）。你可以设置为 FIFO（先进先出）或是 LFU（较少使用）。</li>
<li><strong>clearOnFlush</strong>：内存数量最大时是否清除。</li>
</ul>
<h3 id="API-配置方式"><a href="#API-配置方式" class="headerlink" title="API 配置方式"></a>API 配置方式</h3><p>xml 配置的参数也可以直接通过编程方式来动态的进行配置（dynamicConfig 没有设为 false）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Cache</span> <span class="variable">cache</span> <span class="operator">=</span> manager.getCache(<span class="string">&quot;sampleCache&quot;</span>);</span><br><span class="line"><span class="type">CacheConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> cache.getCacheConfiguration();</span><br><span class="line">config.setTimeToIdleSeconds(<span class="number">60</span>);</span><br><span class="line">config.setTimeToLiveSeconds(<span class="number">120</span>);</span><br><span class="line">config.setmaxEntriesLocalHeap(<span class="number">10000</span>);</span><br><span class="line">config.setmaxEntriesLocalDisk(<span class="number">1000000</span>);</span><br></pre></td></tr></table></figure>

<p>也可以通过<code>disableDynamicFeatures()</code>方式关闭动态配置开关。配置以后你将无法再以编程方式配置参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Cache</span> <span class="variable">cache</span> <span class="operator">=</span> manager.getCache(<span class="string">&quot;sampleCache&quot;</span>);</span><br><span class="line">cache.disableDynamicFeatures();</span><br></pre></td></tr></table></figure>

<h2 id="五、Spring-集成-Ehcache"><a href="#五、Spring-集成-Ehcache" class="headerlink" title="五、Spring 集成 Ehcache"></a>五、Spring 集成 Ehcache</h2><p>Spring3.1 开始添加了对缓存的支持。和事务功能的支持方式类似，缓存抽象允许底层使用不同的缓存解决方案来进行整合。</p>
<p>Spring4.1 开始支持 JSR-107 注解。</p>
<blockquote>
<p><strong>注：我本人使用的 Spring 版本为 4.1.4.RELEASE，目前 Spring 版本仅支持 Ehcache2.5 以上版本，但不支持 Ehcache3。</strong></p>
</blockquote>
<h3 id="绑定-Ehcache"><a href="#绑定-Ehcache" class="headerlink" title="绑定 Ehcache"></a>绑定 Ehcache</h3><p><code>org.springframework.cache.ehcache.EhCacheManagerFactoryBean</code>这个类的作用是加载 Ehcache 配置文件。<br><code>org.springframework.cache.ehcache.EhCacheCacheManager</code>这个类的作用是支持 net.sf.ehcache.CacheManager。</p>
<p><em>spring-ehcache.xml</em>的配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:cache</span>=<span class="string">&quot;http://www.springframework.org/schema/cache&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/cache</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/cache/spring-cache-3.2.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>ehcache缓存配置管理文件<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;ehcache&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.cache.ehcache.EhCacheManagerFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:ehcache/ehcache.xml&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cacheManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.cache.ehcache.EhCacheCacheManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cacheManager&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;ehcache&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 启用缓存注解开关 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cache:annotation-driven</span> <span class="attr">cache-manager</span>=<span class="string">&quot;cacheManager&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="使用-Spring-的缓存注解"><a href="#使用-Spring-的缓存注解" class="headerlink" title="使用 Spring 的缓存注解"></a>使用 Spring 的缓存注解</h3><h4 id="开启注解"><a href="#开启注解" class="headerlink" title="开启注解"></a>开启注解</h4><p>Spring 为缓存功能提供了注解功能，但是你必须启动注解。<br>你有两个选择：<br>(1) 在 xml 中声明<br>像上一节 spring-ehcache.xml 中的做法一样，使用<code>&lt;cache:annotation-driven/&gt;</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache:annotation-driven</span> <span class="attr">cache-manager</span>=<span class="string">&quot;cacheManager&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>(2) 使用标记注解<br>你也可以通过对一个类进行注解修饰的方式在这个类中使用缓存注解。<br>范例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注解基本使用方法"><a href="#注解基本使用方法" class="headerlink" title="注解基本使用方法"></a>注解基本使用方法</h3><p>Spring 对缓存的支持类似于对事务的支持。<br>首先使用注解标记方法，相当于定义了切点，然后使用 Aop 技术在这个方法的调用前、调用后获取方法的入参和返回值，进而实现了缓存的逻辑。<br>下面三个注解都是方法级别：</p>
<h4 id="Cacheable"><a href="#Cacheable" class="headerlink" title="@Cacheable"></a>@Cacheable</h4><p>表明所修饰的方法是可以缓存的：当第一次调用这个方法时，它的结果会被缓存下来，在缓存的有效时间内，以后访问这个方法都直接返回缓存结果，不再执行方法中的代码段。<br>这个注解可以用<code>condition</code>属性来设置条件，如果不满足条件，就不使用缓存能力，直接执行方法。<br>可以使用<code>key</code>属性来指定 key 的生成规则。</p>
<h4 id="CachePut"><a href="#CachePut" class="headerlink" title="@CachePut"></a>@CachePut</h4><p>与<code>@Cacheable</code>不同，<code>@CachePut</code>不仅会缓存方法的结果，还会执行方法的代码段。<br>它支持的属性和用法都与<code>@Cacheable</code>一致。</p>
<h4 id="CacheEvict"><a href="#CacheEvict" class="headerlink" title="@CacheEvict"></a>@CacheEvict</h4><p>与<code>@Cacheable</code>功能相反，<code>@CacheEvict</code>表明所修饰的方法是用来删除失效或无用的缓存数据。<br>下面是<code>@Cacheable</code>、<code>@CacheEvict</code>和<code>@CachePut</code>基本使用方法的一个集中展示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">// @Cacheable可以设置多个缓存，形式如：@Cacheable(&#123;&quot;books&quot;, &quot;isbns&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@Cacheable(value=&#123;&quot;users&quot;&#125;, key=&quot;#user.id&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> findUserInDB(user.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Cacheable(value = &quot;users&quot;, condition = &quot;#user.getId() &lt;= 2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findUserInLimit</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> findUserInDB(user.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CachePut(value = &quot;users&quot;, key = &quot;#user.getId()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        updateUserInDB(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CacheEvict(value = &quot;users&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        removeUserInDB(user.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CacheEvict(value = &quot;users&quot;, allEntries = true)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        removeAllInDB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Caching"><a href="#Caching" class="headerlink" title="@Caching"></a>@Caching</h4><p>如果需要使用同一个缓存注解（<code>@Cacheable</code>、<code>@CacheEvict</code>或<code>@CachePut</code>）多次修饰一个方法，就需要用到<code>@Caching</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Caching(evict = &#123; @CacheEvict(&quot;primary&quot;), @CacheEvict(cacheNames=&quot;secondary&quot;, key=&quot;#p0&quot;) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> Book <span class="title function_">importBooks</span><span class="params">(String deposit, Date date)</span></span><br></pre></td></tr></table></figure>

<h4 id="CacheConfig"><a href="#CacheConfig" class="headerlink" title="@CacheConfig"></a>@CacheConfig</h4><p>与前面的缓存注解不同，这是一个类级别的注解。<br>如果类的所有操作都是缓存操作，你可以使用<code>@CacheConfig</code>来指定类，省去一些配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheConfig(&quot;books&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookRepositoryImpl</span> <span class="keyword">implements</span> <span class="title class_">BookRepository</span> &#123;</span><br><span class="line"> <span class="meta">@Cacheable</span></span><br><span class="line"> <span class="keyword">public</span> Book <span class="title function_">findBook</span><span class="params">(ISBN isbn)</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><strong>官方</strong><ul>
<li><a target="_blank" rel="noopener" href="http://www.ehcache.org/">Ehcache 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/ehcache/ehcache3">Ehcache Github</a></li>
</ul>
</li>
<li><strong>文章</strong><ul>
<li><a target="_blank" rel="noopener" href="https://yq.aliyun.com/articles/72885?utm_campaign=wenzhang&utm_medium=article&utm_source=QQ-qun&2017331&utm_content=m_15513">Ehcache 优缺点以及分布式详解</a></li>
<li><a target="_blank" rel="noopener" href="http://raychase.iteye.com/blog/1545906">Ehcache 详细解读</a></li>
<li><a target="_blank" rel="noopener" href="http://www.ibm.com/developerworks/cn/opensource/os-cn-spring-cache/">注释驱动的 Spring cache 缓存介绍</a></li>
<li><a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/">Spring 官方文档第 36 章缓存抽象</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/30abaa/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/30abaa/" class="post-title-link" itemprop="url">Http 缓存</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-17 22:34:30" itemprop="dateCreated datePublished" datetime="2022-02-17T22:34:30+08:00">2022-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">中间件</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E7%BC%93%E5%AD%98/" itemprop="url" rel="index"><span itemprop="name">缓存</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Http-缓存"><a href="#Http-缓存" class="headerlink" title="Http 缓存"></a>Http 缓存</h1><p>HTTP 缓存分为 2 种，一种是强缓存，另一种是协商缓存。主要作用是可以加快资源获取速度，提升用户体验，减少网络传输，缓解服务端的压力。</p>
<h2 id="Http-强缓存"><a href="#Http-强缓存" class="headerlink" title="Http 强缓存"></a>Http 强缓存</h2><p>不需要发送请求到服务端，直接读取浏览器本地缓存，在 Chrome 的 Network 中显示的 HTTP 状态码是 200 ，在 Chrome 中，强缓存又分为 Disk Cache (存放在硬盘中)和 Memory Cache (存放在内存中)，存放的位置是由浏览器控制的。是否强缓存由 <code>Expires</code>、<code>Cache-Control</code> 和 <code>Pragma</code> 3 个 Header 属性共同来控制。</p>
<h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p><code>Expires</code> 的值是一个 HTTP 日期，在浏览器发起请求时，会根据系统时间和 Expires 的值进行比较，如果系统时间超过了 Expires 的值，缓存失效。由于和系统时间进行比较，所以当系统时间和服务器时间不一致的时候，会有缓存有效期不准的问题。Expires 的优先级在三个 Header 属性中是最低的。</p>
<h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p><code>Cache-Control</code> 是 HTTP&#x2F;1.1 中新增的属性，在请求头和响应头中都可以使用，常用的属性值如有：</p>
<ul>
<li><code>max-age</code>：单位是秒，缓存时间计算的方式是距离发起的时间的秒数，超过间隔的秒数缓存失效</li>
<li><code>no-cache</code>：不使用强缓存，需要与服务器验证缓存是否新鲜</li>
<li><code>no-store</code>：禁止使用缓存（包括协商缓存），每次都向服务器请求最新的资源</li>
<li><code>private</code>：专用于个人的缓存，中间代理、CDN 等不能缓存此响应</li>
<li><code>public</code>：响应可以被中间代理、CDN 等缓存</li>
<li><code>must-revalidate</code>：在缓存过期前可以使用，过期后必须向服务器验证</li>
</ul>
<h3 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a>Pragma</h3><p><code>Pragma</code> 只有一个属性值，就是 no-cache ，效果和 Cache-Control 中的 no-cache 一致，不使用强缓存，需要与服务器验证缓存是否新鲜，在 3 个头部属性中的优先级最高。</p>
<h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>当浏览器的强缓存失效的时候或者请求头中设置了不走强缓存，并且在请求头中设置了 If-Modified-Since 或者 If-None-Match 的时候，会将这两个属性值到服务端去验证是否命中协商缓存，如果命中了协商缓存，会返回 304 状态，加载浏览器缓存，并且响应头会设置 Last-Modified 或者 ETag 属性。</p>
<h3 id="ETag-If-None-Match"><a href="#ETag-If-None-Match" class="headerlink" title="ETag&#x2F;If-None-Match"></a>ETag&#x2F;If-None-Match</h3><p>Etag： 服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识（生成规则由服务器决定）</p>
<p>If-None-Match： 再次请求服务器时，浏览器的请求报文头部会包含此字段，后面的值为在缓存中获取的标识。服务器接收到次报文后发现 If-None-Match 则与被请求资源的唯一标识进行对比。</p>
<ol>
<li>不同，说明资源被改动过，则响应整个资源内容，返回状态码 200。</li>
<li>相同，说明资源无心修改，则响应 header，浏览器直接从缓存中获取数据信息。返回状态码 304.</li>
</ol>
<p>但是实际应用中由于 Etag 的计算是使用算法来得出的，而算法会占用服务端计算的资源，所有服务端的资源都是宝贵的，所以就很少使用 Etag 了。</p>
<h3 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified&#x2F;If-Modified-Since"></a>Last-Modified&#x2F;If-Modified-Since</h3><p>Last-Modified： 服务器在响应请求时，会告诉浏览器资源的最后修改时间。</p>
<p>if-Modified-Since: 浏览器再次请求服务器的时候，请求头会包含此字段，后面跟着在缓存中获得的最后修改时间。服务端收到此请求头发现有 if-Modified-Since，则与被请求资源的最后修改时间进行对比，如果一致则返回 304 和响应报文头，浏览器只需要从缓存中获取信息即可。 从字面上看，就是说：从某个时间节点算起，是否文件被修改了</p>
<ol>
<li>如果真的被修改：那么开始传输响应一个整体，服务器返回：200 OK</li>
<li>如果没有被修改：那么只需传输响应 header，服务器返回：304 Not Modified</li>
</ol>
<p>if-Unmodified-Since: 从字面上看, 就是说: 从某个时间点算起, 是否文件没有被修改</p>
<ol>
<li>如果没有被修改:则开始&#96;继续’传送文件: 服务器返回: 200 OK</li>
<li>如果文件被修改:则不传输,服务器返回: 412 Precondition failed (预处理错误)</li>
</ol>
<p>这两个的区别是一个是修改了才下载一个是没修改才下载。 Last-Modified 说好却也不是特别好，因为如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为 Last-Modified 时间匹配不上而返回了整个实体给客户端（即使客户端缓存里有个一模一样的资源）。为了解决这个问题，HTTP1.1 推出了 Etag。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5eb7f811f265da7bbc7cc5bd">图解 HTTP 缓存</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5a1d4e546fb9a0450f21af23">HTTP—-HTTP 缓存机制</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5a6c87c46fb9a01ca560b4d7">缓存详解</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/ec364e/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/ec364e/" class="post-title-link" itemprop="url">Jetty 快速入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-17 22:34:30" itemprop="dateCreated datePublished" datetime="2022-02-17T22:34:30+08:00">2022-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JavaEE/" itemprop="url" rel="index"><span itemprop="name">JavaEE</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JavaEE/%E6%9C%8D%E5%8A%A1%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">服务器</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>20k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>18 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Jetty-快速入门"><a href="#Jetty-快速入门" class="headerlink" title="Jetty 快速入门"></a>Jetty 快速入门</h1><h2 id="Jetty-简介"><a href="#Jetty-简介" class="headerlink" title="Jetty 简介"></a>Jetty 简介</h2><p><strong>jetty 是什么？</strong></p>
<p>jetty 是轻量级的 web 服务器和 servlet 引擎。</p>
<p>它的最大特点是：可以很方便的作为<strong>嵌入式服务器</strong>。</p>
<p>它是 eclipse 的一个开源项目。不用怀疑，就是你常用的那个 eclipse。</p>
<p>它是使用 Java 开发的，所以天然对 Java 支持良好。</p>
<p><a target="_blank" rel="noopener" href="http://www.eclipse.org/jetty/index.html">官方网址</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/eclipse/jetty.project">github 源码地址</a></p>
<p><strong>什么是嵌入式服务器？</strong></p>
<p>以 jetty 来说明，就是只要引入 jetty 的 jar 包，可以通过直接调用其 API 的方式来启动 web 服务。</p>
<p>用过 Tomcat、Resin 等服务器的朋友想必不会陌生那一套安装、配置、部署的流程吧，还是挺繁琐的。使用 jetty，就不需要这些过程了。</p>
<p>jetty 非常适用于项目的开发、测试，因为非常快捷。如果想用于生产环境，则需要谨慎考虑，它不一定能像成熟的 Tomcat、Resin 等服务器一样支持企业级 Java EE 的需要。</p>
<h2 id="Jetty-的使用"><a href="#Jetty-的使用" class="headerlink" title="Jetty 的使用"></a>Jetty 的使用</h2><p>我觉得嵌入式启动方式的一个好处在于：可以直接运行项目，无需每次部署都得再配置服务器。</p>
<p>jetty 的嵌入式启动使用有两种方式：</p>
<p>API 方式</p>
<p>maven 插件方式</p>
<h3 id="API-方式"><a href="#API-方式" class="headerlink" title="API 方式"></a>API 方式</h3><p>添加 maven 依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetty-webapp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.3.2.v20150730<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetty-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.3.2.v20150730<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>apache-jsp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.3.2.v20150730<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>apache-jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.3.2.v20150730<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>官方的启动代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SplitFileServer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建Server对象，并绑定端口</span></span><br><span class="line">        <span class="type">Server</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Server</span>();</span><br><span class="line">        <span class="type">ServerConnector</span> <span class="variable">connector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerConnector</span>(server);</span><br><span class="line">        connector.setPort(<span class="number">8090</span>);</span><br><span class="line">        server.setConnectors(<span class="keyword">new</span> <span class="title class_">Connector</span>[] &#123; connector &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建上下文句柄，绑定上下文路径。这样启动后的url就会是:http://host:port/context</span></span><br><span class="line">        <span class="type">ResourceHandler</span> <span class="variable">rh0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResourceHandler</span>();</span><br><span class="line">        <span class="type">ContextHandler</span> <span class="variable">context0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ContextHandler</span>();</span><br><span class="line">        context0.setContextPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定测试资源目录（在本例的配置目录dir0的路径是src/test/resources/dir0）</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">dir0</span> <span class="operator">=</span> MavenTestingUtils.getTestResourceDir(<span class="string">&quot;dir0&quot;</span>);</span><br><span class="line">        context0.setBaseResource(Resource.newResource(dir0));</span><br><span class="line">        context0.setHandler(rh0);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 和上面的例子一样</span></span><br><span class="line">        <span class="type">ResourceHandler</span> <span class="variable">rh1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResourceHandler</span>();</span><br><span class="line">        <span class="type">ContextHandler</span> <span class="variable">context1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ContextHandler</span>();</span><br><span class="line">        context1.setContextPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">dir1</span> <span class="operator">=</span> MavenTestingUtils.getTestResourceDir(<span class="string">&quot;dir1&quot;</span>);</span><br><span class="line">        context1.setBaseResource(Resource.newResource(dir1));</span><br><span class="line">        context1.setHandler(rh1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定两个资源句柄</span></span><br><span class="line">        <span class="type">ContextHandlerCollection</span> <span class="variable">contexts</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ContextHandlerCollection</span>();</span><br><span class="line">        contexts.setHandlers(<span class="keyword">new</span> <span class="title class_">Handler</span>[] &#123; context0, context1 &#125;);</span><br><span class="line">        server.setHandler(contexts);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动</span></span><br><span class="line">        server.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印dump时的信息</span></span><br><span class="line">        System.out.println(server.dump());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// join当前线程</span></span><br><span class="line">        server.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接运行 Main 方法，就可以启动 web 服务。</p>
<p><strong><em>注：以上代码在 eclipse 中运行没有问题，如果想在 Intellij 中运行还需要为它指定配置文件。</em></strong></p>
<p>如果想了解在 Eclipse 和 Intellij 都能运行的通用方法可以参考我的 github 代码示例。</p>
<p>我的实现也是参考 springside 的方式。</p>
<p>代码行数有点多，不在这里贴代码了。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/dunwu/spring-notes">完整参考代码</a></p>
<h3 id="Maven-插件方式"><a href="#Maven-插件方式" class="headerlink" title="Maven 插件方式"></a>Maven 插件方式</h3><p>如果你熟悉 maven，那么实在太简单了</p>
<p><strong><em>注： Maven 版本必须在 3.3 及以上版本。</em></strong></p>
<p>(1) 添加 maven 插件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetty-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.3.12.v20160915<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>(2) 执行 maven 命令：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn jetty:<span class="built_in">run</span></span><br></pre></td></tr></table></figure>

<p>讲真，就是这么简单。jetty 默认会为你创建一个 web 服务，地址为 127.0.0.1:8080。</p>
<p>当然，你也可以在插件中配置你的 webapp 环境</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetty-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.3.12.v20160915<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">webAppSourceDirectory</span>&gt;</span>$&#123;project.basedir&#125;/src/staticfiles<span class="tag">&lt;/<span class="name">webAppSourceDirectory</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置webapp --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">webApp</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">contextPath</span>&gt;</span>/<span class="tag">&lt;/<span class="name">contextPath</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">descriptor</span>&gt;</span>$&#123;project.basedir&#125;/src/over/here/web.xml<span class="tag">&lt;/<span class="name">descriptor</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">jettyEnvXml</span>&gt;</span>$&#123;project.basedir&#125;/src/over/here/jetty-env.xml<span class="tag">&lt;/<span class="name">jettyEnvXml</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">webApp</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置classes --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">classesDirectory</span>&gt;</span>$&#123;project.basedir&#125;/somewhere/else<span class="tag">&lt;/<span class="name">classesDirectory</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">scanClassesPattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/Foo.class<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">scanClassesPattern</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">scanTargets</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">scanTarget</span>&gt;</span>src/mydir<span class="tag">&lt;/<span class="name">scanTarget</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">scanTarget</span>&gt;</span>src/myfile.txt<span class="tag">&lt;/<span class="name">scanTarget</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">scanTargets</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 扫描target目录下的资源文件 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">scanTargetPatterns</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">scanTargetPattern</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/other-resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/myspecial.xml<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/myspecial.properties<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">scanTargetPattern</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">scanTargetPatterns</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>官方给的 jetty-env.xml 范例</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">Configure</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//Mort Bay Consulting//DTD Configure//EN&quot;</span> <span class="string">&quot;http://jetty.mortbay.org/configure.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Configure</span> <span class="attr">class</span>=<span class="string">&quot;org.eclipse.jetty.webapp.WebAppContext&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- Add an EnvEntry only valid for this webapp               --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">New</span> <span class="attr">id</span>=<span class="string">&quot;gargle&quot;</span>  <span class="attr">class</span>=<span class="string">&quot;org.eclipse.jetty.plus.jndi.EnvEntry&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Arg</span>&gt;</span>gargle<span class="tag">&lt;/<span class="name">Arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.Double&quot;</span>&gt;</span>100<span class="tag">&lt;/<span class="name">Arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Arg</span> <span class="attr">type</span>=<span class="string">&quot;boolean&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Arg</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">New</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!-- Add an override for a global EnvEntry                           --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">New</span> <span class="attr">id</span>=<span class="string">&quot;wiggle&quot;</span>  <span class="attr">class</span>=<span class="string">&quot;org.eclipse.jetty.plus.jndi.EnvEntry&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Arg</span>&gt;</span>wiggle<span class="tag">&lt;/<span class="name">Arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.Double&quot;</span>&gt;</span>55.0<span class="tag">&lt;/<span class="name">Arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Arg</span> <span class="attr">type</span>=<span class="string">&quot;boolean&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">Arg</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">New</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- an XADataSource                                                --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">New</span> <span class="attr">id</span>=<span class="string">&quot;mydatasource99&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.eclipse.jetty.plus.jndi.Resource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Arg</span>&gt;</span>jdbc/mydatasource99<span class="tag">&lt;/<span class="name">Arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Arg</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">New</span> <span class="attr">class</span>=<span class="string">&quot;com.atomikos.jdbc.SimpleDataSourceBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Set</span> <span class="attr">name</span>=<span class="string">&quot;xaDataSourceClassName&quot;</span>&gt;</span>org.apache.derby.jdbc.EmbeddedXADataSource<span class="tag">&lt;/<span class="name">Set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Set</span> <span class="attr">name</span>=<span class="string">&quot;xaDataSourceProperties&quot;</span>&gt;</span>databaseName=testdb99;createDatabase=create<span class="tag">&lt;/<span class="name">Set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Set</span> <span class="attr">name</span>=<span class="string">&quot;UniqueResourceName&quot;</span>&gt;</span>mydatasource99<span class="tag">&lt;/<span class="name">Set</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">New</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Arg</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">New</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configure</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Jetty-的架构"><a href="#Jetty-的架构" class="headerlink" title="Jetty 的架构"></a>Jetty 的架构</h2><h3 id="Jetty-架构简介"><a href="#Jetty-架构简介" class="headerlink" title="Jetty 架构简介"></a>Jetty 架构简介</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20201127154145.jpg" alt="img"></p>
<p>Jetty Server 就是由多个 Connector（连接器）、多个 Handler（处理器），以及一个线程池组成。</p>
<p>跟 Tomcat 一样，Jetty 也有 HTTP 服务器和 Servlet 容器的功能，因此 Jetty 中的 Connector 组件和 Handler 组件分别来实现这两个功能，而这两个组件工作时所需要的线程资源都直接从一个全局线程池 ThreadPool 中获取。</p>
<p>Jetty Server 可以有多个 Connector 在不同的端口上监听客户请求，而对于请求处理的 Handler 组件，也可以根据具体场景使用不同的 Handler。这样的设计提高了 Jetty 的灵活性，需要支持 Servlet，则可以使用 ServletHandler；需要支持 Session，则再增加一个 SessionHandler。也就是说我们可以不使用 Servlet 或者 Session，只要不配置这个 Handler 就行了。</p>
<p>为了启动和协调上面的核心组件工作，Jetty 提供了一个 Server 类来做这个事情，它负责创建并初始化 Connector、Handler、ThreadPool 组件，然后调用 start 方法启动它们。</p>
<h3 id="Jetty-和-Tomcat-架构区别"><a href="#Jetty-和-Tomcat-架构区别" class="headerlink" title="Jetty 和 Tomcat 架构区别"></a>Jetty 和 Tomcat 架构区别</h3><p>对比一下 Tomcat 的整体架构图，你会发现 Tomcat 在整体上跟 Jetty 很相似，它们的第一个区别是 Jetty 中没有 Service 的概念，Tomcat 中的 Service 包装了多个连接器和一个容器组件，一个 Tomcat 实例可以配置多个 Service，不同的 Service 通过不同的连接器监听不同的端口；而 Jetty 中 Connector 是被所有 Handler 共享的。</p>
<p>第二个区别是，在 Tomcat 中每个连接器都有自己的线程池，而在 Jetty 中所有的 Connector 共享一个全局的线程池。</p>
<h3 id="Connector-组件"><a href="#Connector-组件" class="headerlink" title="Connector 组件"></a>Connector 组件</h3><p>跟 Tomcat 一样，Connector 的主要功能是对 I&#x2F;O 模型和应用层协议的封装。I&#x2F;O 模型方面，最新的 Jetty 9 版本只支持 NIO，因此 Jetty 的 Connector 设计有明显的 Java NIO 通信模型的痕迹。至于应用层协议方面，跟 Tomcat 的 Processor 一样，Jetty 抽象出了 Connection 组件来封装应用层协议的差异。</p>
<p>服务端在 NIO 通信上主要完成了三件事情：<strong>监听连接、I&#x2F;O 事件查询以及数据读写</strong>。因此 Jetty 设计了<strong>Acceptor、SelectorManager 和 Connection 来分别做这三件事情</strong></p>
<h4 id="Acceptor"><a href="#Acceptor" class="headerlink" title="Acceptor"></a>Acceptor</h4><p><strong>Acceptor 用于接受请求</strong>。跟 Tomcat 一样，Jetty 也有独立的 Acceptor 线程组用于处理连接请求。在 <code>Connector</code> 的实现类 <code>ServerConnector</code> 中，有一个 <code>_acceptors</code> 的数组，在 Connector 启动的时候, 会根据 <code>_acceptors</code> 数组的长度创建对应数量的 Acceptor，而 Acceptor 的个数可以配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; _acceptors.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">Acceptor</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Acceptor</span>(i);</span><br><span class="line">  getExecutor().execute(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Acceptor</code> 是 <code>ServerConnector</code> 中的一个内部类，同时也是一个 <code>Runnable</code>，<code>Acceptor</code> 线程是通过 <code>getExecutor()</code> 得到的线程池来执行的，前面提到这是一个全局的线程池。</p>
<p><code>Acceptor</code> 通过阻塞的方式来接受连接，这一点跟 Tomcat 也是一样的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> acceptorID)</span> <span class="keyword">throws</span> IOException</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ServerSocketChannel</span> <span class="variable">serverChannel</span> <span class="operator">=</span> _acceptChannel;</span><br><span class="line">  <span class="keyword">if</span> (serverChannel != <span class="literal">null</span> &amp;&amp; serverChannel.isOpen())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 这里是阻塞的</span></span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> serverChannel.accept();</span><br><span class="line">    <span class="comment">// 执行到这里时说明有请求进来了</span></span><br><span class="line">    accepted(channel);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接受连接成功后会调用 <code>accepted()</code> 函数，<code>accepted()</code> 函数中会将 <code>SocketChannel</code> 设置为非阻塞模式，然后交给 <code>Selector</code> 去处理，因此这也就到了 <code>Selector</code> 的地界了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">accepted</span><span class="params">(SocketChannel channel)</span> <span class="keyword">throws</span> IOException</span><br><span class="line">&#123;</span><br><span class="line">    channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> channel.socket();</span><br><span class="line">    configure(socket);</span><br><span class="line">    <span class="comment">// _manager 是 SelectorManager 实例，里面管理了所有的 Selector 实例</span></span><br><span class="line">    _manager.accept(channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>SelectorManager</strong></p>
<p><strong>Jetty 的 <code>Selector</code> 由 <code>SelectorManager</code> 类管理</strong>，而被管理的 <code>Selector</code> 叫作 <code>ManagedSelector</code>。<code>SelectorManager</code> 内部有一个 <code>ManagedSelector</code> 数组，真正干活的是 <code>ManagedSelector</code>。咱们接着上面分析，看看在 <code>SelectorManager</code> 在 <code>accept</code> 方法里做了什么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(SelectableChannel channel, Object attachment)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 选择一个 ManagedSelector 来处理 Channel</span></span><br><span class="line">  <span class="keyword">final</span> <span class="type">ManagedSelector</span> <span class="variable">selector</span> <span class="operator">=</span> chooseSelector();</span><br><span class="line">  <span class="comment">// 提交一个任务 Accept 给 ManagedSelector</span></span><br><span class="line">  selector.submit(selector.<span class="keyword">new</span> <span class="title class_">Accept</span>(channel, attachment));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SelectorManager 从本身的 Selector 数组中选择一个 Selector 来处理这个 Channel，并创建一个任务 Accept 交给 ManagedSelector，ManagedSelector 在处理这个任务主要做了两步：</p>
<p>第一步，调用 Selector 的 register 方法把 Channel 注册到 Selector 上，拿到一个 SelectionKey。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">_key</span> = _channel.register(selector, SelectionKey.OP_ACCEPT, this)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>第二步，创建一个 EndPoint 和 Connection，并跟这个 SelectionKey（Channel）绑在一起：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">createEndPoint</span><span class="params">(SelectableChannel channel, SelectionKey selectionKey)</span> <span class="keyword">throws</span> IOException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1. 创建 Endpoint</span></span><br><span class="line">    <span class="type">EndPoint</span> <span class="variable">endPoint</span> <span class="operator">=</span> _selectorManager.newEndPoint(channel, <span class="built_in">this</span>, selectionKey);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 创建 Connection</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> _selectorManager.newConnection(channel, endPoint, selectionKey.attachment());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 把 Endpoint、Connection 和 SelectionKey 绑在一起</span></span><br><span class="line">    endPoint.setConnection(connection);</span><br><span class="line">    selectionKey.attach(endPoint);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要你特别注意的是，ManagedSelector 并没有直接调用 EndPoint 的方法去处理数据，而是通过调用 EndPoint 的方法<strong>返回一个 Runnable，然后把这个 Runnable 扔给线程池执行</strong>，所以你能猜到，这个 Runnable 才会去真正读数据和处理请求。</p>
<p><strong>Connection</strong></p>
<p>这个 Runnable 是 EndPoint 的一个内部类，它会调用 Connection 的回调方法来处理请求。Jetty 的 Connection 组件类比就是 Tomcat 的 Processor，负责具体协议的解析，得到 Request 对象，并调用 Handler 容器进行处理。下面我简单介绍一下它的具体实现类 HttpConnection 对请求和响应的处理过程。</p>
<p><strong>请求处理</strong>：HttpConnection 并不会主动向 EndPoint 读取数据，而是向在 EndPoint 中注册一堆回调方法：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">getEndPoint</span>()<span class="selector-class">.fillInterested</span>(_readCallback);</span><br></pre></td></tr></table></figure>

<p>这段代码就是告诉 EndPoint，数据到了你就调我这些回调方法 _readCallback 吧，有点异步 I&#x2F;O 的感觉，也就是说 Jetty 在应用层面模拟了异步 I&#x2F;O 模型。</p>
<p>而在回调方法 _readCallback 里，会调用 EndPoint 的接口去读数据，读完后让 HTTP 解析器去解析字节流，HTTP 解析器会将解析后的数据，包括请求行、请求头相关信息存到 Request 对象里。</p>
<p><strong>响应处理</strong>：Connection 调用 Handler 进行业务处理，Handler 会通过 Response 对象来操作响应流，向流里面写入数据，HttpConnection 再通过 EndPoint 把数据写到 Channel，这样一次响应就完成了。</p>
<p>到此你应该了解了 Connector 的工作原理，下面我画张图再来回顾一下 Connector 的工作流程。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20201118175805.jpg" alt="img"></p>
<ol>
<li><p>Acceptor 监听连接请求，当有连接请求到达时就接受连接，一个连接对应一个 Channel，Acceptor 将 Channel 交给 ManagedSelector 来处理。</p>
</li>
<li><p>ManagedSelector 把 Channel 注册到 Selector 上，并创建一个 EndPoint 和 Connection 跟这个 Channel 绑定，接着就不断地检测 I&#x2F;O 事件。</p>
</li>
<li><p>I&#x2F;O 事件到了就调用 EndPoint 的方法拿到一个 Runnable，并扔给线程池执行。</p>
</li>
<li><p>线程池中调度某个线程执行 Runnable。</p>
</li>
<li><p>Runnable 执行时，调用回调函数，这个回调函数是 Connection 注册到 EndPoint 中的。</p>
</li>
<li><p>回调函数内部实现，其实就是调用 EndPoint 的接口方法来读数据。</p>
</li>
<li><p>Connection 解析读到的数据，生成请求对象并交给 Handler 组件去处理。</p>
</li>
</ol>
<h3 id="Handler-组件"><a href="#Handler-组件" class="headerlink" title="Handler 组件"></a>Handler 组件</h3><p>Jetty 的 Handler 设计是它的一大特色，Jetty 本质就是一个 Handler 管理器，Jetty 本身就提供了一些默认 Handler 来实现 Servlet 容器的功能，你也可以定义自己的 Handler 来添加到 Jetty 中，这体现了“<strong>微内核 + 插件</strong>”的设计思想。</p>
<p><strong>Handler 就是一个接口，它有一堆实现类</strong>，Jetty 的 Connector 组件调用这些接口来处理 Servlet 请求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Handler</span> <span class="keyword">extends</span> <span class="title class_">LifeCycle</span>, Destroyable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理请求的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ServletException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个 Handler 都关联一个 Server 组件，被 Server 管理</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setServer</span><span class="params">(Server server)</span>;</span><br><span class="line">    <span class="keyword">public</span> Server <span class="title function_">getServer</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁方法相关的资源</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法说明：</p>
<ul>
<li><code>Handler</code> 的 <code>handle</code> 方法跟 Tomcat 容器组件的 service 方法一样，它有 <code>ServletRequest</code> 和 <code>ServeletResponse</code> 两个参数。</li>
<li>因为任何一个 <code>Handler</code> 都需要关联一个 <code>Server</code> 组件，<code>Handler</code> 需要被 <code>Server</code> 组件来管理。<code>Handler</code> 通过 <code>setServer</code> 和 <code>getServer</code> 方法绑定 <code>Server</code>。</li>
<li><code>Handler</code> 会加载一些资源到内存，因此通过设置 <code>destroy</code> 方法来销毁。</li>
</ul>
<h4 id="Handler-继承关系"><a href="#Handler-继承关系" class="headerlink" title="Handler 继承关系"></a>Handler 继承关系</h4><p>Handler 只是一个接口，完成具体功能的还是它的子类。那么 Handler 有哪些子类呢？它们的继承关系又是怎样的？这些子类是如何实现 Servlet 容器功能的呢？</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20201118181025.png" alt="img"></p>
<p>在 AbstractHandler 之下有 AbstractHandlerContainer，为什么需要这个类呢？这其实是个过渡，为了实现链式调用，一个 Handler 内部必然要有其他 Handler 的引用，所以这个类的名字里才有 Container，意思就是这样的 Handler 里包含了其他 Handler 的引用。</p>
<p>HandlerWrapper 和 HandlerCollection 都是 Handler，但是这些 Handler 里还包括其他 Handler 的引用。不同的是，HandlerWrapper 只包含一个其他 Handler 的引用，而 HandlerCollection 中有一个 Handler 数组的引用。</p>
<p>HandlerWrapper 有两个子类：Server 和 ScopedHandler。</p>
<ul>
<li>Server 比较好理解，它本身是 Handler 模块的入口，必然要将请求传递给其他 Handler 来处理，为了触发其他 Handler 的调用，所以它是一个 HandlerWrapper。</li>
<li>ScopedHandler 也是一个比较重要的 Handler，实现了“具有上下文信息”的责任链调用。为什么我要强调“具有上下文信息”呢？那是因为 Servlet 规范规定 Servlet 在执行过程中是有上下文的。那么这些 Handler 在执行过程中如何访问这个上下文呢？这个上下文又存在什么地方呢？答案就是通过 ScopedHandler 来实现的。</li>
</ul>
<p>HandlerCollection 其实维护了一个 Handler 数组。这是为了同时支持多个 Web 应用，如果每个 Web 应用有一个 Handler 入口，那么多个 Web 应用的 Handler 就成了一个数组，比如 Server 中就有一个 HandlerCollection，Server 会根据用户请求的 URL 从数组中选取相应的 Handler 来处理，就是选择特定的 Web 应用来处理请求。</p>
<p>Handler 可以分成三种类型：</p>
<ul>
<li>第一种是<strong>协调 Handler</strong>，这种 Handler 负责将请求路由到一组 Handler 中去，比如 HandlerCollection，它内部持有一个 Handler 数组，当请求到来时，它负责将请求转发到数组中的某一个 Handler。</li>
<li>第二种是<strong>过滤器 Handler</strong>，这种 Handler 自己会处理请求，处理完了后再把请求转发到下一个 Handler，比如图上的 HandlerWrapper，它内部持有下一个 Handler 的引用。需要注意的是，所有继承了 HandlerWrapper 的 Handler 都具有了过滤器 Handler 的特征，比如 ContextHandler、SessionHandler 和 WebAppContext 等。</li>
<li>第三种是<strong>内容 Handler</strong>，说白了就是这些 Handler 会真正调用 Servlet 来处理请求，生成响应的内容，比如 ServletHandler。如果浏览器请求的是一个静态资源，也有相应的 ResourceHandler 来处理这个请求，返回静态页面。</li>
</ul>
<h4 id="实现-Servlet-规范"><a href="#实现-Servlet-规范" class="headerlink" title="实现 Servlet 规范"></a>实现 Servlet 规范</h4><p>ServletHandler、ContextHandler 以及 WebAppContext 等，它们实现了 Servlet 规范。</p>
<p>Servlet 规范中有 Context、Servlet、Filter、Listener 和 Session 等，Jetty 要支持 Servlet 规范，就需要有相应的 Handler 来分别实现这些功能。因此，Jetty 设计了 3 个组件：ContextHandler、ServletHandler 和 SessionHandler 来实现 Servle 规范中规定的功能，而<strong>WebAppContext 本身就是一个 ContextHandler</strong>，另外它还负责管理 ServletHandler 和 SessionHandler。</p>
<p>ContextHandler 会创建并初始化 Servlet 规范里的 ServletContext 对象，同时 ContextHandler 还包含了一组能够让你的 Web 应用运行起来的 Handler，可以这样理解，Context 本身也是一种 Handler，它里面包含了其他的 Handler，这些 Handler 能处理某个特定 URL 下的请求。比如，ContextHandler 包含了一个或者多个 ServletHandler。</p>
<p>ServletHandler 实现了 Servlet 规范中的 Servlet、Filter 和 Listener 的功能。ServletHandler 依赖 FilterHolder、ServletHolder、ServletMapping、FilterMapping 这四大组件。FilterHolder 和 ServletHolder 分别是 Filter 和 Servlet 的包装类，每一个 Servlet 与路径的映射会被封装成 ServletMapping，而 Filter 与拦截 URL 的映射会被封装成 FilterMapping。</p>
<p>SessionHandler 用来管理 Session。除此之外 WebAppContext 还有一些通用功能的 Handler，比如 SecurityHandler 和 GzipHandler，同样从名字可以知道这些 Handler 的功能分别是安全控制和压缩 &#x2F; 解压缩。</p>
<p>WebAppContext 会将这些 Handler 构建成一个执行链，通过这个链会最终调用到我们的业务 Servlet。</p>
<h2 id="Jetty-的线程策略"><a href="#Jetty-的线程策略" class="headerlink" title="Jetty 的线程策略"></a>Jetty 的线程策略</h2><h3 id="传统-Selector-编程模型"><a href="#传统-Selector-编程模型" class="headerlink" title="传统 Selector 编程模型"></a>传统 Selector 编程模型</h3><p>常规的 NIO 编程思路是，将 I&#x2F;O 事件的侦测和请求的处理分别用不同的线程处理。具体过程是：</p>
<p>启动一个线程，在一个死循环里不断地调用 select 方法，检测 Channel 的 I&#x2F;O 状态，一旦 I&#x2F;O 事件达到，比如数据就绪，就把该 I&#x2F;O 事件以及一些数据包装成一个 Runnable，将 Runnable 放到新线程中去处理。</p>
<p>在这个过程中按照职责划分，有两个线程在干活，一个是 I&#x2F;O 事件检测线程，另一个是 I&#x2F;O 事件处理线程。这样的好处是它们互不干扰和阻塞对方。</p>
<h3 id="Jetty-的-Selector-编程模型"><a href="#Jetty-的-Selector-编程模型" class="headerlink" title="Jetty 的 Selector 编程模型"></a>Jetty 的 Selector 编程模型</h3><p>将 I&#x2F;O 事件检测和业务处理这两种工作分开的思路也有缺点：当 Selector 检测读就绪事件时，数据已经被拷贝到内核中的缓存了，同时 CPU 的缓存中也有这些数据了，我们知道 CPU 本身的缓存比内存快多了，这时当应用程序去读取这些数据时，如果用另一个线程去读，很有可能这个读线程使用另一个 CPU 核，而不是之前那个检测数据就绪的 CPU 核，这样 CPU 缓存中的数据就用不上了，并且线程切换也需要开销。</p>
<p>因此 Jetty 的 Connector 做了一个大胆尝试，那就是<strong>把 I&#x2F;O 事件的生产和消费放到同一个线程来处理</strong>，如果这两个任务由同一个线程来执行，如果执行过程中线程不阻塞，操作系统会用同一个 CPU 核来执行这两个任务，这样就能利用 CPU 缓存了。</p>
<h4 id="ManagedSelector"><a href="#ManagedSelector" class="headerlink" title="ManagedSelector"></a>ManagedSelector</h4><p>ManagedSelector 的本质就是一个 Selector，负责 I&#x2F;O 事件的检测和分发。为了方便使用，Jetty 在 Java 原生的 Selector 上做了一些扩展，就变成了 ManagedSelector，我们先来看看它有哪些成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ManagedSelector</span> <span class="keyword">extends</span> <span class="title class_">ContainerLifeCycle</span> <span class="keyword">implements</span> <span class="title class_">Dumpable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 原子变量，表明当前的 ManagedSelector 是否已经启动</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicBoolean</span> <span class="variable">_started</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表明是否阻塞在 select 调用上</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">_selecting</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 管理器的引用，SelectorManager 管理若干 ManagedSelector 的生命周期</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SelectorManager _selectorManager;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ManagedSelector 不止一个，为它们每人分配一个 id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> _id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关键的执行策略，生产者和消费者是否在同一个线程处理由它决定</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutionStrategy _strategy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Java 原生的 Selector</span></span><br><span class="line">    <span class="keyword">private</span> Selector _selector;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//&quot;Selector 更新任务 &quot; 队列</span></span><br><span class="line">    <span class="keyword">private</span> Deque&lt;SelectorUpdate&gt; _updates = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Deque&lt;SelectorUpdate&gt; _updateable = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些成员变量中其他的都好理解，就是“Selector 更新任务”队列<code>_updates</code>和执行策略<code>_strategy</code>可能不是很直观。</p>
<h4 id="SelectorUpdate-接口"><a href="#SelectorUpdate-接口" class="headerlink" title="SelectorUpdate 接口"></a>SelectorUpdate 接口</h4><p>为什么需要一个“Selector 更新任务”队列呢，对于 Selector 的用户来说，我们对 Selector 的操作无非是将 Channel 注册到 Selector 或者告诉 Selector 我对什么 I&#x2F;O 事件感兴趣，那么这些操作其实就是对 Selector 状态的更新，Jetty 把这些操作抽象成 SelectorUpdate 接口。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A selector update to be done when the selector has been woken.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">SelectorUpdate</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">void</span> update(Selector selector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这意味着如果你不能直接操作 ManageSelector 中的 Selector，而是需要向 ManagedSelector 提交一个任务类，这个类需要实现 SelectorUpdate 接口 update 方法，在 update 方法里定义你想要对 ManagedSelector 做的操作。</p>
<p>比如 Connector 中 Endpoint 组件对读就绪事件感兴趣，它就向 ManagedSelector 提交了一个内部任务类 ManagedSelector.SelectorUpdate：</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">_selector</span>.submit(<span class="variable">_updateKeyAction</span>);</span><br></pre></td></tr></table></figure>

<p>这个<code>_updateKeyAction</code>就是一个 SelectorUpdate 实例，它的 update 方法实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ManagedSelector.<span class="type">SelectorUpdate</span> <span class="variable">_updateKeyAction</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ManagedSelector</span>.SelectorUpdate()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Selector selector)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 这里的 updateKey 其实就是调用了 SelectionKey.interestOps(OP_READ);</span></span><br><span class="line">        updateKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们看到在 update 方法里，调用了 SelectionKey 类的 interestOps 方法，传入的参数是<code>OP_READ</code>，意思是现在我对这个 Channel 上的读就绪事件感兴趣了。</p>
<p>那谁来负责执行这些 update 方法呢，答案是 ManagedSelector 自己，它在一个死循环里拉取这些 SelectorUpdate 任务类逐个执行。</p>
<h4 id="Selectable-接口"><a href="#Selectable-接口" class="headerlink" title="Selectable 接口"></a>Selectable 接口</h4><p>那 I&#x2F;O 事件到达时，ManagedSelector 怎么知道应该调哪个函数来处理呢？其实也是通过一个任务类接口，这个接口就是 Selectable，它返回一个 Runnable，这个 Runnable 其实就是 I&#x2F;O 事件就绪时相应的处理逻辑。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Selectable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 当某一个 Channel 的 I/O 事件就绪后，ManagedSelector 会调用的回调函数</span></span><br><span class="line">    <span class="function">Runnable <span class="title">onSelected</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当所有事件处理完了之后 ManagedSelector 会调的回调函数，我们先忽略。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateKey</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ManagedSelector 在检测到某个 Channel 上的 I&#x2F;O 事件就绪时，也就是说这个 Channel 被选中了，ManagedSelector 调用这个 Channel 所绑定的附件类的 onSelected 方法来拿到一个 Runnable。</p>
<p>这句话有点绕，其实就是 ManagedSelector 的使用者，比如 Endpoint 组件在向 ManagedSelector 注册读就绪事件时，同时也要告诉 ManagedSelector 在事件就绪时执行什么任务，具体来说就是传入一个附件类，这个附件类需要实现 Selectable 接口。ManagedSelector 通过调用这个 onSelected 拿到一个 Runnable，然后把 Runnable 扔给线程池去执行。</p>
<p>那 Endpoint 的 onSelected 是如何实现的呢？</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function">Runnable <span class="title">onSelected</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> readyOps = _key.readyOps();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> fillable = (readyOps &amp; SelectionKey.OP_READ) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flushable = (readyOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return task to complete the job</span></span><br><span class="line">    Runnable task= fillable</span><br><span class="line">            ? (flushable</span><br><span class="line">                    ? _runCompleteWriteFillable</span><br><span class="line">                    : _runFillable)</span><br><span class="line">            : (flushable</span><br><span class="line">                    ? _runCompleteWrite</span><br><span class="line">                    : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码逻辑很简单，就是读事件到了就读，写事件到了就写。</p>
<h4 id="ExecutionStrategy"><a href="#ExecutionStrategy" class="headerlink" title="ExecutionStrategy"></a>ExecutionStrategy</h4><p>铺垫了这么多，终于要上主菜了。前面我主要介绍了 ManagedSelector 的使用者如何跟 ManagedSelector 交互，也就是如何注册 Channel 以及 I&#x2F;O 事件，提供什么样的处理类来处理 I&#x2F;O 事件，接下来我们来看看 ManagedSelector 是如何统一管理和维护用户注册的 Channel 集合。再回到今天开始的讨论，ManagedSelector 将 I&#x2F;O 事件的生产和消费看作是生产者消费者模式，为了充分利用 CPU 缓存，生产和消费尽量放到同一个线程处理，那这是如何实现的呢？Jetty 定义了 ExecutionStrategy 接口：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ExecutionStrategy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 只在 HTTP2 中用到，简单起见，我们先忽略这个方法。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatch</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现具体执行策略，任务生产出来后可能由当前线程执行，也可能由新线程来执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务的生产委托给 Producer 内部接口，</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Producer</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 生产一个 Runnable(任务)</span></span><br><span class="line">        <span class="function">Runnable <span class="title">produce</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到 ExecutionStrategy 接口比较简单，它将具体任务的生产委托内部接口 Producer，而在自己的 produce 方法里来实现具体执行逻辑，<strong>也就是生产出来的任务要么由当前线程执行，要么放到新线程中执行</strong>。Jetty 提供了一些具体策略实现类：ProduceConsume、ProduceExecuteConsume、ExecuteProduceConsume 和 EatWhatYouKill。它们的区别是：</p>
<ul>
<li>ProduceConsume：任务生产者自己依次生产和执行任务，对应到 NIO 通信模型就是用一个线程来侦测和处理一个 ManagedSelector 上所有的 I&#x2F;O 事件，后面的 I&#x2F;O 事件要等待前面的 I&#x2F;O 事件处理完，效率明显不高。通过图来理解，图中绿色表示生产一个任务，蓝色表示执行这个任务。</li>
</ul>
<p><img src="data:image/jpeg;base64,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" alt="img"></p>
<ul>
<li>ProduceExecuteConsume：任务生产者开启新线程来运行任务，这是典型的 I&#x2F;O 事件侦测和处理用不同的线程来处理，缺点是不能利用 CPU 缓存，并且线程切换成本高。同样我们通过一张图来理解，图中的棕色表示线程切换。</li>
</ul>
<p><img src="data:image/png;base64,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" alt="img"></p>
<ul>
<li>ExecuteProduceConsume：任务生产者自己运行任务，但是该策略可能会新建一个新线程以继续生产和执行任务。这种策略也被称为“吃掉你杀的猎物”，它来自狩猎伦理，认为一个人不应该杀死他不吃掉的东西，对应线程来说，不应该生成自己不打算运行的任务。它的优点是能利用 CPU 缓存，但是潜在的问题是如果处理 I&#x2F;O 事件的业务代码执行时间过长，会导致线程大量阻塞和线程饥饿。</li>
</ul>
<p><img src="data:image/png;base64,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" alt="img"></p>
<ul>
<li>EatWhatYouKill：这是 Jetty 对 ExecuteProduceConsume 策略的改良，在线程池线程充足的情况下等同于 ExecuteProduceConsume；当系统比较忙线程不够时，切换成 ProduceExecuteConsume 策略。为什么要这么做呢，原因是 ExecuteProduceConsume 是在同一线程执行 I&#x2F;O 事件的生产和消费，它使用的线程来自 Jetty 全局的线程池，这些线程有可能被业务代码阻塞，如果阻塞得多了，全局线程池中的线程自然就不够用了，最坏的情况是连 I&#x2F;O 事件的侦测都没有线程可用了，会导致 Connector 拒绝浏览器请求。于是 Jetty 做了一个优化，在低线程情况下，就执行 ProduceExecuteConsume 策略，I&#x2F;O 侦测用专门的线程处理，I&#x2F;O 事件的处理扔给线程池处理，其实就是放到线程池的队列里慢慢处理。</li>
</ul>
<p>分析了这几种线程策略，我们再来看看 Jetty 是如何实现 ExecutionStrategy 接口的。答案其实就是实现 produce 接口生产任务，一旦任务生产出来，ExecutionStrategy 会负责执行这个任务。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">SelectorProducer</span> <span class="keyword">implements</span> <span class="title class_">ExecutionStrategy</span>.<span class="property">Producer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">Set</span>&lt;<span class="title class_">SelectionKey</span>&gt; _keys = <span class="title class_">Collections</span>.<span class="title function_">emptySet</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">Iterator</span>&lt;<span class="title class_">SelectionKey</span>&gt; _cursor = <span class="title class_">Collections</span>.<span class="title function_">emptyIterator</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">Runnable</span> <span class="title function_">produce</span>(<span class="params"></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如何 Channel 集合中有 I/O 事件就绪，调用前面提到的 Selectable 接口获取 Runnable, 直接返回给 ExecutionStrategy 去处理</span></span><br><span class="line">            <span class="title class_">Runnable</span> task = <span class="title function_">processSelected</span>();</span><br><span class="line">            <span class="keyword">if</span> (task != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> task;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 如果没有 I/O 事件就绪，就干点杂活，看看有没有客户提交了更新 Selector 的任务，就是上面提到的 SelectorUpdate 任务类。</span></span><br><span class="line">            <span class="title function_">processUpdates</span>();</span><br><span class="line">            <span class="title function_">updateKeys</span>();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 继续执行 select 方法，侦测 I/O 就绪事件</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="title function_">select</span>())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>SelectorProducer 是 ManagedSelector 的内部类，SelectorProducer 实现了 ExecutionStrategy 中的 Producer 接口中的 produce 方法，需要向 ExecutionStrategy 返回一个 Runnable。在这个方法里 SelectorProducer 主要干了三件事情</p>
<ol>
<li>如果 Channel 集合中有 I&#x2F;O 事件就绪，调用前面提到的 Selectable 接口获取 Runnable，直接返回给 ExecutionStrategy 去处理。</li>
<li>如果没有 I&#x2F;O 事件就绪，就干点杂活，看看有没有客户提交了更新 Selector 上事件注册的任务，也就是上面提到的 SelectorUpdate 任务类。</li>
<li>干完杂活继续执行 select 方法，侦测 I&#x2F;O 就绪事件。</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="http://www.eclipse.org/jetty/index.html">Jetty 官方网址</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/eclipse/jetty.project">Jetty Github</a></li>
<li><a target="_blank" rel="noopener" href="http://wiki.eclipse.org/Jetty/Reference/jetty-env.xml">Jetty wiki</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/3295c4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/3295c4/" class="post-title-link" itemprop="url">Shiro 快速入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-17 22:34:30" itemprop="dateCreated datePublished" datetime="2022-02-17T22:34:30+08:00">2022-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E6%A1%86%E6%9E%B6/%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">安全</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>10k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Shiro-快速入门"><a href="#Shiro-快速入门" class="headerlink" title="Shiro 快速入门"></a>Shiro 快速入门</h1><blockquote>
<p>Shiro 是一个安全框架，具有认证、授权、加密、会话管理功能。</p>
</blockquote>
<h2 id="一、Shiro-简介"><a href="#一、Shiro-简介" class="headerlink" title="一、Shiro 简介"></a>一、Shiro 简介</h2><h3 id="Shiro-特性"><a href="#Shiro-特性" class="headerlink" title="Shiro 特性"></a>Shiro 特性</h3><p align="center">
  <img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/standalone/security/shiro/shiro-features.png">
</p>

<p>核心功能：</p>
<ul>
<li><strong>Authentication</strong> - <strong>认证</strong>。验证用户是不是拥有相应的身份。</li>
<li><strong>Authorization</strong> - <strong>授权</strong>。验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限。</li>
<li><strong>Session Manager</strong> - <strong>会话管理</strong>。即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中。会话可以是普通 JavaSE 环境的，也可以是如 Web 环境的。</li>
<li><strong>Cryptography</strong> - <strong>加密</strong>。保护数据的安全性，如密码加密存储到数据库，而不是明文存储。</li>
</ul>
<p>辅助功能：</p>
<ul>
<li><strong>Web Support</strong> - <strong>Web 支持</strong>。可以非常容易的集成到 Web 环境；</li>
<li><strong>Caching</strong> - <strong>缓存</strong>。比如用户登录后，其用户信息、拥有的角色 &#x2F; 权限不必每次去查，这样可以提高效率；</li>
<li><strong>Concurrency</strong> - <strong>并发</strong>。Shiro 支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去；</li>
<li><strong>Testing</strong> - <strong>测试</strong>。提供测试支持；</li>
<li><strong>Run As</strong> - <strong>运行方式</strong>。允许一个用户假装为另一个用户（如果他们允许）的身份进行访问；</li>
<li><strong>Remember Me</strong> - <strong>记住我</strong>。即一次登录后，下次再访问免登录。</li>
</ul>
<blockquote>
<p>:bell: 注意：Shiro 不会去维护用户、维护权限；这些需要我们自己去提供；然后通过相应的接口注入给 Shiro 即可。</p>
</blockquote>
<h3 id="Shiro-架构概述"><a href="#Shiro-架构概述" class="headerlink" title="Shiro 架构概述"></a>Shiro 架构概述</h3><p align="center">
  <img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/standalone/security/shiro/ShiroBasicArchitecture.png">
</p>

<ul>
<li><p><strong>Subject</strong> - <strong>主题</strong>。它代表当前用户，<code>Subject</code> 可以是一个人，但也可以是第三方服务、守护进程帐户、时钟守护任务或者其它——当前和软件交互的任何事件。<code>Subject</code> 是 Shiro 的入口。</p>
<ul>
<li><code>Principals</code> 是 <code>Subject</code> 的“识别属性”。<code>Principals</code> 可以是任何可以识别 <code>Subject</code> 的东西，例如名字（姓氏），姓氏（姓氏或姓氏），用户名，社会保险号等。当然，<code>Principals</code> 在应用程序中最好是惟一的。</li>
<li><code>Credentials</code> 通常是仅由 <code>Subject</code> 知道的秘密值，用作他们实际上“拥有”所主张身份的佐证 凭据的一些常见示例是密码，生物特征数据（例如指纹和视网膜扫描）以及 X.509 证书。</li>
</ul>
</li>
<li><p><strong>SecurityManager</strong> - <strong>安全管理</strong>。它是 Shiro 的核心，所有与安全有关的操作（认证、授权、及会话、缓存的管理）都与 <code>SecurityManager</code> 交互，且它管理着所有 <code>Subject</code>。</p>
</li>
<li><p><strong>Realm</strong> - <strong>域</strong>。用于访问安全相关数据，可以视为应用自身的数据源，需要开发者自己实现。Shiro 会通过 <code>Realm</code> 获取安全数据（如用户、角色、权限），就是说 <code>SecurityManager</code> 要验证用户身份，那么它需要从 <code>Realm</code> 获取相应的用户进行比较以确定用户身份是否合法；也需要从 Realm 得到用户相应的角色&#x2F;权限进行验证用户是否能进行操作；可以把 <code>Realm</code> 看成 DataSource，即安全数据源。</p>
</li>
</ul>
<h3 id="SecurityManager"><a href="#SecurityManager" class="headerlink" title="SecurityManager"></a>SecurityManager</h3><p><code>SecurityManager</code> 是 Shiro 框架核心中的核心，它相当于 Shiro 的总指挥，负责调度所有行为，包括：认证、授权、获取安全数据（调用 <code>Realm</code>）、会话管理等。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/standalone/security/shiro/ShiroArchitecture.png" alt="img"></p>
<p><code>SecurityManager</code> 聚合了以下组件：</p>
<ul>
<li><strong>Authenticator</strong> - 认证器，负责认证。如果用户需要定制认证策略，可以实现此接口。</li>
<li><strong>Authorizer</strong> - 授权器，负责权限控制。用来决定主体是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能；</li>
<li><strong>SessionManager</strong> - 会话管理器。Shiro 抽象了一个自己的 Session 来管理主体与应用之间交互的数据。</li>
<li><strong>SessionDAO</strong> - 会话 DAO 用于存储会话，需要用户自己实现。</li>
<li><strong>CacheManager</strong> - 缓存控制器。用于管理如用户、角色、权限等信息的缓存。</li>
<li><strong>Cryptography</strong> - 密码器。用于对数据加密、解密。</li>
</ul>
<h2 id="二、Shiro-认证"><a href="#二、Shiro-认证" class="headerlink" title="二、Shiro 认证"></a>二、Shiro 认证</h2><h3 id="认证-Subject"><a href="#认证-Subject" class="headerlink" title="认证 Subject"></a>认证 Subject</h3><p>验证 Subject 的过程可以有效地分为三个不同的步骤：</p>
<p>（1）收集 <code>Subject</code> 提交的 <code>Principals</code> 和 <code>Credentials</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Example using most common scenario of username/password pair:</span></span><br><span class="line"><span class="type">UsernamePasswordToken</span> <span class="variable">token</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordToken</span>(username, password);</span><br><span class="line"></span><br><span class="line"><span class="comment">//&quot;Remember Me&quot; built-in:</span></span><br><span class="line">token.setRememberMe(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>（2）提交 <code>Principals</code> 和 <code>Credentials</code> 以进行身份验证。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Subject</span> <span class="variable">currentUser</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line"></span><br><span class="line">currentUser.login(token);</span><br></pre></td></tr></table></figure>

<p>（3）如果提交成功，则允许访问，否则重试身份验证或阻止访问。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    currentUser.login(token);</span><br><span class="line">&#125; <span class="keyword">catch</span> ( UnknownAccountException uae ) &#123; ...</span><br><span class="line">&#125; <span class="keyword">catch</span> ( IncorrectCredentialsException ice ) &#123; ...</span><br><span class="line">&#125; <span class="keyword">catch</span> ( LockedAccountException lae ) &#123; ...</span><br><span class="line">&#125; <span class="keyword">catch</span> ( ExcessiveAttemptsException eae ) &#123; ...</span><br><span class="line">&#125; ... <span class="keyword">catch</span> your own ...</span><br><span class="line">&#125; <span class="keyword">catch</span> ( AuthenticationException ae ) &#123;</span><br><span class="line">    <span class="comment">//unexpected error?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Remembered-和-Authenticated"><a href="#Remembered-和-Authenticated" class="headerlink" title="Remembered 和 Authenticated"></a>Remembered 和 Authenticated</h3><ul>
<li><code>Remembered</code> - 记住我。被记住的 <code>Subject</code> 不是匿名的，并且具有已知的身份（即 <code>subject.getPrincipals()</code> 是非空的）。 但是，在先前的会话期间，通过先前的身份验证会记住此身份。 如果 <code>subject.isRemembered()</code> 返回 <code>true</code>，则认为该主题已被记住。</li>
<li><code>Authenticated</code> - 已认证。已认证的 <code>Subject</code> 是在当前会话期间已成功认证的 <code>Subject</code>。 如果 <code>subject.isAuthenticated()</code> 返回 <code>true</code>，则认为该 <code>Subject</code> 已通过身份验证。</li>
</ul>
<h3 id="登出"><a href="#登出" class="headerlink" title="登出"></a>登出</h3><p>当 Subject 与应用程序完成交互后，可以调用 <code>subject.logout()</code> 登出，即放弃所有标识信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">currentUser.logout();</span><br></pre></td></tr></table></figure>

<h3 id="认证流程"><a href="#认证流程" class="headerlink" title="认证流程"></a>认证流程</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200317092427.png" alt="img"></p>
<ol>
<li><p>应用程序代码调用 <code>Subject.login</code> 方法，传入构造的 <code>AuthenticationToken</code> 实例，该实例代表最终用户的 <code>Principals</code> 和 <code>Credentials</code>。</p>
</li>
<li><p><code>Subject</code> 实例（通常是 <code>DelegatingSubject</code>（或子类））通过调用 <code>securityManager.login</code>（token）委托应用程序的 <code>SecurityManager</code>，在此处开始实际的身份验证工作。</p>
</li>
<li><p><code>SecurityManager</code> 接收令牌，并通过调用 <code>authenticator.authenticate</code>（token）来简单地委派给其内部 <code>Authenticator</code> 实例。这几乎总是一个 <code>ModularRealmAuthenticator</code> 实例，它支持在身份验证期间协调一个或多个 <code>Realm</code> 实例。</p>
</li>
<li><p>如果为该应用程序配置了多个 <code>Realm</code>，则 <code>ModularRealmAuthenticator</code> 实例将利用其配置的 <code>AuthenticationStrategy</code> 发起多域验证尝试。在调用领域进行身份验证之前，期间和之后，将调用 <code>AuthenticationStrategy</code> 以使其对每个领域的结果做出反应。</p>
</li>
<li><p>请咨询每个已配置的 <code>Realm</code>，以查看其是否支持提交的 <code>AuthenticationToken</code>。 如果是这样，将使用提交的令牌调用支持 <code>Realm</code> 的 <code>getAuthenticationInfo</code> 方法。 <code>getAuthenticationInfo</code> 方法有效地表示对该特定 <code>Realm</code> 的单个身份验证尝试。</p>
</li>
</ol>
<h3 id="认证策略"><a href="#认证策略" class="headerlink" title="认证策略"></a>认证策略</h3><p>当为一个应用程序配置两个或多个领域时，<code>ModularRealmAuthenticator</code> 依赖于内部 <code>AuthenticationStrategy</code> 组件来确定认证尝试成功或失败的条件。</p>
<p>例如，如果只有一个 Realm 成功地对 AuthenticationToken 进行身份验证，而所有其他 Realm 都失败了，那么该身份验证尝试是否被视为成功？还是必须所有领域都成功进行身份验证才能将整体尝试视为成功？或者，如果某个领域成功通过身份验证，是否有必要进一步咨询其他领域？ AuthenticationStrategy 根据应用程序的需求做出适当的决定。</p>
<p><code>AuthenticationStrategy</code> 是无状态组件，在尝试进行身份验证时会被查询 4 次（这 4 种交互所需的任何必要状态都将作为方法参数给出）：</p>
<ul>
<li>在任何领域被调用之前</li>
<li>在调用单个 <code>Realm</code> 的 <code>getAuthenticationInfo</code> 方法之前</li>
<li>在调用单个 <code>Realm</code> 的 <code>getAuthenticationInfo</code> 方法之后</li>
<li>在所有领域都被调用之后</li>
</ul>
<p><code>AuthenticationStrategy</code> 还负责汇总每个成功 <code>Realm</code> 的结果，并将它们“捆绑”成单个 <code>AuthenticationInfo</code> 表示形式。最终的聚合 <code>AuthenticationInfo</code> 实例是 <code>Authenticator</code> 实例返回的结果，也是 Shiro 用来表示主体的最终身份（也称为委托人）的东西。</p>
<table>
<thead>
<tr>
<th align="left"><code>AuthenticationStrategy</code></th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/authc/pam/AtLeastOneSuccessfulStrategy.html"><code>AtLeastOneSuccessfulStrategy</code></a></td>
<td align="left">只要有一个 <code>Realm</code> 成功认证，则整个尝试都被视为成功。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/authc/pam/FirstSuccessfulStrategy.html"><code>FirstSuccessfulStrategy</code></a></td>
<td align="left">仅使用从第一个成功通过身份验证的 <code>Realm</code> 返回的信息，所有其他 Realm 将被忽略。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/authc/pam/AllSuccessfulStrategy.html"><code>AllSuccessfulStrategy</code></a></td>
<td align="left">只有所有 <code>Realm</code> 成功认证，则整个尝试才被视为成功。</td>
</tr>
</tbody></table>
<blockquote>
<p>:link: 更多认证细节可以参考：<a target="_blank" rel="noopener" href="http://shiro.apache.org/authentication.html#apache-shiro-authentication">Apache Shiro Authentication</a></p>
</blockquote>
<h2 id="三、Shiro-授权"><a href="#三、Shiro-授权" class="headerlink" title="三、Shiro 授权"></a>三、Shiro 授权</h2><p>授权，也称为访问控制，是管理对资源的访问的过程。 换句话说，控制谁有权访问应用程序中的内容。</p>
<h3 id="授权元素"><a href="#授权元素" class="headerlink" title="授权元素"></a>授权元素</h3><p>授权有三个核心要素：权限、角色和用户。</p>
<h4 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h4><p>权限示例：</p>
<ul>
<li>打开一个文件</li>
<li>查看 <code>/user/list</code> web 页面</li>
<li>查询记录</li>
<li>删除一条记录</li>
<li>…</li>
</ul>
<p>大多数资源都支持一般的 CRUD 操作。除此以外，对于一些特定的资源，任何有意义的行为都是可以的。基本的设计思路是：权限控制，至少是基于资源和行为。</p>
<h4 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h4><p>角色是一个命名实体，通常代表一组行为或职责。这些行为会转化为：谁可以在应用程序中执行哪些行为？谁不可以在程序中执行哪些行为？</p>
<p>角色通常是分配给用户帐户的，因此通过关联，用户可以获得自身角色所赋予的权限。</p>
<h4 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h4><p>用户本质上是应用程序的“用户”。</p>
<p>用户（即 Shiro 的 <code>Subject</code>）通过与角色或直接权限的关联在应用程序中执行某些行为。</p>
<h3 id="基于角色的授权"><a href="#基于角色的授权" class="headerlink" title="基于角色的授权"></a>基于角色的授权</h3><p>如果授权是基于角色赋予权限的数据模型，编程模式如下：</p>
<p>【示例一】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Subject</span> <span class="variable">currentUser</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (currentUser.hasRole(<span class="string">&quot;administrator&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">//show the admin button</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//don&#x27;t show the button?  Grey it out?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【示例二】</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Subject currentUser <span class="operator">=</span> SecurityUtils.getSubject()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">// 检查当前 Subject 是否有某种权限</span><br><span class="line">// 如果有，直接跳过；如果没有，Shiro 会抛出 AuthorizationException</span><br><span class="line">currentUser.checkRole(<span class="string">&quot;bankTeller&quot;</span>)<span class="comment">;</span></span><br><span class="line">openBankAccount()<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：方式二相比方式一，代码更简洁</p>
</blockquote>
<h3 id="基于权限的授权"><a href="#基于权限的授权" class="headerlink" title="基于权限的授权"></a>基于权限的授权</h3><p><strong>更好的授权策略通常是基于权限的授权</strong>。基于权限的授权，由于它和应用程序的原始功能（针对具体资源上的行为）紧密相关，所以基于权限的授权源代码会在功能更改时同步更改（而不是在安全策略发生更改时）。 这意味着与类似的基于角色的授权代码相比，修改代码的影响面要小得多。</p>
<p>【示例】基于对象的权限检查</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Permission</span> <span class="variable">printPermission</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrinterPermission</span>(<span class="string">&quot;laserjet4400n&quot;</span>, <span class="string">&quot;print&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Subject</span> <span class="variable">currentUser</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (currentUser.isPermitted(printPermission)) &#123;</span><br><span class="line">    <span class="comment">//show the Print button</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//don&#x27;t show the button?  Grey it out?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在对象中存储权限控制信息，但这种方式较为繁重</p>
<p>【示例】字符串定义权限控制信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Subject</span> <span class="variable">currentUser</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (currentUser.isPermitted(<span class="string">&quot;printer:print:laserjet4400n&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">//show the Print button</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//don&#x27;t show the button?  Grey it out?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 : 分隔，表示资源类型、行为、资源 ID，Shiro 提供了默认实现： <code>org.apache.shiro.authz.permission.WildcardPermission</code>。</p>
<p>这种权限控制方式的好处在于：轻量、灵活。</p>
<h3 id="基于注解的授权"><a href="#基于注解的授权" class="headerlink" title="基于注解的授权"></a>基于注解的授权</h3><p>Shiro 提供了一些用于授权的注解，来进一步简化授权代码。</p>
<h4 id="RequiresAuthentication"><a href="#RequiresAuthentication" class="headerlink" title="@RequiresAuthentication"></a><code>@RequiresAuthentication</code></h4><p><code>@RequiresAuthentication</code> 注解要求当前 <code>Subject</code> 必须是已认证用户才可以访问被修饰的方法。</p>
<p>【示例】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiresAuthentication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateAccount</span><span class="params">(Account userAccount)</span> &#123;</span><br><span class="line">    <span class="comment">//this method will only be invoked by a</span></span><br><span class="line">    <span class="comment">//Subject that is guaranteed authenticated</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RequiresGuest"><a href="#RequiresGuest" class="headerlink" title="@RequiresGuest"></a><code>@RequiresGuest</code></h4><p><code>@RequiresGuest</code> 注解要求当前 <code>Subject</code> 的角色是 <code>guest</code> 才可以访问被修饰的方法。</p>
<h3 id="授权流程"><a href="#授权流程" class="headerlink" title="授权流程"></a>授权流程</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200317092618.png" alt="img"></p>
<ol>
<li><p>应用程序或框架代码调用任何 <code>Subject</code> 的 <code>hasRole*</code>，<code>checkRole*</code>，<code>isPermitted*</code> 或 <code>checkPermission*</code> 方法，并传入所需的权限或角色。</p>
</li>
<li><p><code>Subject</code> 实例，通常是 <code>DelegatingSubject</code>（或子类），通过调用 <code>securityManager</code> 几乎相同的各自 <code>hasRole*</code>，<code>checkRole*</code>，<code>isPermitted*</code> 或 <code>checkPermission*</code> 方法来委托 <code>SecurityManager</code> （实现了 <a target="_blank" rel="noopener" href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/authz/Authorizer.html"><code>org.apache.shiro.authz.Authorizer</code></a> 接口）处理授权。</p>
</li>
<li><p><code>SecurityManager</code> 通过调用授权者各自的 <code>hasRole*</code>，<code>checkRole*</code>，<code>isPermitted*</code> 或 <code>checkPermission*</code> 方法来中继&#x2F;委托其内部的 <code>org.apache.shiro.authz.Authorizer</code> 实例。默认情况下，<code>authorizer</code> 实例是 <code>ModularRealmAuthorizer</code> 实例，该实例支持在任何授权操作期间协调一个或多个 <code>Realm</code> 实例。</p>
</li>
<li><p>检查每个已配置的 <code>Realm</code>，以查看其是否实现相同的 <code>Authorizer</code> 接口。如果是这样，则将调用 <code>Realm</code> 各自的 <code>hasRole*</code>，<code>checkRole*</code>，<code>isPermitted*</code> 或 <code>checkPermission*</code> 方法。</p>
</li>
</ol>
<blockquote>
<p>:link: 更多授权细节可以参考：<a target="_blank" rel="noopener" href="http://shiro.apache.org/authorization.html#apache-shiro-authorization">Apache Shiro Authorization</a></p>
</blockquote>
<h2 id="四、Shiro-会话管理"><a href="#四、Shiro-会话管理" class="headerlink" title="四、Shiro 会话管理"></a>四、Shiro 会话管理</h2><p>Shiro 提供了一套独特的会话管理方案：其 Session 可以使用 Java SE 程序，也可以使用于 Java Web 程序。</p>
<p>在 Shiro 中，<a target="_blank" rel="noopener" href="http://shiro.apache.org/session-management.html#the-sessionmanager">SessionManager</a> 负责管理应用所有 <code>Subject</code> 的会话，如：创建、删除、失效、验证等。</p>
<p>【示例】会话使用示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Subject</span> <span class="variable">currentUser</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line"></span><br><span class="line"><span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> currentUser.getSession();</span><br><span class="line">session.setAttribute( <span class="string">&quot;someKey&quot;</span>, someValue);</span><br></pre></td></tr></table></figure>

<h3 id="会话超时"><a href="#会话超时" class="headerlink" title="会话超时"></a>会话超时</h3><p>默认情况下，Shiro 中的会话有效期为 30 分钟，超时后，该会话将被 Shiro 视为无效。</p>
<p>可以通过 <code>globalSessionTimeout</code> 方法设置 Shiro 会话超时时间。</p>
<h3 id="会话监听"><a href="#会话监听" class="headerlink" title="会话监听"></a>会话监听</h3><p>Shiro 提供了 <code>SessionListener</code> 接口（或 <code>SessionListenerAdapter</code> 接口），用于监听重要的会话事件，并允许使用者在事件触发时做定制化处理。</p>
<p>【示例】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShiroSessionListener</span> <span class="keyword">implements</span> <span class="title class_">SessionListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="built_in">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">sessionCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">(Session session)</span> &#123;</span><br><span class="line">        sessionCount.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStop</span><span class="params">(Session session)</span> &#123;</span><br><span class="line">        sessionCount.decrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onExpiration</span><span class="params">(Session session)</span> &#123;</span><br><span class="line">        sessionCount.decrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="会话存储"><a href="#会话存储" class="headerlink" title="会话存储"></a>会话存储</h3><p>大多数情况下，应用需要保存会话信息，以便在稍后可以使用它。</p>
<p>Shiro 提供了 <code>SessionManager</code> 接口，负责将针对会话的 CRUD 操作委派给内部组件 <code>SessionDAO</code>，该组件反映了数据访问对象（DAO）设计模式。</p>
<blockquote>
<p>:bell: 注意：由于会话通常具有时效性，所以一般会话天然适合存储于缓存中。存储于 Redis 中是一个不错的选择。</p>
</blockquote>
<h2 id="五、Realm"><a href="#五、Realm" class="headerlink" title="五、Realm"></a>五、Realm</h2><p><code>Realm</code> 是 Shiro 访问程序安全相关数据（如：用户、角色、权限）的接口。</p>
<p><code>Realm</code> 是有开发者自己实现的，开发者可以通过实现 Realm 接口，接入应用的数据源，如：JDBC、文件、Nosql 等等。</p>
<h3 id="认证令牌"><a href="#认证令牌" class="headerlink" title="认证令牌"></a>认证令牌</h3><p>Shiro 支持身份验证令牌。在咨询 Realm 进行认证尝试之前，将调用其支持方法。 如果返回值为 true，则仅会调用其 <a target="_blank" rel="noopener" href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/realm/Realm.html#getAuthenticationInfo-org.apache.shiro.authc.AuthenticationToken-">getAuthenticationInfo(token)</a> 方法。通常，Realm 会检查所提交令牌的类型（接口或类），以查看其是否可以处理它。</p>
<p>令牌认证处理流程如下：</p>
<ol>
<li>检查用于标识 principal 的令牌（帐户标识信息）。</li>
<li>根据 principal，在数据源中查找相应的帐户数据。</li>
<li>确保令牌提供的凭证与数据存储中存储的凭证匹配。</li>
<li>如果 credentials 匹配，则返回 <code>AuthenticationInfo</code> 实例。</li>
<li>如果 credentials 不匹配，则抛出 <code>AuthenticationException</code> 异常。</li>
</ol>
<h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>通过前文，可以了解：Shiro 需要通过一对 principal 和 credentials 来确认身份是否匹配（即认证）。</p>
<p>一般来说，成熟软件是不允许存储账户、密码这些敏感数据时，使用明文存储。所以，通常要将密码加密后存储。</p>
<p>Shiro 提供了一些加密器，其思想就是用 MD5、SHA 这种数字签名算法，加 Salt，然后转为 Base64 字符串。为了避免被暴力破解，Shiro 使用多次加密的方式获得最终的 credentials 字符串。</p>
<p>【示例】Shiro 加密密码示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.shiro.crypto.hash.Sha256Hash;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.crypto.RandomNumberGenerator;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.crypto.SecureRandomNumberGenerator;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//We&#x27;ll use a Random Number Generator to generate salts.  This</span></span><br><span class="line"><span class="comment">//is much more secure than using a username as a salt or not</span></span><br><span class="line"><span class="comment">//having a salt at all.  Shiro makes this easy.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//Note that a normal app would reference an attribute rather</span></span><br><span class="line"><span class="comment">//than create a new RNG every time:</span></span><br><span class="line"><span class="type">RandomNumberGenerator</span> <span class="variable">rng</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecureRandomNumberGenerator</span>();</span><br><span class="line"><span class="type">Object</span> <span class="variable">salt</span> <span class="operator">=</span> rng.nextBytes();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Now hash the plain-text password with the random salt and multiple</span></span><br><span class="line"><span class="comment">//iterations and then Base64-encode the value (requires less space than Hex):</span></span><br><span class="line"><span class="type">String</span> <span class="variable">hashedPasswordBase64</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sha256Hash</span>(plainTextPassword, salt, <span class="number">1024</span>).toBase64();</span><br><span class="line"></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(username, hashedPasswordBase64);</span><br><span class="line"><span class="comment">//save the salt with the new account.  The HashedCredentialsMatcher</span></span><br><span class="line"><span class="comment">//will need it later when handling login attempts:</span></span><br><span class="line">user.setPasswordSalt(salt);</span><br><span class="line">userDAO.create(user);</span><br></pre></td></tr></table></figure>

<h2 id="六、配置"><a href="#六、配置" class="headerlink" title="六、配置"></a>六、配置</h2><h3 id="过滤链"><a href="#过滤链" class="headerlink" title="过滤链"></a>过滤链</h3><p>运行 Web 应用程序时，Shiro 将创建一些有用的默认 Filter 实例。</p>
<table>
<thead>
<tr>
<th align="left">Filter Name</th>
<th align="left">Class</th>
</tr>
</thead>
<tbody><tr>
<td align="left">anon</td>
<td align="left"><a target="_blank" rel="noopener" href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authc/AnonymousFilter.html">org.apache.shiro.web.filter.authc.AnonymousFilter</a></td>
</tr>
<tr>
<td align="left">authc</td>
<td align="left"><a target="_blank" rel="noopener" href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authc/FormAuthenticationFilter.html">org.apache.shiro.web.filter.authc.FormAuthenticationFilter</a></td>
</tr>
<tr>
<td align="left">authcBasic</td>
<td align="left"><a target="_blank" rel="noopener" href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authc/BasicHttpAuthenticationFilter.html">org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter</a></td>
</tr>
<tr>
<td align="left">logout</td>
<td align="left"><a target="_blank" rel="noopener" href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authc/LogoutFilter.html">org.apache.shiro.web.filter.authc.LogoutFilter</a></td>
</tr>
<tr>
<td align="left">noSessionCreation</td>
<td align="left"><a target="_blank" rel="noopener" href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/session/NoSessionCreationFilter.html">org.apache.shiro.web.filter.session.NoSessionCreationFilter</a></td>
</tr>
<tr>
<td align="left">perms</td>
<td align="left"><a target="_blank" rel="noopener" href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authz/PermissionsAuthorizationFilter.html">org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter</a></td>
</tr>
<tr>
<td align="left">port</td>
<td align="left"><a target="_blank" rel="noopener" href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authz/PortFilter.html">org.apache.shiro.web.filter.authz.PortFilter</a></td>
</tr>
<tr>
<td align="left">rest</td>
<td align="left"><a target="_blank" rel="noopener" href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authz/HttpMethodPermissionFilter.html">org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter</a></td>
</tr>
<tr>
<td align="left">roles</td>
<td align="left"><a target="_blank" rel="noopener" href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authz/RolesAuthorizationFilter.html">org.apache.shiro.web.filter.authz.RolesAuthorizationFilter</a></td>
</tr>
<tr>
<td align="left">ssl</td>
<td align="left"><a target="_blank" rel="noopener" href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authz/SslFilter.html">org.apache.shiro.web.filter.authz.SslFilter</a></td>
</tr>
<tr>
<td align="left">user</td>
<td align="left"><a target="_blank" rel="noopener" href="http://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authc/UserFilter.html">org.apache.shiro.web.filter.authc.UserFilter</a></td>
</tr>
</tbody></table>
<h3 id="RememberMe"><a href="#RememberMe" class="headerlink" title="RememberMe"></a>RememberMe</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UsernamePasswordToken</span> <span class="variable">token</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordToken</span>(username, password);</span><br><span class="line">token.setRememberMe(<span class="literal">true</span>);</span><br><span class="line">SecurityUtils.getSubject().login(token);</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="http://shiro.apache.org/reference.html">Shiro 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="http://jinnianshilongnian.iteye.com/category/305053">跟我学 Shiro</a></li>
<li><a target="_blank" rel="noopener" href="https://stormpath.com/blog/new-rbac-resource-based-access-control">The New RBAC: Resource-Based Access Control</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/d4e6ee/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/d4e6ee/" class="post-title-link" itemprop="url">Mybatis快速入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-17 22:34:30" itemprop="dateCreated datePublished" datetime="2022-02-17T22:34:30+08:00">2022-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E6%A1%86%E6%9E%B6/ORM/" itemprop="url" rel="index"><span itemprop="name">ORM</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>10k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="MyBatis-快速入门"><a href="#MyBatis-快速入门" class="headerlink" title="MyBatis 快速入门"></a>MyBatis 快速入门</h1><blockquote>
<p>MyBatis 的前身就是 iBatis ，是一个作用在数据持久层的对象关系映射（Object Relational Mapping，简称 ORM）框架。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200716162305.png" alt="img"></p>
<h2 id="Mybatis-简介"><a href="#Mybatis-简介" class="headerlink" title="Mybatis 简介"></a>Mybatis 简介</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20210510164925.png" alt="img"></p>
<h3 id="什么是-MyBatis"><a href="#什么是-MyBatis" class="headerlink" title="什么是 MyBatis"></a>什么是 MyBatis</h3><p>MyBatis 是一款持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p>
<h3 id="MyBatis-vs-Hibernate"><a href="#MyBatis-vs-Hibernate" class="headerlink" title="MyBatis vs. Hibernate"></a>MyBatis vs. Hibernate</h3><p>MyBatis 和 Hibernate 都是 Java 世界中比较流行的 ORM 框架。我们应该了解其各自的优势，根据项目的需要去抉择在开发中使用哪个框架。</p>
<p><strong>Mybatis 优势</strong></p>
<ul>
<li>MyBatis 可以进行更为细致的 SQL 优化，可以减少查询字段。</li>
<li>MyBatis 容易掌握，而 Hibernate 门槛较高。</li>
</ul>
<p><strong>Hibernate 优势</strong></p>
<ul>
<li>Hibernate 的 DAO 层开发比 MyBatis 简单，Mybatis 需要维护 SQL 和结果映射。</li>
<li>Hibernate 对对象的维护和缓存要比 MyBatis 好，对增删改查的对象的维护要方便。</li>
<li>Hibernate 数据库移植性很好，MyBatis 的数据库移植性不好，不同的数据库需要写不同 SQL。</li>
<li>Hibernate 有更好的二级缓存机制，可以使用第三方缓存。MyBatis 本身提供的缓存机制不佳。</li>
</ul>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><blockquote>
<p>这里，我将以一个入门级的示例来演示 Mybatis 是如何工作的。</p>
<p>注：本文后面章节中的原理、源码部分也将基于这个示例来进行讲解。</p>
</blockquote>
<h3 id="数据库准备"><a href="#数据库准备" class="headerlink" title="数据库准备"></a>数据库准备</h3><p>在本示例中，需要针对一张用户表进行 CRUD 操作。其数据模型如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="keyword">user</span> (</span><br><span class="line">    id      <span class="type">BIGINT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;Id&#x27;</span>,</span><br><span class="line">    name    <span class="type">VARCHAR</span>(<span class="number">10</span>)         <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">    age     <span class="type">INT</span>(<span class="number">3</span>)              <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">    address <span class="type">VARCHAR</span>(<span class="number">32</span>)         <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;地址&#x27;</span>,</span><br><span class="line">    email   <span class="type">VARCHAR</span>(<span class="number">32</span>)         <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;邮件&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">) COMMENT <span class="operator">=</span> <span class="string">&#x27;用户表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> (name, age, address, email)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;张三&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;北京&#x27;</span>, <span class="string">&#x27;xxx@163.com&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> (name, age, address, email)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;李四&#x27;</span>, <span class="number">19</span>, <span class="string">&#x27;上海&#x27;</span>, <span class="string">&#x27;xxx@163.com&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="添加-Mybatis"><a href="#添加-Mybatis" class="headerlink" title="添加 Mybatis"></a>添加 Mybatis</h3><p>如果使用 Maven 来构建项目，则需将下面的依赖代码置于 pom.xml 文件中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>x.x.x<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Mybatis-配置"><a href="#Mybatis-配置" class="headerlink" title="Mybatis 配置"></a>Mybatis 配置</h3><p>XML 配置文件中包含了对 MyBatis 系统的核心设置，包括获取数据库连接实例的数据源（DataSource）以及决定事务作用域和控制方式的事务管理器（TransactionManager）。</p>
<p>本示例中只是给出最简化的配置。</p>
<p>【示例】mybatis-config.xml 文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/spring_tutorial?serverTimezone=UTC&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mybatis/mapper/UserMapper.xml&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：上面的配置文件中仅仅指定了数据源连接方式和 User 表的映射配置文件。</p>
</blockquote>
<h3 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h3><h4 id="Mapper-xml"><a href="#Mapper-xml" class="headerlink" title="Mapper.xml"></a>Mapper.xml</h4><p>个人理解，Mapper.xml 文件可以看做是 Mybatis 的 JDBC SQL 模板。</p>
<p>【示例】UserMapper.xml 文件</p>
<p>下面是一个通过 Mybatis Generator 自动生成的完整的 Mapper 文件。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;io.github.dunwu.spring.orm.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;io.github.dunwu.spring.orm.entity.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;BIGINT&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;address&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> <span class="attr">property</span>=<span class="string">&quot;address&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteByPrimaryKey&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Long&quot;</span>&gt;</span></span><br><span class="line">    delete from user</span><br><span class="line">    where id = #&#123;id,jdbcType=BIGINT&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;io.github.dunwu.spring.orm.entity.User&quot;</span>&gt;</span></span><br><span class="line">    insert into user (id, name, age,</span><br><span class="line">      address, email)</span><br><span class="line">    values (#&#123;id,jdbcType=BIGINT&#125;, #&#123;name,jdbcType=VARCHAR&#125;, #&#123;age,jdbcType=INTEGER&#125;,</span><br><span class="line">      #&#123;address,jdbcType=VARCHAR&#125;, #&#123;email,jdbcType=VARCHAR&#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateByPrimaryKey&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;io.github.dunwu.spring.orm.entity.User&quot;</span>&gt;</span></span><br><span class="line">    update user</span><br><span class="line">    set name = #&#123;name,jdbcType=VARCHAR&#125;,</span><br><span class="line">      age = #&#123;age,jdbcType=INTEGER&#125;,</span><br><span class="line">      address = #&#123;address,jdbcType=VARCHAR&#125;,</span><br><span class="line">      email = #&#123;email,jdbcType=VARCHAR&#125;</span><br><span class="line">    where id = #&#123;id,jdbcType=BIGINT&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByPrimaryKey&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Long&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="line">    select id, name, age, address, email</span><br><span class="line">    from user</span><br><span class="line">    where id = #&#123;id,jdbcType=BIGINT&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="line">    select id, name, age, address, email</span><br><span class="line">    from user</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Mapper-java"><a href="#Mapper-java" class="headerlink" title="Mapper.java"></a>Mapper.java</h4><p>Mapper.java 文件是 Mapper.xml 对应的 Java 对象。</p>
<p>【示例】UserMapper.java 文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteByPrimaryKey</span><span class="params">(Long id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">insert</span><span class="params">(User record)</span>;</span><br><span class="line"></span><br><span class="line">    User <span class="title function_">selectByPrimaryKey</span><span class="params">(Long id)</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateByPrimaryKey</span><span class="params">(User record)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比 UserMapper.java 和 UserMapper.xml 文件，不难发现：</p>
<p>UserMapper.java 中的方法和 UserMapper.xml 的 CRUD 语句元素（ <code>&lt;insert&gt;</code>、<code>&lt;delete&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;select&gt;</code>）存在一一对应关系。</p>
<p>在 Mybatis 中，正是通过方法的全限定名，将二者绑定在一起。</p>
<h4 id="数据实体-java"><a href="#数据实体-java" class="headerlink" title="数据实体.java"></a>数据实体.java</h4><p>【示例】User.java 文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&lt;insert&gt;</code>、<code>&lt;delete&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;select&gt;</code> 的 <code>parameterType</code> 属性以及 <code>&lt;resultMap&gt;</code> 的 <code>type</code> 属性都可能会绑定到数据实体。这样就可以把 JDBC 操作的输入输出和 JavaBean 结合起来，更加方便、易于理解。</p>
<h3 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h3><p>【示例】MybatisDemo.java 文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 加载 mybatis 配置文件，创建 SqlSessionFactory</span></span><br><span class="line">        <span class="comment">// 注：在实际的应用中，SqlSessionFactory 应该是单例</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis/mybatis-config.xml&quot;</span>);</span><br><span class="line">        <span class="type">SqlSessionFactoryBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> builder.build(inputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建一个 SqlSession 实例，进行数据库操作</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> factory.openSession();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. Mapper 映射并执行</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">params</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">        List&lt;User&gt; list = sqlSession.selectList(<span class="string">&quot;io.github.dunwu.spring.orm.mapper.UserMapper.selectByPrimaryKey&quot;</span>, params);</span><br><span class="line">        <span class="keyword">for</span> (User user : list) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;user name: &quot;</span> + user.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出：user name: 张三</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：</p>
<p><code>SqlSession</code> 接口是 Mybatis API 核心中的核心，它代表了 Mybatis 和数据库的一次完整会话。</p>
<ul>
<li>Mybatis 会解析配置，并根据配置创建 <code>SqlSession</code> 。</li>
<li>然后，Mybatis 将 Mapper 映射为 <code>SqlSession</code>，然后传递参数，执行 SQL 语句并获取结果。</li>
</ul>
</blockquote>
<h2 id="Mybatis-xml-配置"><a href="#Mybatis-xml-配置" class="headerlink" title="Mybatis xml 配置"></a>Mybatis xml 配置</h2><blockquote>
<p>配置的详细内容请参考：“ <a target="_blank" rel="noopener" href="http://www.mybatis.org/mybatis-3/zh/configuration.html">Mybatis 官方文档之配置</a> ” 。</p>
</blockquote>
<p>MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。主要配置项有以下：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.mybatis.org/mybatis-3/zh/configuration.html#properties">properties（属性）</a></li>
<li><a target="_blank" rel="noopener" href="http://www.mybatis.org/mybatis-3/zh/configuration.html#settings">settings（设置）</a></li>
<li><a target="_blank" rel="noopener" href="http://www.mybatis.org/mybatis-3/zh/configuration.html#typeAliases">typeAliases（类型别名）</a></li>
<li><a target="_blank" rel="noopener" href="http://www.mybatis.org/mybatis-3/zh/configuration.html#typeHandlers">typeHandlers（类型处理器）</a></li>
<li><a target="_blank" rel="noopener" href="http://www.mybatis.org/mybatis-3/zh/configuration.html#objectFactory">objectFactory（对象工厂）</a></li>
<li><a target="_blank" rel="noopener" href="http://www.mybatis.org/mybatis-3/zh/configuration.html#plugins">plugins（插件）</a></li>
<li><a target="_blank" rel="noopener" href="http://www.mybatis.org/mybatis-3/zh/configuration.html#environments">environments（环境配置）</a><ul>
<li>environment（环境变量）<ul>
<li>transactionManager（事务管理器）</li>
<li>dataSource（数据源）</li>
</ul>
</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="http://www.mybatis.org/mybatis-3/zh/configuration.html#databaseIdProvider">databaseIdProvider（数据库厂商标识）</a></li>
<li><a target="_blank" rel="noopener" href="http://www.mybatis.org/mybatis-3/zh/configuration.html#mappers">mappers（映射器）</a></li>
</ul>
<h2 id="Mybatis-xml-映射器"><a href="#Mybatis-xml-映射器" class="headerlink" title="Mybatis xml 映射器"></a>Mybatis xml 映射器</h2><blockquote>
<p>SQL XML 映射文件详细内容请参考：“ <a target="_blank" rel="noopener" href="http://www.mybatis.org/mybatis-3/zh/sqlmap-xml.html">Mybatis 官方文档之 XML 映射文件</a> ”。</p>
</blockquote>
<p>XML 映射文件只有几个顶级元素：</p>
<ul>
<li><code>cache</code> – 对给定命名空间的缓存配置。</li>
<li><code>cache-ref</code> – 对其他命名空间缓存配置的引用。</li>
<li><code>resultMap</code> – 是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象。</li>
<li><del><code>parameterMap</code> – 已被废弃！老式风格的参数映射。更好的办法是使用内联参数，此元素可能在将来被移除。文档中不会介绍此元素。</del></li>
<li><code>sql</code> – 可被其他语句引用的可重用语句块。</li>
<li><code>insert</code> – 映射插入语句</li>
<li><code>update</code> – 映射更新语句</li>
<li><code>delete</code> – 映射删除语句</li>
<li><code>select</code> – 映射查询语句</li>
</ul>
<h2 id="Mybatis-扩展"><a href="#Mybatis-扩展" class="headerlink" title="Mybatis 扩展"></a>Mybatis 扩展</h2><h3 id="Mybatis-类型处理器"><a href="#Mybatis-类型处理器" class="headerlink" title="Mybatis 类型处理器"></a>Mybatis 类型处理器</h3><p>MyBatis 在设置预处理语句（PreparedStatement）中的参数或从结果集中取出一个值时， 都会用类型处理器将获取到的值以合适的方式转换成 Java 类型。下表描述了一些默认的类型处理器。</p>
<p>从 3.4.5 开始，MyBatis 默认支持 JSR-310（日期和时间 API） 。</p>
<p>你可以重写已有的类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。 具体做法为：实现 <code>org.apache.ibatis.type.TypeHandler</code> 接口， 或继承一个很便利的类 <code>org.apache.ibatis.type.BaseTypeHandler</code>， 并且可以（可选地）将它映射到一个 JDBC 类型。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExampleTypeHandler.java</span></span><br><span class="line"><span class="meta">@MappedJdbcTypes(JdbcType.VARCHAR)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleTypeHandler</span> <span class="keyword">extends</span> <span class="title class_">BaseTypeHandler</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNonNullParameter</span><span class="params">(PreparedStatement ps, <span class="type">int</span> i, String parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    ps.setString(i, parameter);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getNullableResult</span><span class="params">(ResultSet rs, String columnName)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="keyword">return</span> rs.getString(columnName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getNullableResult</span><span class="params">(ResultSet rs, <span class="type">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="keyword">return</span> rs.getString(columnIndex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getNullableResult</span><span class="params">(CallableStatement cs, <span class="type">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="keyword">return</span> cs.getString(columnIndex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mybatis-config.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">handler</span>=<span class="string">&quot;org.mybatis.example.ExampleTypeHandler&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用上述的类型处理器将会覆盖已有的处理 Java String 类型的属性以及 VARCHAR 类型的参数和结果的类型处理器。 要注意 MyBatis 不会通过检测数据库元信息来决定使用哪种类型，所以你必须在参数和结果映射中指明字段是 VARCHAR 类型， 以使其能够绑定到正确的类型处理器上。这是因为 MyBatis 直到语句被执行时才清楚数据类型。</p>
<h3 id="Mybatis-插件"><a href="#Mybatis-插件" class="headerlink" title="Mybatis 插件"></a>Mybatis 插件</h3><p>MyBatis 允许你在映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：</p>
<ul>
<li>Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)</li>
<li>ParameterHandler (getParameterObject, setParameters)</li>
<li>ResultSetHandler (handleResultSets, handleOutputParameters)</li>
<li>StatementHandler (prepare, parameterize, batch, update, query)</li>
</ul>
<p>这些类中方法的细节可以通过查看每个方法的签名来发现，或者直接查看 MyBatis 发行包中的源代码。 如果你想做的不仅仅是监控方法的调用，那么你最好相当了解要重写的方法的行为。 因为在试图修改或重写已有方法的行为时，很可能会破坏 MyBatis 的核心模块。 这些都是更底层的类和方法，所以使用插件的时候要特别当心。</p>
<p>通过 MyBatis 提供的强大机制，使用插件是非常简单的，只需实现 Interceptor 接口，并指定想要拦截的方法签名即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExamplePlugin.java</span></span><br><span class="line"><span class="meta">@Intercepts(&#123;@Signature(</span></span><br><span class="line"><span class="meta">  type= Executor.class,</span></span><br><span class="line"><span class="meta">  method = &quot;update&quot;,</span></span><br><span class="line"><span class="meta">  args = &#123;MappedStatement.class,Object.class&#125;)&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExamplePlugin</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// implement pre processing if need</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">returnObject</span> <span class="operator">=</span> invocation.proceed();</span><br><span class="line">    <span class="comment">// implement post processing if need</span></span><br><span class="line">    <span class="keyword">return</span> returnObject;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProperties</span><span class="params">(Properties properties)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.properties = properties;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mybatis-config.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;org.mybatis.example.ExamplePlugin&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;someProperty&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的插件将会拦截在 Executor 实例中所有的 “update” 方法调用， 这里的 Executor 是负责执行底层映射语句的内部对象。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><strong>官方</strong><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/mybatis/mybatis-3">Mybatis Github</a></li>
<li><a target="_blank" rel="noopener" href="http://www.mybatis.org/mybatis-3/">Mybatis 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/mybatis/generator">MyBatis 官方代码生成（mybatis-generator）</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/mybatis/spring">MyBatis 官方集成 Spring（mybatis-spring）</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/mybatis/spring-boot-starter">Mybatis 官方集成 Spring Boot（mybatis-spring-boot）</a></li>
</ul>
</li>
<li><strong>扩展插件</strong><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/baomidou/mybatis-plus">MyBatis-Plus</a> - CRUD 扩展插件、代码生成器、分页器等多功能</li>
<li><a target="_blank" rel="noopener" href="https://github.com/abel533/Mapper">Mapper</a> - CRUD 扩展插件</li>
<li><a target="_blank" rel="noopener" href="https://github.com/pagehelper/Mybatis-PageHelper">Mybatis-PageHelper</a> - Mybatis 通用分页插件</li>
</ul>
</li>
<li><strong>文章</strong><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/luanlouis/article/details/40422941">深入理解 mybatis 原理</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/tuguangquan/mybatis">mybatis 源码中文注释</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/isea533/article/details/42102297">MyBatis Generator 详解</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5aa646cdf265da237e095da1">Mybatis 常见面试题</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5cee8b61e51d455d88219ea4">Mybatis 中强大的 resultMap</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/050cdd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/050cdd/" class="post-title-link" itemprop="url">Spring Security 快速入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-17 22:34:30" itemprop="dateCreated datePublished" datetime="2022-02-17T22:34:30+08:00">2022-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E6%A1%86%E6%9E%B6/%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">安全</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Spring-Security-快速入门"><a href="#Spring-Security-快速入门" class="headerlink" title="Spring Security 快速入门"></a>Spring Security 快速入门</h1><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>参考：<a target="_blank" rel="noopener" href="https://spring.io/guides/gs/securing-web/">Securing a Web Application</a></p>
<h2 id="核心-API"><a href="#核心-API" class="headerlink" title="核心 API"></a>核心 API</h2><h2 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h2><p>Spring Security 对于 Servlet 的支持基于过滤链（<code>FilterChain</code>）实现。</p>
<p>Spring 提供了一个名为 <code>DelegatingFilterProxy</code> 的 <code>Filter</code> 实现，该实现允许在 Servlet 容器的生命周期和 Spring 的 <code>ApplicationContext</code> 之间进行桥接。 Servlet 容器允许使用其自己的标准注册 Filters，但它不了解 Spring 定义的 Bean。 <code>DelegatingFilterProxy</code> 可以通过标准的 Servlet 容器机制进行注册，但是可以将所有工作委托给实现 Filter 的 Spring Bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> &#123;</span><br><span class="line">    <span class="comment">// Lazily get Filter that was registered as a Spring Bean</span></span><br><span class="line">    <span class="comment">// For the example in DelegatingFilterProxy delegate is an instance of Bean Filter0</span></span><br><span class="line">    <span class="type">Filter</span> <span class="variable">delegate</span> <span class="operator">=</span> getFilterBean(someBeanName);</span><br><span class="line">    <span class="comment">// delegate work to the Spring Bean</span></span><br><span class="line">    delegate.doFilter(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>FilterChainProxy</code> 使用 <code>SecurityFilterChain</code> 确定应对此请求调用哪些 Spring Security 过滤器。</p>
<p><code>SecurityFilterChain</code> 中的安全过滤器通常是 Bean，但它们是使用 <code>FilterChainProxy</code> 而不是 <code>DelegatingFilterProxy</code> 注册的。</p>
<p>实际上，<code>FilterChainProxy</code> 可用于确定应使用哪个 <code>SecurityFilterChain</code>。如果您的应用程序可以为不同的模块提供完全独立的配置。</p>
<p><img src="https://docs.spring.io/spring-security/site/docs/5.3.0.RELEASE/reference/html5/images/servlet/architecture/multi-securityfilterchain.png" alt="multi securityfilterchain"></p>
<p>ExceptionTranslationFilter 可以将 AccessDeniedException 和 AuthenticationException 转换为 HTTP 响应。</p>
<p><img src="https://docs.spring.io/spring-security/site/docs/5.3.0.RELEASE/reference/html5/images/servlet/architecture/exceptiontranslationfilter.png" alt="exceptiontranslationfilter"></p>
<p>核心源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    filterChain.doFilter(request, response);</span><br><span class="line">&#125; <span class="keyword">catch</span> (AccessDeniedException | AuthenticationException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!authenticated || e <span class="keyword">instanceof</span> AuthenticationException) &#123;</span><br><span class="line">        startAuthentication();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        accessDenied();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>Spring Security 框架中的认证数据模型如下：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200331115710.png" alt="img"></p>
<ul>
<li><code>Authentication</code> - 认证信息实体。<ul>
<li><code>principal</code> - 用户标识。如：用户名、账户名等。通常是 <code>UserDetails</code> 的实例（后面详细讲解）。</li>
<li><code>credentials</code> - 认证凭证。如：密码等。</li>
<li><code>authorities</code> - 授权信息。如：用户的角色、权限等信息。</li>
</ul>
</li>
<li><code>SecurityContext</code> - 安全上下文。包含一个 <code>Authentication</code> 对象。</li>
<li><code>SecurityContextHolder</code> - 安全上下文持有者。用于存储认证信息。</li>
</ul>
<p>【示例】注册认证信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SecurityContext</span> <span class="variable">context</span> <span class="operator">=</span> SecurityContextHolder.createEmptyContext();</span><br><span class="line"><span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">TestingAuthenticationToken</span>(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;password&quot;</span>, <span class="string">&quot;ROLE_USER&quot;</span>);</span><br><span class="line">context.setAuthentication(authentication);</span><br><span class="line">SecurityContextHolder.setContext(context);</span><br></pre></td></tr></table></figure>

<p>【示例】访问认证信息</p>
<h3 id="认证基本流程"><a href="#认证基本流程" class="headerlink" title="认证基本流程"></a>认证基本流程</h3><p>AbstractAuthenticationProcessingFilter 用作验证用户凭据的基本过滤器。 在对凭证进行身份验证之前，Spring Security 通常使用 AuthenticationEntryPoint 请求凭证。</p>
<p><img src="https://docs.spring.io/spring-security/site/docs/5.3.0.RELEASE/reference/html5/images/servlet/authentication/architecture/abstractauthenticationprocessingfilter.png" alt="abstractauthenticationprocessingfilter"></p>
<ul>
<li>（1）当用户提交其凭据时，<code>AbstractAuthenticationProcessingFilter</code> 从要验证的 <code>HttpServletRequest</code> 创建一个 <code>Authentication</code>。创建的身份验证类型取决于 <code>AbstractAuthenticationProcessingFilter</code> 的子类。例如，<code>UsernamePasswordAuthenticationFilter</code> 根据在 <code>HttpServletRequest</code> 中提交的用户名和密码来创建 <code>UsernamePasswordAuthenticationToken</code>。</li>
<li>（2）接下来，将身份验证传递到 <code>AuthenticationManager</code> 进行身份验证。</li>
<li>（3）如果身份验证失败，则认证失败<ul>
<li>清除 <code>SecurityContextHolder</code>。</li>
<li>调用 <code>RememberMeServices.loginFail</code>。如果没有配置 remember me，则为空。</li>
<li>调用 <code>AuthenticationFailureHandler</code>。</li>
</ul>
</li>
<li>（4）如果身份验证成功，则认证成功。<ul>
<li>如果是新的登录，则通知 <code>SessionAuthenticationStrategy</code>。</li>
<li>身份验证是在 <code>SecurityContextHolder</code> 上设置的。之后，<code>SecurityContextPersistenceFilter</code> 将 <code>SecurityContext</code> 保存到 <code>HttpSession</code> 中。</li>
<li>调用 <code>RememberMeServices.loginSuccess</code>。如果没有配置 remember me，则为空。</li>
<li><code>ApplicationEventPublisher</code> 发布一个 <code>InteractiveAuthenticationSuccessEvent</code>。</li>
</ul>
</li>
</ul>
<h3 id="用户名-密码认证"><a href="#用户名-密码认证" class="headerlink" title="用户名&#x2F;密码认证"></a>用户名&#x2F;密码认证</h3><p>读取用户名和密码的方式：</p>
<ul>
<li>表单</li>
<li>基本认证</li>
<li>数字认证</li>
</ul>
<p>存储机制</p>
<ul>
<li>内存</li>
<li>JDBC</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-security/site/docs/5.3.0.RELEASE/reference/html5/#servlet-authentication-userdetailsservice">UserDetailsService</a></li>
<li>LDAP</li>
</ul>
<h4 id="表单认证"><a href="#表单认证" class="headerlink" title="表单认证"></a>表单认证</h4><p>spring security 支持通过从 html 表单获取登录时提交的用户名、密码。</p>
<p><img src="https://docs.spring.io/spring-security/site/docs/5.3.0.RELEASE/reference/html5/images/servlet/authentication/unpwd/loginurlauthenticationentrypoint.png" alt="loginurlauthenticationentrypoint"></p>
<p>一旦，登录信息被提交，<code>UsernamePasswordAuthenticationFilter</code> 就会验证用户名和密码。</p>
<p><img src="https://docs.spring.io/spring-security/site/docs/5.3.0.RELEASE/reference/html5/images/servlet/authentication/unpwd/usernamepasswordauthenticationfilter.png" alt="usernamepasswordauthenticationfilter"></p>
<h4 id="基本认证"><a href="#基本认证" class="headerlink" title="基本认证"></a>基本认证</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> &#123;</span><br><span class="line">    http</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        .httpBasic(withDefaults());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="内存认证"><a href="#内存认证" class="headerlink" title="内存认证"></a>内存认证</h4><p><code>InMemoryUserDetailsManager</code> 实现了 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-security/site/docs/5.3.0.RELEASE/reference/html5/#servlet-authentication-userdetailsservice">UserDetailsService</a> ，提供了基本的用户名、密码认证，其认证数据存储在内存中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> UserDetailsService <span class="title function_">users</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// The builder will ensure the passwords are encoded before saving in memory</span></span><br><span class="line">    <span class="type">UserBuilder</span> <span class="variable">users</span> <span class="operator">=</span> User.withDefaultPasswordEncoder();</span><br><span class="line">    <span class="type">UserDetails</span> <span class="variable">user</span> <span class="operator">=</span> users</span><br><span class="line">        .username(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">        .password(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">        .roles(<span class="string">&quot;USER&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="type">UserDetails</span> <span class="variable">user</span> <span class="operator">=</span> users</span><br><span class="line">        .username(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">        .password(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">        .roles(<span class="string">&quot;USER&quot;</span>, <span class="string">&quot;ADMIN&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InMemoryUserDetailsManager</span>(user, admin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JDBC-认证"><a href="#JDBC-认证" class="headerlink" title="JDBC 认证"></a>JDBC 认证</h4><p>JdbcUserDetailsManager 实现了 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-security/site/docs/5.3.0.RELEASE/reference/html5/#servlet-authentication-userdetailsservice">UserDetailsService</a> ，提供了基本的用户名、密码认证，其认证数据存储在关系型数据库中，通过 JDBC 方式访问。</p>
<figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">UserDetailsManager users(DataSource dataSource) &#123;</span><br><span class="line">    UserDetails <span class="literal">user</span> = <span class="literal">User</span>.builder()</span><br><span class="line">        .username(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">        .password(<span class="string">&quot;&#123;bcrypt&#125;<span class="variable">$2a</span><span class="variable">$10</span><span class="variable">$GRLdNijSQMUvl</span>/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW&quot;</span>)</span><br><span class="line">        .roles(<span class="string">&quot;USER&quot;</span>)</span><br><span class="line">        .build()<span class="comment">;</span></span><br><span class="line">    UserDetails <span class="literal">admin</span> = <span class="literal">User</span>.builder()</span><br><span class="line">        .username(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">        .password(<span class="string">&quot;&#123;bcrypt&#125;<span class="variable">$2a</span><span class="variable">$10</span><span class="variable">$GRLdNijSQMUvl</span>/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW&quot;</span>)</span><br><span class="line">        .roles(<span class="string">&quot;USER&quot;</span>, <span class="string">&quot;ADMIN&quot;</span>)</span><br><span class="line">        .build()<span class="comment">;</span></span><br><span class="line">    JdbcUserDetailsManager users = new JdbcUserDetailsManager(dataSource)<span class="comment">;</span></span><br><span class="line">    users.createUser()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本的 scheam：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> users(</span><br><span class="line">    username varchar_ignorecase(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">primary</span> key,</span><br><span class="line">    password varchar_ignorecase(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    enabled <span class="type">boolean</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> authorities (</span><br><span class="line">    username varchar_ignorecase(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    authority varchar_ignorecase(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    <span class="keyword">constraint</span> fk_authorities_users <span class="keyword">foreign</span> key(username) <span class="keyword">references</span> users(username)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> index ix_auth_username <span class="keyword">on</span> authorities (username,authority);</span><br></pre></td></tr></table></figure>

<h4 id="UserDetailsService"><a href="#UserDetailsService" class="headerlink" title="UserDetailsService"></a>UserDetailsService</h4><p><code>UserDetails</code> 由 <code>UserDetailsService</code> 返回。 <code>DaoAuthenticationProvider</code> 验证 <code>UserDetails</code>，然后返回身份验证，该身份验证的主体是已配置的 <code>UserDetailsService</code> 返回的 <code>UserDetails</code>。</p>
<p><code>DaoAuthenticationProvider</code> 使用 <code>UserDetailsService</code> 检索用户名，密码和其他用于使用用户名和密码进行身份验证的属性。 Spring Security 提供 <code>UserDetailsService</code> 的内存中和 JDBC 实现。</p>
<p>您可以通过将自定义 <code>UserDetailsService</code> 公开为 bean 来定义自定义身份验证。</p>
<h4 id="PasswordEncoder"><a href="#PasswordEncoder" class="headerlink" title="PasswordEncoder"></a>PasswordEncoder</h4><p>Spring Security 的 servlet 支持通过与 <code>PasswordEncoder</code> 集成来安全地存储密码。 可以通过公开一个 PasswordEncoder Bean 来定制 Spring Security 使用的 PasswordEncoder 实现。</p>
<p><img src="https://docs.spring.io/spring-security/site/docs/5.3.0.RELEASE/reference/html5/images/servlet/authentication/unpwd/daoauthenticationprovider.png" alt="daoauthenticationprovider"></p>
<h3 id="Remember-Me"><a href="#Remember-Me" class="headerlink" title="Remember-Me"></a>Remember-Me</h3><h2 id="Spring-Boot-集成"><a href="#Spring-Boot-集成" class="headerlink" title="Spring Boot 集成"></a>Spring Boot 集成</h2><p><code>@EnableWebSecurity</code> 和 <code>@Configuration</code> 注解一起使用, 注解 <code>WebSecurityConfigurer</code> 类型的类。</p>
<p>或者利用<code>@EnableWebSecurity</code>注解继承 <code>WebSecurityConfigurerAdapter</code> 的类，这样就构成了 <em>Spring Security</em> 的配置。</p>
<ul>
<li>configure(WebSecurity)：通过重载该方法，可配置 Spring Security 的 Filter 链。</li>
<li>configure(HttpSecurity)：通过重载该方法，可配置如何通过拦截器保护请求。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://spring.io/guides/topicals/spring-security-architecture">Spring Security Architecture</a></li>
<li><a target="_blank" rel="noopener" href="https://spring.io/guides/gs/securing-web/">Securing a Web Application</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/d55184/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/d55184/" class="post-title-link" itemprop="url">Mybatis原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-17 22:34:30" itemprop="dateCreated datePublished" datetime="2022-02-17T22:34:30+08:00">2022-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E6%A1%86%E6%9E%B6/ORM/" itemprop="url" rel="index"><span itemprop="name">ORM</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>24k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>22 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Mybatis-原理"><a href="#Mybatis-原理" class="headerlink" title="Mybatis 原理"></a>Mybatis 原理</h1><blockquote>
<p>Mybatis 的前身就是 iBatis ，是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。本文以一个 Mybatis 完整示例为切入点，结合 Mybatis 底层源码分析，图文并茂的讲解 Mybatis 的核心工作机制。</p>
</blockquote>
<h2 id="Mybatis-完整示例"><a href="#Mybatis-完整示例" class="headerlink" title="Mybatis 完整示例"></a>Mybatis 完整示例</h2><blockquote>
<p>这里，我将以一个入门级的示例来演示 Mybatis 是如何工作的。</p>
<p>注：本文后面章节中的原理、源码部分也将基于这个示例来进行讲解。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/dunwu/spring-tutorial/blob/master/codes/data/spring-data-mybatis/src/main/java/io/github/dunwu/spring/orm/MybatisDemo.java">完整示例源码地址</a></p>
</blockquote>
<h3 id="数据库准备"><a href="#数据库准备" class="headerlink" title="数据库准备"></a>数据库准备</h3><p>在本示例中，需要针对一张用户表进行 CRUD 操作。其数据模型如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="keyword">user</span> (</span><br><span class="line">    id      <span class="type">BIGINT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;Id&#x27;</span>,</span><br><span class="line">    name    <span class="type">VARCHAR</span>(<span class="number">10</span>)         <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">    age     <span class="type">INT</span>(<span class="number">3</span>)              <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">    address <span class="type">VARCHAR</span>(<span class="number">32</span>)         <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;地址&#x27;</span>,</span><br><span class="line">    email   <span class="type">VARCHAR</span>(<span class="number">32</span>)         <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;邮件&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">) COMMENT <span class="operator">=</span> <span class="string">&#x27;用户表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> (name, age, address, email)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;张三&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;北京&#x27;</span>, <span class="string">&#x27;xxx@163.com&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> (name, age, address, email)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;李四&#x27;</span>, <span class="number">19</span>, <span class="string">&#x27;上海&#x27;</span>, <span class="string">&#x27;xxx@163.com&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="添加-Mybatis"><a href="#添加-Mybatis" class="headerlink" title="添加 Mybatis"></a>添加 Mybatis</h3><p>如果使用 Maven 来构建项目，则需将下面的依赖代码置于 pom.xml 文件中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.Mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>x.x.x<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Mybatis-配置"><a href="#Mybatis-配置" class="headerlink" title="Mybatis 配置"></a>Mybatis 配置</h3><p>XML 配置文件中包含了对 Mybatis 系统的核心设置，包括获取数据库连接实例的数据源（DataSource）以及决定事务作用域和控制方式的事务管理器（TransactionManager）。</p>
<p>本示例中只是给出最简化的配置。</p>
<p>【示例】Mybatis-config.xml 文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//Mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="string">&quot;http://Mybatis.org/dtd/Mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/spring_tutorial?serverTimezone=UTC&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;Mybatis/mapper/UserMapper.xml&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：上面的配置文件中仅仅指定了数据源连接方式和 User 表的映射配置文件。</p>
</blockquote>
<h3 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h3><h4 id="Mapper-xml"><a href="#Mapper-xml" class="headerlink" title="Mapper.xml"></a>Mapper.xml</h4><p>个人理解，Mapper.xml 文件可以看做是 Mybatis 的 JDBC SQL 模板。</p>
<p>【示例】UserMapper.xml 文件</p>
<p>下面是一个通过 Mybatis Generator 自动生成的完整的 Mapper 文件。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//Mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://Mybatis.org/dtd/Mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;io.github.dunwu.spring.orm.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;io.github.dunwu.spring.orm.entity.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;BIGINT&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;address&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> <span class="attr">property</span>=<span class="string">&quot;address&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteByPrimaryKey&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Long&quot;</span>&gt;</span></span><br><span class="line">    delete from user</span><br><span class="line">    where id = #&#123;id,jdbcType=BIGINT&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;io.github.dunwu.spring.orm.entity.User&quot;</span>&gt;</span></span><br><span class="line">    insert into user (id, name, age,</span><br><span class="line">      address, email)</span><br><span class="line">    values (#&#123;id,jdbcType=BIGINT&#125;, #&#123;name,jdbcType=VARCHAR&#125;, #&#123;age,jdbcType=INTEGER&#125;,</span><br><span class="line">      #&#123;address,jdbcType=VARCHAR&#125;, #&#123;email,jdbcType=VARCHAR&#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateByPrimaryKey&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;io.github.dunwu.spring.orm.entity.User&quot;</span>&gt;</span></span><br><span class="line">    update user</span><br><span class="line">    set name = #&#123;name,jdbcType=VARCHAR&#125;,</span><br><span class="line">      age = #&#123;age,jdbcType=INTEGER&#125;,</span><br><span class="line">      address = #&#123;address,jdbcType=VARCHAR&#125;,</span><br><span class="line">      email = #&#123;email,jdbcType=VARCHAR&#125;</span><br><span class="line">    where id = #&#123;id,jdbcType=BIGINT&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByPrimaryKey&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Long&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="line">    select id, name, age, address, email</span><br><span class="line">    from user</span><br><span class="line">    where id = #&#123;id,jdbcType=BIGINT&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="line">    select id, name, age, address, email</span><br><span class="line">    from user</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Mapper-java"><a href="#Mapper-java" class="headerlink" title="Mapper.java"></a>Mapper.java</h4><p>Mapper.java 文件是 Mapper.xml 对应的 Java 对象。</p>
<p>【示例】UserMapper.java 文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteByPrimaryKey</span><span class="params">(Long id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">insert</span><span class="params">(User record)</span>;</span><br><span class="line"></span><br><span class="line">    User <span class="title function_">selectByPrimaryKey</span><span class="params">(Long id)</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateByPrimaryKey</span><span class="params">(User record)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比 UserMapper.java 和 UserMapper.xml 文件，不难发现：</p>
<p>UserMapper.java 中的方法和 UserMapper.xml 的 CRUD 语句元素（ <code>&lt;insert&gt;</code>、<code>&lt;delete&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;select&gt;</code>）存在一一对应关系。</p>
<p>在 Mybatis 中，正是通过方法的全限定名，将二者绑定在一起。</p>
<h4 id="数据实体-java"><a href="#数据实体-java" class="headerlink" title="数据实体.java"></a>数据实体.java</h4><p>【示例】User.java 文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&lt;insert&gt;</code>、<code>&lt;delete&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;select&gt;</code> 的 <code>parameterType</code> 属性以及 <code>&lt;resultMap&gt;</code> 的 <code>type</code> 属性都可能会绑定到数据实体。这样就可以把 JDBC 操作的输入输出和 JavaBean 结合起来，更加方便、易于理解。</p>
<h3 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h3><p>【示例】MybatisDemo.java 文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 加载 Mybatis 配置文件，创建 SqlSessionFactory</span></span><br><span class="line">        <span class="comment">// 注：在实际的应用中，SqlSessionFactory 应该是单例</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;Mybatis/Mybatis-config.xml&quot;</span>);</span><br><span class="line">        <span class="type">SqlSessionFactoryBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> builder.build(inputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建一个 SqlSession 实例，进行数据库操作</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> factory.openSession();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. Mapper 映射并执行</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">params</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">        List&lt;User&gt; list = sqlSession.selectList(<span class="string">&quot;io.github.dunwu.spring.orm.mapper.UserMapper.selectByPrimaryKey&quot;</span>, params);</span><br><span class="line">        <span class="keyword">for</span> (User user : list) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;user name: &quot;</span> + user.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出：user name: 张三</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：</p>
<p><code>SqlSession</code> 接口是 Mybatis API 核心中的核心，它代表了 Mybatis 和数据库的一次完整会话。</p>
<ul>
<li>Mybatis 会解析配置，并根据配置创建 <code>SqlSession</code> 。</li>
<li>然后，Mybatis 将 Mapper 映射为 <code>SqlSession</code>，然后传递参数，执行 SQL 语句并获取结果。</li>
</ul>
</blockquote>
<h2 id="Mybatis-生命周期"><a href="#Mybatis-生命周期" class="headerlink" title="Mybatis 生命周期"></a>Mybatis 生命周期</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20210510113446.png" alt="img"></p>
<h3 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h3><h4 id="SqlSessionFactoryBuilder-的职责"><a href="#SqlSessionFactoryBuilder-的职责" class="headerlink" title="SqlSessionFactoryBuilder 的职责"></a>SqlSessionFactoryBuilder 的职责</h4><p><strong><code>SqlSessionFactoryBuilder</code> 负责创建 <code>SqlSessionFactory</code> 实例</strong>。<code>SqlSessionFactoryBuilder</code> 可以从 XML 配置文件或一个预先定制的 <code>Configuration</code> 的实例构建出 <code>SqlSessionFactory</code> 的实例。</p>
<p><code>Configuration</code> 类包含了对一个 <code>SqlSessionFactory</code> 实例你可能关心的所有内容。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20210508173040.png" alt="img"></p>
<p><code>SqlSessionFactoryBuilder</code> 应用了建造者设计模式，它有五个 <code>build</code> 方法，允许你通过不同的资源创建 <code>SqlSessionFactory</code> 实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactory <span class="title function_">build</span><span class="params">(InputStream inputStream)</span></span><br><span class="line">SqlSessionFactory <span class="title function_">build</span><span class="params">(InputStream inputStream, String environment)</span></span><br><span class="line">SqlSessionFactory <span class="title function_">build</span><span class="params">(InputStream inputStream, Properties properties)</span></span><br><span class="line">SqlSessionFactory <span class="title function_">build</span><span class="params">(InputStream inputStream, String env, Properties props)</span></span><br><span class="line">SqlSessionFactory <span class="title function_">build</span><span class="params">(Configuration config)</span></span><br></pre></td></tr></table></figure>

<h4 id="SqlSessionFactoryBuilder-的生命周期"><a href="#SqlSessionFactoryBuilder-的生命周期" class="headerlink" title="SqlSessionFactoryBuilder 的生命周期"></a>SqlSessionFactoryBuilder 的生命周期</h4><p><code>SqlSessionFactoryBuilder</code> 可以被实例化、使用和丢弃，一旦创建了 <code>SqlSessionFactory</code>，就不再需要它了。 因此 <code>SqlSessionFactoryBuilder</code> 实例的最佳作用域是方法作用域（也就是局部方法变量）。你可以重用 <code>SqlSessionFactoryBuilder</code> 来创建多个 <code>SqlSessionFactory</code> 实例，但最好还是不要一直保留着它，以保证所有的 XML 解析资源可以被释放给更重要的事情。</p>
<h3 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h3><h4 id="SqlSessionFactory-职责"><a href="#SqlSessionFactory-职责" class="headerlink" title="SqlSessionFactory 职责"></a>SqlSessionFactory 职责</h4><p><strong><code>SqlSessionFactory</code> 负责创建 <code>SqlSession</code> 实例。</strong></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20210510105641.png" alt="img"></p>
<p><code>SqlSessionFactory</code> 应用了工厂设计模式，它提供了一组方法，用于创建 SqlSession 实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SqlSession <span class="title function_">openSession</span><span class="params">()</span></span><br><span class="line">SqlSession <span class="title function_">openSession</span><span class="params">(<span class="type">boolean</span> autoCommit)</span></span><br><span class="line">SqlSession <span class="title function_">openSession</span><span class="params">(Connection connection)</span></span><br><span class="line">SqlSession <span class="title function_">openSession</span><span class="params">(TransactionIsolationLevel level)</span></span><br><span class="line">SqlSession <span class="title function_">openSession</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level)</span></span><br><span class="line">SqlSession <span class="title function_">openSession</span><span class="params">(ExecutorType execType)</span></span><br><span class="line">SqlSession <span class="title function_">openSession</span><span class="params">(ExecutorType execType, <span class="type">boolean</span> autoCommit)</span></span><br><span class="line">SqlSession <span class="title function_">openSession</span><span class="params">(ExecutorType execType, Connection connection)</span></span><br><span class="line">Configuration <span class="title function_">getConfiguration</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>方法说明：</p>
<ul>
<li>默认的 <code>openSession()</code> 方法没有参数，它会创建具备如下特性的 <code>SqlSession</code>：<ul>
<li>事务作用域将会开启（也就是不自动提交）。</li>
<li>将由当前环境配置的 <code>DataSource</code> 实例中获取 <code>Connection</code> 对象。</li>
<li>事务隔离级别将会使用驱动或数据源的默认设置。</li>
<li>预处理语句不会被复用，也不会批量处理更新。</li>
</ul>
</li>
<li><code>TransactionIsolationLevel</code> 表示事务隔离级别，它对应着 JDBC 的五个事务隔离级别。</li>
<li><code>ExecutorType</code> 枚举类型定义了三个值:<ul>
<li><code>ExecutorType.SIMPLE</code>：该类型的执行器没有特别的行为。它为每个语句的执行创建一个新的预处理语句。</li>
<li><code>ExecutorType.REUSE</code>：该类型的执行器会复用预处理语句。</li>
<li><code>ExecutorType.BATCH</code>：该类型的执行器会批量执行所有更新语句，如果 SELECT 在多个更新中间执行，将在必要时将多条更新语句分隔开来，以方便理解。</li>
</ul>
</li>
</ul>
<h4 id="SqlSessionFactory-生命周期"><a href="#SqlSessionFactory-生命周期" class="headerlink" title="SqlSessionFactory 生命周期"></a>SqlSessionFactory 生命周期</h4><p><code>SqlSessionFactory</code> 应该以单例形式在应用的运行期间一直存在。</p>
<h3 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h3><h4 id="SqlSession-职责"><a href="#SqlSession-职责" class="headerlink" title="SqlSession 职责"></a>SqlSession 职责</h4><p><strong>Mybatis 的主要 Java 接口就是 <code>SqlSession</code>。它包含了所有执行语句，获取映射器和管理事务等方法。</strong></p>
<blockquote>
<p>详细内容可以参考：“ <a target="_blank" rel="noopener" href="http://www.mybatis.org/Mybatis-3/zh/java-api.html#sqlSessions">Mybatis 官方文档之 SqlSessions</a> ” 。</p>
</blockquote>
<p>SqlSession 类的方法可以按照下图进行大致分类：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20210510110638.png" alt="img"></p>
<h4 id="SqlSession-生命周期"><a href="#SqlSession-生命周期" class="headerlink" title="SqlSession 生命周期"></a>SqlSession 生命周期</h4><p><code>SqlSessions</code> 是由 <code>SqlSessionFactory</code> 实例创建的；而 <code>SqlSessionFactory</code> 是由 <code>SqlSessionFactoryBuilder</code> 创建的。</p>
<blockquote>
<p>🔔 注意：当 Mybatis 与一些依赖注入框架（如 Spring 或者 Guice）同时使用时，<code>SqlSessions</code> 将被依赖注入框架所创建，所以你不需要使用 <code>SqlSessionFactoryBuilder</code> 或者 <code>SqlSessionFactory</code>。</p>
</blockquote>
<p><strong>每个线程都应该有它自己的 <code>SqlSession</code> 实例。</strong></p>
<p><code>SqlSession</code> 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 绝对不能将 <code>SqlSession</code> 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 <code>SqlSession</code> 实例的引用放在任何类型的托管作用域中，比如 Servlet 框架中的 <code>HttpSession</code>。 正确在 Web 中使用 <code>SqlSession</code> 的场景是：每次收到的 HTTP 请求，就可以打开一个 <code>SqlSession</code>，返回一个响应，就关闭它。</p>
<p>编程模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  <span class="comment">// 你的应用逻辑代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="映射器"><a href="#映射器" class="headerlink" title="映射器"></a>映射器</h3><h4 id="映射器职责"><a href="#映射器职责" class="headerlink" title="映射器职责"></a>映射器职责</h4><p>映射器是一些由用户创建的、绑定 SQL 语句的接口。</p>
<p><code>SqlSession</code> 中的 <code>insert</code>、<code>update</code>、<code>delete</code> 和 <code>select</code> 方法都很强大，但也有些繁琐。更通用的方式是使用映射器类来执行映射语句。<strong>一个映射器类就是一个仅需声明与 <code>SqlSession</code> 方法相匹配的方法的接口类</strong>。</p>
<p>Mybatis 将配置文件中的每一个 <code>&lt;mapper&gt;</code> 节点抽象为一个 <code>Mapper</code> 接口，而这个接口中声明的方法和跟 <code>&lt;mapper&gt;</code> 节点中的 <code>&lt;select|update|delete|insert&gt;</code> 节点相对应，即 <code>&lt;select|update|delete|insert&gt;</code> 节点的 id 值为 Mapper 接口中的方法名称，<code>parameterType</code> 值表示 Mapper 对应方法的入参类型，而 <code>resultMap</code> 值则对应了 Mapper 接口表示的返回值类型或者返回结果集的元素类型。</p>
<p>Mybatis 会根据相应的接口声明的方法信息，通过动态代理机制生成一个 Mapper 实例；Mybatis 会根据这个方法的方法名和参数类型，确定 Statement Id，然后和 SqlSession 进行映射，底层还是通过 SqlSession 完成和数据库的交互。</p>
<p>下面的示例展示了一些方法签名以及它们是如何映射到 <code>SqlSession</code> 上的。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20210512111723.png" alt="img"></p>
<blockquote>
<p><strong>注意</strong></p>
<ul>
<li>映射器接口不需要去实现任何接口或继承自任何类。只要方法可以被唯一标识对应的映射语句就可以了。</li>
<li>映射器接口可以继承自其他接口。当使用 XML 来构建映射器接口时要保证语句被包含在合适的命名空间中。而且，唯一的限制就是你不能在两个继承关系的接口中拥有相同的方法签名（潜在的危险做法不可取）。</li>
</ul>
</blockquote>
<h4 id="映射器生命周期"><a href="#映射器生命周期" class="headerlink" title="映射器生命周期"></a>映射器生命周期</h4><p>映射器接口的实例是从 <code>SqlSession</code> 中获得的。因此从技术层面讲，任何映射器实例的最大作用域是和请求它们的 <code>SqlSession</code> 相同的。尽管如此，映射器实例的最佳作用域是方法作用域。 也就是说，映射器实例应该在调用它们的方法中被请求，用过之后即可丢弃。</p>
<p>编程模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  <span class="type">BlogMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(BlogMapper.class);</span><br><span class="line">  <span class="comment">// 你的应用逻辑代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>映射器注解</strong></li>
</ul>
<p>Mybatis 是一个 XML 驱动的框架。配置信息是基于 XML 的，而且映射语句也是定义在 XML 中的。Mybatis 3 以后，支持注解配置。注解配置基于配置 API；而配置 API 基于 XML 配置。</p>
<p>Mybatis 支持诸如 <code>@Insert</code>、<code>@Update</code>、<code>@Delete</code>、<code>@Select</code>、<code>@Result</code> 等注解。</p>
<blockquote>
<p>详细内容请参考：<a target="_blank" rel="noopener" href="http://www.mybatis.org/Mybatis-3/zh/java-api.html#sqlSessions">Mybatis 官方文档之 sqlSessions</a>，其中列举了 Mybatis 支持的注解清单，以及基本用法。</p>
</blockquote>
<h2 id="Mybatis-的架构"><a href="#Mybatis-的架构" class="headerlink" title="Mybatis 的架构"></a>Mybatis 的架构</h2><p>从 Mybatis 代码实现的角度来看，Mybatis 的主要组件有以下几个：</p>
<ul>
<li><strong>SqlSession</strong> - 作为 Mybatis 工作的主要顶层 API，表示和数据库交互的会话，完成必要数据库增删改查功能。</li>
<li><strong>Executor</strong> - Mybatis 执行器，是 Mybatis 调度的核心，负责 SQL 语句的生成和查询缓存的维护。</li>
<li><strong>StatementHandler</strong> - 封装了 JDBC Statement 操作，负责对 JDBC statement 的操作，如设置参数、将 Statement 结果集转换成 List 集合。</li>
<li><strong>ParameterHandler</strong> - 负责对用户传递的参数转换成 JDBC Statement 所需要的参数。</li>
<li><strong>ResultSetHandler</strong> - 负责将 JDBC 返回的 ResultSet 结果集对象转换成 List 类型的集合。</li>
<li><strong>TypeHandler</strong> - 负责 java 数据类型和 jdbc 数据类型之间的映射和转换。</li>
<li><strong>MappedStatement</strong> - <code>MappedStatement</code> 维护了一条 <code>&lt;select|update|delete|insert&gt;</code> 节点的封装。</li>
<li><strong>SqlSource</strong> - 负责根据用户传递的 parameterObject，动态地生成 SQL 语句，将信息封装到 BoundSql 对象中，并返回。</li>
<li><strong>BoundSql</strong> - 表示动态生成的 SQL 语句以及相应的参数信息。</li>
<li><strong>Configuration</strong> - Mybatis 所有的配置信息都维持在 Configuration 对象之中。</li>
</ul>
<p>这些组件的架构层次如下：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20210512114852.png" alt="img"></p>
<h3 id="配置层"><a href="#配置层" class="headerlink" title="配置层"></a>配置层</h3><p>配置层决定了 Mybatis 的工作方式。</p>
<p>Mybatis 提供了两种配置方式：</p>
<ul>
<li>基于 XML 配置文件的方式</li>
<li>基于 Java API 的方式</li>
</ul>
<p><code>SqlSessionFactoryBuilder</code> 会根据配置创建 <code>SqlSessionFactory</code> ；</p>
<p><code>SqlSessionFactory</code> 负责创建 <code>SqlSessions</code> 。</p>
<h3 id="接口层"><a href="#接口层" class="headerlink" title="接口层"></a>接口层</h3><p>接口层负责和数据库交互的方式。</p>
<p>Mybatis 和数据库的交互有两种方式：</p>
<ul>
<li><strong>使用 SqlSession</strong>：SqlSession 封装了所有执行语句，获取映射器和管理事务的方法。<ul>
<li>用户只需要传入 Statement Id 和查询参数给 SqlSession 对象，就可以很方便的和数据库进行交互。</li>
<li>这种方式的缺点是不符合面向对象编程的范式。</li>
</ul>
</li>
<li><strong>使用 Mapper 接口</strong>：Mybatis 会根据相应的接口声明的方法信息，通过动态代理机制生成一个 Mapper 实例；Mybatis 会根据这个方法的方法名和参数类型，确定 Statement Id，然后和 SqlSession 进行映射，底层还是通过 SqlSession 完成和数据库的交互。</li>
</ul>
<h3 id="数据处理层"><a href="#数据处理层" class="headerlink" title="数据处理层"></a>数据处理层</h3><p>数据处理层可以说是 Mybatis 的核心，从大的方面上讲，它要完成两个功能：</p>
<ul>
<li>根据传参 <code>Statement</code> 和参数构建动态 SQL 语句<ul>
<li>动态语句生成可以说是 Mybatis 框架非常优雅的一个设计，Mybatis 通过传入的参数值，<strong>使用 Ognl 来动态地构造 SQL 语句</strong>，使得 Mybatis 有很强的灵活性和扩展性。</li>
<li>参数映射指的是对于 java 数据类型和 jdbc 数据类型之间的转换：这里有包括两个过程：查询阶段，我们要将 java 类型的数据，转换成 jdbc 类型的数据，通过 <code>preparedStatement.setXXX()</code> 来设值；另一个就是对 resultset 查询结果集的 jdbcType 数据转换成 java 数据类型。</li>
</ul>
</li>
<li>执行 SQL 语句以及处理响应结果集 ResultSet<ul>
<li>动态 SQL 语句生成之后，Mybatis 将执行 SQL 语句，并将可能返回的结果集转换成 <code>List&lt;E&gt;</code> 列表。</li>
<li>Mybatis 在对结果集的处理中，支持结果集关系一对多和多对一的转换，并且有两种支持方式，一种为嵌套查询语句的查询，还有一种是嵌套结果集的查询。</li>
</ul>
</li>
</ul>
<h3 id="框架支撑层"><a href="#框架支撑层" class="headerlink" title="框架支撑层"></a>框架支撑层</h3><ul>
<li><p><strong>事务管理机制</strong> - Mybatis 将事务抽象成了 Transaction 接口。Mybatis 的事务管理分为两种形式：</p>
<ul>
<li>使用 JDBC 的事务管理机制：即利用 <code>java.sql.Connection</code> 对象完成对事务的提交（<code>commit</code>）、回滚（<code>rollback</code>）、关闭（<code>close</code>）等。</li>
<li>使用 MANAGED 的事务管理机制：Mybatis 自身不会去实现事务管理，而是让程序的容器如（JBOSS，Weblogic）来实现对事务的管理。</li>
</ul>
</li>
<li><p><strong>连接池管理</strong></p>
</li>
<li><p><strong>SQL 语句的配置</strong> - 支持两种方式：</p>
<ul>
<li>xml 配置</li>
<li>注解配置</li>
</ul>
</li>
<li><p>缓存机制 - Mybatis 采用两级缓存结构</p>
<ul>
<li><strong>一级缓存是 Session 会话级别的缓存</strong> - 一级缓存又被称之为本地缓存。一般而言，一个 <code>SqlSession</code> 对象会使用一个 <code>Executor</code> 对象来完成会话操作，<code>Executor</code> 对象会维护一个 Cache 缓存，以提高查询性能。<ul>
<li>一级缓存的生命周期是 Session 会话级别的。</li>
</ul>
</li>
<li><strong>二级缓存是 Application 应用级别的缓存</strong> - 用户配置了 <code>&quot;cacheEnabled=true&quot;</code>，才会开启二级缓存。<ul>
<li>如果开启了二级缓存，<code>SqlSession</code> 会先使用 <code>CachingExecutor</code> 对象来处理查询请求。<code>CachingExecutor</code> 会在二级缓存中查看是否有匹配的数据，如果匹配，则直接返回缓存结果；如果缓存中没有，再交给真正的 <code>Executor</code> 对象来完成查询，之后 <code>CachingExecutor</code> 会将真正 <code>Executor</code> 返回的查询结果放置到缓存中，然后在返回给用户。</li>
<li>二级缓存的生命周期是应用级别的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20210512185709.png" alt="img"></p>
<h2 id="SqlSession-内部工作机制"><a href="#SqlSession-内部工作机制" class="headerlink" title="SqlSession 内部工作机制"></a>SqlSession 内部工作机制</h2><p>从前文，我们已经了解了，Mybatis 封装了对数据库的访问，把对数据库的会话和事务控制放到了 SqlSession 对象中。那么具体是如何工作的呢？接下来，我们通过源码解读来进行分析。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20210512173437.png" alt="img"></p>
<p><code>SqlSession</code> 对于 insert、update、delete、select 的内部处理机制基本上大同小异。所以，接下来，我会以一次完整的 select 查询流程为例讲解 <code>SqlSession</code> 内部的工作机制。相信读者如果理解了 select 的处理流程，对于其他 CRUD 操作也能做到一通百通。</p>
<h3 id="SqlSession-子组件"><a href="#SqlSession-子组件" class="headerlink" title="SqlSession 子组件"></a>SqlSession 子组件</h3><p>前面的内容已经介绍了：SqlSession 是 Mybatis 的顶层接口，它提供了所有执行语句，获取映射器和管理事务等方法。</p>
<p>实际上，SqlSession 是通过聚合多个子组件，让每个子组件负责各自功能的方式，实现了任务的下发。</p>
<p>在了解各个子组件工作机制前，先让我们简单认识一下 SqlSession 的核心子组件。</p>
<h4 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h4><p>Executor 即执行器，它负责生成动态 SQL 以及管理缓存。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20210512150000.png" alt="img"></p>
<ul>
<li><code>Executor</code> 即执行器接口。</li>
<li><code>BaseExecutor</code> 是 <code>Executor</code> 的抽象类，它采用了模板方法设计模式，内置了一些共性方法，而将定制化方法留给子类去实现。</li>
<li><code>SimpleExecutor</code> 是最简单的执行器。它只会直接执行 SQL，不会做额外的事。</li>
<li><code>BatchExecutor</code> 是批处理执行器。它的作用是通过批处理来优化性能。值得注意的是，批量更新操作，由于内部有缓存机制，使用完后需要调用 <code>flushStatements</code> 来清除缓存。</li>
<li><code>ReuseExecutor</code> 是可重用的执行器。重用的对象是 <code>Statement</code>，也就是说，该执行器会缓存同一个 SQL 的 <code>Statement</code>，避免重复创建 <code>Statement</code>。其内部的实现是通过一个 <code>HashMap</code> 来维护 <code>Statement</code> 对象的。由于当前 <code>Map</code> 只在该 session 中有效，所以使用完后需要调用 <code>flushStatements</code> 来清除 Map。</li>
<li><code>CachingExecutor</code> 是缓存执行器。它只在启用二级缓存时才会用到。</li>
</ul>
<h4 id="StatementHandler"><a href="#StatementHandler" class="headerlink" title="StatementHandler"></a>StatementHandler</h4><p><code>StatementHandler</code> 对象负责设置 <code>Statement</code> 对象中的查询参数、处理 JDBC 返回的 resultSet，将 resultSet 加工为 List 集合返回。</p>
<p><code>StatementHandler</code> 的家族成员：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20210512160243.png" alt="img"></p>
<ul>
<li><code>StatementHandler</code> 是接口；</li>
<li><code>BaseStatementHandler</code> 是实现 <code>StatementHandler</code> 的抽象类，内置一些共性方法；</li>
<li><code>SimpleStatementHandler</code> 负责处理 <code>Statement</code>；</li>
<li><code>PreparedStatementHandler</code> 负责处理 <code>PreparedStatement</code>；</li>
<li><code>CallableStatementHandler</code> 负责处理 <code>CallableStatement</code>。</li>
<li><code>RoutingStatementHandler</code> 负责代理 <code>StatementHandler</code> 具体子类，根据 <code>Statement</code> 类型，选择实例化 <code>SimpleStatementHandler</code>、<code>PreparedStatementHandler</code>、<code>CallableStatementHandler</code>。</li>
</ul>
<h4 id="ParameterHandler"><a href="#ParameterHandler" class="headerlink" title="ParameterHandler"></a>ParameterHandler</h4><p><code>ParameterHandler</code> 负责将传入的 Java 对象转换 JDBC 类型对象，并为 <code>PreparedStatement</code> 的动态 SQL 填充数值。</p>
<p><code>ParameterHandler</code> 只有一个具体实现类，即 <code>DefaultParameterHandler</code>。</p>
<h4 id="ResultSetHandler"><a href="#ResultSetHandler" class="headerlink" title="ResultSetHandler"></a>ResultSetHandler</h4><p><code>ResultSetHandler</code> 负责两件事：</p>
<ul>
<li>处理 <code>Statement</code> 执行后产生的结果集，生成结果列表</li>
<li>处理存储过程执行后的输出参数</li>
</ul>
<p><code>ResultSetHandler</code> 只有一个具体实现类，即 <code>DefaultResultSetHandler</code>。</p>
<h4 id="TypeHandler"><a href="#TypeHandler" class="headerlink" title="TypeHandler"></a>TypeHandler</h4><p>TypeHandler 负责将 Java 对象类型和 JDBC 类型进行相互转换。</p>
<h3 id="SqlSession-和-Mapper"><a href="#SqlSession-和-Mapper" class="headerlink" title="SqlSession 和 Mapper"></a>SqlSession 和 Mapper</h3><p>先来回忆一下 Mybatis 完整示例章节的 测试程序部分的代码。</p>
<p>MybatisDemo.java 文件中的代码片段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 创建一个 SqlSession 实例，进行数据库操作</span></span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> factory.openSession();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Mapper 映射并执行</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">params</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">List&lt;User&gt; list = sqlSession.selectList(<span class="string">&quot;io.github.dunwu.spring.orm.mapper.UserMapper.selectByPrimaryKey&quot;</span>, params);</span><br><span class="line"><span class="keyword">for</span> (User user : list) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;user name: &quot;</span> + user.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码中，给 sqlSession 对象的传递一个配置的 Sql 语句的 Statement Id 和参数，然后返回结果</p>
<p><code>io.github.dunwu.spring.orm.mapper.UserMapper.selectByPrimaryKey</code> 是配置在 <code>UserMapper.xml</code> 的 Statement ID，params 是 SQL 参数。</p>
<p>UserMapper.xml 文件中的代码片段：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByPrimaryKey&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Long&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="line">  select id, name, age, address, email</span><br><span class="line">  from user</span><br><span class="line">  where id = #&#123;id,jdbcType=BIGINT&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Mybatis 通过方法的全限定名，将 SqlSession 和 Mapper 相互映射起来。</p>
<h3 id="SqlSession-和-Executor"><a href="#SqlSession-和-Executor" class="headerlink" title="SqlSession 和 Executor"></a>SqlSession 和 Executor</h3><p><code>org.apache.ibatis.session.defaults.DefaultSqlSession</code> 中 <code>selectList</code> 方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">selectList</span><span class="params">(String statement)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.selectList(statement, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">selectList</span><span class="params">(String statement, Object parameter)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.selectList(statement, parameter, RowBounds.DEFAULT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 根据 Statement Id，在配置对象 Configuration 中查找和配置文件相对应的 MappedStatement</span></span><br><span class="line">    <span class="type">MappedStatement</span> <span class="variable">ms</span> <span class="operator">=</span> configuration.getMappedStatement(statement);</span><br><span class="line">    <span class="comment">// 2. 将 SQL 语句交由执行器 Executor 处理</span></span><br><span class="line">    <span class="keyword">return</span> executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error querying database.  Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>Mybatis 所有的配置信息都维持在 <code>Configuration</code> 对象之中。中维护了一个 <code>Map&lt;String, MappedStatement&gt;</code> 对象。其中，key 为 Mapper 方法的全限定名（对于本例而言，key 就是 <code>io.github.dunwu.spring.orm.mapper.UserMapper.selectByPrimaryKey</code> ），value 为 <code>MappedStatement</code> 对象。所以，传入 Statement Id 就可以从 Map 中找到对应的 <code>MappedStatement</code>。</p>
<p><code>MappedStatement</code> 维护了一个 Mapper 方法的元数据信息，其数据组织可以参考下面的 debug 截图：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20210511150650.png" alt="img"></p>
<blockquote>
<p>小结：</p>
<p>通过 “SqlSession 和 Mapper” 以及 “SqlSession 和 Executor” 这两节，我们已经知道：</p>
<p>SqlSession 的职能是：根据 Statement ID, 在 <code>Configuration</code> 中获取到对应的 <code>MappedStatement</code> 对象，然后调用 <code>Executor</code> 来执行具体的操作。</p>
</blockquote>
<h3 id="Executor-工作流程"><a href="#Executor-工作流程" class="headerlink" title="Executor 工作流程"></a>Executor 工作流程</h3><p>继续上一节的流程，<code>SqlSession</code> 将 SQL 语句交由执行器 <code>Executor</code> 处理。<code>Executor</code> 又做了哪些事儿呢？</p>
<p>（1）执行器查询入口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">	<span class="comment">// 1. 根据传参，动态生成需要执行的 SQL 语句，用 BoundSql 对象表示</span></span><br><span class="line">    <span class="type">BoundSql</span> <span class="variable">boundSql</span> <span class="operator">=</span> ms.getBoundSql(parameter);</span><br><span class="line">    <span class="comment">// 2. 根据传参，创建一个缓存Key</span></span><br><span class="line">    <span class="type">CacheKey</span> <span class="variable">key</span> <span class="operator">=</span> createCacheKey(ms, parameter, rowBounds, boundSql);</span><br><span class="line">    <span class="keyword">return</span> query(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>执行器查询入口主要做两件事：</p>
<ul>
<li><strong>生成动态 SQL</strong>：根据传参，动态生成需要执行的 SQL 语句，用 BoundSql 对象表示。</li>
<li><strong>管理缓存</strong>：根据传参，创建一个缓存 Key。</li>
</ul>
<p>（2）执行器查询第二入口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="comment">// 略</span></span><br><span class="line">  List&lt;E&gt; list;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    queryStack++;</span><br><span class="line">    list = resultHandler == <span class="literal">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 3. 缓存中有值，则直接从缓存中取数据；否则，查询数据库</span></span><br><span class="line">    <span class="keyword">if</span> (list != <span class="literal">null</span>) &#123;</span><br><span class="line">      handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    queryStack--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 略</span></span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际查询方法主要的职能是判断缓存 key 是否能命中缓存：</p>
<ul>
<li>命中，则将缓存中数据返回；</li>
<li>不命中，则查询数据库：</li>
</ul>
<p>（3）查询数据库</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">queryFromDatabase</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  List&lt;E&gt; list;</span><br><span class="line">  localCache.putObject(key, EXECUTION_PLACEHOLDER);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 4. 执行查询，获取 List 结果，并将查询的结果更新本地缓存中</span></span><br><span class="line">    list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    localCache.removeObject(key);</span><br><span class="line">  &#125;</span><br><span class="line">  localCache.putObject(key, list);</span><br><span class="line">  <span class="keyword">if</span> (ms.getStatementType() == StatementType.CALLABLE) &#123;</span><br><span class="line">    localOutputParameterCache.putObject(key, parameter);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>queryFromDatabase</code> 方法的职责是调用 doQuery，向数据库发起查询，并将返回的结果更新到本地缓存。</p>
<p>（4）实际查询方法</p>
<p>SimpleExecutor 类的 doQuery()方法实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> ms.getConfiguration();</span><br><span class="line">    <span class="comment">// 5. 根据既有的参数，创建StatementHandler对象来执行查询操作</span></span><br><span class="line">    <span class="type">StatementHandler</span> <span class="variable">handler</span> <span class="operator">=</span> configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    <span class="comment">// 6. 创建java.Sql.Statement对象，传递给StatementHandler对象</span></span><br><span class="line">    stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">    <span class="comment">// 7. 调用StatementHandler.query()方法，返回List结果</span></span><br><span class="line">    <span class="keyword">return</span> handler.query(stmt, resultHandler);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    closeStatement(stmt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的 Executor.query()方法几经转折，最后会创建一个 <code>StatementHandler</code> 对象，然后将必要的参数传递给 <code>StatementHandler</code>，使用 <code>StatementHandler</code> 来完成对数据库的查询，最终返回 List 结果集。<br>从上面的代码中我们可以看出，<code>Executor</code> 的功能和作用是：</p>
<ol>
<li><p>根据传递的参数，完成 SQL 语句的动态解析，生成 BoundSql 对象，供 <code>StatementHandler</code> 使用；</p>
</li>
<li><p>为查询创建缓存，以提高性能</p>
</li>
<li><p>创建 JDBC 的 <code>Statement</code> 连接对象，传递给 <code>StatementHandler</code> 对象，返回 List 查询结果。</p>
</li>
</ol>
<p>prepareStatement() 方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Statement <span class="title function_">prepareStatement</span><span class="params">(StatementHandler handler, Log statementLog)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  Statement stmt;</span><br><span class="line">  <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> getConnection(statementLog);</span><br><span class="line">  stmt = handler.prepare(connection, transaction.getTimeout());</span><br><span class="line">  <span class="comment">//对创建的Statement对象设置参数，即设置SQL 语句中 ? 设置为指定的参数</span></span><br><span class="line">  handler.parameterize(stmt);</span><br><span class="line">  <span class="keyword">return</span> stmt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 JDBC 的 <code>PreparedStatement</code> 类型的对象，创建的过程中，我们使用的是 SQL 语句字符串会包含 若干个? 占位符，我们其后再对占位符进行设值。</p>
<h3 id="StatementHandler-工作流程"><a href="#StatementHandler-工作流程" class="headerlink" title="StatementHandler 工作流程"></a>StatementHandler 工作流程</h3><p><code>StatementHandler</code> 有一个子类 <code>RoutingStatementHandler</code>，它负责代理其他 <code>StatementHandler</code> 子类的工作。</p>
<p>它会根据配置的 <code>Statement</code> 类型，选择实例化相应的 <code>StatementHandler</code>，然后由其代理对象完成工作。</p>
<p>【源码】RoutingStatementHandler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">RoutingStatementHandler</span><span class="params">(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (ms.getStatementType()) &#123;</span><br><span class="line">    <span class="keyword">case</span> STATEMENT:</span><br><span class="line">      delegate = <span class="keyword">new</span> <span class="title class_">SimpleStatementHandler</span>(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> PREPARED:</span><br><span class="line">      delegate = <span class="keyword">new</span> <span class="title class_">PreparedStatementHandler</span>(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CALLABLE:</span><br><span class="line">      delegate = <span class="keyword">new</span> <span class="title class_">CallableStatementHandler</span>(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutorException</span>(<span class="string">&quot;Unknown statement type: &quot;</span> + ms.getStatementType());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【源码】<code>RoutingStatementHandler</code> 的 <code>parameterize</code> 方法源码</p>
<p>【源码】<code>PreparedStatementHandler</code> 的 <code>parameterize</code> 方法源码</p>
<p><code>StatementHandler</code> 使用 <code>ParameterHandler</code> 对象来完成对 <code>Statement</code> 的赋值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parameterize</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="comment">// 使用 ParameterHandler 对象来完成对 Statement 的设值</span></span><br><span class="line">  parameterHandler.setParameters((PreparedStatement) statement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【源码】<code>StatementHandler</code> 的 <code>query</code> 方法源码</p>
<p><code>StatementHandler</code> 使用 <code>ResultSetHandler</code> 对象来完成对 <code>ResultSet</code> 的处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> (PreparedStatement) statement;</span><br><span class="line">  ps.execute();</span><br><span class="line">  <span class="comment">// 使用ResultHandler来处理ResultSet</span></span><br><span class="line">  <span class="keyword">return</span> resultSetHandler.handleResultSets(ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ParameterHandler-工作流程"><a href="#ParameterHandler-工作流程" class="headerlink" title="ParameterHandler 工作流程"></a>ParameterHandler 工作流程</h3><p>【源码】<code>DefaultParameterHandler</code> 的 <code>setParameters</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setParameters</span><span class="params">(PreparedStatement ps)</span> &#123;</span><br><span class="line"><span class="comment">// parameterMappings 是对占位符 #&#123;&#125; 对应参数的封装</span></span><br><span class="line">   List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">   <span class="keyword">if</span> (parameterMappings != <span class="literal">null</span>) &#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameterMappings.size(); i++) &#123;</span><br><span class="line">       <span class="type">ParameterMapping</span> <span class="variable">parameterMapping</span> <span class="operator">=</span> parameterMappings.get(i);</span><br><span class="line">       <span class="comment">// 不处理存储过程中的参数</span></span><br><span class="line">       <span class="keyword">if</span> (parameterMapping.getMode() != ParameterMode.OUT) &#123;</span><br><span class="line">         Object value;</span><br><span class="line">         <span class="type">String</span> <span class="variable">propertyName</span> <span class="operator">=</span> parameterMapping.getProperty();</span><br><span class="line">         <span class="keyword">if</span> (boundSql.hasAdditionalParameter(propertyName)) &#123; <span class="comment">// issue #448 ask first for additional params</span></span><br><span class="line">           <span class="comment">// 获取对应的实际数值</span></span><br><span class="line">           value = boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterObject == <span class="literal">null</span>) &#123;</span><br><span class="line">           value = <span class="literal">null</span>;</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">           value = parameterObject;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 获取对象中相应的属性或查找 Map 对象中的值</span></span><br><span class="line">           <span class="type">MetaObject</span> <span class="variable">metaObject</span> <span class="operator">=</span> configuration.newMetaObject(parameterObject);</span><br><span class="line">           value = metaObject.getValue(propertyName);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="type">TypeHandler</span> <span class="variable">typeHandler</span> <span class="operator">=</span> parameterMapping.getTypeHandler();</span><br><span class="line">         <span class="type">JdbcType</span> <span class="variable">jdbcType</span> <span class="operator">=</span> parameterMapping.getJdbcType();</span><br><span class="line">         <span class="keyword">if</span> (value == <span class="literal">null</span> &amp;&amp; jdbcType == <span class="literal">null</span>) &#123;</span><br><span class="line">           jdbcType = configuration.getJdbcTypeForNull();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 通过 TypeHandler 将 Java 对象参数转为 JDBC 类型的参数</span></span><br><span class="line">           <span class="comment">// 然后，将数值动态绑定到 PreparedStaement 中</span></span><br><span class="line">           typeHandler.setParameter(ps, i + <span class="number">1</span>, value, jdbcType);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (TypeException | SQLException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeException</span>(<span class="string">&quot;Could not set parameters for mapping: &quot;</span> + parameterMapping + <span class="string">&quot;. Cause: &quot;</span> + e, e);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="ResultSetHandler-工作流程"><a href="#ResultSetHandler-工作流程" class="headerlink" title="ResultSetHandler 工作流程"></a>ResultSetHandler 工作流程</h3><p><code>ResultSetHandler</code> 的实现可以概括为：将 <code>Statement</code> 执行后的结果集，按照 <code>Mapper</code> 文件中配置的 <code>ResultType</code> 或 <code>ResultMap</code> 来转换成对应的 JavaBean 对象，最后将结果返回。</p>
<p>【源码】<code>DefaultResultSetHandler</code> 的 <code>handleResultSets</code> 方法</p>
<p><code>handleResultSets</code> 方法是 <code>DefaultResultSetHandler</code> 的最关键方法。其实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">handleResultSets</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  ErrorContext.instance().activity(<span class="string">&quot;handling results&quot;</span>).object(mappedStatement.getId());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> List&lt;Object&gt; multipleResults = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="variable">resultSetCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 第一个结果集</span></span><br><span class="line">  <span class="type">ResultSetWrapper</span> <span class="variable">rsw</span> <span class="operator">=</span> getFirstResultSet(stmt);</span><br><span class="line">  List&lt;ResultMap&gt; resultMaps = mappedStatement.getResultMaps();</span><br><span class="line">  <span class="comment">// 判断结果集的数量</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">resultMapCount</span> <span class="operator">=</span> resultMaps.size();</span><br><span class="line">  validateResultMapsCount(rsw, resultMapCount);</span><br><span class="line">  <span class="comment">// 遍历处理结果集</span></span><br><span class="line">  <span class="keyword">while</span> (rsw != <span class="literal">null</span> &amp;&amp; resultMapCount &gt; resultSetCount) &#123;</span><br><span class="line">    <span class="type">ResultMap</span> <span class="variable">resultMap</span> <span class="operator">=</span> resultMaps.get(resultSetCount);</span><br><span class="line">    handleResultSet(rsw, resultMap, multipleResults, <span class="literal">null</span>);</span><br><span class="line">    rsw = getNextResultSet(stmt);</span><br><span class="line">    cleanUpAfterHandlingResultSet();</span><br><span class="line">    resultSetCount++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  String[] resultSets = mappedStatement.getResultSets();</span><br><span class="line">  <span class="keyword">if</span> (resultSets != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (rsw != <span class="literal">null</span> &amp;&amp; resultSetCount &lt; resultSets.length) &#123;</span><br><span class="line">      <span class="type">ResultMapping</span> <span class="variable">parentMapping</span> <span class="operator">=</span> nextResultMaps.get(resultSets[resultSetCount]);</span><br><span class="line">      <span class="keyword">if</span> (parentMapping != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">nestedResultMapId</span> <span class="operator">=</span> parentMapping.getNestedResultMapId();</span><br><span class="line">        <span class="type">ResultMap</span> <span class="variable">resultMap</span> <span class="operator">=</span> configuration.getResultMap(nestedResultMapId);</span><br><span class="line">        handleResultSet(rsw, resultMap, <span class="literal">null</span>, parentMapping);</span><br><span class="line">      &#125;</span><br><span class="line">      rsw = getNextResultSet(stmt);</span><br><span class="line">      cleanUpAfterHandlingResultSet();</span><br><span class="line">      resultSetCount++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> collapseSingleResultList(multipleResults);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><strong>官方</strong><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/Mybatis/Mybatis-3">Mybatis Github</a></li>
<li><a target="_blank" rel="noopener" href="http://www.mybatis.org/Mybatis-3/">Mybatis 官网</a></li>
</ul>
</li>
<li><strong>文章</strong><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/luanlouis/article/details/40422941">深入理解 Mybatis 原理</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/tuguangquan/Mybatis">Mybatis 源码中文注释</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5cee8b61e51d455d88219ea4">Mybatis 中强大的 resultMap</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/10bd70/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/10bd70/" class="post-title-link" itemprop="url">Netty 快速入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-17 22:34:30" itemprop="dateCreated datePublished" datetime="2022-02-17T22:34:30+08:00">2022-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E6%A1%86%E6%9E%B6/IO/" itemprop="url" rel="index"><span itemprop="name">IO</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Netty-快速入门"><a href="#Netty-快速入门" class="headerlink" title="Netty 快速入门"></a>Netty 快速入门</h1><h2 id="Netty-简介"><a href="#Netty-简介" class="headerlink" title="Netty 简介"></a>Netty 简介</h2><blockquote>
<p><strong>Netty 是一款基于 NIO（Nonblocking I&#x2F;O，非阻塞 IO）开发的网络通信框架</strong>。</p>
</blockquote>
<h3 id="Netty-的特性"><a href="#Netty-的特性" class="headerlink" title="Netty 的特性"></a>Netty 的特性</h3><ul>
<li><strong>高并发</strong>：Netty 是一款<strong>基于 NIO</strong>（Nonblocking IO，非阻塞 IO）开发的网络通信框架，对比于 BIO（Blocking I&#x2F;O，阻塞 IO），他的并发性能得到了很大提高。</li>
<li><strong>传输快</strong>：Netty 的传输依赖于<strong>内存零拷贝</strong>特性，尽量减少不必要的内存拷贝，实现了更高效率的传输。</li>
<li><strong>封装好</strong>：Netty <strong>封装了 NIO 操作</strong>的很多细节，提供了易于使用调用接口。</li>
</ul>
<h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><ul>
<li><code>Channel</code>：Netty 网络操作抽象类，它除了包括基本的 I&#x2F;O 操作，如 bind、connect、read、write 等。</li>
<li><code>EventLoop</code>：主要是配合 Channel 处理 I&#x2F;O 操作，用来处理连接的生命周期中所发生的事情。</li>
<li><code>ChannelFuture</code>：Netty 框架中所有的 I&#x2F;O 操作都为异步的，因此我们需要 ChannelFuture 的 addListener()注册一个 ChannelFutureListener 监听事件，当操作执行成功或者失败时，监听就会自动触发返回结果。</li>
<li><code>ChannelHandler</code>：充当了所有处理入站和出站数据的逻辑容器。ChannelHandler 主要用来处理各种事件，这里的事件很广泛，比如可以是连接、数据接收、异常、数据转换等。</li>
<li><code>ChannelPipeline</code>：为 ChannelHandler 链提供了容器，当 channel 创建时，就会被自动分配到它专属的 ChannelPipeline，这个关联是永久性的。</li>
</ul>
<p>Netty 有两种发送消息的方式：</p>
<ul>
<li>直接写入 Channel 中，消息从 ChannelPipeline 当中尾部开始移动；</li>
<li>写入和 ChannelHandler 绑定的 ChannelHandlerContext 中，消息从 ChannelPipeline 中的下一个 ChannelHandler 中移动。</li>
</ul>
<h2 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h2><p>Netty 高性能表现在哪些方面：</p>
<ul>
<li><strong>NIO 线程模型</strong>：同步非阻塞，用最少的资源做更多的事。</li>
<li><strong>内存零拷贝</strong>：尽量减少不必要的内存拷贝，实现了更高效率的传输。</li>
<li><strong>内存池设计</strong>：申请的内存可以重用，主要指直接内存。内部实现是用一颗二叉查找树管理内存分配情况。</li>
<li><strong>串形化处理读写</strong>：避免使用锁带来的性能开销。</li>
<li><strong>高性能序列化协议</strong>：支持 protobuf 等高性能序列化协议。</li>
</ul>
<h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><h3 id="传统意义的拷贝"><a href="#传统意义的拷贝" class="headerlink" title="传统意义的拷贝"></a>传统意义的拷贝</h3><p>是在发送数据的时候，传统的实现方式是：</p>
<p><code>File.read(bytes)</code></p>
<p><code>Socket.send(bytes)</code></p>
<p>这种方式需要四次数据拷贝和四次上下文切换：</p>
<ol>
<li><p>数据从磁盘读取到内核的 read buffer</p>
</li>
<li><p>数据从内核缓冲区拷贝到用户缓冲区</p>
</li>
<li><p>数据从用户缓冲区拷贝到内核的 socket buffer</p>
</li>
<li><p>数据从内核的 socket buffer 拷贝到网卡接口（硬件）的缓冲区</p>
</li>
</ol>
<h3 id="零拷贝的概念"><a href="#零拷贝的概念" class="headerlink" title="零拷贝的概念"></a>零拷贝的概念</h3><p>明显上面的第二步和第三步是非必要的，通过 java 的 FileChannel.transferTo 方法，可以避免上面两次多余的拷贝（当然这需要底层操作系统支持）</p>
<ul>
<li>调用 transferTo，数据从文件由 DMA 引擎拷贝到内核 read buffer</li>
<li>接着 DMA 从内核 read buffer 将数据拷贝到网卡接口 buffer</li>
</ul>
<p>上面的两次操作都不需要 CPU 参与，所以就达到了零拷贝。</p>
<h3 id="Netty-中的零拷贝"><a href="#Netty-中的零拷贝" class="headerlink" title="Netty 中的零拷贝"></a>Netty 中的零拷贝</h3><p>主要体现在三个方面：</p>
<p><strong>bytebuffer</strong></p>
<p>Netty 发送和接收消息主要使用 bytebuffer，bytebuffer 使用对外内存（DirectMemory）直接进行 Socket 读写。</p>
<p>原因：如果使用传统的堆内存进行 Socket 读写，JVM 会将堆内存 buffer 拷贝一份到直接内存中然后再写入 socket，多了一次缓冲区的内存拷贝。DirectMemory 中可以直接通过 DMA 发送到网卡接口</p>
<p><strong>Composite Buffers</strong></p>
<p>传统的 ByteBuffer，如果需要将两个 ByteBuffer 中的数据组合到一起，我们需要首先创建一个 size&#x3D;size1+size2 大小的新的数组，然后将两个数组中的数据拷贝到新的数组中。但是使用 Netty 提供的组合 ByteBuf，就可以避免这样的操作，因为 CompositeByteBuf 并没有真正将多个 Buffer 组合起来，而是保存了它们的引用，从而避免了数据的拷贝，实现了零拷贝。</p>
<p><strong>对于 FileChannel.transferTo 的使用</strong></p>
<p>Netty 中使用了 FileChannel 的 transferTo 方法，该方法依赖于操作系统实现零拷贝。</p>
<h2 id="Netty-流程"><a href="#Netty-流程" class="headerlink" title="Netty 流程"></a>Netty 流程</h2><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><blockquote>
<p>Netty 是一个广泛使用的 Java 网络编程框架。很多著名软件都使用了它，如：Dubbo、Cassandra、Elasticsearch、Vert.x 等。</p>
</blockquote>
<p>有了 Netty，你可以实现自己的 HTTP 服务器，FTP 服务器，UDP 服务器，RPC 服务器，WebSocket 服务器，Redis 的 Proxy 服务器，MySQL 的 Proxy 服务器等等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyOioServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">server</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> Unpooled.unreleasableBuffer(</span><br><span class="line">                Unpooled.copiedBuffer(<span class="string">&quot;Hi!\r\n&quot;</span>, Charset.forName(<span class="string">&quot;UTF-8&quot;</span>)));</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();        <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">            b.group(group)                                    <span class="comment">//2</span></span><br><span class="line">             .channel(OioServerSocketChannel.class)</span><br><span class="line">             .localAddress(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(port))</span><br><span class="line">             .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<span class="comment">//3</span></span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span></span><br><span class="line">                     <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                     ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;            <span class="comment">//4</span></span><br><span class="line">                         <span class="meta">@Override</span></span><br><span class="line">                         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                             ctx.writeAndFlush(buf.duplicate()).addListener(ChannelFutureListener.CLOSE);<span class="comment">//5</span></span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">f</span> <span class="operator">=</span> b.bind().sync();  <span class="comment">//6</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully().sync();        <span class="comment">//7</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><strong>官方</strong><ul>
<li><a target="_blank" rel="noopener" href="https://netty.io/">Netty 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/netty/netty">Netty Github</a></li>
</ul>
</li>
<li><strong>文章</strong><ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b9f3f6a16911">Netty 入门教程——认识 Netty</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5bdaf8ea6fb9a0227b02275a">彻底理解 Netty，这一篇文章就够了</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5c81b08f5188257a323f4cef">Java 200+ 面试题补充 ② Netty 模块</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/4a4c02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/4a4c02/" class="post-title-link" itemprop="url">Tomcat 快速入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-17 22:34:30" itemprop="dateCreated datePublished" datetime="2022-02-17T22:34:30+08:00">2022-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JavaEE/" itemprop="url" rel="index"><span itemprop="name">JavaEE</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JavaEE/%E6%9C%8D%E5%8A%A1%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">服务器</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JavaEE/%E6%9C%8D%E5%8A%A1%E5%99%A8/Tomcat/" itemprop="url" rel="index"><span itemprop="name">Tomcat</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>21k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>19 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Tomcat-快速入门"><a href="#Tomcat-快速入门" class="headerlink" title="Tomcat 快速入门"></a>Tomcat 快速入门</h1><blockquote>
<p>🎁 版本说明</p>
<p>当前最新版本：Tomcat 8.5.24</p>
<p>环境要求：JDK7+</p>
</blockquote>
<h2 id="1-Tomcat-简介"><a href="#1-Tomcat-简介" class="headerlink" title="1. Tomcat 简介"></a>1. Tomcat 简介</h2><h3 id="1-1-Tomcat-是什么"><a href="#1-1-Tomcat-是什么" class="headerlink" title="1.1. Tomcat 是什么"></a>1.1. Tomcat 是什么</h3><p>Tomcat 是由 Apache 开发的一个 Servlet 容器，实现了对 Servlet 和 JSP 的支持，并提供了作为 Web 服务器的一些特有功能，如 Tomcat 管理和控制平台、安全域管理和 Tomcat 阀等。</p>
<p>由于 Tomcat 本身也内含了一个 HTTP 服务器，它也可以被视作一个单独的 Web 服务器。但是，不能将 Tomcat 和 Apache HTTP 服务器混淆，Apache HTTP 服务器是一个用 C 语言实现的 HTTP Web 服务器；这两个 HTTP web server 不是捆绑在一起的。Tomcat 包含了一个配置管理工具，也可以通过编辑 XML 格式的配置文件来进行配置。</p>
<h3 id="1-2-Tomcat-重要目录"><a href="#1-2-Tomcat-重要目录" class="headerlink" title="1.2. Tomcat 重要目录"></a>1.2. Tomcat 重要目录</h3><ul>
<li><strong>&#x2F;bin</strong> - Tomcat 脚本存放目录（如启动、关闭脚本）。 <code>*.sh</code> 文件用于 Unix 系统； <code>*.bat</code> 文件用于 Windows 系统。</li>
<li><strong>&#x2F;conf</strong> - Tomcat 配置文件目录。</li>
<li><strong>&#x2F;logs</strong> - Tomcat 默认日志目录。</li>
<li><strong>&#x2F;webapps</strong> - webapp 运行的目录。</li>
</ul>
<h3 id="1-3-web-工程发布目录结构"><a href="#1-3-web-工程发布目录结构" class="headerlink" title="1.3. web 工程发布目录结构"></a>1.3. web 工程发布目录结构</h3><p>一般 web 项目路径结构</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">|<span class="string">-- webapp                         # 站点根目录</span></span><br><span class="line"><span class="string">    </span>|<span class="string">-- META-INF                   # META-INF 目录</span></span><br><span class="line"><span class="string">    </span>|<span class="string">   `-- MANIFEST.MF            # 配置清单文件</span></span><br><span class="line"><span class="string">    </span>|<span class="string">-- WEB-INF                    # WEB-INF 目录</span></span><br><span class="line"><span class="string">    </span>|<span class="string">   </span>|<span class="string">-- classes                # class文件目录</span></span><br><span class="line"><span class="string">    </span>|<span class="string">   </span>|<span class="string">   </span>|<span class="string">-- *.class            # 程序需要的 class 文件</span></span><br><span class="line"><span class="string">    </span>|<span class="string">   </span>|<span class="string">   `-- *.xml              # 程序需要的 xml 文件</span></span><br><span class="line"><span class="string">    </span>|<span class="string">   </span>|<span class="string">-- lib                    # 库文件夹</span></span><br><span class="line"><span class="string">    </span>|<span class="string">   </span>|<span class="string">   `-- *.jar              # 程序需要的 jar 包</span></span><br><span class="line"><span class="string">    </span>|<span class="string">   `-- web.xml                # Web应用程序的部署描述文件</span></span><br><span class="line"><span class="string">    </span>|<span class="string">-- &lt;userdir&gt;                  # 自定义的目录</span></span><br><span class="line"><span class="string">    </span>|<span class="string">-- &lt;userfiles&gt;                # 自定义的资源文件</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>webapp</code>：工程发布文件夹。其实每个 war 包都可以视为 webapp 的压缩包。</p>
</li>
<li><p><code>META-INF</code>：META-INF 目录用于存放工程自身相关的一些信息，元文件信息，通常由开发工具，环境自动生成。</p>
</li>
<li><p><code>WEB-INF</code>：Java web 应用的安全目录。所谓安全就是客户端无法访问，只有服务端可以访问的目录。</p>
</li>
<li><p><code>/WEB-INF/classes</code>：存放程序所需要的所有 Java class 文件。</p>
</li>
<li><p><code>/WEB-INF/lib</code>：存放程序所需要的所有 jar 文件。</p>
</li>
<li><p><code>/WEB-INF/web.xml</code>：web 应用的部署配置文件。它是工程中最重要的配置文件，它描述了 servlet 和组成应用的其它组件，以及应用初始化参数、安全管理约束等。</p>
</li>
</ul>
<h3 id="1-4-Tomcat-功能"><a href="#1-4-Tomcat-功能" class="headerlink" title="1.4. Tomcat 功能"></a>1.4. Tomcat 功能</h3><p>Tomcat 支持的 I&#x2F;O 模型有：</p>
<ul>
<li>NIO：非阻塞 I&#x2F;O，采用 Java NIO 类库实现。</li>
<li>NIO2：异步 I&#x2F;O，采用 JDK 7 最新的 NIO2 类库实现。</li>
<li>APR：采用 Apache 可移植运行库实现，是 C&#x2F;C++ 编写的本地库。</li>
</ul>
<p>Tomcat 支持的应用层协议有：</p>
<ul>
<li>HTTP&#x2F;1.1：这是大部分 Web 应用采用的访问协议。</li>
<li>AJP：用于和 Web 服务器集成（如 Apache）。</li>
<li>HTTP&#x2F;2：HTTP 2.0 大幅度的提升了 Web 性能。</li>
</ul>
<h2 id="2-Tomcat-入门"><a href="#2-Tomcat-入门" class="headerlink" title="2. Tomcat 入门"></a>2. Tomcat 入门</h2><h3 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1. 安装"></a>2.1. 安装</h3><p><strong>前提条件</strong></p>
<p>Tomcat 8.5 要求 JDK 版本为 1.7 以上。</p>
<p>进入 <a target="_blank" rel="noopener" href="https://tomcat.apache.org/download-80.cgi">Tomcat 官方下载地址</a> 选择合适版本下载，并解压到本地。</p>
<p><strong>Windows</strong></p>
<p>添加环境变量 <code>CATALINA_HOME</code> ，值为 Tomcat 的安装路径。</p>
<p>进入安装目录下的 bin 目录，运行 startup.bat 文件，启动 Tomcat</p>
<p><strong>Linux &#x2F; Unix</strong></p>
<p>下面的示例以 8.5.24 版本为例，包含了下载、解压、启动操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载解压到本地</span></span><br><span class="line">wget http://mirrors.hust.edu.cn/apache/tomcat/tomcat-8/v8.5.24/bin/apache-tomcat-8.5.24.tar.gz</span><br><span class="line">tar -zxf apache-tomcat-8.5.24.tar.gz</span><br><span class="line"><span class="comment"># 启动 Tomcat</span></span><br><span class="line">./apache-tomcat-8.5.24/bin/startup.sh</span><br></pre></td></tr></table></figure>

<p>启动后，访问 <code>http://localhost:8080</code> ，可以看到 Tomcat 安装成功的测试页面。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/tools/tomcat/tomcat.png" alt="img"></p>
<h3 id="2-2-配置"><a href="#2-2-配置" class="headerlink" title="2.2. 配置"></a>2.2. 配置</h3><p>本节将列举一些重要、常见的配置项。详细的 Tomcat8 配置可以参考 <a target="_blank" rel="noopener" href="http://tomcat.apache.org/tomcat-8.5-doc/config/index.html">Tomcat 8 配置官方参考文档</a> 。</p>
<h4 id="2-2-1-Server"><a href="#2-2-1-Server" class="headerlink" title="2.2.1. Server"></a>2.2.1. Server</h4><blockquote>
<p>Server 元素表示整个 Catalina servlet 容器。</p>
<p>因此，它必须是 <code>conf/server.xml</code> 配置文件中的根元素。它的属性代表了整个 servlet 容器的特性。</p>
</blockquote>
<p><strong>属性表</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>className</td>
<td>这个类必须实现 org.apache.catalina.Server 接口。</td>
<td>默认 org.apache.catalina.core.StandardServer</td>
</tr>
<tr>
<td>address</td>
<td>服务器等待关机命令的 TCP &#x2F; IP 地址。如果没有指定地址，则使用 localhost。</td>
<td></td>
</tr>
<tr>
<td>port</td>
<td>服务器等待关机命令的 TCP &#x2F; IP 端口号。设置为-1 以禁用关闭端口。</td>
<td></td>
</tr>
<tr>
<td>shutdown</td>
<td>必须通过 TCP &#x2F; IP 连接接收到指定端口号的命令字符串，以关闭 Tomcat。</td>
<td></td>
</tr>
</tbody></table>
<h4 id="2-2-2-Service"><a href="#2-2-2-Service" class="headerlink" title="2.2.2. Service"></a>2.2.2. Service</h4><blockquote>
<p>Service 元素表示一个或多个连接器组件的组合，这些组件共享一个用于处理传入请求的引擎组件。Server 中可以有多个 Service。</p>
</blockquote>
<p><strong>属性表</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>className</td>
<td>这个类必须实现<code>org.apache.catalina.Service</code>接口。</td>
<td>默认 <code>org.apache.catalina.core.StandardService</code></td>
</tr>
<tr>
<td>name</td>
<td>此服务的显示名称，如果您使用标准 Catalina 组件，将包含在日志消息中。与特定服务器关联的每个服务的名称必须是唯一的。</td>
<td></td>
</tr>
</tbody></table>
<p><strong>实例 - <code>conf/server.xml</code> 配置文件示例</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Server</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">shutdown</span>=<span class="string">&quot;SHUTDOWN&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Service</span> <span class="attr">name</span>=<span class="string">&quot;xxx&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Server</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-3-Executor"><a href="#2-2-3-Executor" class="headerlink" title="2.2.3. Executor"></a>2.2.3. Executor</h4><blockquote>
<p>Executor 表示可以在 Tomcat 中的组件之间共享的线程池。</p>
</blockquote>
<p><strong>属性表</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>className</td>
<td>这个类必须实现<code>org.apache.catalina.Executor</code>接口。</td>
<td>默认 <code>org.apache.catalina.core.StandardThreadExecutor</code></td>
</tr>
<tr>
<td>name</td>
<td>线程池名称。</td>
<td>要求唯一, 供 Connector 元素的 executor 属性使用</td>
</tr>
<tr>
<td>namePrefix</td>
<td>线程名称前缀。</td>
<td></td>
</tr>
<tr>
<td>maxThreads</td>
<td>最大活跃线程数。</td>
<td>默认 200</td>
</tr>
<tr>
<td>minSpareThreads</td>
<td>最小活跃线程数。</td>
<td>默认 25</td>
</tr>
<tr>
<td>maxIdleTime</td>
<td>当前活跃线程大于 minSpareThreads 时,空闲线程关闭的等待最大时间。</td>
<td>默认 60000ms</td>
</tr>
<tr>
<td>maxQueueSize</td>
<td>线程池满情况下的请求排队大小。</td>
<td>默认 Integer.MAX_VALUE</td>
</tr>
</tbody></table>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Service</span> <span class="attr">name</span>=<span class="string">&quot;xxx&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Executor</span> <span class="attr">name</span>=<span class="string">&quot;tomcatThreadPool&quot;</span> <span class="attr">namePrefix</span>=<span class="string">&quot;catalina-exec-&quot;</span> <span class="attr">maxThreads</span>=<span class="string">&quot;300&quot;</span> <span class="attr">minSpareThreads</span>=<span class="string">&quot;25&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-4-Connector"><a href="#2-2-4-Connector" class="headerlink" title="2.2.4. Connector"></a>2.2.4. Connector</h4><blockquote>
<p>Connector 代表连接组件。Tomcat 支持三种协议：HTTP&#x2F;1.1、HTTP&#x2F;2.0、AJP。</p>
</blockquote>
<p><strong>属性表</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>asyncTimeout</td>
<td>Servlet3.0 规范中的异步请求超时</td>
<td>默认 30s</td>
</tr>
<tr>
<td>port</td>
<td>请求连接的 TCP Port</td>
<td>设置为 0,则会随机选取一个未占用的端口号</td>
</tr>
<tr>
<td>protocol</td>
<td>协议. 一般情况下设置为 HTTP&#x2F;1.1,这种情况下连接模型会在 NIO 和 APR&#x2F;native 中自动根据配置选择</td>
<td></td>
</tr>
<tr>
<td>URIEncoding</td>
<td>对 URI 的编码方式.</td>
<td>如果设置系统变量 org.apache.catalina.STRICT_SERVLET_COMPLIANCE 为 true,使用 ISO-8859-1 编码;如果未设置此系统变量且未设置此属性, 使用 UTF-8 编码</td>
</tr>
<tr>
<td>useBodyEncodingForURI</td>
<td>是否采用指定的 contentType 而不是 URIEncoding 来编码 URI 中的请求参数</td>
<td></td>
</tr>
</tbody></table>
<p>以下属性在标准的 Connector(NIO, NIO2 和 APR&#x2F;native)中有效:</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>acceptCount</td>
<td>当最大请求连接 maxConnections 满时的最大排队大小</td>
<td>默认 100,注意此属性和 Executor 中属性 maxQueueSize 的区别.这个指的是请求连接满时的堆栈大小,Executor 的 maxQueueSize 指的是处理线程满时的堆栈大小</td>
</tr>
<tr>
<td>connectionTimeout</td>
<td>请求连接超时</td>
<td>默认 60000ms</td>
</tr>
<tr>
<td>executor</td>
<td>指定配置的线程池名称</td>
<td></td>
</tr>
<tr>
<td>keepAliveTimeout</td>
<td>keeAlive 超时时间</td>
<td>默认值为 connectionTimeout 配置值.-1 表示不超时</td>
</tr>
<tr>
<td>maxConnections</td>
<td>最大连接数</td>
<td>连接满时后续连接放入最大为 acceptCount 的队列中. 对 NIO 和 NIO2 连接,默认值为 10000;对 APR&#x2F;native,默认值为 8192</td>
</tr>
<tr>
<td>maxThreads</td>
<td>如果指定了 Executor, 此属性忽略;否则为 Connector 创建的内部线程池最大值</td>
<td>默认 200</td>
</tr>
<tr>
<td>minSpareThreads</td>
<td>如果指定了 Executor, 此属性忽略;否则为 Connector 创建线程池的最小活跃线程数</td>
<td>默认 10</td>
</tr>
<tr>
<td>processorCache</td>
<td>协议处理器缓存 Processor 对象的大小</td>
<td>-1 表示不限制.当不使用 servlet3.0 的异步处理情况下: 如果配置 Executor,配置为 Executor 的 maxThreads;否则配置为 Connnector 的 maxThreads. 如果使用 Serlvet3.0 异步处理, 取 maxThreads 和 maxConnections 的最大值</td>
</tr>
</tbody></table>
<h4 id="2-2-5-Context"><a href="#2-2-5-Context" class="headerlink" title="2.2.5. Context"></a>2.2.5. Context</h4><blockquote>
<p>Context 元素表示一个 Web 应用程序，它在特定的虚拟主机中运行。每个 Web 应用程序都基于 Web 应用程序存档（WAR）文件，或者包含相应的解包内容的相应目录，如 Servlet 规范中所述。</p>
</blockquote>
<p><strong>属性表</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>altDDName</td>
<td>web.xml 部署描述符路径</td>
<td>默认 &#x2F;WEB-INF&#x2F;web.xml</td>
</tr>
<tr>
<td>docBase</td>
<td>Context 的 Root 路径</td>
<td>和 Host 的 appBase 相结合, 可确定 web 应用的实际目录</td>
</tr>
<tr>
<td>failCtxIfServletStartFails</td>
<td>同 Host 中的 failCtxIfServletStartFails, 只对当前 Context 有效</td>
<td>默认为 false</td>
</tr>
<tr>
<td>logEffectiveWebXml</td>
<td>是否日志打印 web.xml 内容(web.xml 由默认的 web.xml 和应用中的 web.xml 组成)</td>
<td>默认为 false</td>
</tr>
<tr>
<td>path</td>
<td>web 应用的 context path</td>
<td>如果为根路径,则配置为空字符串(“”), 不能不配置</td>
</tr>
<tr>
<td>privileged</td>
<td>是否使用 Tomcat 提供的 manager servlet</td>
<td></td>
</tr>
<tr>
<td>reloadable</td>
<td>&#x2F;WEB-INF&#x2F;classes&#x2F; 和&#x2F;WEB-INF&#x2F;lib&#x2F; 目录中 class 文件发生变化是否自动重新加载</td>
<td>默认为 false</td>
</tr>
<tr>
<td>swallowOutput</td>
<td>true 情况下, System.out 和 System.err 输出将被定向到 web 应用日志中</td>
<td>默认为 false</td>
</tr>
</tbody></table>
<h4 id="2-2-6-Engine"><a href="#2-2-6-Engine" class="headerlink" title="2.2.6. Engine"></a>2.2.6. Engine</h4><blockquote>
<p>Engine 元素表示与特定的 Catalina 服务相关联的整个请求处理机器。它接收并处理来自一个或多个连接器的所有请求，并将完成的响应返回给连接器，以便最终传输回客户端。</p>
</blockquote>
<p><strong>属性表</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>defaultHost</td>
<td>默认主机名，用于标识将处理指向此服务器上主机名称但未在此配置文件中配置的请求的主机。</td>
<td>这个名字必须匹配其中一个嵌套的主机元素的名字属性。</td>
</tr>
<tr>
<td>name</td>
<td>此引擎的逻辑名称，用于日志和错误消息。</td>
<td>在同一服务器中使用多个服务元素时，每个引擎必须分配一个唯一的名称。</td>
</tr>
</tbody></table>
<h4 id="2-2-7-Host"><a href="#2-2-7-Host" class="headerlink" title="2.2.7. Host"></a>2.2.7. Host</h4><blockquote>
<p>Host 元素表示一个虚拟主机，它是一个服务器的网络名称（如“<a target="_blank" rel="noopener" href="http://www.mycompany.com”)与运行/">www.mycompany.com”）与运行</a> Tomcat 的特定服务器的关联。</p>
</blockquote>
<p><strong>属性表</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>名称</td>
<td>用于日志输出</td>
</tr>
<tr>
<td>appBase</td>
<td>虚拟主机对应的应用基础路径</td>
<td>可以是个绝对路径, 或${CATALINA_BASE}相对路径</td>
</tr>
<tr>
<td>xmlBase</td>
<td>虚拟主机 XML 基础路径,里面应该有 Context xml 配置文件</td>
<td>可以是个绝对路径, 或${CATALINA_BASE}相对路径</td>
</tr>
<tr>
<td>createDirs</td>
<td>当 appBase 和 xmlBase 不存在时,是否创建目录</td>
<td>默认为 true</td>
</tr>
<tr>
<td>autoDeploy</td>
<td>是否周期性的检查 appBase 和 xmlBase 并 deploy web 应用和 context 描述符</td>
<td>默认为 true</td>
</tr>
<tr>
<td>deployIgnore</td>
<td>忽略 deploy 的正则</td>
<td></td>
</tr>
<tr>
<td>deployOnStartup</td>
<td>Tomcat 启动时是否自动 deploy</td>
<td>默认为 true</td>
</tr>
<tr>
<td>failCtxIfServletStartFails</td>
<td>配置为 true 情况下,任何 load-on-startup &gt;&#x3D;0 的 servlet 启动失败,则其对应的 Contxt 也启动失败</td>
<td>默认为 false</td>
</tr>
</tbody></table>
<h4 id="2-2-8-Cluster"><a href="#2-2-8-Cluster" class="headerlink" title="2.2.8. Cluster"></a>2.2.8. Cluster</h4><p>由于在实际开发中，我从未用过 Tomcat 集群配置，所以没研究。</p>
<h3 id="2-3-启动"><a href="#2-3-启动" class="headerlink" title="2.3. 启动"></a>2.3. 启动</h3><h4 id="2-3-1-部署方式"><a href="#2-3-1-部署方式" class="headerlink" title="2.3.1. 部署方式"></a>2.3.1. 部署方式</h4><p>这种方式要求本地必须安装 Tomcat 。</p>
<p>将打包好的 war 包放在 Tomcat 安装目录下的 <code>webapps</code> 目录下，然后在 bin 目录下执行 <code>startup.bat</code> 或 <code>startup.sh</code> ，Tomcat 会自动解压 <code>webapps</code> 目录下的 war 包。</p>
<p>成功后，可以访问 <code>http://localhost:8080/xxx</code> （xxx 是 war 包文件名）。</p>
<blockquote>
<p><strong>注意</strong></p>
<p>以上步骤是最简单的示例。步骤中的 war 包解压路径、启动端口以及一些更多的功能都可以修改配置文件来定制 （主要是 <code>server.xml</code> 或 <code>context.xml</code> 文件）。</p>
</blockquote>
<h4 id="2-3-2-嵌入式"><a href="#2-3-2-嵌入式" class="headerlink" title="2.3.2. 嵌入式"></a>2.3.2. 嵌入式</h4><h5 id="2-3-2-1-API-方式"><a href="#2-3-2-1-API-方式" class="headerlink" title="2.3.2.1. API 方式"></a>2.3.2.1. API 方式</h5><p>在 pom.xml 中添加依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.5.24<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>添加 SimpleEmbedTomcatServer.java 文件，内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.startup.Tomcat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleTomcatServer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">8080</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONTEXT_PATH</span> <span class="operator">=</span> <span class="string">&quot;/javatool-server&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 设定 profile</span></span><br><span class="line">        Optional&lt;String&gt; profile = Optional.ofNullable(System.getProperty(<span class="string">&quot;spring.profiles.active&quot;</span>));</span><br><span class="line">        System.setProperty(<span class="string">&quot;spring.profiles.active&quot;</span>, profile.orElse(<span class="string">&quot;develop&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Tomcat</span> <span class="variable">tomcat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tomcat</span>();</span><br><span class="line">        tomcat.setPort(PORT);</span><br><span class="line">        tomcat.getHost().setAppBase(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        tomcat.addWebapp(CONTEXT_PATH, getAbsolutePath() + <span class="string">&quot;src/main/webapp&quot;</span>);</span><br><span class="line">        tomcat.start();</span><br><span class="line">        tomcat.getServer().await();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getAbsolutePath</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">folderPath</span> <span class="operator">=</span> SimpleEmbedTomcatServer.class.getProtectionDomain().getCodeSource().getLocation().getPath()</span><br><span class="line">                .substring(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (folderPath.indexOf(<span class="string">&quot;target&quot;</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            path = folderPath.substring(<span class="number">0</span>, folderPath.indexOf(<span class="string">&quot;target&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成功后，可以访问 <code>http://localhost:8080/javatool-server</code> 。</p>
<blockquote>
<p><strong>说明</strong></p>
<p>本示例是使用 <code>org.apache.tomcat.embed</code> 启动嵌入式 Tomcat 的最简示例。</p>
<p>这个示例中使用的是 Tomcat 默认的配置，但通常，我们需要对 Tomcat 配置进行一些定制和调优。为了加载配置文件，启动类就要稍微再复杂一些。这里不想再贴代码，有兴趣的同学可以参考：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/dunwu/JavaStack/tree/master/codes/javatool/server"><strong>示例项目</strong></a></p>
</blockquote>
<h5 id="2-3-2-2-使用-maven-插件启动（不推荐）"><a href="#2-3-2-2-使用-maven-插件启动（不推荐）" class="headerlink" title="2.3.2.2. 使用 maven 插件启动（不推荐）"></a>2.3.2.2. 使用 maven 插件启动（不推荐）</h5><p>不推荐理由：这种方式启动 maven 虽然最简单，但是有一个很大的问题是，真的很久很久没发布新版本了（最新版本发布时间：2013-11-11）。且貌似只能找到 Tomcat6 、Tomcat7 插件。</p>
<p><strong>使用方法</strong></p>
<p>在 pom.xml 中引入插件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">port</span>&gt;</span>8080<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">path</span>&gt;</span>/$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uriEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">uriEncoding</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>运行 <code>mvn tomcat7:run</code> 命令，启动 Tomcat。</p>
<p>成功后，可以访问 <code>http://localhost:8080/xxx</code> （xxx 是 ${project.artifactId} 指定的项目名）。</p>
<h4 id="2-3-3-IDE-插件"><a href="#2-3-3-IDE-插件" class="headerlink" title="2.3.3. IDE 插件"></a>2.3.3. IDE 插件</h4><p>常见 Java IDE 一般都有对 Tomcat 的支持。</p>
<p>以 Intellij IDEA 为例，提供了 <strong>Tomcat and TomEE Integration</strong> 插件（一般默认会安装）。</p>
<p><strong>使用步骤</strong></p>
<ul>
<li>点击 Run&#x2F;Debug Configurations &gt; New Tomcat Server &gt; local ，打开 Tomcat 配置页面。</li>
<li>点击 Confiure… 按钮，设置 Tomcat 安装路径。</li>
<li>点击 Deployment 标签页，设置要启动的应用。</li>
<li>设置启动应用的端口、JVM 参数、启动浏览器等。</li>
<li>成功后，可以访问 <code>http://localhost:8080/</code>（当然，你也可以在 url 中设置上下文名称）。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/tools/tomcat/tomcat-intellij-run-config.png" alt="img"></p>
<blockquote>
<p><strong>说明</strong></p>
<p>个人认为这个插件不如 Eclipse 的 Tomcat 插件好用，Eclipse 的 Tomcat 插件支持对 Tomcat xml 配置文件进行配置。而这里，你只能自己去 Tomcat 安装路径下修改配置文件。</p>
</blockquote>
<p>文中的嵌入式启动示例可以参考<a target="_blank" rel="noopener" href="https://github.com/dunwu/JavaStack/tree/master/codes/javatool/server"><strong>我的示例项目</strong></a></p>
<h2 id="3-Tomcat-架构"><a href="#3-Tomcat-架构" class="headerlink" title="3. Tomcat 架构"></a>3. Tomcat 架构</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20201113193431.png" alt="img"></p>
<p>Tomcat 要实现 2 个核心功能：</p>
<ul>
<li><strong>处理 Socket 连接</strong>，负责网络字节流与 Request 和 Response 对象的转化。</li>
<li><strong>加载和管理 Servlet</strong>，以及<strong>处理具体的 Request 请求</strong>。</li>
</ul>
<p>为此，Tomcat 设计了两个核心组件：</p>
<ul>
<li><strong>连接器（Connector）</strong>：负责和外部通信</li>
<li><strong>容器（Container）</strong>：负责内部处理</li>
</ul>
<h3 id="3-1-Service"><a href="#3-1-Service" class="headerlink" title="3.1. Service"></a>3.1. Service</h3><p>Tomcat 支持的 I&#x2F;O 模型有：</p>
<ul>
<li>NIO：非阻塞 I&#x2F;O，采用 Java NIO 类库实现。</li>
<li>NIO2：异步 I&#x2F;O，采用 JDK 7 最新的 NIO2 类库实现。</li>
<li>APR：采用 Apache 可移植运行库实现，是 C&#x2F;C++ 编写的本地库。</li>
</ul>
<p>Tomcat 支持的应用层协议有：</p>
<ul>
<li>HTTP&#x2F;1.1：这是大部分 Web 应用采用的访问协议。</li>
<li>AJP：用于和 Web 服务器集成（如 Apache）。</li>
<li>HTTP&#x2F;2：HTTP 2.0 大幅度的提升了 Web 性能。</li>
</ul>
<p>Tomcat 支持多种 I&#x2F;O 模型和应用层协议。为了实现这点，一个容器可能对接多个连接器。但是，单独的连接器或容器都不能对外提供服务，需要把它们组装起来才能工作，组装后这个整体叫作 Service 组件。Tomcat 内可能有多个 Service，通过在 Tomcat 中配置多个 Service，可以实现通过不同的端口号来访问同一台机器上部署的不同应用。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20201111093124.png" alt="img"></p>
<p><strong>一个 Tomcat 实例有一个或多个 Service；一个 Service 有多个 Connector 和 Container</strong>。Connector 和 Container 之间通过标准的 ServletRequest 和 ServletResponse 通信。</p>
<h3 id="3-2-连接器"><a href="#3-2-连接器" class="headerlink" title="3.2. 连接器"></a>3.2. 连接器</h3><p>连接器对 Servlet 容器屏蔽了协议及 I&#x2F;O 模型等的区别，无论是 HTTP 还是 AJP，在容器中获取到的都是一个标准的 ServletRequest 对象。</p>
<p>连接器的主要功能是：</p>
<ul>
<li>网络通信</li>
<li>应用层协议解析</li>
<li>Tomcat Request&#x2F;Response 与 ServletRequest&#x2F;ServletResponse 的转化</li>
</ul>
<p>Tomcat 设计了 3 个组件来实现这 3 个功能，分别是 <strong><code>EndPoint</code><strong>、</strong><code>Processor</code></strong> 和 **<code>Adapter</code>**。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20201111101440.png" alt="img"></p>
<p>组件间通过抽象接口交互。这样做还有一个好处是<strong>封装变化。</strong>这是面向对象设计的精髓，将系统中经常变化的部分和稳定的部分隔离，有助于增加复用性，并降低系统耦合度。网络通信的 I&#x2F;O 模型是变化的，可能是非阻塞 I&#x2F;O、异步 I&#x2F;O 或者 APR。应用层协议也是变化的，可能是 HTTP、HTTPS、AJP。浏览器端发送的请求信息也是变化的。但是整体的处理逻辑是不变的，EndPoint 负责提供字节流给 Processor，Processor 负责提供 Tomcat Request 对象给 Adapter，Adapter 负责提供 ServletRequest 对象给容器。</p>
<p>如果要支持新的 I&#x2F;O 方案、新的应用层协议，只需要实现相关的具体子类，上层通用的处理逻辑是不变的。由于 I&#x2F;O 模型和应用层协议可以自由组合，比如 NIO + HTTP 或者 NIO2 + AJP。Tomcat 的设计者将网络通信和应用层协议解析放在一起考虑，设计了一个叫 ProtocolHandler 的接口来封装这两种变化点。各种协议和通信模型的组合有相应的具体实现类。比如：Http11NioProtocol 和 AjpNioProtocol。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20201027091819.png" alt="img"></p>
<h4 id="3-2-1-ProtocolHandler-组件"><a href="#3-2-1-ProtocolHandler-组件" class="headerlink" title="3.2.1. ProtocolHandler 组件"></a>3.2.1. ProtocolHandler 组件</h4><p><strong>连接器用 ProtocolHandler 接口来封装通信协议和 I&#x2F;O 模型的差异</strong>。ProtocolHandler 内部又分为 EndPoint 和 Processor 模块，EndPoint 负责底层 Socket 通信，Proccesor 负责应用层协议解析。</p>
<h5 id="3-2-1-1-EndPoint"><a href="#3-2-1-1-EndPoint" class="headerlink" title="3.2.1.1. EndPoint"></a>3.2.1.1. EndPoint</h5><p>EndPoint 是通信端点，即通信监听的接口，是具体的 Socket 接收和发送处理器，是对传输层的抽象，因此 EndPoint 是用来实现 TCP&#x2F;IP 协议的。</p>
<p>EndPoint 是一个接口，对应的抽象实现类是 AbstractEndpoint，而 AbstractEndpoint 的具体子类，比如在 NioEndpoint 和 Nio2Endpoint 中，有两个重要的子组件：Acceptor 和 SocketProcessor。</p>
<p>其中 Acceptor 用于监听 Socket 连接请求。SocketProcessor 用于处理接收到的 Socket 请求，它实现 Runnable 接口，在 Run 方法里调用协议处理组件 Processor 进行处理。为了提高处理能力，SocketProcessor 被提交到线程池来执行。而这个线程池叫作执行器（Executor)。</p>
<h5 id="3-2-1-2-Processor"><a href="#3-2-1-2-Processor" class="headerlink" title="3.2.1.2. Processor"></a>3.2.1.2. Processor</h5><p>如果说 EndPoint 是用来实现 TCP&#x2F;IP 协议的，那么 Processor 用来实现 HTTP 协议，Processor 接收来自 EndPoint 的 Socket，读取字节流解析成 Tomcat Request 和 Response 对象，并通过 Adapter 将其提交到容器处理，Processor 是对应用层协议的抽象。</p>
<p>Processor 是一个接口，定义了请求的处理等方法。它的抽象实现类 AbstractProcessor 对一些协议共有的属性进行封装，没有对方法进行实现。具体的实现有 AJPProcessor、HTTP11Processor 等，这些具体实现类实现了特定协议的解析方法和请求处理方式。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20201113185929.png" alt="img"></p>
<p>从图中我们看到，EndPoint 接收到 Socket 连接后，生成一个 SocketProcessor 任务提交到线程池去处理，SocketProcessor 的 Run 方法会调用 Processor 组件去解析应用层协议，Processor 通过解析生成 Request 对象后，会调用 Adapter 的 Service 方法。</p>
<h4 id="3-2-2-Adapter"><a href="#3-2-2-Adapter" class="headerlink" title="3.2.2. Adapter"></a>3.2.2. Adapter</h4><p><strong>连接器通过适配器 Adapter 调用容器</strong>。</p>
<p>由于协议不同，客户端发过来的请求信息也不尽相同，Tomcat 定义了自己的 Request 类来适配这些请求信息。</p>
<p>ProtocolHandler 接口负责解析请求并生成 Tomcat Request 类。但是这个 Request 对象不是标准的 ServletRequest，也就意味着，不能用 Tomcat Request 作为参数来调用容器。Tomcat 的解决方案是引入 CoyoteAdapter，这是适配器模式的经典运用，连接器调用 CoyoteAdapter 的 Sevice 方法，传入的是 Tomcat Request 对象，CoyoteAdapter 负责将 Tomcat Request 转成 ServletRequest，再调用容器的 Service 方法。</p>
<h3 id="3-3-容器"><a href="#3-3-容器" class="headerlink" title="3.3. 容器"></a>3.3. 容器</h3><p>Tomcat 设计了 4 种容器，分别是 Engine、Host、Context 和 Wrapper。</p>
<ul>
<li><strong>Engine</strong> - Servlet 的顶层容器，包含一 个或多个 Host 子容器；</li>
<li><strong>Host</strong> - 虚拟主机，负责 web 应用的部署和 Context 的创建；</li>
<li><strong>Context</strong> - Web 应用上下文，包含多个 Wrapper，负责 web 配置的解析、管理所有的 Web 资源；</li>
<li><strong>Wrapper</strong> - 最底层的容器，是对 Servlet 的封装，负责 Servlet 实例的创 建、执行和销毁。</li>
</ul>
<h4 id="3-3-1-请求分发-Servlet-过程"><a href="#3-3-1-请求分发-Servlet-过程" class="headerlink" title="3.3.1. 请求分发 Servlet 过程"></a>3.3.1. 请求分发 Servlet 过程</h4><p>Tomcat 是怎么确定请求是由哪个 Wrapper 容器里的 Servlet 来处理的呢？答案是，Tomcat 是用 Mapper 组件来完成这个任务的。</p>
<p>举例来说，假如有一个网购系统，有面向网站管理人员的后台管理系统，还有面向终端客户的在线购物系统。这两个系统跑在同一个 Tomcat 上，为了隔离它们的访问域名，配置了两个虚拟域名：<code>manage.shopping.com</code>和<code>user.shopping.com</code>，网站管理人员通过<code>manage.shopping.com</code>域名访问 Tomcat 去管理用户和商品，而用户管理和商品管理是两个单独的 Web 应用。终端客户通过<code>user.shopping.com</code>域名去搜索商品和下订单，搜索功能和订单管理也是两个独立的 Web 应用。如下所示，演示了 url 应声 Servlet 的处理流程。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20201113192022.jpg" alt="img"></p>
<p>假如有用户访问一个 URL，比如图中的<code>http://user.shopping.com:8080/order/buy</code>，Tomcat 如何将这个 URL 定位到一个 Servlet 呢？</p>
<ol>
<li><strong>首先，根据协议和端口号选定 Service 和 Engine。</strong></li>
<li><strong>然后，根据域名选定 Host。</strong></li>
<li><strong>之后，根据 URL 路径找到 Context 组件。</strong></li>
<li><strong>最后，根据 URL 路径找到 Wrapper（Servlet）。</strong></li>
</ol>
<p>这个路由分发过程具体是怎么实现的呢？答案是使用 Pipeline-Valve 管道。</p>
<h4 id="3-3-2-Pipeline-Value"><a href="#3-3-2-Pipeline-Value" class="headerlink" title="3.3.2. Pipeline-Value"></a>3.3.2. Pipeline-Value</h4><p>Pipeline 可以理解为现实中的管道，Valve 为管道中的阀门，Request 和 Response 对象在管道中经过各个阀门的处理和控制。</p>
<p>Pipeline-Valve 是责任链模式，责任链模式是指在一个请求处理的过程中有很多处理者依次对请求进行处理，每个处理者负责做自己相应的处理，处理完之后将再调用下一个处理者继续处理。Valve 表示一个处理点，比如权限认证和记录日志。</p>
<p>先来了解一下 Valve 和 Pipeline 接口的设计：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/tools/tomcat/Pipeline%E4%B8%8EValve.png" alt="img"></p>
<ul>
<li>每一个容器都有一个 Pipeline 对象，只要触发这个 Pipeline 的第一个 Valve，这个容器里 Pipeline 中的 Valve 就都会被调用到。但是，不同容器的 Pipeline 是怎么链式触发的呢，比如 Engine 中 Pipeline 需要调用下层容器 Host 中的 Pipeline。</li>
<li>这是因为 Pipeline 中还有个 getBasic 方法。这个 BasicValve 处于 Valve 链表的末端，它是 Pipeline 中必不可少的一个 Valve，负责调用下层容器的 Pipeline 里的第一个 Valve。</li>
<li>Pipeline 中有 addValve 方法。Pipeline 中维护了 Valve 链表，Valve 可以插入到 Pipeline 中，对请求做某些处理。我们还发现 Pipeline 中没有 invoke 方法，因为整个调用链的触发是 Valve 来完成的，Valve 完成自己的处理后，调用 <code>getNext.invoke()</code> 来触发下一个 Valve 调用。</li>
<li>Valve 中主要的三个方法：<code>setNext</code>、<code>getNext</code>、<code>invoke</code>。Valve 之间的关系是单向链式结构，本身 <code>invoke</code> 方法中会调用下一个 Valve 的 <code>invoke</code> 方法。</li>
<li>各层容器对应的 basic valve 分别是 <code>StandardEngineValve</code>、<code>StandardHostValve</code>、 <code>StandardContextValve</code>、<code>StandardWrapperValve</code>。</li>
<li>由于 Valve 是一个处理点，因此 invoke 方法就是来处理请求的。注意到 Valve 中有 getNext 和 setNext 方法，因此我们大概可以猜到有一个链表将 Valve 链起来了。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/tools/tomcat/%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B.png" alt="img"></p>
<p>整个调用过程由连接器中的 Adapter 触发的，它会调用 Engine 的第一个 Valve：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connector.getService().getContainer().getPipeline().getFirst().invoke(request, response);</span><br></pre></td></tr></table></figure>

<h2 id="4-Tomcat-生命周期"><a href="#4-Tomcat-生命周期" class="headerlink" title="4. Tomcat 生命周期"></a>4. Tomcat 生命周期</h2><h3 id="4-1-Tomcat-的启动过程"><a href="#4-1-Tomcat-的启动过程" class="headerlink" title="4.1. Tomcat 的启动过程"></a>4.1. Tomcat 的启动过程</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20201118145455.png" alt="img"></p>
<ol>
<li>Tomcat 是一个 Java 程序，它的运行从执行 <code>startup.sh</code> 脚本开始。<code>startup.sh</code> 会启动一个 JVM 来运行 Tomcat 的启动类 <code>Bootstrap</code>。</li>
<li><code>Bootstrap</code> 会初始化 Tomcat 的类加载器并实例化 <code>Catalina</code>。</li>
<li><code>Catalina</code> 会通过 Digester 解析 <code>server.xml</code>，根据其中的配置信息来创建相应组件，并调用 <code>Server</code> 的 <code>start</code> 方法。</li>
<li><code>Server</code> 负责管理 <code>Service</code> 组件，它会调用 <code>Service</code> 的 <code>start</code> 方法。</li>
<li><code>Service</code> 负责管理 <code>Connector</code> 和顶层容器 <code>Engine</code>，它会调用 <code>Connector</code> 和 <code>Engine</code> 的 <code>start</code> 方法。</li>
</ol>
<h4 id="4-1-1-Catalina-组件"><a href="#4-1-1-Catalina-组件" class="headerlink" title="4.1.1. Catalina 组件"></a>4.1.1. Catalina 组件</h4><p>Catalina 的职责就是解析 server.xml 配置，并据此实例化 Server。接下来，调用 Server 组件的 init 方法和 start 方法，将 Tomcat 启动起来。</p>
<p>Catalina 还需要处理各种“异常”情况，比如当我们通过“Ctrl + C”关闭 Tomcat 时，Tomcat 将如何优雅的停止并且清理资源呢？因此 Catalina 在 JVM 中注册一个“关闭钩子”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1. 如果持有的 Server 实例为空，就解析 server.xml 创建出来</span></span><br><span class="line">    <span class="keyword">if</span> (getServer() == <span class="literal">null</span>) &#123;</span><br><span class="line">        load();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 如果创建失败，报错退出</span></span><br><span class="line">    <span class="keyword">if</span> (getServer() == <span class="literal">null</span>) &#123;</span><br><span class="line">        log.fatal(sm.getString(<span class="string">&quot;catalina.noServer&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 启动 Server</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        getServer().start();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并注册关闭钩子</span></span><br><span class="line">    <span class="keyword">if</span> (useShutdownHook) &#123;</span><br><span class="line">        <span class="keyword">if</span> (shutdownHook == <span class="literal">null</span>) &#123;</span><br><span class="line">            shutdownHook = <span class="keyword">new</span> <span class="title class_">CatalinaShutdownHook</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(shutdownHook);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用 await 方法监听停止请求</span></span><br><span class="line">    <span class="keyword">if</span> (await) &#123;</span><br><span class="line">        await();</span><br><span class="line">        stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么需要关闭钩子？</p>
<p>如果我们需要在 JVM 关闭时做一些清理工作，比如将缓存数据刷到磁盘上，或者清理一些临时文件，可以向 JVM 注册一个“关闭钩子”。“关闭钩子”其实就是一个线程，JVM 在停止之前会尝试执行这个线程的 <code>run</code> 方法。</p>
<p>Tomcat 的“关闭钩子”—— <code>CatalinaShutdownHook</code> 做了些什么呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">class</span> <span class="title class_">CatalinaShutdownHook</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (getServer() != <span class="literal">null</span>) &#123;</span><br><span class="line">                Catalina.<span class="built_in">this</span>.stop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Tomcat 的“关闭钩子”实际上就执行了 <code>Server</code> 的 <code>stop</code> 方法，<code>Server</code> 的 <code>stop</code> 方法会释放和清理所有的资源。</p>
<h4 id="4-1-2-Server-组件"><a href="#4-1-2-Server-组件" class="headerlink" title="4.1.2. Server 组件"></a>4.1.2. Server 组件</h4><p>Server 组件的具体实现类是 StandardServer，Server 继承了 LifeCycleBase，它的生命周期被统一管理，并且它的子组件是 Service，因此它还需要管理 Service 的生命周期，也就是说在启动时调用 Service 组件的启动方法，在停止时调用它们的停止方法。Server 在内部维护了若干 Service 组件，它是以数组来保存的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addService</span><span class="params">(Service service)</span> &#123;</span><br><span class="line"></span><br><span class="line">    service.setServer(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (servicesLock) &#123;</span><br><span class="line">        <span class="comment">// 创建一个长度 +1 的新数组</span></span><br><span class="line">        Service results[] = <span class="keyword">new</span> <span class="title class_">Service</span>[services.length + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将老的数据复制过去</span></span><br><span class="line">        System.arraycopy(services, <span class="number">0</span>, results, <span class="number">0</span>, services.length);</span><br><span class="line">        results[services.length] = service;</span><br><span class="line">        services = results;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动 Service 组件</span></span><br><span class="line">        <span class="keyword">if</span> (getState().isAvailable()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                service.start();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 触发监听事件</span></span><br><span class="line">        support.firePropertyChange(<span class="string">&quot;service&quot;</span>, <span class="literal">null</span>, service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Server 并没有一开始就分配一个很长的数组，而是在添加的过程中动态地扩展数组长度，当添加一个新的 Service 实例时，会创建一个新数组并把原来数组内容复制到新数组，这样做的目的其实是为了节省内存空间。</p>
<p>除此之外，Server 组件还有一个重要的任务是启动一个 Socket 来监听停止端口，这就是为什么你能通过 shutdown 命令来关闭 Tomcat。不知道你留意到没有，上面 Caralina 的启动方法的最后一行代码就是调用了 Server 的 await 方法。</p>
<p>在 await 方法里会创建一个 Socket 监听 8005 端口，并在一个死循环里接收 Socket 上的连接请求，如果有新的连接到来就建立连接，然后从 Socket 中读取数据；如果读到的数据是停止命令“SHUTDOWN”，就退出循环，进入 stop 流程。</p>
<h4 id="4-1-3-Service-组件"><a href="#4-1-3-Service-组件" class="headerlink" title="4.1.3. Service 组件"></a>4.1.3. Service 组件</h4><p>Service 组件的具体实现类是 StandardService。</p>
<p>【源码】StandardService 源码定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StandardService</span> <span class="keyword">extends</span> <span class="title class_">LifecycleBase</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="comment">// 名字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Server 实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Server</span> <span class="variable">server</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接器数组</span></span><br><span class="line">    <span class="keyword">protected</span> Connector connectors[] = <span class="keyword">new</span> <span class="title class_">Connector</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">connectorsLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对应的 Engine 容器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Engine</span> <span class="variable">engine</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 映射器及其监听器</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">Mapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mapper</span>();</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">MapperListener</span> <span class="variable">mapperListener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapperListener</span>(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StandardService 继承了 LifecycleBase 抽象类。</p>
<p>StandardService 维护了一个 MapperListener 用于支持 Tomcat 热部署。当 Web 应用的部署发生变化时，Mapper 中的映射信息也要跟着变化，MapperListener 就是一个监听器，它监听容器的变化，并把信息更新到 Mapper 中，这是典型的观察者模式。</p>
<p>作为“管理”角色的组件，最重要的是维护其他组件的生命周期。此外在启动各种组件时，要注意它们的依赖关系，也就是说，要注意启动的顺序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 触发启动监听器</span></span><br><span class="line">    setState(LifecycleState.STARTING);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 先启动 Engine，Engine 会启动它子容器</span></span><br><span class="line">    <span class="keyword">if</span> (engine != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (engine) &#123;</span><br><span class="line">            engine.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 再启动 Mapper 监听器</span></span><br><span class="line">    mapperListener.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 最后启动连接器，连接器会启动它子组件，比如 Endpoint</span></span><br><span class="line">    <span class="keyword">synchronized</span> (connectorsLock) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Connector connector: connectors) &#123;</span><br><span class="line">            <span class="keyword">if</span> (connector.getState() != LifecycleState.FAILED) &#123;</span><br><span class="line">                connector.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从启动方法可以看到，Service 先启动了 Engine 组件，再启动 Mapper 监听器，最后才是启动连接器。这很好理解，因为内层组件启动好了才能对外提供服务，才能启动外层的连接器组件。而 Mapper 也依赖容器组件，容器组件启动好了才能监听它们的变化，因此 Mapper 和 MapperListener 在容器组件之后启动。组件停止的顺序跟启动顺序正好相反的，也是基于它们的依赖关系。</p>
<h4 id="4-1-4-Engine-组件"><a href="#4-1-4-Engine-组件" class="headerlink" title="4.1.4. Engine 组件"></a>4.1.4. Engine 组件</h4><p>Engine 本质是一个容器，因此它继承了 ContainerBase 基类，并且实现了 Engine 接口。</p>
<h3 id="4-2-Web-应用的部署方式"><a href="#4-2-Web-应用的部署方式" class="headerlink" title="4.2. Web 应用的部署方式"></a>4.2. Web 应用的部署方式</h3><p>注：catalina.home：安装目录;catalina.base：工作目录;默认值 user.dir</p>
<ul>
<li>Server.xml 配置 Host 元素，指定 appBase 属性，默认$catalina.base&#x2F;webapps&#x2F;</li>
<li>Server.xml 配置 Context 元素，指定 docBase，元素，指定 web 应用的路径</li>
<li>自定义配置：在$catalina.base&#x2F;EngineName&#x2F;HostName&#x2F;XXX.xml 配置 Context 元素</li>
</ul>
<p>HostConfig 监听了 StandardHost 容器的事件，在 start 方法中解析上述配置文件：</p>
<ul>
<li>扫描 appbase 路径下的所有文件夹和 war 包，解析各个应用的 META-INF&#x2F;context.xml，并 创建 StandardContext，并将 Context 加入到 Host 的子容器中。</li>
<li>解析$catalina.base&#x2F;EngineName&#x2F;HostName&#x2F;下的所有 Context 配置，找到相应 web 应 用的位置，解析各个应用的 META-INF&#x2F;context.xml，并创建 StandardContext，并将 Context 加入到 Host 的子容器中。</li>
</ul>
<p>注：</p>
<ul>
<li>HostConfig 并没有实际解析 Context.xml，而是在 ContextConfig 中进行的。</li>
<li>HostConfig 中会定期检查 watched 资源文件(context.xml 配置文件)</li>
</ul>
<p>ContextConfig 解析 context.xml 顺序：</p>
<ul>
<li>先解析全局的配置 config&#x2F;context.xml</li>
<li>然后解析 Host 的默认配置 EngineName&#x2F;HostName&#x2F;context.xml.default</li>
<li>最后解析应用的 META-INF&#x2F;context.xml</li>
</ul>
<p>ContextConfig 解析 web.xml 顺序：</p>
<ul>
<li>先解析全局的配置 config&#x2F;web.xml</li>
<li>然后解析 Host 的默认配置 EngineName&#x2F;HostName&#x2F;web.xml.default 接着解析应用的 MEB-INF&#x2F;web.xml</li>
<li>扫描应用 WEB-INF&#x2F;lib&#x2F;下的 jar 文件，解析其中的 META-INF&#x2F;web-fragment.xml 最后合并 xml 封装成 WebXml，并设置 Context</li>
</ul>
<p>注：</p>
<ul>
<li>扫描 web 应用和 jar 中的注解(Filter、Listener、Servlet)就是上述步骤中进行的。</li>
<li>容器的定期执行：backgroundProcess，由 ContainerBase 来实现的，并且只有在顶层容器 中才会开启线程。(backgroundProcessorDelay&#x3D;10 标志位来控制)</li>
</ul>
<h3 id="4-3-LifeCycle"><a href="#4-3-LifeCycle" class="headerlink" title="4.3. LifeCycle"></a>4.3. LifeCycle</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20201118105012.png" alt="img"></p>
<h4 id="4-3-1-请求处理过程"><a href="#4-3-1-请求处理过程" class="headerlink" title="4.3.1. 请求处理过程"></a>4.3.1. 请求处理过程</h4><div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/tools/tomcat/请求处理过程.png" width="600">
</div>

<ol>
<li>根据 server.xml 配置的指定的 connector 以及端口监听 http、或者 ajp 请求</li>
<li>请求到来时建立连接,解析请求参数,创建 Request 和 Response 对象,调用顶层容器 pipeline 的 invoke 方法</li>
<li>容器之间层层调用,最终调用业务 servlet 的 service 方法</li>
<li>Connector 将 response 流中的数据写到 socket 中</li>
</ol>
<h3 id="4-4-Connector-流程"><a href="#4-4-Connector-流程" class="headerlink" title="4.4. Connector 流程"></a>4.4. Connector 流程</h3><div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/tools/tomcat/connector.png" width="600">
</div>

<h4 id="4-4-1-阻塞-IO"><a href="#4-4-1-阻塞-IO" class="headerlink" title="4.4.1. 阻塞 IO"></a>4.4.1. 阻塞 IO</h4><div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/tools/tomcat/阻塞IO.png" width="600">
</div>

<h4 id="4-4-2-非阻塞-IO"><a href="#4-4-2-非阻塞-IO" class="headerlink" title="4.4.2. 非阻塞 IO"></a>4.4.2. 非阻塞 IO</h4><div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/tools/tomcat/非阻塞IO.png" width="600">
</div>

<h4 id="4-4-3-IO-多路复用"><a href="#4-4-3-IO-多路复用" class="headerlink" title="4.4.3. IO 多路复用"></a>4.4.3. IO 多路复用</h4><div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/tools/tomcat/IO多路复用.png" width="600">
</div>

<p>阻塞与非阻塞的区别在于进行读操作和写操作的系统调用时，如果此时内核态没有数据可读或者没有缓冲空间可写时，是否阻塞。</p>
<p>IO 多路复用的好处在于可同时监听多个 socket 的可读和可写事件，这样就能使得应用可以同时监听多个 socket，释放了应用线程资源。</p>
<h4 id="4-4-4-Tomcat-各类-Connector-对比"><a href="#4-4-4-Tomcat-各类-Connector-对比" class="headerlink" title="4.4.4. Tomcat 各类 Connector 对比"></a>4.4.4. Tomcat 各类 Connector 对比</h4><div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/tools/tomcat/Tomcat各类Connector对比.jpg" width="500">
</div>

<ul>
<li>JIO：用 java.io 编写的 TCP 模块，阻塞 IO</li>
<li>NIO：用 java.nio 编写的 TCP 模块，非阻塞 IO，（IO 多路复用）</li>
<li>APR：全称 Apache Portable Runtime，使用 JNI 的方式来进行读取文件以及进行网络传输</li>
</ul>
<p>Apache Portable Runtime 是一个高度可移植的库，它是 Apache HTTP Server 2.x 的核心。 APR 具有许多用途，包括访问高级 IO 功能（如 sendfile，epoll 和 OpenSSL），操作系统级功能（随机数生成，系统状态等）和本地进程处理（共享内存，NT 管道和 Unix 套接字）。</p>
<p>表格中字段含义说明：</p>
<ul>
<li>Support Polling - 是否支持基于 IO 多路复用的 socket 事件轮询</li>
<li>Polling Size - 轮询的最大连接数</li>
<li>Wait for next Request - 在等待下一个请求时，处理线程是否释放，BIO 是没有释放的，所以在 keep-alive&#x3D;true 的情况下处理的并发连接数有限</li>
<li>Read Request Headers - 由于 request header 数据较少，可以由容器提前解析完毕，不需要阻塞</li>
<li>Read Request Body - 读取 request body 的数据是应用业务逻辑的事情，同时 Servlet 的限制，是需要阻塞读取的</li>
<li>Write Response - 跟读取 request body 的逻辑类似，同样需要阻塞写</li>
</ul>
<p><strong>NIO 处理相关类</strong></p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/tools/tomcat/NIO处理相关类.jpg" width="500">
</div>

<p>Poller 线程从 EventQueue 获取 PollerEvent，并执行 PollerEvent 的 run 方法，调用 Selector 的 select 方法，如果有可读的 Socket 则创建 Http11NioProcessor，放入到线程池中执行；</p>
<p>CoyoteAdapter 是 Connector 到 Container 的适配器，Http11NioProcessor 调用其提供的 service 方法，内部创建 Request 和 Response 对象，并调用最顶层容器的 Pipeline 中的第一个 Valve 的 invoke 方法</p>
<p>Mapper 主要处理 http url 到 servlet 的映射规则的解析，对外提供 map 方法</p>
<h3 id="4-5-Comet"><a href="#4-5-Comet" class="headerlink" title="4.5. Comet"></a>4.5. Comet</h3><p>Comet 是一种用于 web 的推送技术，能使服务器实时地将更新的信息传送到客户端，而无须客户端发出请求<br>在 WebSocket 出来之前，如果不适用 comet，只能通过浏览器端轮询 Server 来模拟实现服务器端推送。<br>Comet 支持 servlet 异步处理 IO，当连接上数据可读时触发事件，并异步写数据(阻塞)</p>
<p>Tomcat 要实现 Comet，只需继承 HttpServlet 同时，实现 CometProcessor 接口</p>
<ul>
<li>Begin：新的请求连接接入调用，可进行与 Request 和 Response 相关的对象初始化操作，并保存 response 对象，用于后续写入数据</li>
<li>Read：请求连接有数据可读时调用</li>
<li>End：当数据可用时，如果读取到文件结束或者 response 被关闭时则被调用</li>
<li>Error：在连接上发生异常时调用，数据读取异常、连接断开、处理异常、socket 超时</li>
</ul>
<p>Note：</p>
<ul>
<li>Read：在 post 请求有数据，但在 begin 事件中没有处理，则会调用 read，如果 read 没有读取数据，在会触发 Error 回调，关闭 socket</li>
<li>End：当 socket 超时，并且 response 被关闭时也会调用；server 被关闭时调用</li>
<li>Error：除了 socket 超时不会关闭 socket，其他都会关闭 socket</li>
<li>End 和 Error 时间触发时应关闭当前 comet 会话，即调用 CometEvent 的 close 方法<br>Note：在事件触发时要做好线程安全的操作</li>
</ul>
<h3 id="4-6-异步-Servlet"><a href="#4-6-异步-Servlet" class="headerlink" title="4.6. 异步 Servlet"></a>4.6. 异步 Servlet</h3><div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/tools/tomcat/传统Servlet处理流程.png" >
</div>

<p>传统流程：</p>
<ul>
<li>首先，Servlet 接收到请求之后，request 数据解析；</li>
<li>接着，调用业务接口的某些方法，以完成业务处理；</li>
<li>最后，根据处理的结果提交响应，Servlet 线程结束</li>
</ul>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/tools/tomcat/异步Servlet处理流程.png" >
</div>

<p>异步处理流程：</p>
<ul>
<li>客户端发送一个请求</li>
<li>Servlet 容器分配一个线程来处理容器中的一个 servlet</li>
<li>servlet 调用 request.startAsync()，保存 AsyncContext, 然后返回</li>
<li>任何方式存在的容器线程都将退出，但是 response 仍然保持开放</li>
<li>业务线程使用保存的 AsyncContext 来完成响应（线程池）</li>
<li>客户端收到响应</li>
</ul>
<p>Servlet 线程将请求转交给一个异步线程来执行业务处理，线程本身返回至容器，此时 Servlet 还没有生成响应数据，异步线程处理完业务以后，可以直接生成响应数据（异步线程拥有 ServletRequest 和 ServletResponse 对象的引用）</p>
<p><strong>为什么 web 应用中支持异步？</strong></p>
<p>推出异步，主要是针对那些比较耗时的请求：比如一次缓慢的数据库查询，一次外部 REST API 调用, 或者是其他一些 I&#x2F;O 密集型操作。这种耗时的请求会很快的耗光 Servlet 容器的线程池，继而影响可扩展性。</p>
<p>Note：从客户端的角度来看，request 仍然像任何其他的 HTTP 的 request-response 交互一样，只是耗费了更长的时间而已</p>
<p><strong>异步事件监听</strong></p>
<ul>
<li>onStartAsync：Request 调用 startAsync 方法时触发</li>
<li>onComplete：syncContext 调用 complete 方法时触发</li>
<li>onError：处理请求的过程出现异常时触发</li>
<li>onTimeout：socket 超时触发</li>
</ul>
<p>Note :<br>onError&#x2F; onTimeout 触发后，会紧接着回调 onComplete<br>onComplete 执行后，就不可再操作 request 和 response</p>
<h2 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5. 参考资料"></a>5. 参考资料</h2><ul>
<li><p><strong>官方</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="http://tomcat.apache.org/">Tomcat 官方网站</a></li>
<li><a target="_blank" rel="noopener" href="http://wiki.apache.org/tomcat/FrontPage">Tomcat Wiki</a></li>
<li><a target="_blank" rel="noopener" href="http://tomee.apache.org/">Tomee 官方网站</a></li>
</ul>
</li>
<li><p><strong>文章</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/basic_app_embedded_tomcat/basic_app-tomcat-embedded.html">Creating a Web App with Bootstrap and Tomcat Embedded</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/58eb5fdda0bb9f00692a78fc">Tomcat 组成与工作原理</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/index.html">Tomcat 工作原理</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat2/index.html?ca=drs-">Tomcat 设计模式分析</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/d5076a/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/d5076a/" class="post-title-link" itemprop="url">Tomcat容器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-17 22:34:30" itemprop="dateCreated datePublished" datetime="2022-02-17T22:34:30+08:00">2022-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JavaEE/" itemprop="url" rel="index"><span itemprop="name">JavaEE</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JavaEE/%E6%9C%8D%E5%8A%A1%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">服务器</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JavaEE/%E6%9C%8D%E5%8A%A1%E5%99%A8/Tomcat/" itemprop="url" rel="index"><span itemprop="name">Tomcat</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>20k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>18 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Tomcat-容器"><a href="#Tomcat-容器" class="headerlink" title="Tomcat 容器"></a>Tomcat 容器</h1><h2 id="Tomcat-实现热部署和热加载"><a href="#Tomcat-实现热部署和热加载" class="headerlink" title="Tomcat 实现热部署和热加载"></a>Tomcat 实现热部署和热加载</h2><ul>
<li>热加载的实现方式是 Web 容器启动一个后台线程，定期检测类文件的变化，如果有变化，就重新加载类，在这个过程中不会清空 Session ，一般用在开发环境。</li>
<li>热部署原理类似，也是由后台线程定时检测 Web 应用的变化，但它会重新加载整个 Web 应用。这种方式会清空 Session，比热加载更加干净、彻底，一般用在生产环境。</li>
</ul>
<p>Tomcat 通过开启后台线程，使得各个层次的容器组件都有机会完成一些周期性任务。Tomcat 是基于 ScheduledThreadPoolExecutor 实现周期性任务的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bgFuture = exec.scheduleWithFixedDelay(</span><br><span class="line">              <span class="keyword">new</span> <span class="title class_">ContainerBackgroundProcessor</span>(),<span class="comment">// 要执行的 Runnable</span></span><br><span class="line">              backgroundProcessorDelay, <span class="comment">// 第一次执行延迟多久</span></span><br><span class="line">              backgroundProcessorDelay, <span class="comment">// 之后每次执行间隔多久</span></span><br><span class="line">              TimeUnit.SECONDS);        <span class="comment">// 时间单位</span></span><br></pre></td></tr></table></figure>

<p>第一个参数就是要周期性执行的任务类 ContainerBackgroundProcessor，它是一个 Runnable，同时也是 ContainerBase 的内部类，ContainerBase 是所有容器组件的基类，我们来回忆一下容器组件有哪些，有 Engine、Host、Context 和 Wrapper 等，它们具有父子关系。</p>
<h3 id="ContainerBackgroundProcessor-实现"><a href="#ContainerBackgroundProcessor-实现" class="headerlink" title="ContainerBackgroundProcessor 实现"></a>ContainerBackgroundProcessor 实现</h3><p>我们接来看 ContainerBackgroundProcessor 具体是如何实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">class</span> <span class="title class_">ContainerBackgroundProcessor</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 请注意这里传入的参数是 &quot; 宿主类 &quot; 的实例</span></span><br><span class="line">        processChildren(ContainerBase.<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processChildren</span><span class="params">(Container container)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1. 调用当前容器的 backgroundProcess 方法。</span></span><br><span class="line">            container.backgroundProcess();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2. 遍历所有的子容器，递归调用 processChildren，</span></span><br><span class="line">            <span class="comment">// 这样当前容器的子孙都会被处理</span></span><br><span class="line">            Container[] children = container.findChildren();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 这里请你注意，容器基类有个变量叫做 backgroundProcessorDelay，如果大于 0，表明子容器有自己的后台线程，无需父容器来调用它的 processChildren 方法。</span></span><br><span class="line">                <span class="keyword">if</span> (children[i].getBackgroundProcessorDelay() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    processChildren(children[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码逻辑也是比较清晰的，首先 ContainerBackgroundProcessor 是一个 Runnable，它需要实现 run 方法，它的 run 很简单，就是调用了 processChildren 方法。这里有个小技巧，它把“宿主类”，也就是<strong>ContainerBase 的类实例当成参数传给了 run 方法</strong>。</p>
<p>而在 processChildren 方法里，就做了两步：调用当前容器的 backgroundProcess 方法，以及递归调用子孙的 backgroundProcess 方法。请你注意 backgroundProcess 是 Container 接口中的方法，也就是说所有类型的容器都可以实现这个方法，在这个方法里完成需要周期性执行的任务。</p>
<p>这样的设计意味着什么呢？我们只需要在顶层容器，也就是 Engine 容器中启动一个后台线程，那么这个线程<strong>不但会执行 Engine 容器的周期性任务，它还会执行所有子容器的周期性任务</strong>。</p>
<h3 id="backgroundProcess-方法"><a href="#backgroundProcess-方法" class="headerlink" title="backgroundProcess 方法"></a>backgroundProcess 方法</h3><p>上述代码都是在基类 ContainerBase 中实现的，那具体容器类需要做什么呢？其实很简单，如果有周期性任务要执行，就实现 backgroundProcess 方法；如果没有，就重用基类 ContainerBase 的方法。ContainerBase 的 backgroundProcess 方法实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backgroundProcess</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 执行容器中 Cluster 组件的周期性任务</span></span><br><span class="line">    <span class="type">Cluster</span> <span class="variable">cluster</span> <span class="operator">=</span> getClusterInternal();</span><br><span class="line">    <span class="keyword">if</span> (cluster != <span class="literal">null</span>) &#123;</span><br><span class="line">        cluster.backgroundProcess();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 执行容器中 Realm 组件的周期性任务</span></span><br><span class="line">    <span class="type">Realm</span> <span class="variable">realm</span> <span class="operator">=</span> getRealmInternal();</span><br><span class="line">    <span class="keyword">if</span> (realm != <span class="literal">null</span>) &#123;</span><br><span class="line">        realm.backgroundProcess();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3. 执行容器中 Valve 组件的周期性任务</span></span><br><span class="line">    <span class="type">Valve</span> <span class="variable">current</span> <span class="operator">=</span> pipeline.getFirst();</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">       current.backgroundProcess();</span><br><span class="line">       current = current.getNext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 触发容器的 &quot; 周期事件 &quot;，Host 容器的监听器 HostConfig 就靠它来调用</span></span><br><span class="line">    fireLifecycleEvent(Lifecycle.PERIODIC_EVENT, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看到，不仅每个容器可以有周期性任务，每个容器中的其他通用组件，比如跟集群管理有关的 Cluster 组件、跟安全管理有关的 Realm 组件都可以有自己的周期性任务。</p>
<p>我在前面的专栏里提到过，容器之间的链式调用是通过 Pipeline-Valve 机制来实现的，从上面的代码你可以看到容器中的 Valve 也可以有周期性任务，并且被 ContainerBase 统一处理。</p>
<p>请你特别注意的是，在 backgroundProcess 方法的最后，还触发了容器的“周期事件”。我们知道容器的生命周期事件有初始化、启动和停止等，那“周期事件”又是什么呢？它跟生命周期事件一样，是一种扩展机制，你可以这样理解：</p>
<p>又一段时间过去了，容器还活着，你想做点什么吗？如果你想做点什么，就创建一个监听器来监听这个“周期事件”，事件到了我负责调用你的方法。</p>
<p>总之，有了 ContainerBase 中的后台线程和 backgroundProcess 方法，各种子容器和通用组件不需要各自弄一个后台线程来处理周期性任务，这样的设计显得优雅和整洁。</p>
<h3 id="Tomcat-热加载"><a href="#Tomcat-热加载" class="headerlink" title="Tomcat 热加载"></a>Tomcat 热加载</h3><p>有了 ContainerBase 的周期性任务处理“框架”，作为具体容器子类，只需要实现自己的周期性任务就行。而 Tomcat 的热加载，就是在 Context 容器中实现的。Context 容器的 backgroundProcess 方法是这样实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backgroundProcess</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//WebappLoader 周期性的检查 WEB-INF/classes 和 WEB-INF/lib 目录下的类文件</span></span><br><span class="line">    <span class="type">Loader</span> <span class="variable">loader</span> <span class="operator">=</span> getLoader();</span><br><span class="line">    <span class="keyword">if</span> (loader != <span class="literal">null</span>) &#123;</span><br><span class="line">        loader.backgroundProcess();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Session 管理器周期性的检查是否有过期的 Session</span></span><br><span class="line">    <span class="type">Manager</span> <span class="variable">manager</span> <span class="operator">=</span> getManager();</span><br><span class="line">    <span class="keyword">if</span> (manager != <span class="literal">null</span>) &#123;</span><br><span class="line">        manager.backgroundProcess();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 周期性的检查静态资源是否有变化</span></span><br><span class="line">    <span class="type">WebResourceRoot</span> <span class="variable">resources</span> <span class="operator">=</span> getResources();</span><br><span class="line">    <span class="keyword">if</span> (resources != <span class="literal">null</span>) &#123;</span><br><span class="line">        resources.backgroundProcess();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用父类 ContainerBase 的 backgroundProcess 方法</span></span><br><span class="line">    <span class="built_in">super</span>.backgroundProcess();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码我们看到 Context 容器通过 WebappLoader 来检查类文件是否有更新，通过 Session 管理器来检查是否有 Session 过期，并且通过资源管理器来检查静态资源是否有更新，最后还调用了父类 ContainerBase 的 backgroundProcess 方法。</p>
<p>这里我们要重点关注，WebappLoader 是如何实现热加载的，它主要是调用了 Context 容器的 reload 方法，而 Context 的 reload 方法比较复杂，总结起来，主要完成了下面这些任务：</p>
<ol>
<li>停止和销毁 Context 容器及其所有子容器，子容器其实就是 Wrapper，也就是说 Wrapper 里面 Servlet 实例也被销毁了。</li>
<li>停止和销毁 Context 容器关联的 Listener 和 Filter。</li>
<li>停止和销毁 Context 下的 Pipeline 和各种 Valve。</li>
<li>停止和销毁 Context 的类加载器，以及类加载器加载的类文件资源。</li>
<li>启动 Context 容器，在这个过程中会重新创建前面四步被销毁的资源。</li>
</ol>
<p>在这个过程中，类加载器发挥着关键作用。一个 Context 容器对应一个类加载器，类加载器在销毁的过程中会把它加载的所有类也全部销毁。Context 容器在启动过程中，会创建一个新的类加载器来加载新的类文件。</p>
<p>在 Context 的 reload 方法里，并没有调用 Session 管理器的 distroy 方法，也就是说这个 Context 关联的 Session 是没有销毁的。你还需要注意的是，Tomcat 的热加载默认是关闭的，你需要在 conf 目录下的 Context.xml 文件中设置 reloadable 参数来开启这个功能，像下面这样：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Context <span class="attribute">reloadable</span>=<span class="string">&quot;true&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Tomcat-热部署"><a href="#Tomcat-热部署" class="headerlink" title="Tomcat 热部署"></a>Tomcat 热部署</h3><p>我们再来看看热部署，热部署跟热加载的本质区别是，热部署会重新部署 Web 应用，原来的 Context 对象会整个被销毁掉，因此这个 Context 所关联的一切资源都会被销毁，包括 Session。</p>
<p>那么 Tomcat 热部署又是由哪个容器来实现的呢？应该不是由 Context，因为热部署过程中 Context 容器被销毁了，那么这个重担就落在 Host 身上了，因为它是 Context 的父容器。</p>
<p>跟 Context 不一样，Host 容器并没有在 backgroundProcess 方法中实现周期性检测的任务，而是通过监听器 HostConfig 来实现的，HostConfig 就是前面提到的“周期事件”的监听器，那“周期事件”达到时，HostConfig 会做什么事呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lifecycleEvent</span><span class="params">(LifecycleEvent event)</span> &#123;</span><br><span class="line">    <span class="comment">// 执行 check 方法。</span></span><br><span class="line">    <span class="keyword">if</span> (event.getType().equals(Lifecycle.PERIODIC_EVENT)) &#123;</span><br><span class="line">        check();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它执行了 check 方法，我们接着来看 check 方法里做了什么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (host.getAutoDeploy()) &#123;</span><br><span class="line">        <span class="comment">// 检查这个 Host 下所有已经部署的 Web 应用</span></span><br><span class="line">        DeployedApplication[] apps =</span><br><span class="line">            deployed.values().toArray(<span class="keyword">new</span> <span class="title class_">DeployedApplication</span>[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; apps.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 检查 Web 应用目录是否有变化</span></span><br><span class="line">            checkResources(apps[i], <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行部署</span></span><br><span class="line">        deployApps();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实 HostConfig 会检查 webapps 目录下的所有 Web 应用：</p>
<ul>
<li>如果原来 Web 应用目录被删掉了，就把相应 Context 容器整个销毁掉。</li>
<li>是否有新的 Web 应用目录放进来了，或者有新的 WAR 包放进来了，就部署相应的 Web 应用。</li>
</ul>
<p>因此 HostConfig 做的事情都是比较“宏观”的，它不会去检查具体类文件或者资源文件是否有变化，而是检查 Web 应用目录级别的变化。</p>
<h2 id="Tomcat-的类加载机制"><a href="#Tomcat-的类加载机制" class="headerlink" title="Tomcat 的类加载机制"></a>Tomcat 的类加载机制</h2><p>Tomcat 的自定义类加载器 <code>WebAppClassLoader</code> 打破了双亲委派机制，它<strong>首先自己尝试去加载某个类，如果找不到再代理给父类加载器</strong>，其目的是优先加载 Web 应用自己定义的类。具体实现就是重写 ClassLoader 的两个方法：findClass 和 loadClass。</p>
<h3 id="findClass-方法"><a href="#findClass-方法" class="headerlink" title="findClass 方法"></a>findClass 方法</h3><p>我们先来看看 findClass 方法的实现，为了方便理解和阅读，我去掉了一些细节：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; clazz = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1. 先在 Web 应用目录下查找类</span></span><br><span class="line">            clazz = findClassInternal(name);</span><br><span class="line">    &#125;  <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> e;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//2. 如果在本地目录没有找到，交给父加载器去查找</span></span><br><span class="line">            clazz = <span class="built_in">super</span>.findClass(name);</span><br><span class="line">    &#125;  <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> e;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 如果父类也没找到，抛出 ClassNotFoundException</span></span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 findClass 方法里，主要有三个步骤：</p>
<ol>
<li>先在 Web 应用本地目录下查找要加载的类。</li>
<li>如果没有找到，交给父加载器去查找，它的父加载器就是上面提到的系统类加载器 AppClassLoader。</li>
<li>如何父加载器也没找到这个类，抛出 ClassNotFound 异常。</li>
</ol>
<h3 id="loadClass-方法"><a href="#loadClass-方法" class="headerlink" title="loadClass 方法"></a>loadClass 方法</h3><p>接着我们再来看 Tomcat 类加载器的 loadClass 方法的实现，同样我也去掉了一些细节：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; clazz = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 先在本地 cache 查找该类是否已经加载过</span></span><br><span class="line">        clazz = findLoadedClass0(name);</span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (resolve)</span><br><span class="line">                resolveClass(clazz);</span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 从系统类加载器的 cache 中查找是否加载过</span></span><br><span class="line">        clazz = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (resolve)</span><br><span class="line">                resolveClass(clazz);</span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 尝试用 ExtClassLoader 类加载器类加载，为什么？</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">javaseLoader</span> <span class="operator">=</span> getJavaseClassLoader();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clazz = javaseLoader.loadClass(name);</span><br><span class="line">            <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (resolve)</span><br><span class="line">                    resolveClass(clazz);</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// Ignore</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 尝试在本地目录搜索 class 并加载</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clazz = findClass(name);</span><br><span class="line">            <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (resolve)</span><br><span class="line">                    resolveClass(clazz);</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// Ignore</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 尝试用系统类加载器 (也就是 AppClassLoader) 来加载</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                clazz = Class.forName(name, <span class="literal">false</span>, parent);</span><br><span class="line">                <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (resolve)</span><br><span class="line">                        resolveClass(clazz);</span><br><span class="line">                    <span class="keyword">return</span> clazz;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6. 上述过程都加载失败，抛出异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>loadClass 方法稍微复杂一点，主要有六个步骤：</p>
<ol>
<li>先在本地 Cache 查找该类是否已经加载过，也就是说 Tomcat 的类加载器是否已经加载过这个类。</li>
<li>如果 Tomcat 类加载器没有加载过这个类，再看看系统类加载器是否加载过。</li>
<li>如果都没有，就让<strong>ExtClassLoader</strong>去加载，这一步比较关键，目的<strong>防止 Web 应用自己的类覆盖 JRE 的核心类</strong>。因为 Tomcat 需要打破双亲委派机制，假如 Web 应用里自定义了一个叫 Object 的类，如果先加载这个 Object 类，就会覆盖 JRE 里面的那个 Object 类，这就是为什么 Tomcat 的类加载器会优先尝试用 ExtClassLoader 去加载，因为 ExtClassLoader 会委托给 BootstrapClassLoader 去加载，BootstrapClassLoader 发现自己已经加载了 Object 类，直接返回给 Tomcat 的类加载器，这样 Tomcat 的类加载器就不会去加载 Web 应用下的 Object 类了，也就避免了覆盖 JRE 核心类的问题。</li>
<li>如果 ExtClassLoader 加载器加载失败，也就是说 JRE 核心类中没有这类，那么就在本地 Web 应用目录下查找并加载。</li>
<li>如果本地目录下没有这个类，说明不是 Web 应用自己定义的类，那么由系统类加载器去加载。这里请你注意，Web 应用是通过<code>Class.forName</code>调用交给系统类加载器的，因为<code>Class.forName</code>的默认加载器就是系统类加载器。</li>
<li>如果上述加载过程全部失败，抛出 ClassNotFound 异常。</li>
</ol>
<p>从上面的过程我们可以看到，Tomcat 的类加载器打破了双亲委派机制，没有一上来就直接委托给父加载器，而是先在本地目录下加载，为了避免本地目录下的类覆盖 JRE 的核心类，先尝试用 JVM 扩展类加载器 ExtClassLoader 去加载。那为什么不先用系统类加载器 AppClassLoader 去加载？很显然，如果是这样的话，那就变成双亲委派机制了，这就是 Tomcat 类加载器的巧妙之处。</p>
<h3 id="Tomcat-实现应用隔离"><a href="#Tomcat-实现应用隔离" class="headerlink" title="Tomcat 实现应用隔离"></a>Tomcat 实现应用隔离</h3><p>Tomcat 作为 Web 容器，需要解决以下问题：</p>
<ol>
<li>如果在 Tomcat 中运行了两个 Web 应用程序，两个 Web 应用中有同名的 Servlet，但是功能不同，Tomcat 需要同时加载和管理这两个同名的 Servlet 类，保证它们不会冲突，因此 Web 应用之间的类需要隔离。</li>
<li>两个 Web 应用都依赖同一个第三方的 JAR 包，比如 Spring，那 Spring 的 JAR 包被加载到内存后，Tomcat 要保证这两个 Web 应用能够共享，也就是说 Spring 的 JAR 包只被加载一次，否则随着依赖的第三方 JAR 包增多，JVM 的内存会膨胀。</li>
<li>需要隔离 Tomcat 本身的类和 Web 应用的类。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20201130141536.png" alt="img"></p>
<h4 id="WebAppClassLoader"><a href="#WebAppClassLoader" class="headerlink" title="WebAppClassLoader"></a>WebAppClassLoader</h4><p>针对第一个问题：</p>
<p>如果使用 JVM 默认 AppClassLoader 来加载 Web 应用，AppClassLoader 只能加载一个 Servlet 类，在加载第二个同名 Servlet 类时，AppClassLoader 会返回第一个 Servlet 类的 Class 实例，这是因为在 AppClassLoader 看来，同名的 Servlet 类只被加载一次。</p>
<p>Tomcat 的解决方案是自定义一个类加载器 WebAppClassLoader， 并且给每个 Web 应用创建一个类加载器实例。我们知道，Context 容器组件对应一个 Web 应用，因此，每个 Context 容器负责创建和维护一个 WebAppClassLoader 加载器实例。这背后的原理是，<strong>不同的加载器实例加载的类被认为是不同的类</strong>，即使它们的类名相同。这就相当于在 Java 虚拟机内部创建了一个个相互隔离的 Java 类空间，每一个 Web 应用都有自己的类空间，Web 应用之间通过各自的类加载器互相隔离。</p>
<h4 id="SharedClassLoader"><a href="#SharedClassLoader" class="headerlink" title="SharedClassLoader"></a>SharedClassLoader</h4><p>针对第二个问题：</p>
<p>本质需求是两个 Web 应用之间怎么共享库类，并且不能重复加载相同的类。我们知道，在双亲委派机制里，各个子加载器都可以通过父加载器去加载类，那么把需要共享的类放到父加载器的加载路径下不就行了吗，应用程序也正是通过这种方式共享 JRE 的核心类。因此 Tomcat 的设计者又加了一个类加载器 SharedClassLoader，作为 WebAppClassLoader 的父加载器，专门来加载 Web 应用之间共享的类。如果 WebAppClassLoader 自己没有加载到某个类，就会委托父加载器 SharedClassLoader 去加载这个类，SharedClassLoader 会在指定目录下加载共享类，之后返回给 WebAppClassLoader，这样共享的问题就解决了。</p>
<h4 id="CatalinaClassloader"><a href="#CatalinaClassloader" class="headerlink" title="CatalinaClassloader"></a>CatalinaClassloader</h4><p>如何隔离 Tomcat 本身的类和 Web 应用的类？</p>
<p>要共享可以通过父子关系，要隔离那就需要兄弟关系了。兄弟关系就是指两个类加载器是平行的，它们可能拥有同一个父加载器，但是两个兄弟类加载器加载的类是隔离的。基于此 Tomcat 又设计一个类加载器 CatalinaClassloader，专门来加载 Tomcat 自身的类。这样设计有个问题，那 Tomcat 和各 Web 应用之间需要共享一些类时该怎么办呢？</p>
<h4 id="CommonClassLoader"><a href="#CommonClassLoader" class="headerlink" title="CommonClassLoader"></a>CommonClassLoader</h4><p>老办法，还是再增加一个 CommonClassLoader，作为 CatalinaClassloader 和 SharedClassLoader 的父加载器。CommonClassLoader 能加载的类都可以被 CatalinaClassLoader 和 SharedClassLoader 使用，而 CatalinaClassLoader 和 SharedClassLoader 能加载的类则与对方相互隔离。WebAppClassLoader 可以使用 SharedClassLoader 加载到的类，但各个 WebAppClassLoader 实例之间相互隔离。</p>
<h2 id="Tomcat-实现-Servlet-规范"><a href="#Tomcat-实现-Servlet-规范" class="headerlink" title="Tomcat 实现 Servlet 规范"></a>Tomcat 实现 Servlet 规范</h2><p>Servlet 容器最重要的任务就是创建 Servlet 的实例并且调用 Servlet。</p>
<p>一个 Web 应用里往往有多个 Servlet，而在 Tomcat 中一个 Web 应用对应一个 Context 容器，也就是说一个 Context 容器需要管理多个 Servlet 实例。但 Context 容器并不直接持有 Servlet 实例，而是通过子容器 Wrapper 来管理 Servlet，你可以把 Wrapper 容器看作是 Servlet 的包装。</p>
<p>为什么需要 Wrapper 呢？Context 容器直接维护一个 Servlet 数组不就行了吗？这是因为 Servlet 不仅仅是一个类实例，它还有相关的配置信息，比如它的 URL 映射、它的初始化参数，因此设计出了一个包装器，把 Servlet 本身和它相关的数据包起来，没错，这就是面向对象的思想。</p>
<p>除此以外，Servlet 规范中还有两个重要特性：Listener 和 Filter，Tomcat 也需要创建它们的实例，并在合适的时机去调用它们的方法。</p>
<h3 id="Servlet-管理"><a href="#Servlet-管理" class="headerlink" title="Servlet 管理"></a>Servlet 管理</h3><p>Tomcat 是用 Wrapper 容器来管理 Servlet 的，那 Wrapper 容器具体长什么样子呢？我们先来看看它里面有哪些关键的成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="type">Servlet</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>它拥有一个 Servlet 实例，并且 Wrapper 通过 loadServlet 方法来实例化 Servlet。为了方便你阅读，我简化了代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Servlet <span class="title function_">loadServlet</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    Servlet servlet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 创建一个 Servlet 实例</span></span><br><span class="line">    servlet = (Servlet) instanceManager.newInstance(servletClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 调用了 Servlet 的 init 方法，这是 Servlet 规范要求的</span></span><br><span class="line">    initServlet(servlet);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> servlet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实 loadServlet 主要做了两件事：创建 Servlet 的实例，并且调用 Servlet 的 init 方法，因为这是 Servlet 规范要求的。</p>
<p>那接下来的问题是，什么时候会调到这个 loadServlet 方法呢？为了加快系统的启动速度，我们往往会采取资源延迟加载的策略，Tomcat 也不例外，默认情况下 Tomcat 在启动时不会加载你的 Servlet，除非你把 Servlet 的<code>loadOnStartup</code>参数设置为<code>true</code>。</p>
<p>这里还需要你注意的是，虽然 Tomcat 在启动时不会创建 Servlet 实例，但是会创建 Wrapper 容器，就好比尽管枪里面还没有子弹，先把枪造出来。那子弹什么时候造呢？是真正需要开枪的时候，也就是说有请求来访问某个 Servlet 时，这个 Servlet 的实例才会被创建。</p>
<p>那 Servlet 是被谁调用的呢？我们回忆一下专栏前面提到过 Tomcat 的 Pipeline-Valve 机制，每个容器组件都有自己的 Pipeline，每个 Pipeline 中有一个 Valve 链，并且每个容器组件有一个 BasicValve（基础阀）。Wrapper 作为一个容器组件，它也有自己的 Pipeline 和 BasicValve，Wrapper 的 BasicValve 叫 <strong>StandardWrapperValve</strong>。</p>
<p>你可以想到，当请求到来时，Context 容器的 BasicValve 会调用 Wrapper 容器中 Pipeline 中的第一个 Valve，然后会调用到 StandardWrapperValve。我们先来看看它的 invoke 方法是如何实现的，同样为了方便你阅读，我简化了代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Request request, Response response)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 实例化 Servlet</span></span><br><span class="line">    servlet = wrapper.allocate();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 给当前请求创建一个 Filter 链</span></span><br><span class="line">    <span class="type">ApplicationFilterChain</span> <span class="variable">filterChain</span> <span class="operator">=</span></span><br><span class="line">        ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3. 调用这个 Filter 链，Filter 链中的最后一个 Filter 会调用 Servlet</span></span><br><span class="line">   filterChain.doFilter(request.getRequest(), response.getResponse());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StandardWrapperValve 的 invoke 方法比较复杂，去掉其他异常处理的一些细节，本质上就是三步：</p>
<ul>
<li>第一步，创建 Servlet 实例；</li>
<li>第二步，给当前请求创建一个 Filter 链；</li>
<li>第三步，调用这个 Filter 链。</li>
</ul>
<p>你可能会问，为什么需要给每个请求创建一个 Filter 链？这是因为每个请求的请求路径都不一样，而 Filter 都有相应的路径映射，因此不是所有的 Filter 都需要来处理当前的请求，我们需要根据请求的路径来选择特定的一些 Filter 来处理。</p>
<p>第二个问题是，为什么没有看到调到 Servlet 的 service 方法？这是因为 Filter 链的 doFilter 方法会负责调用 Servlet，具体来说就是 Filter 链中的最后一个 Filter 会负责调用 Servlet。</p>
<p>接下来我们来看 Filter 的实现原理。</p>
<h3 id="Filter-管理"><a href="#Filter-管理" class="headerlink" title="Filter 管理"></a>Filter 管理</h3><p>我们知道，跟 Servlet 一样，Filter 也可以在<code>web.xml</code>文件里进行配置，不同的是，Filter 的作用域是整个 Web 应用，因此 Filter 的实例是在 Context 容器中进行管理的，Context 容器用 Map 集合来保存 Filter。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, FilterDef&gt; filterDefs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>那上面提到的 Filter 链又是什么呢？Filter 链的存活期很短，它是跟每个请求对应的。一个新的请求来了，就动态创建一个 FIlter 链，请求处理完了，Filter 链也就被回收了。理解它的原理也非常关键，我们还是来看看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ApplicationFilterChain</span> <span class="keyword">implements</span> <span class="title class_">FilterChain</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Filter 链中有 Filter 数组，这个好理解</span></span><br><span class="line">  <span class="keyword">private</span> ApplicationFilterConfig[] filters = <span class="keyword">new</span> <span class="title class_">ApplicationFilterConfig</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Filter 链中的当前的调用位置</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 总共有多少了 Filter</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 每个 Filter 链对应一个 Servlet，也就是它要调用的 Servlet</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">Servlet</span> <span class="variable">servlet</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse res)</span> &#123;</span><br><span class="line">        internalDoFilter(request,response);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">internalDoFilter</span><span class="params">(ServletRequest req,</span></span><br><span class="line"><span class="params">                                ServletResponse res)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个 Filter 链在内部维护了一个 Filter 数组</span></span><br><span class="line">    <span class="keyword">if</span> (pos &lt; n) &#123;</span><br><span class="line">        <span class="type">ApplicationFilterConfig</span> <span class="variable">filterConfig</span> <span class="operator">=</span> filters[pos++];</span><br><span class="line">        <span class="type">Filter</span> <span class="variable">filter</span> <span class="operator">=</span> filterConfig.getFilter();</span><br><span class="line"></span><br><span class="line">        filter.doFilter(request, response, <span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    servlet.service(request, response);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 ApplicationFilterChain 的源码我们可以看到几个关键信息：</p>
<ul>
<li>Filter 链中除了有 Filter 对象的数组，还有一个整数变量 pos，这个变量用来记录当前被调用的 Filter 在数组中的位置。</li>
<li>Filter 链中有个 Servlet 实例，这个好理解，因为上面提到了，每个 Filter 链最后都会调到一个 Servlet。</li>
<li>Filter 链本身也实现了 doFilter 方法，直接调用了一个内部方法 internalDoFilter。</li>
<li>internalDoFilter 方法的实现比较有意思，它做了一个判断，如果当前 Filter 的位置小于 Filter 数组的长度，也就是说 Filter 还没调完，就从 Filter 数组拿下一个 Filter，调用它的 doFilter 方法。否则，意味着所有 Filter 都调到了，就调用 Servlet 的 service 方法。</li>
</ul>
<p>但问题是，方法体里没看到循环，谁在不停地调用 Filter 链的 doFIlter 方法呢？Filter 是怎么依次调到的呢？</p>
<p>答案是<strong>Filter 本身的 doFilter 方法会调用 Filter 链的 doFilter 方法</strong>，我们还是来看看代码就明白了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response,</span></span><br><span class="line"><span class="params">        FilterChain chain)</span>&#123;</span><br><span class="line"></span><br><span class="line">          ...</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 调用 Filter 的方法</span></span><br><span class="line">          chain.doFilter(request, response);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>注意 Filter 的 doFilter 方法有个关键参数 FilterChain，就是 Filter 链。并且每个 Filter 在实现 doFilter 时，必须要调用 Filter 链的 doFilter 方法，而 Filter 链中保存当前 FIlter 的位置，会调用下一个 FIlter 的 doFilter 方法，这样链式调用就完成了。</p>
<p>Filter 链跟 Tomcat 的 Pipeline-Valve 本质都是责任链模式，但是在具体实现上稍有不同，你可以细细体会一下。</p>
<h3 id="Listener-管理"><a href="#Listener-管理" class="headerlink" title="Listener 管理"></a>Listener 管理</h3><p>我们接着聊 Servlet 规范里 Listener。跟 Filter 一样，Listener 也是一种扩展机制，你可以监听容器内部发生的事件，主要有两类事件：</p>
<ul>
<li>第一类是生命状态的变化，比如 Context 容器启动和停止、Session 的创建和销毁。</li>
<li>第二类是属性的变化，比如 Context 容器某个属性值变了、Session 的某个属性值变了以及新的请求来了等。</li>
</ul>
<p>我们可以在<code>web.xml</code>配置或者通过注解的方式来添加监听器，在监听器里实现我们的业务逻辑。对于 Tomcat 来说，它需要读取配置文件，拿到监听器类的名字，实例化这些类，并且在合适的时机调用这些监听器的方法。</p>
<p>Tomcat 是通过 Context 容器来管理这些监听器的。Context 容器将两类事件分开来管理，分别用不同的集合来存放不同类型事件的监听器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听属性值变化的监听器</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Object&gt; applicationEventListenersList = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听生命事件的监听器</span></span><br><span class="line"><span class="keyword">private</span> Object applicationLifecycleListenersObjects[] = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>剩下的事情就是触发监听器了，比如在 Context 容器的启动方法里，就触发了所有的 ServletContextListener：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 拿到所有的生命周期监听器</span></span><br><span class="line">Object instances[] = getApplicationLifecycleListeners();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; instances.length; i++) &#123;</span><br><span class="line">   <span class="comment">//2. 判断 Listener 的类型是不是 ServletContextListener</span></span><br><span class="line">   <span class="keyword">if</span> (!(instances[i] <span class="keyword">instanceof</span> ServletContextListener))</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3. 触发 Listener 的方法</span></span><br><span class="line">   <span class="type">ServletContextListener</span> <span class="variable">lr</span> <span class="operator">=</span> (ServletContextListener) instances[i];</span><br><span class="line">   lr.contextInitialized(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，这里的 ServletContextListener 接口是一种留给用户的扩展机制，用户可以实现这个接口来定义自己的监听器，监听 Context 容器的启停事件。Spring 就是这么做的。ServletContextListener 跟 Tomcat 自己的生命周期事件 LifecycleListener 是不同的。LifecycleListener 定义在生命周期管理组件中，由基类 LifeCycleBase 统一管理。</p>
<h2 id="Tomcat-支持异步-Servlet"><a href="#Tomcat-支持异步-Servlet" class="headerlink" title="Tomcat 支持异步 Servlet"></a>Tomcat 支持异步 Servlet</h2><h3 id="异步示例"><a href="#异步示例" class="headerlink" title="异步示例"></a>异步示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &#123;&quot;/async&quot;&#125;, asyncSupported = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Web 应用线程池，用来处理异步 Servlet</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 调用 startAsync 或者异步上下文</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">AsyncContext</span> <span class="variable">ctx</span> <span class="operator">=</span> req.startAsync();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 用线程池来执行耗时操作</span></span><br><span class="line">        executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 在这里做耗时的操作</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ctx.getResponse().getWriter().println(<span class="string">&quot;Handling Async Servlet&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;&#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//3. 异步 Servlet 处理完了调用异步上下文的 complete 方法</span></span><br><span class="line">                ctx.complete();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有三个要点：</p>
<ol>
<li>通过注解的方式来注册 Servlet，除了 @WebServlet 注解，还需要加上 asyncSupported&#x3D;true 的属性，表明当前的 Servlet 是一个异步 Servlet。</li>
<li>Web 应用程序需要调用 Request 对象的 startAsync 方法来拿到一个异步上下文 AsyncContext。这个上下文保存了请求和响应对象。</li>
<li>Web 应用需要开启一个新线程来处理耗时的操作，处理完成后需要调用 AsyncContext 的 complete 方法。目的是告诉 Tomcat，请求已经处理完成。</li>
</ol>
<p>这里请你注意，虽然异步 Servlet 允许用更长的时间来处理请求，但是也有超时限制的，默认是 30 秒，如果 30 秒内请求还没处理完，Tomcat 会触发超时机制，向浏览器返回超时错误，如果这个时候你的 Web 应用再调用<code>ctx.complete</code>方法，会得到一个 IllegalStateException 异常。</p>
<h3 id="异步-Servlet-原理"><a href="#异步-Servlet-原理" class="headerlink" title="异步 Servlet 原理"></a>异步 Servlet 原理</h3><p>通过上面的例子，相信你对 Servlet 的异步实现有了基本的理解。要理解 Tomcat 在这个过程都做了什么事情，关键就是要弄清楚<code>req.startAsync</code>方法和<code>ctx.complete</code>方法都做了什么。</p>
<h4 id="startAsync-方法"><a href="#startAsync-方法" class="headerlink" title="startAsync 方法"></a>startAsync 方法</h4><p>startAsync 方法其实就是创建了一个异步上下文 AsyncContext 对象，AsyncContext 对象的作用是保存请求的中间信息，比如 Request 和 Response 对象等上下文信息。你来思考一下为什么需要保存这些信息呢？</p>
<p>这是因为 Tomcat 的工作线程在<code>Request.startAsync</code>调用之后，就直接结束回到线程池中了，线程本身不会保存任何信息。也就是说一个请求到服务端，执行到一半，你的 Web 应用正在处理，这个时候 Tomcat 的工作线程没了，这就需要有个缓存能够保存原始的 Request 和 Response 对象，而这个缓存就是 AsyncContext。</p>
<p>有了 AsyncContext，你的 Web 应用通过它拿到 request 和 response 对象，拿到 Request 对象后就可以读取请求信息，请求处理完了还需要通过 Response 对象将 HTTP 响应发送给浏览器。</p>
<p>除了创建 AsyncContext 对象，startAsync 还需要完成一个关键任务，那就是告诉 Tomcat 当前的 Servlet 处理方法返回时，不要把响应发到浏览器，因为这个时候，响应还没生成呢；并且不能把 Request 对象和 Response 对象销毁，因为后面 Web 应用还要用呢。</p>
<p>在 Tomcat 中，负责 flush 响应数据的是 CoyoteAdaptor，它还会销毁 Request 对象和 Response 对象，因此需要通过某种机制通知 CoyoteAdaptor，具体来说是通过下面这行代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.request.getCoyoteRequest().action(ActionCode.ASYNC_START, <span class="built_in">this</span>);</span><br></pre></td></tr></table></figure>

<p>你可以把它理解为一个 Callback，在这个 action 方法里设置了 Request 对象的状态，设置它为一个异步 Servlet 请求。</p>
<p>我们知道连接器是调用 CoyoteAdapter 的 service 方法来处理请求的，而 CoyoteAdapter 会调用容器的 service 方法，当容器的 service 方法返回时，CoyoteAdapter 判断当前的请求是不是异步 Servlet 请求，如果是，就不会销毁 Request 和 Response 对象，也不会把响应信息发到浏览器。你可以通过下面的代码理解一下，这是 CoyoteAdapter 的 service 方法，我对它进行了简化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(org.apache.coyote.Request req, org.apache.coyote.Response res)</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 调用容器的 service 方法处理请求</span></span><br><span class="line">    connector.getService().getContainer().getPipeline().</span><br><span class="line">           getFirst().invoke(request, response);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果是异步 Servlet 请求，仅仅设置一个标志，</span></span><br><span class="line">   <span class="comment">// 否则说明是同步 Servlet 请求，就将响应数据刷到浏览器</span></span><br><span class="line">    <span class="keyword">if</span> (request.isAsync()) &#123;</span><br><span class="line">        async = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        request.finishRequest();</span><br><span class="line">        response.finishResponse();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果不是异步 Servlet 请求，就销毁 Request 对象和 Response 对象</span></span><br><span class="line">    <span class="keyword">if</span> (!async) &#123;</span><br><span class="line">        request.recycle();</span><br><span class="line">        response.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，当 CoyoteAdaptor 的 service 方法返回到 ProtocolHandler 组件时，ProtocolHandler 判断返回值，如果当前请求是一个异步 Servlet 请求，它会把当前 Socket 的协议处理者 Processor 缓存起来，将 SocketWrapper 对象和相应的 Processor 存到一个 Map 数据结构里。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;S,Processor&gt; connections = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>之所以要缓存是因为这个请求接下来还要接着处理，还是由原来的 Processor 来处理，通过 SocketWrapper 就能从 Map 里找到相应的 Processor。</p>
<h4 id="complete-方法"><a href="#complete-方法" class="headerlink" title="complete 方法"></a>complete 方法</h4><p>接着我们再来看关键的<code>ctx.complete</code>方法，当请求处理完成时，Web 应用调用这个方法。那么这个方法做了些什么事情呢？最重要的就是把响应数据发送到浏览器。</p>
<p>这件事情不能由 Web 应用线程来做，也就是说<code>ctx.complete</code>方法不能直接把响应数据发送到浏览器，因为这件事情应该由 Tomcat 线程来做，但具体怎么做呢？</p>
<p>我们知道，连接器中的 Endpoint 组件检测到有请求数据达到时，会创建一个 SocketProcessor 对象交给线程池去处理，因此 Endpoint 的通信处理和具体请求处理在两个线程里运行。</p>
<p>在异步 Servlet 的场景里，Web 应用通过调用<code>ctx.complete</code>方法时，也可以生成一个新的 SocketProcessor 任务类，交给线程池处理。对于异步 Servlet 请求来说，相应的 Socket 和协议处理组件 Processor 都被缓存起来了，并且这些对象都可以通过 Request 对象拿到。</p>
<p>讲到这里，你可能已经猜到<code>ctx.complete</code>是如何实现的了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">complete</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 检查状态合法性，我们先忽略这句</span></span><br><span class="line">    check();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 Request 对象的 action 方法，其实就是通知连接器，这个异步请求处理完了</span></span><br><span class="line">request.getCoyoteRequest().action(ActionCode.ASYNC_COMPLETE, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到 complete 方法调用了 Request 对象的 action 方法。而在 action 方法里，则是调用了 Processor 的 processSocketEvent 方法，并且传入了操作码 OPEN_READ。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> ASYNC_COMPLETE: &#123;</span><br><span class="line">    clearDispatches();</span><br><span class="line">    <span class="keyword">if</span> (asyncStateMachine.asyncComplete()) &#123;</span><br><span class="line">        processSocketEvent(SocketEvent.OPEN_READ, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们接着看 processSocketEvent 方法，它调用 SocketWrapper 的 processSocket 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processSocketEvent</span><span class="params">(SocketEvent event, <span class="type">boolean</span> dispatch)</span> &#123;</span><br><span class="line">    SocketWrapperBase&lt;?&gt; socketWrapper = getSocketWrapper();</span><br><span class="line">    <span class="keyword">if</span> (socketWrapper != <span class="literal">null</span>) &#123;</span><br><span class="line">        socketWrapper.processSocket(event, dispatch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 SocketWrapper 的 processSocket 方法会创建 SocketProcessor 任务类，并通过 Tomcat 线程池来处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">processSocket</span><span class="params">(SocketWrapperBase&lt;S&gt; socketWrapper,</span></span><br><span class="line"><span class="params">        SocketEvent event, <span class="type">boolean</span> dispatch)</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (socketWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      SocketProcessorBase&lt;S&gt; sc = processorCache.pop();</span><br><span class="line">      <span class="keyword">if</span> (sc == <span class="literal">null</span>) &#123;</span><br><span class="line">          sc = createSocketProcessor(socketWrapper, event);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          sc.reset(socketWrapper, event);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 线程池运行</span></span><br><span class="line">      <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> getExecutor();</span><br><span class="line">      <span class="keyword">if</span> (dispatch &amp;&amp; executor != <span class="literal">null</span>) &#123;</span><br><span class="line">          executor.execute(sc);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          sc.run();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请你注意 createSocketProcessor 函数的第二个参数是 SocketEvent，这里我们传入的是 OPEN_READ。通过这个参数，我们就能控制 SocketProcessor 的行为，因为我们不需要再把请求发送到容器进行处理，只需要向浏览器端发送数据，并且重新在这个 Socket 上监听新的请求就行了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><strong>官方</strong><ul>
<li><a target="_blank" rel="noopener" href="http://tomcat.apache.org/">Tomcat 官方网站</a></li>
<li><a target="_blank" rel="noopener" href="http://wiki.apache.org/tomcat/FrontPage">Tomcat Wiki</a></li>
<li><a target="_blank" rel="noopener" href="http://tomee.apache.org/">Tomee 官方网站</a></li>
</ul>
</li>
<li><strong>教程</strong><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100027701">深入拆解 Tomcat &amp; Jetty</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/12/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/47/">47</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/14/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2015 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">李狗蛋</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">3.5m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">53:28</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/yiyirushi/" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.1/dist/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  




<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>

</body>
</html>
