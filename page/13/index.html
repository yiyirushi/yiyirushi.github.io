<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/uploads/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/uploads/favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.ligoudan.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="天气不错哇，你看这大冰雹下得">
<meta property="og:type" content="website">
<meta property="og:title" content="LIGOUDAN">
<meta property="og:url" content="https://www.ligoudan.cn/page/13/index.html">
<meta property="og:site_name" content="LIGOUDAN">
<meta property="og:description" content="天气不错哇，你看这大冰雹下得">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="李狗蛋">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://www.ligoudan.cn/page/13/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/13/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>LIGOUDAN</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">LIGOUDAN</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">好好学习，天天向上</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">326</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">137</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">462</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="李狗蛋"
      src="/uploads/ligoudan.png">
  <p class="site-author-name" itemprop="name">李狗蛋</p>
  <div class="site-description" itemprop="description">天气不错哇，你看这大冰雹下得</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">462</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">137</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">326</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/yiyirushi" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yiyirushi" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yuanhaohoo@163.com" title="E-Mail → mailto:yuanhaohoo@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/cd38ec/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/cd38ec/" class="post-title-link" itemprop="url">JavaMail 快速入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-17 22:34:30" itemprop="dateCreated datePublished" datetime="2022-02-17T22:34:30+08:00">2022-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E5%B7%A5%E5%85%B7/%E5%85%B6%E4%BB%96/" itemprop="url" rel="index"><span itemprop="name">其他</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>11 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="JavaMail-快速入门"><a href="#JavaMail-快速入门" class="headerlink" title="JavaMail 快速入门"></a>JavaMail 快速入门</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="邮件相关的标准"><a href="#邮件相关的标准" class="headerlink" title="邮件相关的标准"></a>邮件相关的标准</h3><p>厂商所提供的 JavaMail 服务程序可以有选择地实现某些邮件协议，常见的邮件协议包括：</p>
<ul>
<li><code>SMTP(Simple Mail Transfer Protocol)</code> ：即简单邮件传输协议，它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。</li>
<li><code>POP3(Post Office Protocol - Version 3)</code> ：即邮局协议版本 3 ，用于接收电子邮件的标准协议。</li>
<li><code>IMAP(Internet Mail Access Protocol)</code> ：即 Internet 邮件访问协议。是 POP3 的替代协议。</li>
</ul>
<p>这三种协议都有对应 SSL 加密传输的协议，分别是 <strong>SMTPS</strong>， <strong>POP3S</strong>和 <strong>IMAPS</strong>。</p>
<p><code>MIME(Multipurpose Internet Mail Extensions)</code> ：即多用途因特网邮件扩展标准。它不是邮件传输协议。但对传输内容的消息、附件及其它的内容定义了格式。</p>
<h3 id="JavaMail-简介"><a href="#JavaMail-简介" class="headerlink" title="JavaMail 简介"></a>JavaMail 简介</h3><p>JavaMail 是由 Sun 发布的用来处理 email 的 API 。它并没有包含在 Java SE 中，而是作为 Java EE 的一部分。</p>
<ul>
<li><code>mail.jar</code> ：此 JAR 文件包含 JavaMail API 和 Sun 提供的 SMTP 、 IMAP 和 POP3 服务提供程序；</li>
<li><code>activation.jar</code> ：此 JAR 文件包含 JAF API 和 Sun 的实现。</li>
</ul>
<p>JavaMail 包中用于处理电子邮件的核心类是： <code>Properties</code> 、 <code>Session</code> 、 <code>Message</code> 、 <code>Address</code> 、 <code>Authenticator</code> 、 <code>Transport</code> 、 <code>Store</code> 等。</p>
<h3 id="邮件传输过程"><a href="#邮件传输过程" class="headerlink" title="邮件传输过程"></a>邮件传输过程</h3><p>如上图，电子邮件的处理步骤如下：</p>
<ol>
<li>创建一个 Session 对象。</li>
<li>Session 对象创建一个 Transport 对象 &#x2F;Store 对象，用来发送 &#x2F; 保存邮件。</li>
<li>Transport 对象 &#x2F;Store 对象连接邮件服务器。</li>
<li>Transport 对象 &#x2F;Store 对象创建一个 Message 对象 ( 也就是邮件内容 ) 。</li>
<li>Transport 对象发送邮件； Store 对象获取邮箱的邮件。</li>
</ol>
<h3 id="Message-结构"><a href="#Message-结构" class="headerlink" title="Message 结构"></a>Message 结构</h3><ul>
<li><code>MimeMessage</code> 类：代表整封邮件。</li>
<li><code>MimeBodyPart</code> 类：代表邮件的一个 MIME 信息。</li>
<li><code>MimeMultipart</code> 类：代表一个由多个 MIME 信息组合成的组合 MIME 信息。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/3101171-948230d2f5c7a620.png" alt="img"></p>
<h2 id="JavaMail-的核心类"><a href="#JavaMail-的核心类" class="headerlink" title="JavaMail 的核心类"></a>JavaMail 的核心类</h2><p>JavaMail 对收发邮件进行了高级的抽象，形成了一些关键的的接口和类，它们构成了程序的基础，下面我们分别来了解一下这些最常见的对象。</p>
<h3 id="java-util-Properties-类（属性对象）"><a href="#java-util-Properties-类（属性对象）" class="headerlink" title="java.util.Properties 类（属性对象）"></a>java.util.Properties 类（属性对象）</h3><p>java.util.Properties 类代表一组属性集合。</p>
<p>它的每一个键和值都是 String <strong>类型。</strong></p>
<p>由于 JavaMail 需要和邮件服务器进行通信，这就要求程序提供许多诸如服务器地址、端口、用户名、密码等信息， JavaMail 通过 Properties 对象封装这些属性信息。</p>
<p>例： 如下面的代码封装了几个属性信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">prop.setProperty(<span class="string">&quot;mail.debug&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">prop.setProperty(<span class="string">&quot;mail.host&quot;</span>, <span class="string">&quot;[email protected]&quot;</span>);</span><br><span class="line">prop.setProperty(<span class="string">&quot;mail.transport.protocol&quot;</span>, <span class="string">&quot;smtp&quot;</span>);</span><br><span class="line">prop.setProperty(<span class="string">&quot;mail.smtp.auth&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>针对不同的的邮件协议， JavaMail 规定了服务提供者必须支持一系列属性，</p>
<p>下表是一些常见属性（属性值都以 String 类型进行设置，属性类型栏仅表示属性是如何被解析的）：</p>
<table>
<thead>
<tr>
<th>关键词</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>mail.debug</td>
<td>boolean</td>
<td>debug 开关。</td>
</tr>
<tr>
<td>mail.host</td>
<td>String</td>
<td>指定发送、接收邮件的默认邮箱服务器。</td>
</tr>
<tr>
<td>mail.store.protocol</td>
<td>String</td>
<td>指定接收邮件的协议。</td>
</tr>
<tr>
<td>mail.transport.protocol</td>
<td>String</td>
<td>指定发送邮件的协议。</td>
</tr>
<tr>
<td>mail.debug.auth</td>
<td>boolean</td>
<td>debug 输出中是否包含认证命令。默认是 false 。</td>
</tr>
</tbody></table>
<p>详情请参考官方 API 文档：</p>
<p><a target="_blank" rel="noopener" href="https://javamail.java.net/nonav/docs/api/">https://javamail.java.net/nonav/docs/api/</a> 。</p>
<h3 id="javax-mail-Session-类（会话对象）"><a href="#javax-mail-Session-类（会话对象）" class="headerlink" title="javax.mail.Session 类（会话对象）"></a>javax.mail.Session 类（会话对象）</h3><p><code>Session</code> 表示一个邮件会话。</p>
<p>Session 的主要作用包括两个方面：</p>
<ul>
<li>接收各种配置属性信息：通过 Properties 对象设置的属性信息；</li>
<li>初始化 JavaMail 环境：根据 JavaMail 的配置文件，初始化 JavaMail 环境，以便通过 Session 对象创建其他重要类的实例。</li>
</ul>
<p>JavaMail 在 Jar 包的 META-INF 目录下，通过以下文件提供了基本配置信息，以便 session 能够根据这个配置文件加载提供者的实现类：</p>
<ul>
<li>javamail.default.providers</li>
<li>javamail.default.address.map</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/3101171-b59382c69385df45.png" alt="img"></p>
<p><strong>例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">props.setProperty(<span class="string">&quot;mail.transport.protocol&quot;</span>, <span class="string">&quot;smtp&quot;</span>);</span><br><span class="line"><span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> Session.getInstance(props);</span><br></pre></td></tr></table></figure>

<h3 id="javax-mail-Transport-类（邮件传输）"><a href="#javax-mail-Transport-类（邮件传输）" class="headerlink" title="javax.mail.Transport 类（邮件传输）"></a>javax.mail.Transport 类（邮件传输）</h3><p>邮件操作只有发送或接收两种处理方式。</p>
<p>JavaMail 将这两种不同操作描述为传输（ javax.mail.Transport ）和存储（ javax.mail.Store ），传输对应邮件的发送，而存储对应邮件的接收。</p>
<ul>
<li><code>getTransport</code> - Session 类中的 **getTransport()**有多个重载方法，可以用来创建 Transport 对象。</li>
<li><code>connect</code> - 如果设置了认证命令—— mail.smtp.auth ，那么使用 Transport 类的 connect 方法连接服务器时，则必须加上用户名和密码。</li>
<li><code>sendMessage</code> - Transport 类的 sendMessage 方法用来发送邮件消息。</li>
<li><code>close</code> - Transport 类的 close 方法用来关闭和邮件服务器的连接。</li>
</ul>
<h3 id="javax-mail-Store-类（邮件存储-）"><a href="#javax-mail-Store-类（邮件存储-）" class="headerlink" title="javax.mail.Store 类（邮件存储 ）"></a>javax.mail.Store 类（邮件存储 ）</h3><ul>
<li><code>getStore</code> - Session 类中的 getStore () 有多个重载方法，可以用来创建 Store 对象。</li>
<li><code>connect</code> - 如果设置了认证命令—— mail.smtp.auth ，那么使用 Store 类的 connect 方法连接服务器时，则必须加上用户名和密码。</li>
<li><code>getFolder</code> - Store 类的 getFolder 方法可以 获取邮箱内的邮件夹 Folder 对象</li>
<li><code>close</code> - Store 类的 close 方法用来关闭和邮件服务器的连接。</li>
</ul>
<h3 id="javax-mail-Message-类（消息对象）"><a href="#javax-mail-Message-类（消息对象）" class="headerlink" title="javax.mail.Message 类（消息对象）"></a>javax.mail.Message 类（消息对象）</h3><ul>
<li><code>javax.mail.Message</code> - 是个抽象类，只能用子类去实例化，多数情况下为 <code>javax.mail.internet.MimeMessage</code>。</li>
<li><code>MimeMessage</code> - 代表 MIME 类型的电子邮件消息。</li>
</ul>
<p>要创建一个 Message ，需要将 Session 对象传递给 <code>MimeMessage</code> 构造器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MimeMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMessage</span>(session);</span><br></pre></td></tr></table></figure>

<p>注意：还存在其它构造器，如用按 RFC822 格式的输入流来创建消息。</p>
<ul>
<li>setFrom - 设置邮件的发件人</li>
<li>setRecipient - 设置邮件的发送人、抄送人、密送人</li>
</ul>
<p>三种预定义的地址类型是：</p>
<ul>
<li><code>Message.RecipientType.TO</code> - 收件人</li>
<li><code>Message.RecipientType.CC</code> - 抄送人</li>
<li><code>Message.RecipientType.BCC</code> - 密送人</li>
<li><code>setSubject</code> - 设置邮件的主题</li>
<li><code>setContent</code> - 设置邮件内容</li>
<li><code>setText</code> - 如果邮件内容是纯文本，可以使用此接口设置文本内容。</li>
</ul>
<h3 id="javax-mail-Address-类（地址）"><a href="#javax-mail-Address-类（地址）" class="headerlink" title="javax.mail.Address 类（地址）"></a>javax.mail.Address 类（地址）</h3><p>一旦您创建了 Session 和 Message ，并将内容填入消息后，就可以用 Address 确定信件地址了。和 Message 一样， Address 也是个抽象类。您用的是 javax.mail.internet.InternetAddress 类。</p>
<p>若创建的地址只包含电子邮件地址，只要传递电子邮件地址到构造器就行了。</p>
<p><strong>例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Address</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InternetAddress</span>(<span class="string">&quot;[email protected]&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Authenticator-类（认证者）"><a href="#Authenticator-类（认证者）" class="headerlink" title="Authenticator 类（认证者）"></a>Authenticator 类（认证者）</h3><p>与 java.net 类一样， JavaMail API 也可以利用 <code>Authenticator</code> 通过用户名和密码访问受保护的资源。对于 JavaMail API 来说，这些资源就是邮件服务器。<code>Authenticator</code> 在 javax.mail 包中，而且它和 java.net 中同名的类 Authenticator 不同。两者并不共享同一个 Authenticator ，因为 JavaMail API 用于 Java 1.1 ，它没有 java.net 类别。</p>
<p>要使用 Authenticator ，先创建一个抽象类的子类，并从 <code>getPasswordAuthentication()</code> 方法中返回 <code>PasswordAuthentication</code> 实例。创建完成后，您必需向 session 注册 <code>Authenticator</code> 。然后，在需要认证的时候，就会通知 <code>Authenticator</code> 。您可以弹出窗口，也可以从配置文件中（虽然没有加密是不安全的）读取用户名和密码，将它们作为 <code>PasswordAuthentication</code> 对象返回给调用程序。</p>
<p><strong>例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"><span class="type">Authenticator</span> <span class="variable">auth</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyAuthenticator</span>();</span><br><span class="line"><span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> Session.getDefaultInstance(props, auth);</span><br></pre></td></tr></table></figure>

<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="发送文本邮件"><a href="#发送文本邮件" class="headerlink" title="发送文本邮件"></a>发送文本邮件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    prop.setProperty(<span class="string">&quot;mail.debug&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">    prop.setProperty(<span class="string">&quot;mail.host&quot;</span>, MAIL_SERVER_HOST);</span><br><span class="line">    prop.setProperty(<span class="string">&quot;mail.transport.protocol&quot;</span>, <span class="string">&quot;smtp&quot;</span>);</span><br><span class="line">    prop.setProperty(<span class="string">&quot;mail.smtp.auth&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、创建session</span></span><br><span class="line">    <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> Session.getInstance(prop);</span><br><span class="line">    <span class="type">Transport</span> <span class="variable">ts</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、通过session得到transport对象</span></span><br><span class="line">    ts = session.getTransport();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、连上邮件服务器</span></span><br><span class="line">    ts.connect(MAIL_SERVER_HOST, USER, PASSWORD);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、创建邮件</span></span><br><span class="line">    <span class="type">MimeMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMessage</span>(session);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 邮件消息头</span></span><br><span class="line">    message.setFrom(<span class="keyword">new</span> <span class="title class_">InternetAddress</span>(MAIL_FROM)); <span class="comment">// 邮件的发件人</span></span><br><span class="line">    message.setRecipient(Message.RecipientType.TO, <span class="keyword">new</span> <span class="title class_">InternetAddress</span>(MAIL_TO)); <span class="comment">// 邮件的收件人</span></span><br><span class="line">    message.setRecipient(Message.RecipientType.CC, <span class="keyword">new</span> <span class="title class_">InternetAddress</span>(MAIL_CC)); <span class="comment">// 邮件的抄送人</span></span><br><span class="line">    message.setRecipient(Message.RecipientType.BCC, <span class="keyword">new</span> <span class="title class_">InternetAddress</span>(MAIL_BCC)); <span class="comment">// 邮件的密送人</span></span><br><span class="line">    message.setSubject(<span class="string">&quot;测试文本邮件&quot;</span>); <span class="comment">// 邮件的标题</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 邮件消息体</span></span><br><span class="line">    message.setText(<span class="string">&quot;天下无双。&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5、发送邮件</span></span><br><span class="line">    ts.sendMessage(message, message.getAllRecipients());</span><br><span class="line">    ts.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="发送-HTML-格式的邮件"><a href="#发送-HTML-格式的邮件" class="headerlink" title="发送 HTML 格式的邮件"></a>发送 HTML 格式的邮件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    prop.setProperty(<span class="string">&quot;mail.debug&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">    prop.setProperty(<span class="string">&quot;mail.host&quot;</span>, MAIL_SERVER_HOST);</span><br><span class="line">    prop.setProperty(<span class="string">&quot;mail.transport.protocol&quot;</span>, <span class="string">&quot;smtp&quot;</span>);</span><br><span class="line">    prop.setProperty(<span class="string">&quot;mail.smtp.auth&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、创建session</span></span><br><span class="line">    <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> Session.getInstance(prop);</span><br><span class="line">    <span class="type">Transport</span> <span class="variable">ts</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、通过session得到transport对象</span></span><br><span class="line">    ts = session.getTransport();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、连上邮件服务器</span></span><br><span class="line">    ts.connect(MAIL_SERVER_HOST, USER, PASSWORD);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、创建邮件</span></span><br><span class="line">    <span class="type">MimeMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMessage</span>(session);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 邮件消息头</span></span><br><span class="line">    message.setFrom(<span class="keyword">new</span> <span class="title class_">InternetAddress</span>(MAIL_FROM)); <span class="comment">// 邮件的发件人</span></span><br><span class="line">    message.setRecipient(Message.RecipientType.TO, <span class="keyword">new</span> <span class="title class_">InternetAddress</span>(MAIL_TO)); <span class="comment">// 邮件的收件人</span></span><br><span class="line">    message.setRecipient(Message.RecipientType.CC, <span class="keyword">new</span> <span class="title class_">InternetAddress</span>(MAIL_CC)); <span class="comment">// 邮件的抄送人</span></span><br><span class="line">    message.setRecipient(Message.RecipientType.BCC, <span class="keyword">new</span> <span class="title class_">InternetAddress</span>(MAIL_BCC)); <span class="comment">// 邮件的密送人</span></span><br><span class="line">    message.setSubject(<span class="string">&quot;测试HTML邮件&quot;</span>); <span class="comment">// 邮件的标题</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">htmlContent</span> <span class="operator">=</span> <span class="string">&quot;&lt;h1&gt;Hello&lt;/h1&gt;&quot;</span> + <span class="string">&quot;&lt;p&gt;显示图片&lt;img src=&#x27;cid:abc.jpg&#x27;&gt;1.jpg&lt;/p&gt;&quot;</span>;</span><br><span class="line">    <span class="type">MimeBodyPart</span> <span class="variable">text</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeBodyPart</span>();</span><br><span class="line">    text.setContent(htmlContent, <span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">    <span class="type">MimeBodyPart</span> <span class="variable">image</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeBodyPart</span>();</span><br><span class="line">    <span class="type">DataHandler</span> <span class="variable">dh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataHandler</span>(<span class="keyword">new</span> <span class="title class_">FileDataSource</span>(<span class="string">&quot;D:\\05_Datas\\图库\\吉他少年背影.png&quot;</span>));</span><br><span class="line">    image.setDataHandler(dh);</span><br><span class="line">    image.setContentID(<span class="string">&quot;abc.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 描述数据关系</span></span><br><span class="line">    <span class="type">MimeMultipart</span> <span class="variable">mm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMultipart</span>();</span><br><span class="line">    mm.addBodyPart(text);</span><br><span class="line">    mm.addBodyPart(image);</span><br><span class="line">    mm.setSubType(<span class="string">&quot;related&quot;</span>);</span><br><span class="line">    message.setContent(mm);</span><br><span class="line">    message.saveChanges();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5、发送邮件</span></span><br><span class="line">    ts.sendMessage(message, message.getAllRecipients());</span><br><span class="line">    ts.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="发送带附件的邮件"><a href="#发送带附件的邮件" class="headerlink" title="发送带附件的邮件"></a>发送带附件的邮件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    prop.setProperty(<span class="string">&quot;mail.debug&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">    prop.setProperty(<span class="string">&quot;mail.host&quot;</span>, MAIL_SERVER_HOST);</span><br><span class="line">    prop.setProperty(<span class="string">&quot;mail.transport.protocol&quot;</span>, <span class="string">&quot;smtp&quot;</span>);</span><br><span class="line">    prop.setProperty(<span class="string">&quot;mail.smtp.auth&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、创建session</span></span><br><span class="line">    <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> Session.getInstance(prop);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、通过session得到transport对象</span></span><br><span class="line">    <span class="type">Transport</span> <span class="variable">ts</span> <span class="operator">=</span> session.getTransport();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、连上邮件服务器</span></span><br><span class="line">    ts.connect(MAIL_SERVER_HOST, USER, PASSWORD);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、创建邮件</span></span><br><span class="line">    <span class="type">MimeMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMessage</span>(session);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 邮件消息头</span></span><br><span class="line">    message.setFrom(<span class="keyword">new</span> <span class="title class_">InternetAddress</span>(MAIL_FROM)); <span class="comment">// 邮件的发件人</span></span><br><span class="line">    message.setRecipient(Message.RecipientType.TO, <span class="keyword">new</span> <span class="title class_">InternetAddress</span>(MAIL_TO)); <span class="comment">// 邮件的收件人</span></span><br><span class="line">    message.setRecipient(Message.RecipientType.CC, <span class="keyword">new</span> <span class="title class_">InternetAddress</span>(MAIL_CC)); <span class="comment">// 邮件的抄送人</span></span><br><span class="line">    message.setRecipient(Message.RecipientType.BCC, <span class="keyword">new</span> <span class="title class_">InternetAddress</span>(MAIL_BCC)); <span class="comment">// 邮件的密送人</span></span><br><span class="line">    message.setSubject(<span class="string">&quot;测试带附件邮件&quot;</span>); <span class="comment">// 邮件的标题</span></span><br><span class="line"></span><br><span class="line">    <span class="type">MimeBodyPart</span> <span class="variable">text</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeBodyPart</span>();</span><br><span class="line">    text.setContent(<span class="string">&quot;邮件中有两个附件。&quot;</span>, <span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 描述数据关系</span></span><br><span class="line">    <span class="type">MimeMultipart</span> <span class="variable">mm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMultipart</span>();</span><br><span class="line">    mm.setSubType(<span class="string">&quot;related&quot;</span>);</span><br><span class="line">    mm.addBodyPart(text);</span><br><span class="line">    String[] files = &#123;</span><br><span class="line">            <span class="string">&quot;D:\\00_Temp\\temp\\1.jpg&quot;</span>, <span class="string">&quot;D:\\00_Temp\\temp\\2.png&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加邮件附件</span></span><br><span class="line">    <span class="keyword">for</span> (String filename : files) &#123;</span><br><span class="line">        <span class="type">MimeBodyPart</span> <span class="variable">attachPart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeBodyPart</span>();</span><br><span class="line">        attachPart.attachFile(filename);</span><br><span class="line">        mm.addBodyPart(attachPart);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    message.setContent(mm);</span><br><span class="line">    message.saveChanges();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5、发送邮件</span></span><br><span class="line">    ts.sendMessage(message, message.getAllRecipients());</span><br><span class="line">    ts.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取邮箱中的邮件"><a href="#获取邮箱中的邮件" class="headerlink" title="获取邮箱中的邮件"></a>获取邮箱中的邮件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个有具体连接信息的Properties对象</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    prop.setProperty(<span class="string">&quot;mail.debug&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">    prop.setProperty(<span class="string">&quot;mail.store.protocol&quot;</span>, <span class="string">&quot;pop3&quot;</span>);</span><br><span class="line">    prop.setProperty(<span class="string">&quot;mail.pop3.host&quot;</span>, MAIL_SERVER_HOST);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、创建session</span></span><br><span class="line">    <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> Session.getInstance(prop);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、通过session得到Store对象</span></span><br><span class="line">    <span class="type">Store</span> <span class="variable">store</span> <span class="operator">=</span> session.getStore();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、连上邮件服务器</span></span><br><span class="line">    store.connect(MAIL_SERVER_HOST, USER, PASSWORD);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、获得邮箱内的邮件夹</span></span><br><span class="line">    <span class="type">Folder</span> <span class="variable">folder</span> <span class="operator">=</span> store.getFolder(<span class="string">&quot;inbox&quot;</span>);</span><br><span class="line">    folder.open(Folder.READ_ONLY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得邮件夹Folder内的所有邮件Message对象</span></span><br><span class="line">    Message[] messages = folder.getMessages();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; messages.length; i++) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">subject</span> <span class="operator">=</span> messages[i].getSubject();</span><br><span class="line">        <span class="type">String</span> <span class="variable">from</span> <span class="operator">=</span> (messages[i].getFrom()[<span class="number">0</span>]).toString();</span><br><span class="line">        System.out.println(<span class="string">&quot;第 &quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;封邮件的主题：&quot;</span> + subject);</span><br><span class="line">        System.out.println(<span class="string">&quot;第 &quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;封邮件的发件人地址：&quot;</span> + from);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5、关闭</span></span><br><span class="line">    folder.close(<span class="literal">false</span>);</span><br><span class="line">    store.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="转发邮件"><a href="#转发邮件" class="headerlink" title="转发邮件"></a>转发邮件</h3><p>例：获取指定邮件夹下的第一封邮件并转发</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    prop.put(<span class="string">&quot;mail.store.protocol&quot;</span>, <span class="string">&quot;pop3&quot;</span>);</span><br><span class="line">    prop.put(<span class="string">&quot;mail.pop3.host&quot;</span>, MAIL_SERVER_POP3);</span><br><span class="line">    prop.put(<span class="string">&quot;mail.pop3.starttls.enable&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">    prop.put(<span class="string">&quot;mail.smtp.auth&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">    prop.put(<span class="string">&quot;mail.smtp.host&quot;</span>, MAIL_SERVER_SMTP);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、创建session</span></span><br><span class="line">    <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> Session.getDefaultInstance(prop);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、读取邮件夹</span></span><br><span class="line">    <span class="type">Store</span> <span class="variable">store</span> <span class="operator">=</span> session.getStore(<span class="string">&quot;pop3&quot;</span>);</span><br><span class="line">    store.connect(MAIL_SERVER_POP3, USER, PASSWORD);</span><br><span class="line">    <span class="type">Folder</span> <span class="variable">folder</span> <span class="operator">=</span> store.getFolder(<span class="string">&quot;inbox&quot;</span>);</span><br><span class="line">    folder.open(Folder.READ_ONLY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取邮件夹中第1封邮件信息</span></span><br><span class="line">    Message[] messages = folder.getMessages();</span><br><span class="line">    <span class="keyword">if</span> (messages.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> messages[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印邮件关键信息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">from</span> <span class="operator">=</span> InternetAddress.toString(message.getFrom());</span><br><span class="line">    <span class="keyword">if</span> (from != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;From: &quot;</span> + from);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">replyTo</span> <span class="operator">=</span> InternetAddress.toString(message.getReplyTo());</span><br><span class="line">    <span class="keyword">if</span> (replyTo != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Reply-to: &quot;</span> + replyTo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">to</span> <span class="operator">=</span> InternetAddress.toString(message.getRecipients(Message.RecipientType.TO));</span><br><span class="line">    <span class="keyword">if</span> (to != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;To: &quot;</span> + to);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">subject</span> <span class="operator">=</span> message.getSubject();</span><br><span class="line">    <span class="keyword">if</span> (subject != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Subject: &quot;</span> + subject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Date</span> <span class="variable">sent</span> <span class="operator">=</span> message.getSentDate();</span><br><span class="line">    <span class="keyword">if</span> (sent != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sent: &quot;</span> + sent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置转发邮件信息头</span></span><br><span class="line">    <span class="type">Message</span> <span class="variable">forward</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMessage</span>(session);</span><br><span class="line">    forward.setFrom(<span class="keyword">new</span> <span class="title class_">InternetAddress</span>(MAIL_FROM));</span><br><span class="line">    forward.setRecipient(Message.RecipientType.TO, <span class="keyword">new</span> <span class="title class_">InternetAddress</span>(MAIL_TO));</span><br><span class="line">    forward.setSubject(<span class="string">&quot;Fwd: &quot;</span> + message.getSubject());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置转发邮件内容</span></span><br><span class="line">    <span class="type">MimeBodyPart</span> <span class="variable">bodyPart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeBodyPart</span>();</span><br><span class="line">    bodyPart.setContent(message, <span class="string">&quot;message/rfc822&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Multipart</span> <span class="variable">multipart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMultipart</span>();</span><br><span class="line">    multipart.addBodyPart(bodyPart);</span><br><span class="line">    forward.setContent(multipart);</span><br><span class="line">    forward.saveChanges();</span><br><span class="line"></span><br><span class="line">    <span class="type">Transport</span> <span class="variable">ts</span> <span class="operator">=</span> session.getTransport(<span class="string">&quot;smtp&quot;</span>);</span><br><span class="line">    ts.connect(USER, PASSWORD);</span><br><span class="line">    ts.sendMessage(forward, forward.getAllRecipients());</span><br><span class="line"></span><br><span class="line">    folder.close(<span class="literal">false</span>);</span><br><span class="line">    store.close();</span><br><span class="line">    ts.close();</span><br><span class="line">    System.out.println(<span class="string">&quot;message forwarded successfully....&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/adacc5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/adacc5/" class="post-title-link" itemprop="url">Thumbnailator 快速入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-17 22:34:30" itemprop="dateCreated datePublished" datetime="2022-02-17T22:34:30+08:00">2022-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E5%B7%A5%E5%85%B7/%E5%85%B6%E4%BB%96/" itemprop="url" rel="index"><span itemprop="name">其他</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Thumbnailator-快速入门"><a href="#Thumbnailator-快速入门" class="headerlink" title="Thumbnailator 快速入门"></a>Thumbnailator 快速入门</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>Thumbnailator</code> 是一个开源的 <strong>Java</strong> 项目，它提供了非常简单的 API 来对图片进行缩放、旋转以及加水印的处理。</p>
<p>有多简单呢？简单到一行代码就可以完成图片处理。形式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thumbnails.of(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;path/to/directory&quot;</span>).listFiles())</span><br><span class="line">    .size(<span class="number">640</span>, <span class="number">480</span>)</span><br><span class="line">    .outputFormat(<span class="string">&quot;jpg&quot;</span>)</span><br><span class="line">    .toFiles(Rename.PREFIX_DOT_THUMBNAIL);</span><br></pre></td></tr></table></figure>

<p>当然，Thumbnailator 还有一些使用细节，下面我会一一道来。</p>
<h2 id="核心-API"><a href="#核心-API" class="headerlink" title="核心 API"></a>核心 API</h2><h3 id="Thumbnails"><a href="#Thumbnails" class="headerlink" title="Thumbnails"></a>Thumbnails</h3><p><code>Thumbnails</code> 是使用 Thumbnailator 创建缩略图的主入口。</p>
<p>它提供了一组初始化 <code>Thumbnails.Builder</code> 的接口。</p>
<p>先看下这组接口的声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可变长度参数列表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Builder&lt;File&gt; <span class="title function_">of</span><span class="params">(String... files)</span> &#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Builder&lt;File&gt; <span class="title function_">of</span><span class="params">(File... files)</span> &#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Builder&lt;URL&gt; <span class="title function_">of</span><span class="params">(URL... urls)</span> &#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Builder&lt;? <span class="keyword">extends</span> <span class="title class_">InputStream</span>&gt; of(InputStream... inputStreams) &#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Builder&lt;BufferedImage&gt; <span class="title function_">of</span><span class="params">(BufferedImage... images)</span> &#123;...&#125;</span><br><span class="line"><span class="comment">// 迭代器（所有实现 Iterable 接口的 Java 对象都可以，当然也包括 List、Set）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Builder&lt;File&gt; <span class="title function_">fromFilenames</span><span class="params">(Iterable&lt;String&gt; files)</span> &#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Builder&lt;File&gt; <span class="title function_">fromFiles</span><span class="params">(Iterable&lt;File&gt; files)</span> &#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Builder&lt;URL&gt; <span class="title function_">fromURLs</span><span class="params">(Iterable&lt;URL&gt; urls)</span> &#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Builder&lt;InputStream&gt; <span class="title function_">fromInputStreams</span><span class="params">(Iterable&lt;? extends InputStream&gt; inputStreams)</span> &#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Builder&lt;BufferedImage&gt; <span class="title function_">fromImages</span><span class="params">(Iterable&lt;BufferedImage&gt; images)</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>很显然，<strong>Thumbnails 允许通过传入文件名、文件、网络图的 URL、图片流、图片缓存多种方式来初始化构造器</strong>。</p>
<p>因此，你可以根据实际需求来灵活的选择图片的输入方式。</p>
<p>需要注意一点：<strong>如果输入是多个对象（无论你是直接输入容器对象或使用可变参数方式传入多个对象），则输出也必须选用输出多个对象的方式，否则会报异常。</strong></p>
<h3 id="Thumbnails-Builder"><a href="#Thumbnails-Builder" class="headerlink" title="Thumbnails.Builder"></a>Thumbnails.Builder</h3><p><code>Thumbnails.Builder</code> 是 <code>Thumbnails</code> 的内部静态类。它用于设置生成缩略图任务的相关参数。</p>
<p><strong><em>注：<code>Thumbnails.Builder</code> 的构造函数是私有函数。所以，它只允许通过 <code>Thumbnails</code> 的实例化函数来进行初始化。</em></strong></p>
<h4 id="设置参数的函数"><a href="#设置参数的函数" class="headerlink" title="设置参数的函数"></a>设置参数的函数</h4><p><code>Thumbnails.Builder</code> 提供了一组函数链形式的接口来设置缩放图参数。</p>
<p>以设置大小函数为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Builder&lt;T&gt; <span class="title function_">size</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height)</span></span><br><span class="line">&#123;</span><br><span class="line"> updateStatus(Properties.SIZE, Status.ALREADY_SET);</span><br><span class="line"> updateStatus(Properties.SCALE, Status.CANNOT_SET);</span><br><span class="line"></span><br><span class="line"> validateDimensions(width, height);</span><br><span class="line"> <span class="built_in">this</span>.width = width;</span><br><span class="line"> <span class="built_in">this</span>.height = height;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过返回 this 指针，使得设置参数函数可以以链式调用的方式来使用，形式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thumbnails.of(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;original.jpg&quot;</span>))</span><br><span class="line">        .size(<span class="number">160</span>, <span class="number">160</span>)</span><br><span class="line">        .rotate(<span class="number">90</span>)</span><br><span class="line">        .watermark(Positions.BOTTOM_RIGHT, ImageIO.read(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;watermark.png&quot;</span>)), <span class="number">0.5f</span>)</span><br><span class="line">        .outputQuality(<span class="number">0.8</span>)</span><br><span class="line">        .toFile(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;image-with-watermark.jpg&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>好处，不言自明：那就是大大简化了代码。</p>
<h4 id="输出函数"><a href="#输出函数" class="headerlink" title="输出函数"></a>输出函数</h4><p><code>Thumbnails.Builder</code> 提供了一组重载函数来输出生成的缩放图。</p>
<p>函数声明如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回图片缓存</span></span><br><span class="line"><span class="keyword">public</span> List&lt;BufferedImage&gt; <span class="title function_">asBufferedImages</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> BufferedImage <span class="title function_">asBufferedImage</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;...&#125;</span><br><span class="line"><span class="comment">// 返回文件列表</span></span><br><span class="line"><span class="keyword">public</span> List&lt;File&gt; <span class="title function_">asFiles</span><span class="params">(Iterable&lt;File&gt; iterable)</span> <span class="keyword">throws</span> IOException &#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> List&lt;File&gt; <span class="title function_">asFiles</span><span class="params">(Rename rename)</span> <span class="keyword">throws</span> IOException &#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> List&lt;File&gt; <span class="title function_">asFiles</span><span class="params">(File destinationDir, Rename rename)</span> <span class="keyword">throws</span> IOException &#123;...&#125;</span><br><span class="line"><span class="comment">// 创建文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toFile</span><span class="params">(File outFile)</span> <span class="keyword">throws</span> IOException &#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toFile</span><span class="params">(String outFilepath)</span> <span class="keyword">throws</span> IOException &#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toFiles</span><span class="params">(Iterable&lt;File&gt; iterable)</span> <span class="keyword">throws</span> IOException &#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toFiles</span><span class="params">(Rename rename)</span> <span class="keyword">throws</span> IOException &#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toFiles</span><span class="params">(File destinationDir, Rename rename)</span> <span class="keyword">throws</span> IOException &#123;...&#125;</span><br><span class="line"><span class="comment">// 创建输出流</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toOutputStream</span><span class="params">(OutputStream os)</span> <span class="keyword">throws</span> IOException &#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toOutputStreams</span><span class="params">(Iterable&lt;? extends OutputStream&gt; iterable)</span> <span class="keyword">throws</span> IOException &#123;...&#125;</span><br></pre></td></tr></table></figure>

<h3 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h3><p>Thumbnailator 的工作步骤十分简单，可分为三步：</p>
<ol>
<li><p><strong>输入</strong>：<code>Thumbnails</code> 根据输入初始化构造器—— <code>Thumbnails.Builder</code> 。</p>
</li>
<li><p><strong>设置</strong>：<code>Thumbnails.Builder</code> 设置缩放图片的参数。</p>
</li>
<li><p><strong>输出</strong>：<code>Thumbnails.Builder</code> 输出图片文件或图片流。</p>
</li>
</ol>
<blockquote>
<p>更多详情可以参考： <a target="_blank" rel="noopener" href="https://coobird.github.io/thumbnailator/javadoc/0.4.8/"><u>Thumbnailator 官网 javadoc</u></a></p>
</blockquote>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>前文介绍了 Thumbnailator 的核心 API，接下来我们就可以通过实战来看看 Thumbnailator 究竟可以做些什么。</p>
<p>Thumbnailator 生成什么样的图片，是根据设置参数来决定的。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>maven 项目中引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.coobird<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thumbnailator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>[0.4, 0.5)<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="图片缩放"><a href="#图片缩放" class="headerlink" title="图片缩放"></a>图片缩放</h3><p><code>Thumbnails.Builder</code> 的 <code>size</code> 函数可以设置新图片精确的宽度和高度，也可以用 <code>scale</code> 函数设置缩放比例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Thumbnails.of(<span class="string">&quot;oldFile.png&quot;</span>)</span><br><span class="line">  .size(<span class="number">16</span>, <span class="number">16</span>)</span><br><span class="line">  .toFile(<span class="string">&quot;newFile_16_16.png&quot;</span>);</span><br><span class="line"></span><br><span class="line">Thumbnails.of(<span class="string">&quot;oldFile.png&quot;</span>)</span><br><span class="line">  .scale(<span class="number">2.0</span>)</span><br><span class="line">  .toFile(<span class="string">&quot;newFile_scale_2.0.png&quot;</span>);</span><br><span class="line"></span><br><span class="line">Thumbnails.of(<span class="string">&quot;oldFile.png&quot;</span>)</span><br><span class="line">  .scale(<span class="number">1.0</span>, <span class="number">0.5</span>)</span><br><span class="line">  .toFile(<span class="string">&quot;newFile_scale_1.0_0.5.png&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>oldFile.png</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3101171-ba63439898602e8f.png" alt="img"></p>
<p><strong>newFile_scale_1.0_0.5.png</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3101171-a01ea4515fff865d.png" alt="img"></p>
<h3 id="图片旋转"><a href="#图片旋转" class="headerlink" title="图片旋转"></a>图片旋转</h3><p><code>Thumbnails.Builder</code> 的 <code>size</code> 函数可以设置新图片的旋转角度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Thumbnails.of(<span class="string">&quot;oldFile.png&quot;</span>)</span><br><span class="line">  .scale(<span class="number">0.8</span>)</span><br><span class="line">  .rotate(<span class="number">90</span>)</span><br><span class="line">  .toFile(<span class="string">&quot;newFile_rotate_90.png&quot;</span>);</span><br><span class="line"></span><br><span class="line">Thumbnails.of(<span class="string">&quot;oldFile.png&quot;</span>)</span><br><span class="line">  .scale(<span class="number">0.8</span>)</span><br><span class="line">  .rotate(<span class="number">180</span>)</span><br><span class="line">  .toFile(<span class="string">&quot;newFile_rotate_180.png&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>newFile_rotate_90.png</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3101171-17d54bc33b38d45b.png" alt="img"></p>
<h3 id="加水印"><a href="#加水印" class="headerlink" title="加水印"></a>加水印</h3><p><code>Thumbnails.Builder</code> 的 <code>watermark</code> 函数可以为图片添加水印图片。第一个参数是水印的位置；第二个参数是水印图片的缓存数据；第三个参数是透明度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedImage</span> <span class="variable">watermarkImage</span> <span class="operator">=</span> ImageIO.read(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;wartermarkFile.png&quot;</span>));</span><br><span class="line">Thumbnails.of(<span class="string">&quot;oldFile.png&quot;</span>)</span><br><span class="line">  .scale(<span class="number">0.8</span>)</span><br><span class="line">  .watermark(Positions.BOTTOM_LEFT, watermarkImage, <span class="number">0.5f</span>)</span><br><span class="line">  .toFile(<span class="string">&quot;newFile_watermark.png&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>wartermarkFile.png</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3101171-97909ee6c066c195.png?imageMogr2/auto-orient/strip" alt="img"></p>
<p><strong>newFile_watermark.png</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3101171-93eb7ef71b811a0c.png" alt="img"></p>
<h3 id="批量处理图片"><a href="#批量处理图片" class="headerlink" title="批量处理图片"></a>批量处理图片</h3><p>下面以批量给图片加水印来展示一下如何处理多个图片文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedImage</span> <span class="variable">watermarkImage</span> <span class="operator">=</span> ImageIO.read(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;wartermarkFile.png&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="type">File</span> <span class="variable">destinationDir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\watermark\\&quot;</span>);</span><br><span class="line">Thumbnails.of(<span class="string">&quot;oldFile.png&quot;</span>, <span class="string">&quot;oldFile2.png&quot;</span>)</span><br><span class="line">  .scale(<span class="number">0.8</span>)</span><br><span class="line">  .watermark(Positions.BOTTOM_LEFT, watermarkImage, <span class="number">0.5f</span>)</span><br><span class="line">  .toFiles(destinationDir, Rename.PREFIX_DOT_THUMBNAIL);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>需要参考完整测试例代码请</strong> <a target="_blank" rel="noopener" href="https://github.com/dunwu/JavaParty/blob/master/toolbox/image/src/test/java/org/zp/image/ThumbnailatorTest.java"><u><strong>点击这里</strong></u></a></p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://github.com/coobird/thumbnailator/wiki/Examples">Thumbnailator 官方示例文档</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/5dd78d/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/5dd78d/" class="post-title-link" itemprop="url">Jsoup 快速入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-17 22:34:30" itemprop="dateCreated datePublished" datetime="2022-02-17T22:34:30+08:00">2022-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E5%B7%A5%E5%85%B7/%E5%85%B6%E4%BB%96/" itemprop="url" rel="index"><span itemprop="name">其他</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>11k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>10 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Jsoup-快速入门"><a href="#Jsoup-快速入门" class="headerlink" title="Jsoup 快速入门"></a>Jsoup 快速入门</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>jsoup 是一款 Java 的 HTML 解析器，可直接解析某个 URL 地址、HTML 文本内容。它提供了一套非常省力的 API，可通过 DOM，CSS 以及类似于 JQuery 的操作方法来取出和操作数据。</p>
<p>jsoup 工作的流程主要如下：</p>
<ol>
<li>从一个 URL，文件或字符串中解析 HTML，并加载为一个 <code>Document</code> 对象。</li>
<li>使用 DOM 或 CSS 选择器来取出数据；</li>
<li>可操作 HTML 元素、属性、文本。</li>
</ol>
<p>jsoup 是基于 MIT 协议发布的，可放心使用于商业项目。</p>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><h3 id="从-HTML-字符串加载一个文档"><a href="#从-HTML-字符串加载一个文档" class="headerlink" title="从 HTML 字符串加载一个文档"></a>从 HTML 字符串加载一个文档</h3><p>使用静态 <code>Jsoup.parse(String html)</code> 方法或 <code>Jsoup.parse(String html, String baseUri)</code> 示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">html</span> <span class="operator">=</span> <span class="string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;First parse&lt;/title&gt;&lt;/head&gt;&quot;</span></span><br><span class="line">  + <span class="string">&quot;&lt;body&gt;&lt;p&gt;Parsed HTML into a doc.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>;</span><br><span class="line"><span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> Jsoup.parse(html);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>说明</strong></p>
<p><code>parse(String html, String baseUri)</code> 这方法能够将输入的 HTML 解析为一个新的文档 (Document），参数 baseUri 是用来将相对 URL 转成绝对 URL，并指定从哪个网站获取文档。如这个方法不适用，你可以使用 <code>parse(String html)</code> 方法来解析成 HTML 字符串如上面的示例。</p>
<p>只要解析的不是空字符串，就能返回一个结构合理的文档，其中包含(至少) 一个 head 和一个 body 元素。</p>
<p>一旦拥有了一个 Document，你就可以使用 Document 中适当的方法或它父类 <code>Element</code>和<code>Node</code>中的方法来取得相关数据。</p>
</blockquote>
<h3 id="解析一个-body-片断"><a href="#解析一个-body-片断" class="headerlink" title="解析一个 body 片断"></a>解析一个 body 片断</h3><p><strong>问题</strong></p>
<p>假如你有一个 HTML 片断 (比如. 一个 <code>div</code> 包含一对 <code>p</code> 标签; 一个不完整的 HTML 文档) 想对它进行解析。这个 HTML 片断可以是用户提交的一条评论或在一个 CMS 页面中编辑 body 部分。</p>
<p><strong>办法</strong></p>
<p>使用<code>Jsoup.parseBodyFragment(String html)</code>方法.</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String html <span class="operator">=</span> <span class="string">&quot;&lt;div&gt;&lt;p&gt;Lorem ipsum.&lt;/p&gt;&quot;</span><span class="comment">;</span></span><br><span class="line">Document doc <span class="operator">=</span> Jsoup.parseBodyFragment(html)<span class="comment">;</span></span><br><span class="line">Element body <span class="operator">=</span> doc.body()<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>说明</strong></p>
<p><code>parseBodyFragment</code> 方法创建一个空壳的文档，并插入解析过的 HTML 到<code>body</code>元素中。假如你使用正常的 <code>Jsoup.parse(String html)</code> 方法，通常你也可以得到相同的结果，但是明确将用户输入作为 body 片段处理，以确保用户所提供的任何糟糕的 HTML 都将被解析成 body 元素。</p>
<p><code>Document.body()</code> 方法能够取得文档 body 元素的所有子元素，与 <code>doc.getElementsByTag(&quot;body&quot;)</code>相同。</p>
</blockquote>
<h4 id="保证安全-Stay-safe"><a href="#保证安全-Stay-safe" class="headerlink" title="保证安全 Stay safe"></a>保证安全 Stay safe</h4><p>假如你可以让用户输入 HTML 内容，那么要小心避免跨站脚本攻击。利用基于 <code>Whitelist</code> 的清除器和 <code>clean(String bodyHtml, Whitelist whitelist)</code>方法来清除用户输入的恶意内容。</p>
<h3 id="从-URL-加载一个文档"><a href="#从-URL-加载一个文档" class="headerlink" title="从 URL 加载一个文档"></a>从 URL 加载一个文档</h3><p>使用 <code>Jsoup.connect(String url)</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> Jsoup.connect(<span class="string">&quot;http://example.com/&quot;</span>).get();</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>说明</strong></p>
<p><code>connect(String url)</code> 方法创建一个新的 <code>Connection</code>, 和 <code>get()</code> 取得和解析一个 HTML 文件。如果从该 URL 获取 HTML 时发生错误，便会抛出 IOException，应适当处理。</p>
</blockquote>
<p><code>Connection</code> 接口还提供一个方法链来解决特殊请求，具体如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> Jsoup.connect(<span class="string">&quot;http://example.com&quot;</span>)</span><br><span class="line">  .data(<span class="string">&quot;query&quot;</span>, <span class="string">&quot;Java&quot;</span>)</span><br><span class="line">  .userAgent(<span class="string">&quot;Mozilla&quot;</span>)</span><br><span class="line">  .cookie(<span class="string">&quot;auth&quot;</span>, <span class="string">&quot;token&quot;</span>)</span><br><span class="line">  .timeout(<span class="number">3000</span>)</span><br><span class="line">  .post();</span><br></pre></td></tr></table></figure>

<h3 id="从一个文件加载一个文档"><a href="#从一个文件加载一个文档" class="headerlink" title="从一个文件加载一个文档"></a>从一个文件加载一个文档</h3><p>可以使用静态 <code>Jsoup.parse(File in, String charsetName, String baseUri)</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/tmp/input.html&quot;</span>);</span><br><span class="line"><span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> Jsoup.parse(input, <span class="string">&quot;UTF-8&quot;</span>, <span class="string">&quot;http://example.com/&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>说明</strong></p>
<p><code>parse(File in, String charsetName, String baseUri)</code> 这个方法用来加载和解析一个 HTML 文件。如在加载文件的时候发生错误，将抛出 IOException，应作适当处理。</p>
<p><code>baseUri</code> 参数用于解决文件中 URLs 是相对路径的问题。如果不需要可以传入一个空的字符串。</p>
<p>另外还有一个方法<code>parse(File in, String charsetName)</code> ，它使用文件的路径做为 <code>baseUri</code>。 这个方法适用于如果被解析文件位于网站的本地文件系统，且相关链接也指向该文件系统。</p>
</blockquote>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h3 id="使用-DOM-方法来遍历一个文档"><a href="#使用-DOM-方法来遍历一个文档" class="headerlink" title="使用 DOM 方法来遍历一个文档"></a>使用 DOM 方法来遍历一个文档</h3><p><strong>问题</strong></p>
<p>你有一个 HTML 文档要从中提取数据，并了解这个 HTML 文档的结构。</p>
<p><strong>方法</strong></p>
<p>将 HTML 解析成一个<code>Document</code>之后，就可以使用类似于 DOM 的方法进行操作。示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/tmp/input.html&quot;</span>);</span><br><span class="line"><span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> Jsoup.parse(input, <span class="string">&quot;UTF-8&quot;</span>, <span class="string">&quot;http://example.com/&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Element</span> <span class="variable">content</span> <span class="operator">=</span> doc.getElementById(<span class="string">&quot;content&quot;</span>);</span><br><span class="line"><span class="type">Elements</span> <span class="variable">links</span> <span class="operator">=</span> content.getElementsByTag(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Element link : links) &#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">linkHref</span> <span class="operator">=</span> link.attr(<span class="string">&quot;href&quot;</span>);</span><br><span class="line">  <span class="type">String</span> <span class="variable">linkText</span> <span class="operator">=</span> link.text();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong></p>
<p><code>Elements</code> 这个对象提供了一系列类似于 DOM 的方法来查找元素，抽取并处理其中的数据。</p>
<p>具体如下：</p>
<h4 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h4><ul>
<li><code>getElementById(String id)</code></li>
<li><code>getElementsByTag(String tag)</code></li>
<li><code>getElementsByClass(String className)</code></li>
<li><code>getElementsByAttribute(String key)</code> (and related methods)</li>
<li>Element siblings: <code>siblingElements()</code>, <code>firstElementSibling()</code>, <code>lastElementSibling()</code>;<code>nextElementSibling()</code>, <code>previousElementSibling()</code></li>
<li>Graph: <code>parent()</code>, <code>children()</code>, <code>child(int index)</code></li>
</ul>
<h4 id="元素数据"><a href="#元素数据" class="headerlink" title="元素数据"></a>元素数据</h4><ul>
<li><code>attr(String key)</code>获取属性<code>attr(String key, String value)</code>设置属性</li>
<li><code>attributes()</code>获取所有属性</li>
<li><code>id()</code>, <code>className()</code> and <code>classNames()</code></li>
<li><code>text()</code>获取文本内容<code>text(String value)</code> 设置文本内容</li>
<li><code>html()</code>获取元素内 HTML<code>html(String value)</code>设置元素内的 HTML 内容</li>
<li><code>outerHtml()</code>获取元素外 HTML 内容</li>
<li><code>data()</code>获取数据内容（例如：script 和 style 标签)</li>
<li><code>tag()</code> and <code>tagName()</code></li>
</ul>
<h4 id="操作-HTML-和文本"><a href="#操作-HTML-和文本" class="headerlink" title="操作 HTML 和文本"></a>操作 HTML 和文本</h4><ul>
<li><code>append(String html)</code>, <code>prepend(String html)</code></li>
<li><code>appendText(String text)</code>, <code>prependText(String text)</code></li>
<li><code>appendElement(String tagName)</code>, <code>prependElement(String tagName)</code></li>
<li><code>html(String value)</code></li>
</ul>
<h3 id="使用选择器语法来查找元素"><a href="#使用选择器语法来查找元素" class="headerlink" title="使用选择器语法来查找元素"></a>使用选择器语法来查找元素</h3><p><strong>问题</strong></p>
<p>你想使用类似于 CSS 或 jQuery 的语法来查找和操作元素。</p>
<p><strong>方法</strong></p>
<p>可以使用<code>Element.select(String selector)</code> 和 <code>Elements.select(String selector)</code> 方法实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/tmp/input.html&quot;</span>);</span><br><span class="line"><span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> Jsoup.parse(input, <span class="string">&quot;UTF-8&quot;</span>, <span class="string">&quot;http://example.com/&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Elements</span> <span class="variable">links</span> <span class="operator">=</span> doc.select(<span class="string">&quot;a[href]&quot;</span>); <span class="comment">//带有href属性的a元素</span></span><br><span class="line"><span class="type">Elements</span> <span class="variable">pngs</span> <span class="operator">=</span> doc.select(<span class="string">&quot;img[src$=.png]&quot;</span>);</span><br><span class="line">  <span class="comment">//扩展名为.png的图片</span></span><br><span class="line"></span><br><span class="line"><span class="type">Element</span> <span class="variable">masthead</span> <span class="operator">=</span> doc.select(<span class="string">&quot;div.masthead&quot;</span>).first();</span><br><span class="line">  <span class="comment">//class等于masthead的div标签</span></span><br><span class="line"></span><br><span class="line"><span class="type">Elements</span> <span class="variable">resultLinks</span> <span class="operator">=</span> doc.select(<span class="string">&quot;h3.r &gt; a&quot;</span>); <span class="comment">//在h3元素之后的a元素</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>说明</strong></p>
<p>jsoup elements 对象支持类似于<a target="_blank" rel="noopener" href="http://www.w3.org/TR/2009/PR-css3-selectors-20091215/">CSS</a> (或<a target="_blank" rel="noopener" href="http://jquery.com/">jquery</a>)的选择器语法，来实现非常强大和灵活的查找功能。.</p>
<p>这个<code>select</code> 方法在<code>Document</code>, <code>Element</code>,或<code>Elements</code>对象中都可以使用。且是上下文相关的，因此可实现指定元素的过滤，或者链式选择访问。</p>
<p>Select 方法将返回一个<code>Elements</code>集合，并提供一组方法来抽取和处理结果。</p>
</blockquote>
<h4 id="Selector-选择器概述"><a href="#Selector-选择器概述" class="headerlink" title="Selector 选择器概述"></a>Selector 选择器概述</h4><ul>
<li><code>tagname</code>: 通过标签查找元素，比如：<code>a</code></li>
<li><code>ns|tag</code>: 通过标签在命名空间查找元素，比如：可以用 <code>fb|name</code> 语法来查找 &#96;&#96; 元素</li>
<li><code>#id</code>: 通过 ID 查找元素，比如：<code>#logo</code></li>
<li><code>.class</code>: 通过 class 名称查找元素，比如：<code>.masthead</code></li>
<li><code>[attribute]</code>: 利用属性查找元素，比如：<code>[href]</code></li>
<li><code>[^attr]</code>: 利用属性名前缀来查找元素，比如：可以用<code>[^data-]</code> 来查找带有 HTML5 Dataset 属性的元素</li>
<li><code>[attr=value]</code>: 利用属性值来查找元素，比如：<code>[width=500]</code></li>
<li><code>[attr^=value]</code>, <code>[attr$=value]</code>, <code>[attr*=value]</code>: 利用匹配属性值开头、结尾或包含属性值来查找元素，比如：<code>[href*=/path/]</code></li>
<li><code>[attr\~=regex]</code>: 利用属性值匹配正则表达式来查找元素，比如： <code>img[src\~=(?i)\.(png|jpe?g)]</code></li>
<li><code>*</code>: 这个符号将匹配所有元素</li>
</ul>
<h4 id="Selector-选择器组合使用"><a href="#Selector-选择器组合使用" class="headerlink" title="Selector 选择器组合使用"></a>Selector 选择器组合使用</h4><ul>
<li><code>el##id</code>: 元素+ID，比如： <code>div##logo</code></li>
<li><code>el.class</code>: 元素+class，比如： <code>div.masthead</code></li>
<li><code>el[attr]</code>: 元素+class，比如： <code>a[href]</code></li>
<li>任意组合，比如：<code>a[href].highlight</code></li>
<li><code>ancestor child</code>: 查找某个元素下子元素，比如：可以用<code>.body p</code> 查找在”body”元素下的所有<code>p</code>元素</li>
<li><code>parent &gt; child</code>: 查找某个父元素下的直接子元素，比如：可以用<code>div.content &gt; p</code> 查找 <code>p</code> 元素，也可以用<code>body &gt; *</code> 查找 body 标签下所有直接子元素</li>
<li><code>siblingA + siblingB</code>: 查找在 A 元素之前第一个同级元素 B，比如：<code>div.head + div</code></li>
<li><code>siblingA \~ siblingX</code>: 查找 A 元素之前的同级 X 元素，比如：<code>h1 \~ p</code></li>
<li><code>el, el, el</code>:多个选择器组合，查找匹配任一选择器的唯一元素，例如：<code>div.masthead, div.logo</code></li>
</ul>
<h4 id="伪选择器-selectors"><a href="#伪选择器-selectors" class="headerlink" title="伪选择器 selectors"></a>伪选择器 selectors</h4><ul>
<li><code>:lt(n)</code>: 查找哪些元素的同级索引值（它的位置在 DOM 树中是相对于它的父节点）小于 n，比如：<code>td:lt(3)</code> 表示小于三列的元素</li>
<li><code>:gt(n)</code>:查找哪些元素的同级索引值大于<code>n``，比如</code>： <code>div p:gt(2)</code>表示哪些 div 中有包含 2 个以上的 p 元素</li>
<li><code>:eq(n)</code>: 查找哪些元素的同级索引值与<code>n</code>相等，比如：<code>form input:eq(1)</code>表示包含一个 input 标签的 Form 元素</li>
<li><code>:has(seletor)</code>: 查找匹配选择器包含元素的元素，比如：<code>div:has(p)</code>表示哪些 div 包含了 p 元素</li>
<li><code>:not(selector)</code>: 查找与选择器不匹配的元素，比如： <code>div:not(.logo)</code> 表示不包含 class&#x3D;logo 元素的所有 div 列表</li>
<li><code>:contains(text)</code>: 查找包含给定文本的元素，搜索不区分大不写，比如： <code>p:contains(jsoup)</code></li>
<li><code>:containsOwn(text)</code>: 查找直接包含给定文本的元素</li>
<li><code>:matches(regex)</code>: 查找哪些元素的文本匹配指定的正则表达式，比如：<code>div:matches((?i)login)</code></li>
<li><code>:matchesOwn(regex)</code>: 查找自身包含文本匹配指定正则表达式的元素</li>
<li>注意：上述伪选择器索引是从 0 开始的，也就是说第一个元素索引值为 0，第二个元素 index 为 1 等</li>
</ul>
<p>可以查看<code>Selector</code> API 参考来了解更详细的内容</p>
<h3 id="从元素抽取属性，文本和-HTML"><a href="#从元素抽取属性，文本和-HTML" class="headerlink" title="从元素抽取属性，文本和 HTML"></a>从元素抽取属性，文本和 HTML</h3><p><strong>问题</strong></p>
<p>在解析获得一个 Document 实例对象，并查找到一些元素之后，你希望取得在这些元素中的数据。</p>
<p><strong>方法</strong></p>
<ul>
<li>要取得一个属性的值，可以使用<code>Node.attr(String key)</code> 方法</li>
<li>对于一个元素中的文本，可以使用<code>Element.text()</code>方法</li>
<li>对于要取得元素或属性中的 HTML 内容，可以使用<code>Element.html()</code>, 或 <code>Node.outerHtml()</code>方法</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">html</span> <span class="operator">=</span> <span class="string">&quot;&lt;p&gt;An &lt;a href=&#x27;http://example.com/&#x27;&gt;&lt;b&gt;example&lt;/b&gt;&lt;/a&gt; link.&lt;/p&gt;&quot;</span>;</span><br><span class="line"><span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> Jsoup.parse(html);<span class="comment">//解析HTML字符串返回一个Document实现</span></span><br><span class="line"><span class="type">Element</span> <span class="variable">link</span> <span class="operator">=</span> doc.select(<span class="string">&quot;a&quot;</span>).first();<span class="comment">//查找第一个a元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> doc.body().text(); <span class="comment">// &quot;An example link&quot;//取得字符串中的文本</span></span><br><span class="line"><span class="type">String</span> <span class="variable">linkHref</span> <span class="operator">=</span> link.attr(<span class="string">&quot;href&quot;</span>); <span class="comment">// &quot;http://example.com/&quot;//取得链接地址</span></span><br><span class="line"><span class="type">String</span> <span class="variable">linkText</span> <span class="operator">=</span> link.text(); <span class="comment">// &quot;example&quot;&quot;//取得链接地址中的文本</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">linkOuterH</span> <span class="operator">=</span> link.outerHtml();</span><br><span class="line">    <span class="comment">// &quot;&lt;a href=&quot;http://example.com&quot;&gt;&lt;b&gt;example&lt;/b&gt;&lt;/a&gt;&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">linkInnerH</span> <span class="operator">=</span> link.html(); <span class="comment">// &quot;&lt;b&gt;example&lt;/b&gt;&quot;//取得链接内的html内容</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>说明</strong></p>
<p>上述方法是元素数据访问的核心办法。此外还其它一些方法可以使用：</p>
<ul>
<li><code>Element.id()</code></li>
<li><code>Element.tagName()</code></li>
<li><code>Element.className()</code> and <code>Element.hasClass(String className)</code></li>
</ul>
<p>这些访问器方法都有相应的 setter 方法来更改数据</p>
</blockquote>
<p><strong>参见</strong></p>
<ul>
<li><code>Element</code>和<code>Elements</code>集合类的参考文档</li>
<li><a target="_blank" rel="noopener" href="http://www.open-open.com/jsoup/working-with-urls.htm">URLs 处理</a></li>
<li><a target="_blank" rel="noopener" href="http://www.open-open.com/jsoup/selector-syntax.htm">使用 CSS 选择器语法来查找元素</a></li>
</ul>
<h3 id="处理-URLs"><a href="#处理-URLs" class="headerlink" title="处理 URLs"></a>处理 URLs</h3><p><strong>问题</strong></p>
<p>你有一个包含相对 URLs 路径的 HTML 文档，需要将这些相对路径转换成绝对路径的 URLs。</p>
<p><strong>方法</strong></p>
<ol>
<li>在你解析文档时确保有指定<code>base URI</code>，然后</li>
<li>使用 <code>abs:</code> 属性前缀来取得包含<code>base URI</code>的绝对路径。代码如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> Jsoup.connect(<span class="string">&quot;http://www.open-open.com&quot;</span>).get();</span><br><span class="line"></span><br><span class="line"><span class="type">Element</span> <span class="variable">link</span> <span class="operator">=</span> doc.select(<span class="string">&quot;a&quot;</span>).first();</span><br><span class="line"><span class="type">String</span> <span class="variable">relHref</span> <span class="operator">=</span> link.attr(<span class="string">&quot;href&quot;</span>); <span class="comment">// == &quot;/&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">absHref</span> <span class="operator">=</span> link.attr(<span class="string">&quot;abs:href&quot;</span>); <span class="comment">// &quot;http://www.open-open.com/&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>说明</strong></p>
<p>在 HTML 元素中，URLs 经常写成相对于文档位置的相对路径： <code>&lt;a href=&quot;/download&quot;&gt;...&lt;/a&gt;</code>. 当你使用 <code>Node.attr(String key)</code> 方法来取得 a 元素的 href 属性时，它将直接返回在 HTML 源码中指定定的值。</p>
<p>假如你需要取得一个绝对路径，需要在属性名前加 <code>abs:</code> 前缀。这样就可以返回包含根路径的 URL 地址<code>attr(&quot;abs:href&quot;)</code></p>
<p>因此，在解析 HTML 文档时，定义 base URI 非常重要。</p>
<p>如果你不想使用<code>abs:</code> 前缀，还有一个方法能够实现同样的功能 <code>Node.absUrl(String key)</code>。</p>
</blockquote>
<h2 id="数据修改"><a href="#数据修改" class="headerlink" title="数据修改"></a>数据修改</h2><h3 id="设置属性的值"><a href="#设置属性的值" class="headerlink" title="设置属性的值"></a>设置属性的值</h3><p><strong>问题</strong></p>
<p>在你解析一个 <code>Document</code> 之后可能想修改其中的某些属性值，然后再保存到磁盘或都输出到前台页面。</p>
<p><strong>方法</strong></p>
<p>可以使用属性设置方法 <code>Element.attr(String key, String value)</code>, 和 <code>Elements.attr(String key, String value)</code>.</p>
<p>假如你需要修改一个元素的 <code>class</code> 属性，可以使用 <code>Element.addClass(String className)</code> 和<code>Element.removeClass(String className)</code> 方法。</p>
<p><code>Elements</code> 提供了批量操作元素属性和 class 的方法，比如：要为 div 中的每一个 a 元素都添加一个<code>rel=&quot;nofollow&quot;</code> 可以使用如下方法：</p>
<figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">doc.<span class="keyword">select</span>(<span class="string">&quot;div.comments a&quot;</span>).<span class="built_in">attr</span>(<span class="string">&quot;rel&quot;</span>, <span class="string">&quot;nofollow&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>说明</strong></p>
<p>与<code>Element</code>中的其它方法一样，<code>attr</code> 方法也是返回当 <code>Element</code> (或在使用选择器是返回 <code>Elements</code>集合)。这样能够很方便使用方法连用的书写方式。比如：</p>
<figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doc.<span class="keyword">select</span>(<span class="string">&quot;div.masthead&quot;</span>).<span class="built_in">attr</span>(<span class="string">&quot;title&quot;</span>, <span class="string">&quot;jsoup&quot;</span>).addClass(<span class="string">&quot;round-box&quot;</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="设置一个元素的-HTML-内容"><a href="#设置一个元素的-HTML-内容" class="headerlink" title="设置一个元素的 HTML 内容"></a>设置一个元素的 HTML 内容</h3><p><strong>问题</strong></p>
<p>你需要一个元素中的 HTML 内容</p>
<p><strong>方法</strong></p>
<p>可以使用<code>Element</code>中的 HTML 设置方法具体如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Element</span> <span class="variable">div</span> <span class="operator">=</span> doc.select(<span class="string">&quot;div&quot;</span>).first(); <span class="comment">// &lt;div&gt;&lt;/div&gt;</span></span><br><span class="line">div.html(<span class="string">&quot;&lt;p&gt;lorem ipsum&lt;/p&gt;&quot;</span>); <span class="comment">// &lt;div&gt;&lt;p&gt;lorem ipsum&lt;/p&gt;&lt;/div&gt;</span></span><br><span class="line">div.prepend(<span class="string">&quot;&lt;p&gt;First&lt;/p&gt;&quot;</span>);<span class="comment">//在div前添加html内容</span></span><br><span class="line">div.append(<span class="string">&quot;&lt;p&gt;Last&lt;/p&gt;&quot;</span>);<span class="comment">//在div之后添加html内容</span></span><br><span class="line"><span class="comment">// 添完后的结果: &lt;div&gt;&lt;p&gt;First&lt;/p&gt;&lt;p&gt;lorem ipsum&lt;/p&gt;&lt;p&gt;Last&lt;/p&gt;&lt;/div&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="type">Element</span> <span class="variable">span</span> <span class="operator">=</span> doc.select(<span class="string">&quot;span&quot;</span>).first(); <span class="comment">// &lt;span&gt;One&lt;/span&gt;</span></span><br><span class="line">span.wrap(<span class="string">&quot;&lt;li&gt;&lt;a href=&#x27;http://example.com/&#x27;&gt;&lt;/a&gt;&lt;/li&gt;&quot;</span>);</span><br><span class="line"><span class="comment">// 添完后的结果: &lt;li&gt;&lt;a href=&quot;http://example.com&quot;&gt;&lt;span&gt;One&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>说明</strong></p>
<ul>
<li><code>Element.html(String html)</code> 这个方法将先清除元素中的 HTML 内容，然后用传入的 HTML 代替。</li>
<li><code>Element.prepend(String first)</code> 和 <code>Element.append(String last)</code> 方法用于在分别在元素内部 HTML 的前面和后面添加 HTML 内容</li>
<li><code>Element.wrap(String around)</code> 对元素包裹一个外部 HTML 内容。</li>
</ul>
<p><strong>参见</strong></p>
<p>可以查看 API 参考文档中 <code>Element.prependElement(String tag)</code>和<code>Element.appendElement(String tag)</code> 方法来创建新的元素并作为文档的子元素插入其中。</p>
</blockquote>
<h3 id="设置元素的文本内容"><a href="#设置元素的文本内容" class="headerlink" title="设置元素的文本内容"></a>设置元素的文本内容</h3><p><strong>问题</strong></p>
<p>你需要修改一个 HTML 文档中的文本内容</p>
<p><strong>方法</strong></p>
<p>可以使用<code>Element</code>的设置方法：:</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Element div =<span class="built_in"> doc</span>.select(<span class="string">&quot;div&quot;</span>).first(); // <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">div.<span class="type">text</span>(<span class="string">&quot;five &gt; four&quot;</span>); // <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>five <span class="symbol">&amp;gt;</span> four<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">div.prepend(<span class="string">&quot;First &quot;</span>);</span><br><span class="line">div.append(<span class="string">&quot; Last&quot;</span>);</span><br><span class="line">// now: <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>First five <span class="symbol">&amp;gt;</span> four Last<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>说明</strong></p>
<p>文本设置方法与 <a target="_blank" rel="noopener" href="http://jsoup.org/cookbook/modifying-data/set-html">HTML setter</a> 方法一样：</p>
<ul>
<li><code>Element.text(String text)</code> 将清除一个元素中的内部 HTML 内容，然后提供的文本进行代替</li>
<li><code>Element.prepend(String first)</code> 和 <code>Element.append(String last)</code> 将分别在元素的内部 html 前后添加文本节点。</li>
</ul>
<p>对于传入的文本如果含有像 <code>&lt;</code>, <code>&gt;</code> 等这样的字符，将以文本处理，而非 HTML。</p>
</blockquote>
<h2 id="HTML-清理"><a href="#HTML-清理" class="headerlink" title="HTML 清理"></a>HTML 清理</h2><h3 id="消除不受信任的-HTML-来防止-XSS-攻击"><a href="#消除不受信任的-HTML-来防止-XSS-攻击" class="headerlink" title="消除不受信任的 HTML (来防止 XSS 攻击)"></a>消除不受信任的 HTML (来防止 XSS 攻击)</h3><p><strong>问题</strong></p>
<p>在做网站的时候，经常会提供用户评论的功能。有些不怀好意的用户，会搞一些脚本到评论内容中，而这些脚本可能会破坏整个页面的行为，更严重的是获取一些机要信息，此时需要清理该 HTML，以避免跨站脚本<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Cross-site_scripting">cross-site scripting</a>攻击（XSS）。</p>
<p><strong>方法</strong></p>
<p>使用 jsoup HTML <code>Cleaner</code> 方法进行清除，但需要指定一个可配置的 <code>Whitelist</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">unsafe</span> <span class="operator">=</span></span><br><span class="line">  <span class="string">&quot;&lt;p&gt;&lt;a href=&#x27;http://example.com/&#x27; onclick=&#x27;stealCookies()&#x27;&gt;Link&lt;/a&gt;&lt;/p&gt;&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">safe</span> <span class="operator">=</span> Jsoup.clean(unsafe, Whitelist.basic());</span><br><span class="line"><span class="comment">// now: &lt;p&gt;&lt;a href=&quot;http://example.com/&quot; rel=&quot;nofollow&quot;&gt;Link&lt;/a&gt;&lt;/p&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>说明</strong></p>
<p>XSS 又叫 CSS (Cross Site Script) ，跨站脚本攻击。它指的是恶意攻击者往 Web 页面里插入恶意 html 代码，当用户浏览该页之时，嵌入其中 Web 里面的 html 代码会被执行，从而达到恶意攻击用户的特殊目的。XSS 属于被动式的攻击，因为其被动且不好利用，所以许多人常忽略其危害性。所以我们经常只让用户输入纯文本的内容，但这样用户体验就比较差了。</p>
<p>一个更好的解决方法就是使用一个富文本编辑器 WYSIWYG 如 <a target="_blank" rel="noopener" href="http://ckeditor.com/">CKEditor</a> 和 <a target="_blank" rel="noopener" href="http://tinymce.moxiecode.com/">TinyMCE</a>。这些可以输出 HTML 并能够让用户可视化编辑。虽然他们可以在客户端进行校验，但是这样还不够安全，需要在服务器端进行校验并清除有害的 HTML 代码，这样才能确保输入到你网站的 HTML 是安全的。否则，攻击者能够绕过客户端的 Javascript 验证，并注入不安全的 HMTL 直接进入您的网站。</p>
<p>jsoup 的 whitelist 清理器能够在服务器端对用户输入的 HTML 进行过滤，只输出一些安全的标签和属性。</p>
<p>jsoup 提供了一系列的 <code>Whitelist</code> 基本配置，能够满足大多数要求；但如有必要，也可以进行修改，不过要小心。</p>
<p>这个 cleaner 非常好用不仅可以避免 XSS 攻击，还可以限制用户可以输入的标签范围。</p>
<p><strong>参见</strong></p>
<ul>
<li>参阅<a target="_blank" rel="noopener" href="http://ha.ckers.org/xss.html">XSS cheat sheet</a> ，有一个例子可以了解为什么不能使用正则表达式，而采用安全的 whitelist parser-based 清理器才是正确的选择。</li>
<li>参阅<code>Cleaner</code> ，了解如何返回一个 <code>Document</code> 对象，而不是字符串</li>
<li>参阅<code>Whitelist</code>，了解如何创建一个自定义的 whitelist</li>
<li><a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Nofollow">nofollow</a> 链接属性了解</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/jhy/jsoup">jsoup github 托管代码</a></li>
<li><a target="_blank" rel="noopener" href="https://jsoup.org/cookbook/">jsoup Cookbook</a></li>
<li><a target="_blank" rel="noopener" href="http://www.open-open.com/jsoup/">jsoup Cookbook(中文版)</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/code4craft/jsoup-learning">不错的 jsoup 学习笔记</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/b563af/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/b563af/" class="post-title-link" itemprop="url">ZXing 快速入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-17 22:34:30" itemprop="dateCreated datePublished" datetime="2022-02-17T22:34:30+08:00">2022-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E5%B7%A5%E5%85%B7/%E5%85%B6%E4%BB%96/" itemprop="url" rel="index"><span itemprop="name">其他</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="ZXing-快速入门"><a href="#ZXing-快速入门" class="headerlink" title="ZXing 快速入门"></a>ZXing 快速入门</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>ZXing</code> 是一个开源 Java 类库用于解析多种格式的 1D&#x2F;2D 条形码。目标是能够对 QR 编码、Data Matrix、UPC 的 1D 条形码进行解码。 其提供了多种平台下的客户端包括：J2ME、J2SE 和 Android。</p>
<p>官网：<a target="_blank" rel="noopener" href="https://github.com/zxing/zxing"><u>ZXing github 仓库</u></a></p>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p><strong><em>本例演示如何在一个非 android 的 Java 项目中使用 ZXing 来生成、解析二维码图片。</em></strong></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>maven 项目只需引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.zxing<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.zxing<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javase<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果非 maven 项目，就去官网下载发布版本：<a target="_blank" rel="noopener" href="https://github.com/zxing/zxing/releases"><u>下载地址</u></a></p>
<h3 id="生成二维码图片"><a href="#生成二维码图片" class="headerlink" title="生成二维码图片"></a>生成二维码图片</h3><p>ZXing 生成二维码图片有以下步骤：</p>
<ol>
<li><code>com.google.zxing.MultiFormatWriter</code> 根据内容以及图像编码参数生成图像 2D 矩阵。</li>
<li>​ <code>com.google.zxing.client.j2se.MatrixToImageWriter</code> 根据图像矩阵生成图片文件或图片缓存 <code>BufferedImage</code> 。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(String content, String filepath)</span> <span class="keyword">throws</span> WriterException, IOException &#123;</span><br><span class="line"> <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"> <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"> Map&lt;EncodeHintType, Object&gt; encodeHints = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;EncodeHintType, Object&gt;();</span><br><span class="line"> encodeHints.put(EncodeHintType.CHARACTER_SET, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"> <span class="type">BitMatrix</span> <span class="variable">bitMatrix</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MultiFormatWriter</span>().encode(content, BarcodeFormat.QR_CODE, width, height, encodeHints);</span><br><span class="line"> <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> FileSystems.getDefault().getPath(filepath);</span><br><span class="line"> MatrixToImageWriter.writeToPath(bitMatrix, <span class="string">&quot;png&quot;</span>, path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解析二维码图片"><a href="#解析二维码图片" class="headerlink" title="解析二维码图片"></a>解析二维码图片</h3><p>ZXing 解析二维码图片有以下步骤：</p>
<ol>
<li><p>使用 <code>javax.imageio.ImageIO</code> 读取图片文件，并存为一个 <code>java.awt.image.BufferedImage</code> 对象。</p>
</li>
<li><p>将 <code>java.awt.image.BufferedImage</code> 转换为 ZXing 能识别的 <code>com.google.zxing.BinaryBitmap</code> 对象。</p>
</li>
<li><p><code>com.google.zxing.MultiFormatReader</code> 根据图像解码参数来解析 <code>com.google.zxing.BinaryBitmap</code> 。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">decode</span><span class="params">(String filepath)</span> <span class="keyword">throws</span> IOException, NotFoundException &#123;</span><br><span class="line"> <span class="type">BufferedImage</span> <span class="variable">bufferedImage</span> <span class="operator">=</span> ImageIO.read(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filepath));</span><br><span class="line"> <span class="type">LuminanceSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedImageLuminanceSource</span>(bufferedImage);</span><br><span class="line"> <span class="type">Binarizer</span> <span class="variable">binarizer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HybridBinarizer</span>(source);</span><br><span class="line"> <span class="type">BinaryBitmap</span> <span class="variable">bitmap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinaryBitmap</span>(binarizer);</span><br><span class="line"> HashMap&lt;DecodeHintType, Object&gt; decodeHints = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;DecodeHintType, Object&gt;();</span><br><span class="line"> decodeHints.put(DecodeHintType.CHARACTER_SET, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"> <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MultiFormatReader</span>().decode(bitmap, decodeHints);</span><br><span class="line"> <span class="keyword">return</span> result.getText();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整参考示例：<a target="_blank" rel="noopener" href="https://github.com/dunwu/JavaParty/blob/master/toolbox/image/src/test/java/org/zp/image/QRCodeUtilTest.java"><u>测试例代码</u></a></p>
<p>以下是一个生成的二维码图片示例：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3101171-26b73730088f0ab8.png" alt="img"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://github.com/zxing/zxing">ZXing github 仓库</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/364124/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/364124/" class="post-title-link" itemprop="url">Hystrix 快速入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-17 22:34:30" itemprop="dateCreated datePublished" datetime="2022-02-17T22:34:30+08:00">2022-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">中间件</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/" itemprop="url" rel="index"><span itemprop="name">流量控制</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>11 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Hystrix-快速入门"><a href="#Hystrix-快速入门" class="headerlink" title="Hystrix 快速入门"></a>Hystrix 快速入门</h1><h2 id="一、Hystrix-简介"><a href="#一、Hystrix-简介" class="headerlink" title="一、Hystrix 简介"></a>一、Hystrix 简介</h2><h3 id="Hystrix-是什么"><a href="#Hystrix-是什么" class="headerlink" title="Hystrix 是什么"></a>Hystrix 是什么</h3><p>Hystrix 是 Netflix 开源的一款容错框架，包含常用的容错方法：线程池隔离、信号量隔离、熔断、降级。</p>
<p>Hystrix 官方宣布<strong>不再发布新版本</strong>。</p>
<p>但是 Hystrix 的客户端熔断保护，断路器设计理念，有非常高的学习价值。</p>
<h3 id="为什么需要-Hystrix"><a href="#为什么需要-Hystrix" class="headerlink" title="为什么需要 Hystrix"></a>为什么需要 Hystrix</h3><p>复杂的分布式系统架构中的应用程序往往具有数十个依赖项，每个依赖项都会不可避免地在某个时刻失败。 如果主机应用程序未与这些外部故障隔离开来，则可能会被波及。</p>
<p>例如，对于依赖于 30 个服务的应用程序，假设每个服务的正常运行时间为 99.99％，则可以期望：</p>
<blockquote>
<p>99.99<sup>30</sup> &#x3D; 99.7％ 的正常运行时间</p>
<p>10 亿个请求中的 0.3％&#x3D; 3,000,000 个失败</p>
<p>即使所有依赖项都具有出色的正常运行时间，每月也会有 2 个小时以上的停机时间。</p>
<p>然而，现实情况一般比这种估量情况更糟糕。</p>
</blockquote>
<hr>
<p>当一切正常时，整体系统如下所示：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200717141615.png" alt="img"></p>
<p>在高并发场景，这些依赖的稳定性与否对系统的影响非常大，但是依赖有很多不可控问题：如网络连接、资源繁忙、服务宕机等。例如：下图中有一个 QPS 为 50 的依赖 I 出现不可用，但是其他依赖服务是可用的。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200717141749.png" alt="img"></p>
<p>但是，在高并发场景下，当依赖 I 阻塞时，大多数服务器的线程池就出现阻塞(BLOCK)。当这种级联故障愈演愈烈，就可能造成整个线上服务不可用的雪崩效应，如下图：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200717141859.png" alt="img"></p>
<p>Hystrix 就是为了解决这类问题而应运而生。</p>
<h3 id="Hystrix-的功能"><a href="#Hystrix-的功能" class="headerlink" title="Hystrix 的功能"></a>Hystrix 的功能</h3><p>Hystrix 具有以下功能：</p>
<ul>
<li>避免资源耗尽：阻止任何一个依赖服务耗尽所有的资源，比如 tomcat 中的所有线程资源。</li>
<li>避免请求排队和积压：采用限流和 <code>fail fast</code> 来控制故障。</li>
<li>支持降级：提供 fallback 降级机制来应对故障。</li>
<li>资源隔离：比如 <code>bulkhead</code>（舱壁隔离技术）、<code>swimlane</code>（泳道技术）、<code>circuit breaker</code>（断路技术）来限制任何一个依赖服务的故障的影响。</li>
<li>统计&#x2F;监控&#x2F;报警：通过近实时的统计&#x2F;监控&#x2F;报警功能，来提高故障发现的速度。</li>
<li>通过近实时的属性和配置<strong>热修改</strong>功能，来提高故障处理和恢复的速度。</li>
<li>保护依赖服务调用的所有故障情况，而不仅仅只是网络故障情况。</li>
</ul>
<p>如果使用 Hystrix 对每个基础依赖服务进行过载保护，则整个系统架构将会类似下图所示，每个依赖项彼此隔离，受到延迟时发生饱和的资源的被限制访问，并包含 fallback 逻辑（用于降级处理），该逻辑决定了在依赖项中发生任何类型的故障时做出对应的处理。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200717142842.png" alt="img"></p>
<h2 id="Hystrix-核心概念"><a href="#Hystrix-核心概念" class="headerlink" title="Hystrix 核心概念"></a>Hystrix 核心概念</h2><h2 id="二、Hystrix-工作流程"><a href="#二、Hystrix-工作流程" class="headerlink" title="二、Hystrix 工作流程"></a>二、Hystrix 工作流程</h2><p>如下图所示，Hystrix 的工作流程大致可以分为 9 个步骤。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200717143247.png" alt="img"></p>
<h3 id="（一）包装命令"><a href="#（一）包装命令" class="headerlink" title="（一）包装命令"></a>（一）包装命令</h3><p>x 支持资源隔离。</p>
<p>资源隔离，就是说，你如果要把对某一个依赖服务的所有调用请求，全部隔离在同一份资源池内，不会去用其它资源了，这就叫资源隔离。哪怕对这个依赖服务，比如说商品服务，现在同时发起的调用量已经到了 1000，但是分配给商品服务线程池内就 10 个线程，最多就只会用这 10 个线程去执行。不会因为对商品服务调用的延迟，将 Tomcat 内部所有的线程资源全部耗尽。</p>
<p>Hystrix 进行资源隔离，其实是提供了一个抽象，叫做命令模式。这也是 Hystrix 最最基本的资源隔离技术。</p>
<p>在使用 Hystrix 的过程中，会对<strong>依赖服务</strong>的调用请求封装成<strong>命令对象</strong>，Hystrix 对 <strong>命令对象</strong>抽象了两个抽象类：<code>HystrixCommand</code> 和<code>HystrixObservableCommand</code> 。</p>
<ul>
<li><code>HystrixCommand</code> 表示的<strong>命令对象</strong>会返回一个唯一返回值。</li>
<li><code>HystrixObservableCommand</code> 表示的<strong>命令对象</strong> 会返回多个返回值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HystrixCommand</span> <span class="variable">command</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HystrixCommand</span>(arg1, arg2);</span><br><span class="line"><span class="type">HystrixObservableCommand</span> <span class="variable">command</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HystrixObservableCommand</span>(arg1, arg2);</span><br></pre></td></tr></table></figure>

<h3 id="（二）执行命令"><a href="#（二）执行命令" class="headerlink" title="（二）执行命令"></a>（二）执行命令</h3><p>Hystrix 中共有 4 种方式执行命令，如下所示：</p>
<table>
<thead>
<tr>
<th align="left">执行方式</th>
<th align="left">说明</th>
<th align="left">可用对象</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>execute()</code></td>
<td align="left">阻塞式同步执行，返回依赖服务的单一返回结果(或者抛出异常)</td>
<td align="left"><code>HystrixCommand</code></td>
</tr>
<tr>
<td align="left"><code>queue()</code></td>
<td align="left">基于 Future 的异步方式执行，返回依赖服务的单一返回结果(或者抛出异常)</td>
<td align="left"><code>HystrixCommand</code></td>
</tr>
<tr>
<td align="left"><code>observe()</code></td>
<td align="left">基于 Rxjava 的 Observable 方式，返回通过 Observable 表示的依赖服务返回结果,代调用代码先执行(Hot Obserable)</td>
<td align="left"><code>HystrixObservableCommand</code></td>
</tr>
<tr>
<td align="left"><code>toObvsevable</code></td>
<td align="left">基于 Rxjava 的 Observable 方式，返回通过 Observable 表示的依赖服务返回结果,执行代码等到真正订阅的时候才会执行(cold observable)</td>
<td align="left"><code>HystrixObservableCommand</code></td>
</tr>
</tbody></table>
<p>这四种命令中，<code>exeucte()</code>、<code>queue()</code>、<code>observe()</code>的表示也是通过<code>toObservable()</code>实现的，其转换关系如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14126519-60964d9fa41614c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/563/format/webp" alt="img"></p>
<p><code>HystrixCommand</code> 执行方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">K</span> <span class="variable">value</span>   <span class="operator">=</span> command.execute();</span><br><span class="line"><span class="comment">// 等价语句：</span></span><br><span class="line"><span class="type">K</span> <span class="variable">value</span> <span class="operator">=</span> command.execute().queue().get();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Future&lt;K&gt; fValue  = command.queue();</span><br><span class="line"><span class="comment">//等价语句：</span></span><br><span class="line">Future&lt;K&gt; fValue = command.toObservable().toBlocking().toFuture();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Observable&lt;K&gt; ohValue = command.observe(); <span class="comment">//hot observable，立刻订阅，命令立刻执行</span></span><br><span class="line"><span class="comment">//等价语句：</span></span><br><span class="line">Observable&lt;K&gt; ohValue = command.toObservable().subscribe(subject);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述执行最终实现还是基于 toObservable()</span></span><br><span class="line">Observable&lt;K&gt; ocValue = command.toObservable(); <span class="comment">//cold observable，延后订阅，订阅发生后，执行才真正执行</span></span><br></pre></td></tr></table></figure>

<h3 id="（三）是否缓存"><a href="#（三）是否缓存" class="headerlink" title="（三）是否缓存"></a>（三）是否缓存</h3><p>如果当前命令对象配置了允许从<code>结果缓存</code>中取返回结果，并且在<code>结果缓存</code>中已经缓存了请求结果，则缓存的请求结果会立刻通过 <code>Observable</code> 的格式返回。</p>
<h3 id="（四）是否开启断路器"><a href="#（四）是否开启断路器" class="headerlink" title="（四）是否开启断路器"></a>（四）是否开启断路器</h3><p>如果第三步没有缓存没有命中，则判断一下当前断路器的断路状态是否打开。如果断路器状态为<code>打开</code>状态，则 <code>Hystrix</code> 将不会执行此 Command 命令，直接执行<strong>步骤 8</strong> 调用 Fallback；</p>
<p>如果断路器状态是<code>关闭</code>，则执行 <strong>步骤 5</strong> 检查是否有足够的资源运行 Command 命令</p>
<h3 id="（五）信号量、线程池是否拒绝"><a href="#（五）信号量、线程池是否拒绝" class="headerlink" title="（五）信号量、线程池是否拒绝"></a>（五）信号量、线程池是否拒绝</h3><p>如果当前要执行的 Command 命令 先关连的线程池 和队列(或者信号量)资源已经满了，Hystrix 将不会运行 Command 命令，直接执行 <strong>步骤 8</strong>的 Fallback 降级处理；如果未满，表示有剩余的资源执行 Command 命令，则执行<strong>步骤 6</strong></p>
<h3 id="（六）construct-或-run"><a href="#（六）construct-或-run" class="headerlink" title="（六）construct() 或 run()"></a>（六）construct() 或 run()</h3><p>当经过<strong>步骤 5</strong> 判断，有足够的资源执行 Command 命令时，本步骤将调用 Command 命令运行方法，基于不同类型的 Command，有如下两种两种运行方式：</p>
<table>
<thead>
<tr>
<th align="left">运行方式</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>HystrixCommand.run()</code></td>
<td align="left">返回一个处理结果或者抛出一个异常</td>
</tr>
<tr>
<td align="left"><code>HystrixObservableCommand.construct()</code></td>
<td align="left">返回一个 Observable 表示的结果(可能多个)，或者 基于<code>onError</code>的错误通知</td>
</tr>
</tbody></table>
<p>如果<code>run()</code> 或者<code>construct()</code>方法 的<code>真实执行时间</code>超过了 Command 设置的<code>超时时间阈值</code>, 则<strong>当前则执行线程</strong>（或者是独立的定时器线程）将会抛出<code>TimeoutException</code>。抛出超时异常 TimeoutException，后，将执行<strong>步骤 8</strong>的 Fallback 降级处理。即使<code>run()</code>或者<code>construct()</code>执行没有被取消或中断，最终能够处理返回结果，但在降级处理逻辑中，将会抛弃<code>run()</code>或<code>construct()</code>方法的返回结果，而返回 Fallback 降级处理结果。</p>
<blockquote>
<p><strong>注意事项</strong><br>需要注意的是，Hystrix 无法强制 将正在运行的线程停止掉–Hystrix 能够做的最好的方式就是在 JVM 中抛出一个<code>InterruptedException</code>。如果 Hystrix 包装的工作不抛出中断异常<code>InterruptedException</code>, 则在 Hystrix 线程池中的线程将会继续执行，尽管<code>调用的客户端</code>已经接收到了<code>TimeoutException</code>。这种方式会使 Hystrix 的线程池处于饱和状态。大部分的 Java Http Client 开源库并不会解析 <code>InterruptedException</code>。所以确认 HTTP client 相关的连接和读&#x2F;写相关的超时时间设置。<br>如果 Command 命令没有抛出任何异常，并且有返回结果，则 Hystrix 将会在做完日志记录和统计之后会将结果返回。 如果是通过<code>run()</code>方式运行，则返回一个<code>Obserable</code>对象，包含一个唯一值，并且发送一个<code>onCompleted</code>通知；如果是通过<code>consturct()</code>方式运行 ，则返回一个<code>Observable对象</code>。</p>
</blockquote>
<h3 id="（七）健康检查"><a href="#（七）健康检查" class="headerlink" title="（七）健康检查"></a>（七）健康检查</h3><p>Hystrix 会统计 Command 命令执行执行过程中的<strong>成功数</strong>、<strong>失败数</strong>、<strong>拒绝数</strong>和<strong>超时数</strong>,将这些信息记录到<strong>断路器(Circuit Breaker)<strong>中。断路器将上述统计按照</strong>时间窗</strong>的形式记录到一个定长数组中。断路器根据时间窗内的统计数据去判定请求什么时候可以被熔断，熔断后，在接下来一段恢复周期内，相同的请求过来后会直接被熔断。当再次校验，如果健康监测通过后，熔断开关将会被关闭。</p>
<h3 id="（八）获取-Fallback"><a href="#（八）获取-Fallback" class="headerlink" title="（八）获取 Fallback"></a>（八）获取 Fallback</h3><p>当以下场景出现后，Hystrix 将会尝试触发 <code>Fallback</code>:</p>
<blockquote>
<ul>
<li>步骤 6 Command 执行时抛出了任何异常；</li>
<li>步骤 4 断路器已经被打开</li>
<li>步骤 5 执行命令的线程池、队列或者信号量资源已满</li>
<li>命令执行的时间超过阈值</li>
</ul>
</blockquote>
<h3 id="（九）返回结果"><a href="#（九）返回结果" class="headerlink" title="（九）返回结果"></a>（九）返回结果</h3><p>如果 Hystrix 命令对象执行成功，将会返回结果，或者以<code>Observable</code>形式包装的结果。根据<strong>步骤 2</strong>的 command 调用方式，返回的<code>Observable</code> 会按照如下图说是的转换关系进行返回：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14126519-8790f97df332d9a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640/format/webp" alt="img"></p>
<ul>
<li><code>execute()</code> — 用和 <code>.queue()</code> 相同的方式获取 <code>Future</code>，然后调用 <code>Future</code> 的 <code>get()</code> 以获取 <code>Observable</code> 的单个值。</li>
<li><code>queue()</code> —将 <code>Observable</code> 转换为 <code>BlockingObservable</code>，以便可以将其转换为 <code>Future</code> 并返回。</li>
<li><code>watch()</code> —订阅 <code>Observable</code> 并开始执行命令的流程； 返回一个 <code>Observable</code>，当订阅该 <code>Observable</code> 时，它会重新通知。</li>
<li><code>toObservable()</code> —返回不变的 <code>Observable</code>； 必须订阅它才能真正开始执行命令的流程。</li>
</ul>
<h2 id="三、断路器工作原理"><a href="#三、断路器工作原理" class="headerlink" title="三、断路器工作原理"></a>三、断路器工作原理</h2><p><img src="https://upload-images.jianshu.io/upload_images/14126519-dce007513bf90794.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640/format/webp" alt="img"></p>
<ol>
<li>断路器时间窗内的请求数 是否超过了<strong>请求数断路器生效阈值</strong><code>circuitBreaker.requestVolumeThreshold</code>,如果超过了阈值，则将会触发断路，断路状态为<strong>开启</strong><br>例如，如果当前阈值设置的是<code>20</code>,则当时间窗内统计的请求数共计 19 个，即使 19 个全部失败了，都不会触发断路器。</li>
<li>并且请求错误率超过了<strong>请求错误率阈值</strong><code>errorThresholdPercentage</code></li>
<li>如果两个都满足，则将断路器由<strong>关闭</strong>迁移到<strong>开启</strong></li>
<li>如果断路器开启，则后续的所有相同请求将会被断路掉；</li>
<li>直到过了<strong>沉睡时间窗</strong><code>sleepWindowInMilliseconds</code>后，再发起请求时，允许其通过（此时的状态为<strong>半开起状态</strong>）。如果请求失败了，则保持断路器状态为<strong>开启</strong>状态，并更新<strong>沉睡时间窗</strong>。如果请求成功了，则将断路器状态改为<strong>关闭</strong>状态；</li>
</ol>
<p>核心的逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">                       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(HealthCounts hc)</span> &#123;</span><br><span class="line">                           <span class="comment">// check if we are past the statisticalWindowVolumeThreshold</span></span><br><span class="line">                           <span class="keyword">if</span> (hc.getTotalRequests() &lt; properties.circuitBreakerRequestVolumeThreshold().get()) &#123;</span><br><span class="line">                               <span class="comment">// we are not past the minimum volume threshold for the stat window,</span></span><br><span class="line">                               <span class="comment">// so no change to circuit status.</span></span><br><span class="line">                               <span class="comment">// if it was CLOSED, it stays CLOSED</span></span><br><span class="line">                               <span class="comment">// if it was half-open, we need to wait for a successful command execution</span></span><br><span class="line">                               <span class="comment">// if it was open, we need to wait for sleep window to elapse</span></span><br><span class="line">                           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                               <span class="keyword">if</span> (hc.getErrorPercentage() &lt; properties.circuitBreakerErrorThresholdPercentage().get()) &#123;</span><br><span class="line">                                   <span class="comment">//we are not past the minimum error threshold for the stat window,</span></span><br><span class="line">                                   <span class="comment">// so no change to circuit status.</span></span><br><span class="line">                                   <span class="comment">// if it was CLOSED, it stays CLOSED</span></span><br><span class="line">                                   <span class="comment">// if it was half-open, we need to wait for a successful command execution</span></span><br><span class="line">                                   <span class="comment">// if it was open, we need to wait for sleep window to elapse</span></span><br><span class="line">                               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                   <span class="comment">// our failure rate is too high, we need to set the state to OPEN</span></span><br><span class="line">                                   <span class="keyword">if</span> (status.compareAndSet(Status.CLOSED, Status.OPEN)) &#123;</span><br><span class="line">                                       circuitOpened.set(System.currentTimeMillis());</span><br><span class="line">                                   &#125;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br></pre></td></tr></table></figure>

<h3 id="系统指标"><a href="#系统指标" class="headerlink" title="系统指标"></a>系统指标</h3><p>Hystrix 对系统指标的统计是基于时间窗模式的：</p>
<blockquote>
<p><strong>时间窗</strong>：最近的一个时间区间内，比如前一小时到现在，那么时间窗的长度就是<code>1小时</code>；<br><strong>桶</strong>：桶是在特定的<strong>时间窗</strong>内，等分的指标收集的统计集合；比如时间窗的长度为<code>1小时</code>，而桶的数量为<code>10</code>,那么每个桶在时间轴上依次排开，时间由远及近，每个桶统计的时间分片为 <code>1h / 10 = 6 min</code> 6 分钟。一个桶中，包含了<code>成功数</code>、<code>失败数</code>、<code>超时数</code>、<code>拒绝数</code> 四个指标。</p>
</blockquote>
<p>在系统内，时间窗会随着系统的运行逐渐向前移动，而时间窗的长度和桶的数量是固定不变的，那么随着时间的移动，会出现较久的过期的桶被移除出去，新的桶被添加进来，如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14126519-11710915e1a5dcda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640/format/webp" alt="img"></p>
<h2 id="四、资源隔离技术"><a href="#四、资源隔离技术" class="headerlink" title="四、资源隔离技术"></a>四、资源隔离技术</h2><h3 id="线程池隔离"><a href="#线程池隔离" class="headerlink" title="线程池隔离"></a>线程池隔离</h3><p>如下图所示，由于计算机系统的基本执行单位就是线程，线程具备独立的执行能力，所以，为了做到资源保护，需要对系统的线程池进行划分，对于外部调用方</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">User</span> <span class="title">Request</span></span><br></pre></td></tr></table></figure>

<p>的请求，调用各个线程池的服务，各个线程池独立完成调用，然后将结果返回</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">调用方</span><br></pre></td></tr></table></figure>

<p>。在调用服务的过程中，如果</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">服务提供方</span><br></pre></td></tr></table></figure>

<p>执行时间过长，则</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">调用方</span><br></pre></td></tr></table></figure>

<p>可以直接以超时的方式直接返回，快速失败。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14126519-55a0be64ecac4cda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640/format/webp" alt="img"></p>
<p>线程池隔离的几点好处</p>
<blockquote>
<ol>
<li>使用超时返回的机制，避免同步调用服务时，调用时间过长，无法释放，导致资源耗尽的情况</li>
<li>服务方可以控制请求数量，请求过多，可以直接拒绝,达到快速失败的目的；</li>
<li>请求排队，线程池可以维护执行队列，将请求压到队列中处理</li>
</ol>
</blockquote>
<p>举个例子，如下代码段，模拟了同步调用服务的过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务提供方，执行服务的时候模拟2分钟的耗时</span></span><br><span class="line">Callable&lt;String&gt; callableService  = ()-&gt;&#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">while</span>(System.currentTimeMillis()-start&gt; <span class="number">1000</span> * <span class="number">60</span> *<span class="number">2</span>)&#123;</span><br><span class="line">       <span class="comment">//模拟服务执行时间过长的情况</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟10个客户端调用服务</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">clients</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//模拟给10个客户端提交处理请求</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">    clients.execute(()-&gt;&#123;</span><br><span class="line">        <span class="comment">//同步调用</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> callableService.call();</span><br><span class="line">            System.out.println(<span class="string">&quot;当前客户端：&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;调用服务完成，得到结果：&quot;</span>+result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此环节中，客户端 <code>clients</code>必须等待服务方返回结果之后，才能接收新的请求。如果用吞吐量来衡量系统的话，会发现系统的处理能力比较低。为了提高相应时间，可以借助线程池的方式，设置超时时间，这样的话，客户端就不需要必须等待服务方返回，如果时间过长，可以提前返回,改造后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务提供方，执行服务的时候模拟2分钟的耗时</span></span><br><span class="line">       Callable&lt;String&gt; callableService  = ()-&gt;&#123;</span><br><span class="line">           <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">           <span class="keyword">while</span>(System.currentTimeMillis()-start&gt; <span class="number">1000</span> * <span class="number">60</span> *<span class="number">2</span>)&#123;</span><br><span class="line">              <span class="comment">//模拟服务执行时间过长的情况</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//创建线程池作为服务方</span></span><br><span class="line">       <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">//模拟10个客户端调用服务</span></span><br><span class="line">       <span class="type">ExecutorService</span> <span class="variable">clients</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">           clients.execute(()-&gt;&#123;</span><br><span class="line">               <span class="comment">//同步调用</span></span><br><span class="line">                   <span class="comment">//将请求提交给线程池执行，Callable 和 Runnable在某种意义上，也是Command对象</span></span><br><span class="line">                   Future&lt;String&gt; future = executorService.submit(callableService::call);</span><br><span class="line">                   <span class="comment">//在指定的时间内获取结果，如果超时，调用方可以直接返回</span></span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> future.get(<span class="number">1000</span>, TimeUnit.SECONDS);</span><br><span class="line">                       <span class="comment">//客户端等待时间之后，快速返回</span></span><br><span class="line">                       System.out.println(<span class="string">&quot;当前客户端：&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;调用服务完成，得到结果：&quot;</span>+result);</span><br><span class="line">                   &#125;<span class="keyword">catch</span> (TimeoutException timeoutException)&#123;</span><br><span class="line">                       System.out.println(<span class="string">&quot;服务调用超时，返回处理&quot;</span>);</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">                   &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                   &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>如果我们将服务方的线程池设置为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">executorService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">10</span>,<span class="number">1000</span>,TimeUnit.SECONDS,</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">100</span>),</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.DiscardPolicy() <span class="comment">// 提交请求过多时，可以丢弃请求，避免死等阻塞的情况。</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>线程池隔离模式的弊端</strong></p>
<blockquote>
<p>线程池隔离模式，会根据服务划分出独立的线程池，系统资源的线程并发数是有限的，当线程数过多，系统话费大量的 CPU 时间来做线程上下文切换的无用操作，反而降低系统性能；如果线程池隔离的过多，会导致真正用于接收用户请求的线程就相应地减少，系统吞吐量反而下降；<br><strong>在实践上，应当对像远程方法调用，网络资源请求这种服务时间不太可控的场景下使用线程池隔离模式处理</strong><br>如下图所示，是线程池隔离模式的三种场景：</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/14126519-8e16e7f8072475eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640/format/webp" alt="img"></p>
<h3 id="信号量隔离"><a href="#信号量隔离" class="headerlink" title="信号量隔离"></a>信号量隔离</h3><p>由于基于线程池隔离的模式占用系统线程池资源，Hystrix 还提供了另外一个隔离技术：基于信号量的隔离。</p>
<p>基于信号量的隔离方式非常地简单，其核心就是使用共用变量</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">semaphore</span></span><br></pre></td></tr></table></figure>

<p>进行原子操作，控制线程的并发量，当并发量达到一定量级时，服务禁止调用。如下图所示：信号量本身不会消耗多余的线程资源，所以就非常轻量。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14126519-9af3442e03df941e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640/format/webp" alt="img"></p>
<p>基于信号量隔离的利弊</p>
<blockquote>
<p>利：基于信号量的隔离，利用 JVM 的原子性 CAS 操作，避免了资源锁的竞争，省去了线程池开销，效率非常高；<br>弊：本质上基于信号量的隔离是同步行为，所以无法做到超时熔断，所以服务方自身要控制住执行时间，避免超时。<br>应用场景：<strong>业务服务上，有并发上限限制时，可以考虑此方式</strong> &gt; <code>Alibaba Sentinel</code>开源框架，就是基于信号量的熔断和断路器框架。</p>
</blockquote>
<h2 id="五、Hystrix-应用"><a href="#五、Hystrix-应用" class="headerlink" title="五、Hystrix 应用"></a>五、Hystrix 应用</h2><h3 id="Spring-Cloud-Hystrix"><a href="#Spring-Cloud-Hystrix" class="headerlink" title="Spring Cloud + Hystrix"></a>Spring Cloud + Hystrix</h3><ul>
<li><strong>Hystrix 配置无法动态调节生效</strong>。Hystrix 框架本身是使用的<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://github.com/Netflix/archaius">Archaius</a>框架完成的配置加载和刷新，但是集成自 Spring Cloud 下，无法有效地根据实时监控结果，动态调整熔断和系统参数</li>
<li><strong>线程池和 Command 之间的配置比较复杂</strong>,在 Spring Cloud 在做 feigin-hystrix 集成的时候，还有些 BUG，对 command 的默认配置没有处理好，导致所有 command 占用公共的 command 线程池，没有细粒度控制，还需要做框架适配调整</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SetterFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns a hystrix setter appropriate for the given target and method</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  HystrixCommand.Setter <span class="title function_ invoke__">create</span>(Target&lt;?&gt; target, Method method);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Default behavior is to derive the group key from &#123;<span class="doctag">@link</span> Target#name()&#125; and the command key from</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@link</span> Feign#configKey(Class, Method)&#125;.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Default</span> <span class="keyword">implements</span> <span class="title">SetterFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> HystrixCommand.Setter <span class="title function_ invoke__">create</span>(Target&lt;?&gt; target, Method method) &#123;</span><br><span class="line">      String groupKey = target.<span class="title function_ invoke__">name</span>();</span><br><span class="line">      String commandKey = Feign.<span class="title function_ invoke__">configKey</span>(target.<span class="title function_ invoke__">type</span>(), method);</span><br><span class="line">      <span class="keyword">return</span> HystrixCommand.Setter</span><br><span class="line">          .<span class="title function_ invoke__">withGroupKey</span>(HystrixCommandGroupKey.Factory.<span class="title function_ invoke__">asKey</span>(groupKey))</span><br><span class="line">          .<span class="title function_ invoke__">andCommandKey</span>(HystrixCommandKey.Factory.<span class="title function_ invoke__">asKey</span>(commandKey));</span><br><span class="line">          <span class="comment">//没有处理好default配置项的加载</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Hystrix-配置"><a href="#Hystrix-配置" class="headerlink" title="Hystrix 配置"></a>Hystrix 配置</h2><blockquote>
<p>详细配置可以参考 <a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/Configuration">Hystrix 官方配置手册</a>，这里仅介绍比较核心的配置</p>
</blockquote>
<h3 id="执行配置"><a href="#执行配置" class="headerlink" title="执行配置"></a>执行配置</h3><p>以下配置用于控制 <a target="_blank" rel="noopener" href="http://netflix.github.io/Hystrix/javadoc/com/netflix/hystrix/HystrixCommand.html#run()"><code>HystrixCommand.run()</code></a> 如何执行。</p>
<table>
<thead>
<tr>
<th>配置项</th>
<th>说明</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/Configuration#execution.isolation.strategy"><code>execution.isolation.strategy</code></a></td>
<td>线程隔离（THREAD）或信号量隔离（SEMAPHORE）</td>
<td>THREAD</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/Configuration#execution.isolation.thread.timeoutInMilliseconds"><code>execution.isolation.thread.timeoutInMilliseconds</code></a></td>
<td>方法执行超时时间</td>
<td>1000(ms)</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/Configuration#execution.isolation.semaphore.maxConcurrentRequests"><code>execution.isolation.semaphore.maxConcurrentRequests</code></a></td>
<td>信号量隔离最大并发数</td>
<td>10</td>
</tr>
</tbody></table>
<h3 id="断路配置"><a href="#断路配置" class="headerlink" title="断路配置"></a>断路配置</h3><p>以下配置用于控制 <a target="_blank" rel="noopener" href="http://netflix.github.io/Hystrix/javadoc/index.html?com/netflix/hystrix/HystrixCircuitBreaker.html"><code>HystrixCircuitBreaker</code></a> 的断路处理。</p>
<table>
<thead>
<tr>
<th align="left">配置项</th>
<th align="left">说明</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/Configuration#circuitBreaker.enabled"><code>circuitBreaker.enabled</code></a></td>
<td align="left">是否开启断路器</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/Configuration#circuitBreaker.requestVolumeThreshold"><code>circuitBreaker.requestVolumeThreshold</code></a></td>
<td align="left">断路器启用请求数阈值</td>
<td align="left">20</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/Configuration#circuitBreaker.sleepWindowInMilliseconds"><code>circuitBreaker.sleepWindowInMilliseconds</code></a></td>
<td align="left">断路器启用后的休眠时间</td>
<td align="left">5000(ms)</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/Configuration#circuitBreaker.errorThresholdPercentage"><code>circuitBreaker.errorThresholdPercentage</code></a></td>
<td align="left">断路器启用失败率阈值</td>
<td align="left">50(%)</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/Configuration#circuitBreaker.forceOpen"><code>circuitBreaker.forceOpen</code></a></td>
<td align="left">是否强制将断路器设置成开启状态</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/Configuration#circuitBreaker.forceClosed"><code>circuitBreaker.forceClosed</code></a></td>
<td align="left">是否强制将断路器设置成关闭状态</td>
<td align="left">false</td>
</tr>
</tbody></table>
<h3 id="指标配置"><a href="#指标配置" class="headerlink" title="指标配置"></a>指标配置</h3><p>以下配置用于从 HystrixCommand 和 HystrixObservableCommand 执行中捕获相关指标。</p>
<table>
<thead>
<tr>
<th align="left">配置项</th>
<th align="left">说明</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/Configuration#metrics.rollingStats.timeInMilliseconds"><code>metrics.rollingStats.timeInMilliseconds</code></a></td>
<td align="left">时间窗的长度</td>
<td align="left">10000(ms)</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/Configuration#metrics.rollingStats.numBuckets"><code>metrics.rollingStats.numBuckets</code></a></td>
<td align="left">桶的数量，需要保证<code>timeInMilliseconds % numBuckets =0</code></td>
<td align="left">10</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/Configuration#metrics.rollingPercentile.enabled"><code>metrics.rollingPercentile.enabled</code></a></td>
<td align="left">是否统计运行延迟的占比</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/Configuration#metrics.rollingPercentile.timeInMilliseconds"><code>metrics.rollingPercentile.timeInMilliseconds</code></a></td>
<td align="left"><strong>运行延迟占比</strong>统计的时间窗</td>
<td align="left">60000(ms)</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/Configuration#metrics.rollingPercentile.numBuckets"><code>metrics.rollingPercentile.numBuckets</code></a></td>
<td align="left"><strong>运行延迟占比</strong>统计的桶数</td>
<td align="left">6</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/Configuration#metrics.rollingPercentile.bucketSize"><code>metrics.rollingPercentile.bucketSize</code></a></td>
<td align="left">百分比统计桶的容量，桶内最多保存的运行时间统计</td>
<td align="left">100</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/Configuration#metrics.healthSnapshot.intervalInMilliseconds"><code>metrics.healthSnapshot.intervalInMilliseconds</code></a></td>
<td align="left">统计快照刷新间隔</td>
<td align="left">500 (ms)</td>
</tr>
</tbody></table>
<h3 id="线程池配置"><a href="#线程池配置" class="headerlink" title="线程池配置"></a>线程池配置</h3><p>以下配置用于控制 Hystrix Command 执行所使用的线程池。</p>
<table>
<thead>
<tr>
<th align="left">配置项</th>
<th align="left">说明</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/Configuration#coreSize"><code>coreSize</code></a></td>
<td align="left">线程池核心线程数</td>
<td align="left">10</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/Configuration#maximumSize"><code>maximumSize</code></a></td>
<td align="left">线程池最大线程数</td>
<td align="left">10</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/Configuration#maxQueueSize"><code>maxQueueSize</code></a></td>
<td align="left">最大 LinkedBlockingQueue 的大小，-1 表示用 SynchronousQueue</td>
<td align="left">-1</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/Configuration#queueSizeRejectionThreshold"><code>queueSizeRejectionThreshold</code></a></td>
<td align="left">队列大小阈值，超过则拒绝</td>
<td align="left">5</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/Configuration#allowMaximumSizeToDivergeFromCoreSize"><code>allowMaximumSizeToDivergeFromCoreSize</code></a></td>
<td align="left">此属性允许 maximumSize 的配置生效。该值可以等于或大于 coreSize。设置 coreSize &lt;maximumSize 使得线程池可以维持 maximumSize 并发性，但是会在相对空闲时将线程回收。（取决于 keepAliveTimeInMinutes）</td>
<td align="left">false</td>
</tr>
</tbody></table>
<h2 id="六、其他限流技术"><a href="#六、其他限流技术" class="headerlink" title="六、其他限流技术"></a>六、其他限流技术</h2><ul>
<li><p><strong>resilience4j</strong><br>Hystrix 虽然官方宣布不再维护，其推荐另外一个框架：<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://github.com/resilience4j/resilience4j">resilience4j</a>, 这个框架是是为 Java 8 和 函数式编程设计的一个轻量级的容错框架，该框架充分利用函数式编程的概念，为<code>函数式接口</code>、<code>lamda表达式</code>、<code>方法引用</code>高阶函数进行包装，(本质上是装饰者模式的概念)，通过包装实现<code>断路</code>、<code>限流</code>、<code>重试</code>、<code>舱壁</code>功能。<br>这个框架整体而言比较轻量，没有控制台，不太好做系统级监控；</p>
</li>
<li><p>Alibaba Sentinel</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Sentinel</span></span><br></pre></td></tr></table></figure>

<p>是 阿里巴巴开源的轻量级的流量控制、熔断降级 Java 库，该库的核心是使用的是信号量隔离的方式做流量控制和熔断，其优点是其集成性和易用性，几乎能和当前主流的 Spring Cloud, dubbo ,grpc ,nacos, zookeeper 做集成，如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14126519-70fd779fc1f3b9b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>sentinel-features-overview-en.png</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Sentinel</span></span><br></pre></td></tr></table></figure>

<p>的目标生态圈：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14126519-84833e6225a05df0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sentinel</span></span><br></pre></td></tr></table></figure>

<p>一个强大的功能，就是它有一个流控管理控制台，你可以实时地监控每个服务的流控情况，并且可以实时编辑各种流控、熔断规则，有效地保证了服务保护的及时性。下图是内部试用的 sentinel 控制台：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/14126519-bb4aa4ba3a1de64c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img">另外，</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sentinel</span></span><br></pre></td></tr></table></figure>

<p>还可以和</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ctrip apollo</span></span><br></pre></td></tr></table></figure>

<p>分布式配置系统进行集成，将流控规降级等各种规则先配置在 apollo 中，然后服务启动自动加载流控规则。</p>
</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix">Hystrix Github</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/684b04b6c454">Spring Cloud Hystrix 设计原理</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5c009ff6f265da614b11b84d">Hystrix 都停更了，我为什么还要学？</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/59f078/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/59f078/" class="post-title-link" itemprop="url">Java 进程内缓存</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-17 22:34:30" itemprop="dateCreated datePublished" datetime="2022-02-17T22:34:30+08:00">2022-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">中间件</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E7%BC%93%E5%AD%98/" itemprop="url" rel="index"><span itemprop="name">缓存</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java-进程内缓存"><a href="#Java-进程内缓存" class="headerlink" title="Java 进程内缓存"></a>Java 进程内缓存</h1><blockquote>
<p>关键词：ConcurrentHashMap、LRUHashMap、Guava Cache、Caffeine、Ehcache</p>
</blockquote>
<h2 id="一、ConcurrentHashMap"><a href="#一、ConcurrentHashMap" class="headerlink" title="一、ConcurrentHashMap"></a>一、ConcurrentHashMap</h2><p>最简单的进程内缓存可以通过 JDK 自带的 <code>HashMap</code> 或 <code>ConcurrentHashMap</code> 实现。</p>
<p>适用场景：<strong>不需要淘汰的缓存数据</strong>。</p>
<p>缺点：无法进行缓存淘汰，内存会无限制的增长。</p>
<h2 id="二、LRUHashMap"><a href="#二、LRUHashMap" class="headerlink" title="二、LRUHashMap"></a>二、LRUHashMap</h2><p>可以通过**继承 <code>LinkedHashMap</code> 来实现一个简单的 <code>LRUHashMap</code>**，即可完成一个简单的 <strong>LRU （最近最少使用）</strong>算法。</p>
<p>缺点：</p>
<ul>
<li>锁竞争严重，性能比较低。</li>
<li>不支持过期时间</li>
<li>不支持自动刷新</li>
</ul>
<p>【示例】LRUHashMap 的简单实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> max;</span><br><span class="line">    <span class="keyword">private</span> Object lock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> max)</span> &#123;</span><br><span class="line">        <span class="comment">//无需扩容</span></span><br><span class="line">        <span class="built_in">super</span>((<span class="type">int</span>) (max * <span class="number">1.4f</span>), <span class="number">0.75f</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="built_in">this</span>.max = max;</span><br><span class="line">        <span class="built_in">this</span>.lock = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写LinkedHashMap的removeEldestEntry方法即可 在Put的时候判断，如果为true，就会删除最老的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> eldest</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">return</span> get(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putValue</span><span class="params">(Object key, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            put(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeValue</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">return</span> remove(key) != <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeAll</span><span class="params">()</span> &#123;</span><br><span class="line">        clear();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、Guava-Cache"><a href="#三、Guava-Cache" class="headerlink" title="三、Guava Cache"></a>三、Guava Cache</h2><p>Guava Cache 解决了 <code>LRUHashMap</code> 中的几个缺点。</p>
<p>Guava Cache 提供了<strong>基于容量，时间和引用的缓存回收方式</strong>。基于容量的方式内部实现采用 LRU 算法，基于引用回收很好的利用了 Java 虚拟机的垃圾回收机制。</p>
<p>其中的缓存构造器 CacheBuilder 采用构建者模式提供了设置好各种参数的缓存对象。缓存核心类 LocalCache 里面的内部类 Segment 与 jdk1.7 及以前的 <code>ConcurrentHashMap</code> 非常相似，分段加锁，减少锁竞争，并且都继承于 <code>ReetrantLock</code>，还有六个队列，以实现丰富的本地缓存方案。Guava Cache 对于过期的 Entry 并没有马上过期(也就是并没有后台线程一直在扫)，而是通过进行读写操作的时候进行过期处理，这样做的好处是避免后台线程扫描的时候进行全局加锁。</p>
<p>直接通过查询，判断其是否满足刷新条件，进行刷新。</p>
<h3 id="Guava-Cache-缓存回收"><a href="#Guava-Cache-缓存回收" class="headerlink" title="Guava Cache 缓存回收"></a>Guava Cache 缓存回收</h3><p>Guava Cache 提供了三种基本的缓存回收方式。</p>
<h3 id="基于容量回收"><a href="#基于容量回收" class="headerlink" title="基于容量回收"></a>基于容量回收</h3><p><code>maximumSize(long)</code>：当缓存中的元素数量超过指定值时触发回收。</p>
<h3 id="基于定时回收"><a href="#基于定时回收" class="headerlink" title="基于定时回收"></a>基于定时回收</h3><ul>
<li><code>expireAfterAccess(long, TimeUnit)</code>：缓存项在给定时间内没有被读&#x2F;写访问，则回收。请注意这种缓存的回收顺序和基于大小回收一样。</li>
<li><code>expireAfterWrite(long, TimeUnit)</code>：缓存项在给定时间内没有被写访问（创建或覆盖），则回收。如果认为缓存数据总是在固定时候后变得陈旧不可用，这种回收方式是可取的。</li>
</ul>
<p>如下文所讨论，定时回收周期性地在写操作中执行，偶尔在读操作中执行。</p>
<h3 id="基于引用回收"><a href="#基于引用回收" class="headerlink" title="基于引用回收"></a>基于引用回收</h3><ul>
<li><code>CacheBuilder.weakKeys()</code>：使用弱引用存储键。当键没有其它（强或软）引用时，缓存项可以被垃圾回收。</li>
<li><code>CacheBuilder.weakValues()</code>：使用弱引用存储值。当值没有其它（强或软）引用时，缓存项可以被垃圾回收。</li>
<li><code>CacheBuilder.softValues()</code>：使用软引用存储值。软引用只有在响应内存需要时，才按照全局最近最少使用的顺序回收。</li>
</ul>
<h3 id="Guava-Cache-核心-API"><a href="#Guava-Cache-核心-API" class="headerlink" title="Guava Cache 核心 API"></a>Guava Cache 核心 API</h3><h4 id="CacheBuilder"><a href="#CacheBuilder" class="headerlink" title="CacheBuilder"></a>CacheBuilder</h4><p>缓存构建器。构建缓存的入口，指定缓存配置参数并初始化本地缓存。<br>主要采用 builder 的模式，CacheBuilder 的每一个方法都返回这个 CacheBuilder 知道 build 方法的调用。<br>注意 build 方法有重载，带有参数的为构建一个具有数据加载功能的缓存，不带参数的构建一个没有数据加载功能的缓存。</p>
<h4 id="LocalManualCache"><a href="#LocalManualCache" class="headerlink" title="LocalManualCache"></a>LocalManualCache</h4><p>作为 LocalCache 的一个内部类，在构造方法里面会把 LocalCache 类型的变量传入，并且调用方法时都直接或者间接调用 LocalCache 里面的方法。</p>
<h4 id="LocalLoadingCache"><a href="#LocalLoadingCache" class="headerlink" title="LocalLoadingCache"></a>LocalLoadingCache</h4><p>可以看到该类继承了 LocalManualCache 并实现接口 LoadingCache。<br>覆盖了 get，getUnchecked 等方法。</p>
<h4 id="LocalCache"><a href="#LocalCache" class="headerlink" title="LocalCache"></a>LocalCache</h4><p>Guava Cache 中的核心类，重点了解。</p>
<p>LocalCache 的数据结构与 ConcurrentHashMap 很相似，都由多个 segment 组成，且各 segment 相对独立，互不影响，所以能支持并行操作。每个 segment 由一个 table 和若干队列组成。缓存数据存储在 table 中，其类型为 AtomicReferenceArray。</p>
<h2 id="四、Caffeine"><a href="#四、Caffeine" class="headerlink" title="四、Caffeine"></a>四、Caffeine</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/ben-manes/caffeine">caffeine</a> 是一个使用 JDK8 改进 Guava 缓存的高性能缓存库。</p>
</blockquote>
<p>Caffeine 实现了 W-TinyLFU(<strong>LFU</strong> + <strong>LRU</strong> 算法的变种)，其<strong>命中率和读写吞吐量大大优于 Guava Cache</strong>。</p>
<p>其实现原理较复杂，可以参考<a target="_blank" rel="noopener" href="https://juejin.im/post/5b7593496fb9a009b62904fa#comment">你应该知道的缓存进化史</a>。</p>
<h2 id="五、Ehcache"><a href="#五、Ehcache" class="headerlink" title="五、Ehcache"></a>五、Ehcache</h2><blockquote>
<p>参考：<a href="04.Ehcache.md">Ehcache</a></p>
</blockquote>
<h2 id="六、进程内缓存对比"><a href="#六、进程内缓存对比" class="headerlink" title="六、进程内缓存对比"></a>六、进程内缓存对比</h2><p>常用进程内缓存技术对比：</p>
<table>
<thead>
<tr>
<th>比较项</th>
<th>ConcurrentHashMap</th>
<th>LRUMap</th>
<th>Ehcache</th>
<th>Guava Cache</th>
<th>Caffeine</th>
</tr>
</thead>
<tbody><tr>
<td>读写性能</td>
<td>很好，分段锁</td>
<td>一般，全局加锁</td>
<td>好</td>
<td>好，需要做淘汰操作</td>
<td>很好</td>
</tr>
<tr>
<td>淘汰算法</td>
<td>无</td>
<td>LRU，一般</td>
<td>支持多种淘汰算法,LRU,LFU,FIFO</td>
<td>LRU，一般</td>
<td>W-TinyLFU, 很好</td>
</tr>
<tr>
<td>功能丰富程度</td>
<td>功能比较简单</td>
<td>功能比较单一</td>
<td>功能很丰富</td>
<td>功能很丰富，支持刷新和虚引用等</td>
<td>功能和 Guava Cache 类似</td>
</tr>
<tr>
<td>工具大小</td>
<td>jdk 自带类，很小</td>
<td>基于 LinkedHashMap，较小</td>
<td>很大，最新版本 1.4MB</td>
<td>是 Guava 工具类中的一个小部分，较小</td>
<td>一般，最新版本 644KB</td>
</tr>
<tr>
<td>是否持久化</td>
<td>否</td>
<td>否</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>是否支持集群</td>
<td>否</td>
<td>否</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
<ul>
<li><strong><code>ConcurrentHashMap</code></strong> - 比较适合缓存比较固定不变的元素，且缓存的数量较小的。虽然从上面表格中比起来有点逊色，但是其由于是 JDK 自带的类，在各种框架中依然有大量的使用，比如我们可以用来缓存我们反射的 Method，Field 等等；也可以缓存一些链接，防止其重复建立。在 Caffeine 中也是使用的 <code>ConcurrentHashMap</code> 来存储元素。</li>
<li><strong><code>LRUMap</code></strong> - 如果不想引入第三方包，又想使用淘汰算法淘汰数据，可以使用这个。</li>
<li><strong><code>Ehcache</code></strong> - 由于其 jar 包很大，较重量级。对于需要持久化和集群的一些功能的，可以选择 Ehcache。需要注意的是，虽然 Ehcache 也支持分布式缓存，但是由于其节点间通信方式为 rmi，表现不如 Redis，所以一般不建议用它来作为分布式缓存。</li>
<li><strong><code>Guava Cache</code></strong> - Guava 这个 jar 包在很多 Java 应用程序中都有大量的引入，所以很多时候其实是直接用就好了，并且其本身是轻量级的而且功能较为丰富，在不了解 Caffeine 的情况下可以选择 Guava Cache。</li>
<li><strong><code>Caffeine</code></strong> - 其在命中率，读写性能上都比 Guava Cache 好很多，并且其 API 和 Guava cache 基本一致，甚至会多一点。在真实环境中使用 Caffeine，取得过不错的效果。</li>
</ul>
<p>总结一下：**如果不需要淘汰算法则选择 <code>ConcurrentHashMap</code>，如果需要淘汰算法和一些丰富的 API，推荐选择 <code>Caffeine</code>**。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/ben-manes/caffeine">caffeine github</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5b8df63c6fb9a019e04ebaf4">深入解密来自未来的缓存-Caffeine</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9a80c662dac4">Caffeine 缓存</a></li>
<li><a target="_blank" rel="noopener" href="https://wizardforcel.gitbooks.io/guava-tutorial/content/1.html">Google Guava 官方教程（中文版）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/38bd5f1cf2f2">Google Guava Cache 全解析</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.ibm.com/zh/articles/os-cn-spring-cache/">注释驱动的 Spring cache 缓存介绍</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/85460d/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/85460d/" class="post-title-link" itemprop="url">Java 缓存中间件</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-17 22:34:30" itemprop="dateCreated datePublished" datetime="2022-02-17T22:34:30+08:00">2022-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">中间件</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E7%BC%93%E5%AD%98/" itemprop="url" rel="index"><span itemprop="name">缓存</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java-缓存中间件"><a href="#Java-缓存中间件" class="headerlink" title="Java 缓存中间件"></a>Java 缓存中间件</h1><blockquote>
<p>关键词：Spring Cache、J2Cache、JetCache</p>
</blockquote>
<h2 id="一-、JSR-107"><a href="#一-、JSR-107" class="headerlink" title="一 、JSR 107"></a>一 、JSR 107</h2><p><a target="_blank" rel="noopener" href="https://www.jcp.org/en/jsr/detail?id=107">JSR107</a> 中制订了 Java 缓存的规范。</p>
<p>因此，在很多缓存框架、缓存库中，其 API 都参考了 JSR 107 规范。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200709174139.png" alt="img"></p>
<p>Java Caching 定义了 5 个核心接口</p>
<ul>
<li><strong>CachingProvider</strong> - 定义了创建、配置、获取、管理和控制多个 <code>CacheManager</code>。一个应用可以在运行期访问多个 <code>CachingProvider</code>。</li>
<li><strong>CacheManager</strong> - 定义了创建、配置、获取、管理和控制多个唯一命名的 Cache，这些 Cache 存在于 CacheManager 的上下文中。一个 CacheManager 仅被一个 CachingProvider 所拥有。</li>
<li><strong>Cache</strong> - 是一个类似 Map 的数据结构并临时存储以 Key 为索引的值。一个 Cache 仅被一个 CacheManager 所拥有。</li>
<li><strong>Entry</strong> - 是一个存储在 Cache 中的 key-value 对。</li>
<li><strong>Expiry</strong> - 每一个存储在 Cache 中的条目有一个定义的有效期，即 Expiry Duration。一旦超过这个时间，条目为过期的状态。一旦过期，条目将不可访问、更新和删除。缓存有效期可以通过 ExpiryPolicy 设置。</li>
</ul>
<h2 id="二、Spring-Cache"><a href="#二、Spring-Cache" class="headerlink" title="二、Spring Cache"></a>二、Spring Cache</h2><blockquote>
<p>详见：<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/integration.html#cache">Spring Cache 官方文档</a></p>
</blockquote>
<p>Spring 作为 Java 开发最著名的框架，也提供了缓存功能的框架—— Spring Cache。</p>
<p>Spring 支持基于注释（annotation）的缓存（cache）技术，它本质上不是一个具体的缓存实现方案（例如：EHCache 或 OSCache），而是一个对缓存使用的抽象，通过在既有代码中添加少量它定义的各种 annotation，即能够达到缓存方法的返回对象的效果。</p>
<p>Spring Cache 的特点：</p>
<ul>
<li>通过缓存注解即可支持缓存功能</li>
<li>支持 Spring EL 表达式</li>
<li>支持 AspectJ</li>
<li>支持自定义 key 和缓存管理</li>
</ul>
<h3 id="开启缓存注解"><a href="#开启缓存注解" class="headerlink" title="开启缓存注解"></a>开启缓存注解</h3><p>Spring 为缓存功能提供了注解功能，但是你必须启动注解。</p>
<p>有两种方式：</p>
<p>（一）使用标记注解 <code>@EnableCaching</code></p>
<p>这种方式对于 Spring 或 Spring Boot 项目都适用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（二）在 xml 中声明</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache:annotation-driven</span> <span class="attr">cache-manager</span>=<span class="string">&quot;cacheManager&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="spring-缓存注解-API"><a href="#spring-缓存注解-API" class="headerlink" title="spring 缓存注解 API"></a>spring 缓存注解 API</h3><p>Spring 对缓存的支持类似于对事务的支持。</p>
<p>首先使用注解标记方法，相当于定义了切点，然后使用 Aop 技术在这个方法的调用前、调用后获取方法的入参和返回值，进而实现了缓存的逻辑。</p>
<h4 id="Cacheable"><a href="#Cacheable" class="headerlink" title="@Cacheable"></a>@Cacheable</h4><p><strong><code>@Cacheable</code> 用于触发缓存</strong>。</p>
<p>表明所修饰的方法是可以缓存的：当第一次调用这个方法时，它的结果会被缓存下来，在缓存的有效时间内，以后访问这个方法都直接返回缓存结果，不再执行方法中的代码段。</p>
<p>这个注解可以用<code>condition</code>属性来设置条件，如果不满足条件，就不使用缓存能力，直接执行方法。</p>
<p>可以使用<code>key</code>属性来指定 key 的生成规则。</p>
<h4 id="CachePut"><a href="#CachePut" class="headerlink" title="@CachePut"></a>@CachePut</h4><p><strong><code>@CachePut</code> 用于更新缓存</strong>。</p>
<p>与<code>@Cacheable</code>不同，<code>@CachePut</code>不仅会缓存方法的结果，还会执行方法的代码段。</p>
<p>它支持的属性和用法都与<code>@Cacheable</code>一致。</p>
<h4 id="CacheEvict"><a href="#CacheEvict" class="headerlink" title="@CacheEvict"></a>@CacheEvict</h4><p><strong><code>@CacheEvict</code> 用于清除缓存</strong>。</p>
<p>与<code>@Cacheable</code>功能相反，<code>@CacheEvict</code>表明所修饰的方法是用来删除失效或无用的缓存数据。</p>
<p>下面是<code>@Cacheable</code>、<code>@CacheEvict</code>和<code>@CachePut</code>基本使用方法的一个集中展示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">// @Cacheable可以设置多个缓存，形式如：@Cacheable(&#123;&quot;books&quot;, &quot;isbns&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@Cacheable(value=&#123;&quot;users&quot;&#125;, key=&quot;#user.id&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> findUserInDB(user.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Cacheable(value = &quot;users&quot;, condition = &quot;#user.getId() &lt;= 2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findUserInLimit</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> findUserInDB(user.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CachePut(value = &quot;users&quot;, key = &quot;#user.getId()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        updateUserInDB(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CacheEvict(value = &quot;users&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        removeUserInDB(user.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CacheEvict(value = &quot;users&quot;, allEntries = true)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        removeAllInDB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Caching"><a href="#Caching" class="headerlink" title="@Caching"></a>@Caching</h4><p><strong><code>@Caching</code> 用于组合定义多种缓存功能</strong>。</p>
<p>如果需要使用同一个缓存注解（<code>@Cacheable</code>、<code>@CacheEvict</code>或<code>@CachePut</code>）多次修饰一个方法，就需要用到<code>@Caching</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Caching(evict = &#123; @CacheEvict(&quot;primary&quot;), @CacheEvict(cacheNames=&quot;secondary&quot;, key=&quot;#p0&quot;) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> Book <span class="title function_">importBooks</span><span class="params">(String deposit, Date date)</span></span><br></pre></td></tr></table></figure>

<h4 id="CacheConfig"><a href="#CacheConfig" class="headerlink" title="@CacheConfig"></a>@CacheConfig</h4><p><strong><code>@CacheConfig</code> 用于定义公共缓存配置</strong>。</p>
<p>与前面的缓存注解不同，这是一个类级别的注解。</p>
<p>如果类的所有操作都是缓存操作，你可以使用<code>@CacheConfig</code>来指定类，省去一些配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheConfig(&quot;books&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookRepositoryImpl</span> <span class="keyword">implements</span> <span class="title class_">BookRepository</span> &#123;</span><br><span class="line"> <span class="meta">@Cacheable</span></span><br><span class="line"> <span class="keyword">public</span> Book <span class="title function_">findBook</span><span class="params">(ISBN isbn)</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、Spring-Boot-Cache"><a href="#三、Spring-Boot-Cache" class="headerlink" title="三、Spring Boot Cache"></a>三、Spring Boot Cache</h2><blockquote>
<p>详见：<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.3.1.RELEASE/reference/html/spring-boot-features.html#boot-features-caching">Spring Boot Cache 特性官方文档</a></p>
</blockquote>
<p>Spring Boot Cache 是在 Spring Cache 的基础上做了封装，使得使用更为便捷。</p>
<h3 id="Spring-Boot-Cache-快速入门"><a href="#Spring-Boot-Cache-快速入门" class="headerlink" title="Spring Boot Cache 快速入门"></a>Spring Boot Cache 快速入门</h3><p>（1）引入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 按序引入需要的缓存库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）缓存配置</p>
<p>例如，选用缓存为 redis，则需要配置 redis 相关的配置项（如：数据源、连接池等配置信息）</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 缓存类型，支持类型：GENERIC、JCACHE、EHCACHE、HAZELCAST、INFINISPAN、COUCHBASE、REDIS、CAFFEINE、SIMPLE</span></span><br><span class="line"><span class="attr">spring.cache.type</span> = <span class="string">redis</span></span><br><span class="line"><span class="comment"># 全局缓存时间</span></span><br><span class="line"><span class="attr">spring.cache.redis.time-to-live</span> = <span class="string">60s</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Redis 配置</span></span><br><span class="line"><span class="attr">spring.redis.database</span> = <span class="string">0</span></span><br><span class="line"><span class="attr">spring.redis.host</span> = <span class="string">localhost</span></span><br><span class="line"><span class="attr">spring.redis.port</span> = <span class="string">6379</span></span><br><span class="line"><span class="attr">spring.redis.password</span> =<span class="string"></span></span><br></pre></td></tr></table></figure>

<p>（3）使用 <code>@EnableCaching</code> 开启缓存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）缓存注解（<code>@Cacheable</code>、<code>@CachePut</code>、<code>@CacheEvit</code> 等）使用方式与 Spring Cache 完全一样</p>
<h2 id="四、JetCache"><a href="#四、JetCache" class="headerlink" title="四、JetCache"></a>四、JetCache</h2><blockquote>
<p>JetCache 是一个基于 Java 的缓存系统封装，提供统一的 API 和注解来简化缓存的使用。 JetCache 提供了比 SpringCache 更加强大的注解，可以原生的支持 TTL、两级缓存、分布式自动刷新，还提供了<code>Cache</code>接口用于手工缓存操作。 当前有四个实现，<code>RedisCache</code>、<code>TairCache</code>（此部分未在 github 开源）、<code>CaffeineCache</code>(in memory)和一个简易的<code>LinkedHashMapCache</code>(in memory)，要添加新的实现也是非常简单的。</p>
<p>详见：<a target="_blank" rel="noopener" href="https://github.com/alibaba/jetcache">jetcache Github</a></p>
</blockquote>
<h3 id="jetcache-快速入门"><a href="#jetcache-快速入门" class="headerlink" title="jetcache 快速入门"></a>jetcache 快速入门</h3><p>如果使用 Spring Boot，可以按如下的方式配置（这里使用了 jedis 客户端连接 redis，如果需要集群、读写分离、异步等特性支持请使用<a target="_blank" rel="noopener" href="https://github.com/alibaba/jetcache/wiki/RedisWithLettuce_CN">lettuce</a>客户端）。</p>
<p>（1）引入 POM</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alicp.jetcache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetcache-starter-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）配置</p>
<p>配置一个 spring boot 风格的 application.yml 文件，把他放到资源目录中</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jetcache:</span></span><br><span class="line">  <span class="attr">statIntervalMinutes:</span> <span class="number">15</span></span><br><span class="line">  <span class="attr">areaInCacheName:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">local:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">linkedhashmap</span></span><br><span class="line">      <span class="attr">keyConvertor:</span> <span class="string">fastjson</span></span><br><span class="line">  <span class="attr">remote:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">redis</span></span><br><span class="line">      <span class="attr">keyConvertor:</span> <span class="string">fastjson</span></span><br><span class="line">      <span class="attr">valueEncoder:</span> <span class="string">java</span></span><br><span class="line">      <span class="attr">valueDecoder:</span> <span class="string">java</span></span><br><span class="line">      <span class="attr">poolConfig:</span></span><br><span class="line">        <span class="attr">minIdle:</span> <span class="number">5</span></span><br><span class="line">        <span class="attr">maxIdle:</span> <span class="number">20</span></span><br><span class="line">        <span class="attr">maxTotal:</span> <span class="number">50</span></span><br><span class="line">      <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure>

<p>（3）开启缓存</p>
<p>然后创建一个 App 类放在业务包的根下，EnableMethodCache，EnableCreateCacheAnnotation 这两个注解分别激活 Cached 和 CreateCache 注解，其他和标准的 Spring Boot 程序是一样的。这个类可以直接 main 方法运行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.mypackage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alicp.jetcache.anno.config.EnableCreateCacheAnnotation;</span><br><span class="line"><span class="keyword">import</span> com.alicp.jetcache.anno.config.EnableMethodCache;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableMethodCache(basePackages = &quot;com.company.mypackage&quot;)</span></span><br><span class="line"><span class="meta">@EnableCreateCacheAnnotation</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySpringBootApp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MySpringBootApp.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）API 基本使用</p>
<p>创建缓存实例</p>
<p>通过 @CreateCache 注解创建一个缓存实例，默认超时时间是 100 秒</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CreateCache(expire = 100)</span></span><br><span class="line"><span class="keyword">private</span> Cache&lt;Long, UserDO&gt; userCache;</span><br></pre></td></tr></table></figure>

<p>用起来就像 map 一样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UserDO</span> <span class="variable">user</span> <span class="operator">=</span> userCache.get(<span class="number">123L</span>);</span><br><span class="line">userCache.put(<span class="number">123L</span>, user);</span><br><span class="line">userCache.remove(<span class="number">123L</span>);</span><br></pre></td></tr></table></figure>

<p>创建一个两级（内存+远程）的缓存，内存中的元素个数限制在 50 个。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CreateCache(name = &quot;UserService.userCache&quot;, expire = 100, cacheType = CacheType.BOTH, localLimit = 50)</span></span><br><span class="line"><span class="keyword">private</span> Cache&lt;Long, UserDO&gt; userCache;</span><br></pre></td></tr></table></figure>

<p>name 属性不是必须的，但是起个名字是个好习惯，展示统计数据的使用，会使用这个名字。如果同一个 area 两个 @CreateCache 的 name 配置一样，它们生成的 Cache 将指向同一个实例。</p>
<p>创建方法缓存</p>
<p>使用 @Cached 方法可以为一个方法添加上缓存。JetCache 通过 Spring AOP 生成代理，来支持缓存功能。注解可以加在接口方法上也可以加在类方法上，但需要保证是个 Spring bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Cached(name=&quot;UserService.getUserById&quot;, expire = 3600)</span></span><br><span class="line">    User <span class="title function_">getUserById</span><span class="params">(<span class="type">long</span> userId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、j2cache"><a href="#五、j2cache" class="headerlink" title="五、j2cache"></a>五、j2cache</h2><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>使用缓存框架，使得开发缓存功能非常便捷。</p>
<p>如果你的系统只需要使用一种缓存，那么推荐使用 Spring Boot Cache。Spring Boot Cache 在 Spring Cache 基础上做了封装，使用更简单、方便。</p>
<p>如果你的系统需要使用多级缓存，那么推荐使用 jetcache。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.jcp.org/en/jsr/detail?id=107">JSR107</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/integration.html#cache">Spring Cache 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.3.1.RELEASE/reference/html/spring-boot-features.html#boot-features-caching">Spring Boot Cache 特性官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://gitee.com/ld/J2Cache">J2Cache Gitee</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/alibaba/jetcache">jetcache Github</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/alibaba/jetcache/wiki/Home_CN">jetcache wiki</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/5f7893/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/5f7893/" class="post-title-link" itemprop="url">Ehcache 快速入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-17 22:34:30" itemprop="dateCreated datePublished" datetime="2022-02-17T22:34:30+08:00">2022-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">中间件</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E7%BC%93%E5%AD%98/" itemprop="url" rel="index"><span itemprop="name">缓存</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>11 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Ehcache-快速入门"><a href="#Ehcache-快速入门" class="headerlink" title="Ehcache 快速入门"></a>Ehcache 快速入门</h1><blockquote>
<p>EhCache 是一个纯 Java 的进程内缓存框架，具有快速、精干等特点，是 Hibernate 中默认的 CacheProvider。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/technology/cache/ehcache-architecture.png" alt="img"></p>
<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><blockquote>
<p>Ehcache 虽然也支持分布式模式，但是分布式方案不是很好好，建议只将其作为单机的进程内缓存使用。</p>
</blockquote>
<h3 id="Ehcache-特性"><a href="#Ehcache-特性" class="headerlink" title="Ehcache 特性"></a>Ehcache 特性</h3><p>优点</p>
<ul>
<li>快速、简单</li>
<li>支持多种缓存策略：LRU、LFU、FIFO 淘汰算法</li>
<li>缓存数据有两级：内存和磁盘，因此无需担心容量问题</li>
<li>缓存数据会在虚拟机重启的过程中写入磁盘</li>
<li>可以通过 RMI、可插入 API 等方式进行分布式缓存</li>
<li>具有缓存和缓存管理器的侦听接口</li>
<li>支持多缓存管理器实例，以及一个实例的多个缓存区域</li>
<li>提供 Hibernate 的缓存实现</li>
</ul>
<p>缺点</p>
<ul>
<li><strong>使用磁盘 Cache 的时候非常占用磁盘空间</strong></li>
<li><strong>不保证数据的安全</strong></li>
<li>虽然支持分布式缓存，但效率不高（通过组播方式，在不同节点之间同步数据）。</li>
</ul>
<h3 id="Ehcache-集群"><a href="#Ehcache-集群" class="headerlink" title="Ehcache 集群"></a>Ehcache 集群</h3><p>Ehcache 目前支持五种集群方式：</p>
<ul>
<li>RMI</li>
<li>JMS</li>
<li>JGroup</li>
<li>Terracotta</li>
<li>Ehcache Server</li>
</ul>
<h4 id="RMI"><a href="#RMI" class="headerlink" title="RMI"></a>RMI</h4><p>使用组播方式通知所有节点同步数据。</p>
<p>如果网络有问题，或某台服务宕机，则存在数据无法同步的可能，导致数据不一致。</p>
<p><img src="https://www.ehcache.org/images/documentation/rmi_replication.png" alt="Ehcache Image"></p>
<h4 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h4><p>JMS 类似 MQ，所有节点订阅消息，当某节点缓存发生变化，就向 JMS 发消息，其他节点感知变化后，同步数据。</p>
<p><img src="https://www.ehcache.org/images/documentation/jms_replication.png" alt="Ehcache Image"></p>
<h4 id="Cache-Server"><a href="#Cache-Server" class="headerlink" title="Cache Server"></a>Cache Server</h4><p><img src="https://www.ehcache.org/images/documentation/loadbalancer_hashing.png" alt="Ehcache Image"></p>
<h2 id="二、快速入门"><a href="#二、快速入门" class="headerlink" title="二、快速入门"></a>二、快速入门</h2><h3 id="引入-Ehcache"><a href="#引入-Ehcache" class="headerlink" title="引入 Ehcache"></a>引入 Ehcache</h3><p>如果你的项目使用 maven 管理，添加以下依赖到你的 pom.xml 中。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sf.ehcache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果你的项目不使用 maven 管理，请在 <a target="_blank" rel="noopener" href="http://www.ehcache.org/downloads/">Ehcache 官网下载地址</a> 下载 jar 包。</p>
<p>Spring 提供了对于 Ehcache 接口的封装，可以更简便的使用其功能。接入方式如下：</p>
<p>如果你的项目使用 maven 管理，添加以下依赖到你的<em>pom.xml</em>中。</p>
<p><code>spring-context-support</code>这个 jar 包中含有 Spring 对于缓存功能的抽象封装接口。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-support<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="添加配置文件"><a href="#添加配置文件" class="headerlink" title="添加配置文件"></a>添加配置文件</h3><p>（1）在 classpath 下添加 <code>ehcache.xml</code><br>添加一个名为 <em>helloworld</em> 的缓存。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">&quot;http://ehcache.org/ehcache.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 磁盘缓存位置 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">&quot;java.io.tmpdir/ehcache&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 默认缓存 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">defaultCache</span></span></span><br><span class="line"><span class="tag">          <span class="attr">maxEntriesLocalHeap</span>=<span class="string">&quot;10000&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">maxEntriesLocalDisk</span>=<span class="string">&quot;10000000&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">&quot;LRU&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- helloworld缓存 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">&quot;helloworld&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">maxElementsInMemory</span>=<span class="string">&quot;1000&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;5&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;5&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">overflowToDisk</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">&quot;LRU&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Ehcache-工作示例"><a href="#Ehcache-工作示例" class="headerlink" title="Ehcache 工作示例"></a>Ehcache 工作示例</h3><p>Ehcache 会自动加载 <code>classpath</code> 根目录下名为 <code>ehcache.xml</code> 文件。</p>
<p>EhcacheDemo 的工作步骤如下：</p>
<ol>
<li>在 EhcacheDemo 中，我们引用 <code>ehcache.xml</code> 声明的名为 <em>helloworld</em> 的缓存来创建<code>Cache</code>对象；</li>
<li>然后我们用一个键值对来实例化<code>Element</code>对象；</li>
<li>将<code>Element</code>对象添加到<code>Cache</code>；</li>
<li>然后用<code>Cache</code>的 get 方法获取<code>Element</code>对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EhcacheDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// Create a cache manager</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">CacheManager</span> <span class="variable">cacheManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CacheManager</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create the cache called &quot;helloworld&quot;</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Cache</span> <span class="variable">cache</span> <span class="operator">=</span> cacheManager.getCache(<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create a key to map the data to</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;greeting&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a data element</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Element</span> <span class="variable">putGreeting</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Element</span>(key, <span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Put the element into the data store</span></span><br><span class="line">        cache.put(putGreeting);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Retrieve the data element</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Element</span> <span class="variable">getGreeting</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Print the value</span></span><br><span class="line">        System.out.println(getGreeting.getObjectValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Hello,</span> World!</span><br></pre></td></tr></table></figure>

<h2 id="三、Ehcache-API"><a href="#三、Ehcache-API" class="headerlink" title="三、Ehcache API"></a>三、Ehcache API</h2><p><code>Element</code>、<code>Cache</code>、<code>CacheManager</code>是 Ehcache 最重要的 API。</p>
<ul>
<li><code>Element</code> - 缓存的元素，它维护着一个键值对。</li>
<li><code>Cache</code> - 它是 Ehcache 的核心类，它有多个<code>Element</code>，并被<code>CacheManager</code>管理。它实现了对缓存的逻辑行为。</li>
<li><code>CacheManager</code> - <code>Cache</code>的容器对象，并管理着<code>Cache</code>的生命周期。CacheManager 支持两种创建模式：单例（Singleton mode）和实例（InstanceMode）。</li>
</ul>
<h3 id="创建-CacheManager"><a href="#创建-CacheManager" class="headerlink" title="创建 CacheManager"></a>创建 CacheManager</h3><p>下面的代码列举了创建 <code>CacheManager</code> 的五种方式。</p>
<p>使用静态方法<code>create()</code>会以默认配置来创建单例的<code>CacheManager</code>实例。</p>
<p><code>newInstance()</code>方法是一个工厂方法，以默认配置创建一个新的<code>CacheManager</code>实例。</p>
<p>此外，<code>newInstance()</code>还有几个重载函数，分别可以通过传入<code>String</code>、<code>URL</code>、<code>InputStream</code>参数来加载配置文件，然后创建<code>CacheManager</code>实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Ehcache默认配置获取单例的CacheManager实例</span></span><br><span class="line">CacheManager.create();</span><br><span class="line">String[] cacheNames = CacheManager.getInstance().getCacheNames();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Ehcache默认配置新建一个CacheManager实例</span></span><br><span class="line">CacheManager.newInstance();</span><br><span class="line">String[] cacheNames = manager.getCacheNames();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用不同的配置文件分别创建一个CacheManager实例</span></span><br><span class="line"><span class="type">CacheManager</span> <span class="variable">manager1</span> <span class="operator">=</span> CacheManager.newInstance(<span class="string">&quot;src/config/ehcache1.xml&quot;</span>);</span><br><span class="line"><span class="type">CacheManager</span> <span class="variable">manager2</span> <span class="operator">=</span> CacheManager.newInstance(<span class="string">&quot;src/config/ehcache2.xml&quot;</span>);</span><br><span class="line">String[] cacheNamesForManager1 = manager1.getCacheNames();</span><br><span class="line">String[] cacheNamesForManager2 = manager2.getCacheNames();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于classpath下的配置文件创建CacheManager实例</span></span><br><span class="line"><span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> getClass().getResource(<span class="string">&quot;/anotherconfigurationname.xml&quot;</span>);</span><br><span class="line"><span class="type">CacheManager</span> <span class="variable">manager</span> <span class="operator">=</span> CacheManager.newInstance(url);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于文件流得到配置文件，并创建CacheManager实例</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span></span><br><span class="line">(<span class="string">&quot;src/config/ehcache.xml&quot;</span>).getAbsolutePath());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="type">CacheManager</span> <span class="variable">manager</span> <span class="operator">=</span> CacheManager.newInstance(fis);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"> fis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加缓存"><a href="#添加缓存" class="headerlink" title="添加缓存"></a>添加缓存</h3><p><strong>需要强调一点，<code>Cache</code>对象在用<code>addCache</code>方法添加到<code>CacheManager</code>之前，是无效的。</strong></p>
<p>使用 CacheManager 的 addCache 方法可以根据缓存名将 ehcache.xml 中声明的 cache 添加到容器中；它也可以直接将 Cache 对象添加到缓存容器中。</p>
<p><code>Cache</code>有多个构造函数，提供了不同方式去加载缓存的配置参数。</p>
<p>有时候，你可能需要使用 API 来动态的添加缓存，下面的例子就提供了这样的范例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 除了可以使用xml文件中配置的缓存，你也可以使用API动态增删缓存</span></span><br><span class="line"><span class="comment">// 添加缓存</span></span><br><span class="line">manager.addCache(cacheName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用默认配置添加缓存</span></span><br><span class="line"><span class="type">CacheManager</span> <span class="variable">singletonManager</span> <span class="operator">=</span> CacheManager.create();</span><br><span class="line">singletonManager.addCache(<span class="string">&quot;testCache&quot;</span>);</span><br><span class="line"><span class="type">Cache</span> <span class="variable">test</span> <span class="operator">=</span> singletonManager.getCache(<span class="string">&quot;testCache&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用自定义配置添加缓存，注意缓存未添加进CacheManager之前并不可用</span></span><br><span class="line"><span class="type">CacheManager</span> <span class="variable">singletonManager</span> <span class="operator">=</span> CacheManager.create();</span><br><span class="line"><span class="type">Cache</span> <span class="variable">memoryOnlyCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cache</span>(<span class="string">&quot;testCache&quot;</span>, <span class="number">5000</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line">singletonManager.addCache(memoryOnlyCache);</span><br><span class="line"><span class="type">Cache</span> <span class="variable">test</span> <span class="operator">=</span> singletonManager.getCache(<span class="string">&quot;testCache&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用特定的配置添加缓存</span></span><br><span class="line"><span class="type">CacheManager</span> <span class="variable">manager</span> <span class="operator">=</span> CacheManager.create();</span><br><span class="line"><span class="type">Cache</span> <span class="variable">testCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cache</span>(</span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">CacheConfiguration</span>(<span class="string">&quot;testCache&quot;</span>, maxEntriesLocalHeap)</span><br><span class="line"> .memoryStoreEvictionPolicy(MemoryStoreEvictionPolicy.LFU)</span><br><span class="line"> .eternal(<span class="literal">false</span>)</span><br><span class="line"> .timeToLiveSeconds(<span class="number">60</span>)</span><br><span class="line"> .timeToIdleSeconds(<span class="number">30</span>)</span><br><span class="line"> .diskExpiryThreadIntervalSeconds(<span class="number">0</span>)</span><br><span class="line"> .persistence(<span class="keyword">new</span> <span class="title class_">PersistenceConfiguration</span>().strategy(Strategy.LOCALTEMPSWAP)));</span><br><span class="line"> manager.addCache(testCache);</span><br></pre></td></tr></table></figure>

<h3 id="删除缓存"><a href="#删除缓存" class="headerlink" title="删除缓存"></a>删除缓存</h3><p>删除缓存比较简单，你只需要将指定的缓存名传入<code>removeCache</code>方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CacheManager</span> <span class="variable">singletonManager</span> <span class="operator">=</span> CacheManager.create();</span><br><span class="line">singletonManager.removeCache(<span class="string">&quot;sampleCache1&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="基本缓存操作"><a href="#基本缓存操作" class="headerlink" title="基本缓存操作"></a>基本缓存操作</h3><p>Cache 最重要的两个方法就是 put 和 get，分别用来添加 Element 和获取 Element。</p>
<p>Cache 还提供了一系列的 get、set 方法来设置或获取缓存参数，这里不一一列举，更多 API 操作可参考<a target="_blank" rel="noopener" href="http://www.ehcache.org/generated/2.10.2/pdf/Ehcache_API_Developer_Guide.pdf">官方 API 开发手册</a>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试：使用默认配置或使用指定配置来创建CacheManager</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Zhang Peng</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheOperationTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(CacheOperationTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用Ehcache默认配置(classpath下的ehcache.xml)获取单例的CacheManager实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CacheManager</span> <span class="variable">manager</span> <span class="operator">=</span> CacheManager.newInstance(<span class="string">&quot;src/test/resources/ehcache/ehcache.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得Cache的引用</span></span><br><span class="line">        <span class="type">Cache</span> <span class="variable">cache</span> <span class="operator">=</span> manager.getCache(<span class="string">&quot;userCache&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将一个Element添加到Cache</span></span><br><span class="line">        cache.put(<span class="keyword">new</span> <span class="title class_">Element</span>(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取Element，Element类支持序列化，所以下面两种方法都可以用</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">element1</span> <span class="operator">=</span> cache.get(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取非序列化的值</span></span><br><span class="line">        log.debug(<span class="string">&quot;key:&#123;&#125;, value:&#123;&#125;&quot;</span>, element1.getObjectKey(), element1.getObjectValue());</span><br><span class="line">        <span class="comment">// 获取序列化的值</span></span><br><span class="line">        log.debug(<span class="string">&quot;key:&#123;&#125;, value:&#123;&#125;&quot;</span>, element1.getKey(), element1.getValue());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新Cache中的Element</span></span><br><span class="line">        cache.put(<span class="keyword">new</span> <span class="title class_">Element</span>(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value2&quot;</span>));</span><br><span class="line">        <span class="type">Element</span> <span class="variable">element2</span> <span class="operator">=</span> cache.get(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;key:&#123;&#125;, value:&#123;&#125;&quot;</span>, element2.getObjectKey(), element2.getObjectValue());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取Cache的元素数</span></span><br><span class="line">        log.debug(<span class="string">&quot;cache size:&#123;&#125;&quot;</span>, cache.getSize());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取MemoryStore的元素数</span></span><br><span class="line">        log.debug(<span class="string">&quot;MemoryStoreSize:&#123;&#125;&quot;</span>, cache.getMemoryStoreSize());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取DiskStore的元素数</span></span><br><span class="line">        log.debug(<span class="string">&quot;DiskStoreSize:&#123;&#125;&quot;</span>, cache.getDiskStoreSize());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移除Element</span></span><br><span class="line">        cache.remove(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;cache size:&#123;&#125;&quot;</span>, cache.getSize());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭当前CacheManager对象</span></span><br><span class="line">        manager.shutdown();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭CacheManager单例实例</span></span><br><span class="line">        CacheManager.getInstance().shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、Ehcache-配置"><a href="#四、Ehcache-配置" class="headerlink" title="四、Ehcache 配置"></a>四、Ehcache 配置</h2><blockquote>
<p>Ehcache 支持通过 xml 文件和 API 两种方式进行配置。</p>
<p>详情参考：<a target="_blank" rel="noopener" href="http://www.ehcache.org/documentation/3.8/xml.html">Ehcache 官方 XML 配置手册</a></p>
</blockquote>
<h3 id="xml-配置方式"><a href="#xml-配置方式" class="headerlink" title="xml 配置方式"></a>xml 配置方式</h3><p>Ehcache 的<code>CacheManager</code>构造函数或工厂方法被调用时，会默认加载 classpath 下名为<em>ehcache.xml</em>的配置文件。如果加载失败，会加载 Ehcache jar 包中的<em>ehcache-failsafe.xml</em>文件，这个文件中含有简单的默认配置。<br><strong>ehcache.xml 配置参数说明：</strong></p>
<ul>
<li><strong>name</strong>：缓存名称。</li>
<li><strong>maxElementsInMemory</strong>：缓存最大个数。</li>
<li><strong>eternal</strong>：缓存中对象是否为永久的，如果是，超时设置将被忽略，对象从不过期。</li>
<li><strong>timeToIdleSeconds</strong>：置对象在失效前的允许闲置时间（单位：秒）。仅当 eternal&#x3D;false 对象不是永久有效时使用，可选属性，默认值是 0，也就是可闲置时间无穷大。</li>
<li><strong>timeToLiveSeconds</strong>：缓存数据的生存时间（TTL），也就是一个元素从构建到消亡的最大时间间隔值，这只能在元素不是永久驻留时有效，如果该值是 0 就意味着元素可以停顿无穷长的时间。</li>
<li><strong>maxEntriesLocalDisk</strong>：当内存中对象数量达到 maxElementsInMemory 时，Ehcache 将会对象写到磁盘中。</li>
<li><strong>overflowToDisk</strong>：内存不足时，是否启用磁盘缓存。</li>
<li><strong>diskSpoolBufferSizeMB</strong>：这个参数设置 DiskStore（磁盘缓存）的缓存区大小。默认是 30MB。每个 Cache 都应该有自己的一个缓冲区。</li>
<li><strong>maxElementsOnDisk</strong>：硬盘最大缓存个数。</li>
<li><strong>diskPersistent</strong>：是否在 VM 重启时存储硬盘的缓存数据。默认值是 false。</li>
<li><strong>diskExpiryThreadIntervalSeconds</strong>：磁盘失效线程运行时间间隔，默认是 120 秒。</li>
<li><strong>memoryStoreEvictionPolicy</strong>：当达到 maxElementsInMemory 限制时，Ehcache 将会根据指定的策略去清理内存。默认策略是 LRU（最近最少使用）。你可以设置为 FIFO（先进先出）或是 LFU（较少使用）。</li>
<li><strong>clearOnFlush</strong>：内存数量最大时是否清除。</li>
</ul>
<h3 id="API-配置方式"><a href="#API-配置方式" class="headerlink" title="API 配置方式"></a>API 配置方式</h3><p>xml 配置的参数也可以直接通过编程方式来动态的进行配置（dynamicConfig 没有设为 false）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Cache</span> <span class="variable">cache</span> <span class="operator">=</span> manager.getCache(<span class="string">&quot;sampleCache&quot;</span>);</span><br><span class="line"><span class="type">CacheConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> cache.getCacheConfiguration();</span><br><span class="line">config.setTimeToIdleSeconds(<span class="number">60</span>);</span><br><span class="line">config.setTimeToLiveSeconds(<span class="number">120</span>);</span><br><span class="line">config.setmaxEntriesLocalHeap(<span class="number">10000</span>);</span><br><span class="line">config.setmaxEntriesLocalDisk(<span class="number">1000000</span>);</span><br></pre></td></tr></table></figure>

<p>也可以通过<code>disableDynamicFeatures()</code>方式关闭动态配置开关。配置以后你将无法再以编程方式配置参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Cache</span> <span class="variable">cache</span> <span class="operator">=</span> manager.getCache(<span class="string">&quot;sampleCache&quot;</span>);</span><br><span class="line">cache.disableDynamicFeatures();</span><br></pre></td></tr></table></figure>

<h2 id="五、Spring-集成-Ehcache"><a href="#五、Spring-集成-Ehcache" class="headerlink" title="五、Spring 集成 Ehcache"></a>五、Spring 集成 Ehcache</h2><p>Spring3.1 开始添加了对缓存的支持。和事务功能的支持方式类似，缓存抽象允许底层使用不同的缓存解决方案来进行整合。</p>
<p>Spring4.1 开始支持 JSR-107 注解。</p>
<blockquote>
<p><strong>注：我本人使用的 Spring 版本为 4.1.4.RELEASE，目前 Spring 版本仅支持 Ehcache2.5 以上版本，但不支持 Ehcache3。</strong></p>
</blockquote>
<h3 id="绑定-Ehcache"><a href="#绑定-Ehcache" class="headerlink" title="绑定 Ehcache"></a>绑定 Ehcache</h3><p><code>org.springframework.cache.ehcache.EhCacheManagerFactoryBean</code>这个类的作用是加载 Ehcache 配置文件。<br><code>org.springframework.cache.ehcache.EhCacheCacheManager</code>这个类的作用是支持 net.sf.ehcache.CacheManager。</p>
<p><em>spring-ehcache.xml</em>的配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:cache</span>=<span class="string">&quot;http://www.springframework.org/schema/cache&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/cache</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/cache/spring-cache-3.2.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>ehcache缓存配置管理文件<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;ehcache&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.cache.ehcache.EhCacheManagerFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:ehcache/ehcache.xml&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cacheManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.cache.ehcache.EhCacheCacheManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cacheManager&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;ehcache&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 启用缓存注解开关 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cache:annotation-driven</span> <span class="attr">cache-manager</span>=<span class="string">&quot;cacheManager&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="使用-Spring-的缓存注解"><a href="#使用-Spring-的缓存注解" class="headerlink" title="使用 Spring 的缓存注解"></a>使用 Spring 的缓存注解</h3><h4 id="开启注解"><a href="#开启注解" class="headerlink" title="开启注解"></a>开启注解</h4><p>Spring 为缓存功能提供了注解功能，但是你必须启动注解。<br>你有两个选择：<br>(1) 在 xml 中声明<br>像上一节 spring-ehcache.xml 中的做法一样，使用<code>&lt;cache:annotation-driven/&gt;</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache:annotation-driven</span> <span class="attr">cache-manager</span>=<span class="string">&quot;cacheManager&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>(2) 使用标记注解<br>你也可以通过对一个类进行注解修饰的方式在这个类中使用缓存注解。<br>范例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注解基本使用方法"><a href="#注解基本使用方法" class="headerlink" title="注解基本使用方法"></a>注解基本使用方法</h3><p>Spring 对缓存的支持类似于对事务的支持。<br>首先使用注解标记方法，相当于定义了切点，然后使用 Aop 技术在这个方法的调用前、调用后获取方法的入参和返回值，进而实现了缓存的逻辑。<br>下面三个注解都是方法级别：</p>
<h4 id="Cacheable"><a href="#Cacheable" class="headerlink" title="@Cacheable"></a>@Cacheable</h4><p>表明所修饰的方法是可以缓存的：当第一次调用这个方法时，它的结果会被缓存下来，在缓存的有效时间内，以后访问这个方法都直接返回缓存结果，不再执行方法中的代码段。<br>这个注解可以用<code>condition</code>属性来设置条件，如果不满足条件，就不使用缓存能力，直接执行方法。<br>可以使用<code>key</code>属性来指定 key 的生成规则。</p>
<h4 id="CachePut"><a href="#CachePut" class="headerlink" title="@CachePut"></a>@CachePut</h4><p>与<code>@Cacheable</code>不同，<code>@CachePut</code>不仅会缓存方法的结果，还会执行方法的代码段。<br>它支持的属性和用法都与<code>@Cacheable</code>一致。</p>
<h4 id="CacheEvict"><a href="#CacheEvict" class="headerlink" title="@CacheEvict"></a>@CacheEvict</h4><p>与<code>@Cacheable</code>功能相反，<code>@CacheEvict</code>表明所修饰的方法是用来删除失效或无用的缓存数据。<br>下面是<code>@Cacheable</code>、<code>@CacheEvict</code>和<code>@CachePut</code>基本使用方法的一个集中展示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">// @Cacheable可以设置多个缓存，形式如：@Cacheable(&#123;&quot;books&quot;, &quot;isbns&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@Cacheable(value=&#123;&quot;users&quot;&#125;, key=&quot;#user.id&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> findUserInDB(user.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Cacheable(value = &quot;users&quot;, condition = &quot;#user.getId() &lt;= 2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findUserInLimit</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> findUserInDB(user.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CachePut(value = &quot;users&quot;, key = &quot;#user.getId()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        updateUserInDB(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CacheEvict(value = &quot;users&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        removeUserInDB(user.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CacheEvict(value = &quot;users&quot;, allEntries = true)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        removeAllInDB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Caching"><a href="#Caching" class="headerlink" title="@Caching"></a>@Caching</h4><p>如果需要使用同一个缓存注解（<code>@Cacheable</code>、<code>@CacheEvict</code>或<code>@CachePut</code>）多次修饰一个方法，就需要用到<code>@Caching</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Caching(evict = &#123; @CacheEvict(&quot;primary&quot;), @CacheEvict(cacheNames=&quot;secondary&quot;, key=&quot;#p0&quot;) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> Book <span class="title function_">importBooks</span><span class="params">(String deposit, Date date)</span></span><br></pre></td></tr></table></figure>

<h4 id="CacheConfig"><a href="#CacheConfig" class="headerlink" title="@CacheConfig"></a>@CacheConfig</h4><p>与前面的缓存注解不同，这是一个类级别的注解。<br>如果类的所有操作都是缓存操作，你可以使用<code>@CacheConfig</code>来指定类，省去一些配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheConfig(&quot;books&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookRepositoryImpl</span> <span class="keyword">implements</span> <span class="title class_">BookRepository</span> &#123;</span><br><span class="line"> <span class="meta">@Cacheable</span></span><br><span class="line"> <span class="keyword">public</span> Book <span class="title function_">findBook</span><span class="params">(ISBN isbn)</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><strong>官方</strong><ul>
<li><a target="_blank" rel="noopener" href="http://www.ehcache.org/">Ehcache 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/ehcache/ehcache3">Ehcache Github</a></li>
</ul>
</li>
<li><strong>文章</strong><ul>
<li><a target="_blank" rel="noopener" href="https://yq.aliyun.com/articles/72885?utm_campaign=wenzhang&utm_medium=article&utm_source=QQ-qun&2017331&utm_content=m_15513">Ehcache 优缺点以及分布式详解</a></li>
<li><a target="_blank" rel="noopener" href="http://raychase.iteye.com/blog/1545906">Ehcache 详细解读</a></li>
<li><a target="_blank" rel="noopener" href="http://www.ibm.com/developerworks/cn/opensource/os-cn-spring-cache/">注释驱动的 Spring cache 缓存介绍</a></li>
<li><a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/">Spring 官方文档第 36 章缓存抽象</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/30abaa/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/30abaa/" class="post-title-link" itemprop="url">Http 缓存</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-17 22:34:30" itemprop="dateCreated datePublished" datetime="2022-02-17T22:34:30+08:00">2022-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">中间件</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E7%BC%93%E5%AD%98/" itemprop="url" rel="index"><span itemprop="name">缓存</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Http-缓存"><a href="#Http-缓存" class="headerlink" title="Http 缓存"></a>Http 缓存</h1><p>HTTP 缓存分为 2 种，一种是强缓存，另一种是协商缓存。主要作用是可以加快资源获取速度，提升用户体验，减少网络传输，缓解服务端的压力。</p>
<h2 id="Http-强缓存"><a href="#Http-强缓存" class="headerlink" title="Http 强缓存"></a>Http 强缓存</h2><p>不需要发送请求到服务端，直接读取浏览器本地缓存，在 Chrome 的 Network 中显示的 HTTP 状态码是 200 ，在 Chrome 中，强缓存又分为 Disk Cache (存放在硬盘中)和 Memory Cache (存放在内存中)，存放的位置是由浏览器控制的。是否强缓存由 <code>Expires</code>、<code>Cache-Control</code> 和 <code>Pragma</code> 3 个 Header 属性共同来控制。</p>
<h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p><code>Expires</code> 的值是一个 HTTP 日期，在浏览器发起请求时，会根据系统时间和 Expires 的值进行比较，如果系统时间超过了 Expires 的值，缓存失效。由于和系统时间进行比较，所以当系统时间和服务器时间不一致的时候，会有缓存有效期不准的问题。Expires 的优先级在三个 Header 属性中是最低的。</p>
<h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p><code>Cache-Control</code> 是 HTTP&#x2F;1.1 中新增的属性，在请求头和响应头中都可以使用，常用的属性值如有：</p>
<ul>
<li><code>max-age</code>：单位是秒，缓存时间计算的方式是距离发起的时间的秒数，超过间隔的秒数缓存失效</li>
<li><code>no-cache</code>：不使用强缓存，需要与服务器验证缓存是否新鲜</li>
<li><code>no-store</code>：禁止使用缓存（包括协商缓存），每次都向服务器请求最新的资源</li>
<li><code>private</code>：专用于个人的缓存，中间代理、CDN 等不能缓存此响应</li>
<li><code>public</code>：响应可以被中间代理、CDN 等缓存</li>
<li><code>must-revalidate</code>：在缓存过期前可以使用，过期后必须向服务器验证</li>
</ul>
<h3 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a>Pragma</h3><p><code>Pragma</code> 只有一个属性值，就是 no-cache ，效果和 Cache-Control 中的 no-cache 一致，不使用强缓存，需要与服务器验证缓存是否新鲜，在 3 个头部属性中的优先级最高。</p>
<h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>当浏览器的强缓存失效的时候或者请求头中设置了不走强缓存，并且在请求头中设置了 If-Modified-Since 或者 If-None-Match 的时候，会将这两个属性值到服务端去验证是否命中协商缓存，如果命中了协商缓存，会返回 304 状态，加载浏览器缓存，并且响应头会设置 Last-Modified 或者 ETag 属性。</p>
<h3 id="ETag-If-None-Match"><a href="#ETag-If-None-Match" class="headerlink" title="ETag&#x2F;If-None-Match"></a>ETag&#x2F;If-None-Match</h3><p>Etag： 服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识（生成规则由服务器决定）</p>
<p>If-None-Match： 再次请求服务器时，浏览器的请求报文头部会包含此字段，后面的值为在缓存中获取的标识。服务器接收到次报文后发现 If-None-Match 则与被请求资源的唯一标识进行对比。</p>
<ol>
<li>不同，说明资源被改动过，则响应整个资源内容，返回状态码 200。</li>
<li>相同，说明资源无心修改，则响应 header，浏览器直接从缓存中获取数据信息。返回状态码 304.</li>
</ol>
<p>但是实际应用中由于 Etag 的计算是使用算法来得出的，而算法会占用服务端计算的资源，所有服务端的资源都是宝贵的，所以就很少使用 Etag 了。</p>
<h3 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified&#x2F;If-Modified-Since"></a>Last-Modified&#x2F;If-Modified-Since</h3><p>Last-Modified： 服务器在响应请求时，会告诉浏览器资源的最后修改时间。</p>
<p>if-Modified-Since: 浏览器再次请求服务器的时候，请求头会包含此字段，后面跟着在缓存中获得的最后修改时间。服务端收到此请求头发现有 if-Modified-Since，则与被请求资源的最后修改时间进行对比，如果一致则返回 304 和响应报文头，浏览器只需要从缓存中获取信息即可。 从字面上看，就是说：从某个时间节点算起，是否文件被修改了</p>
<ol>
<li>如果真的被修改：那么开始传输响应一个整体，服务器返回：200 OK</li>
<li>如果没有被修改：那么只需传输响应 header，服务器返回：304 Not Modified</li>
</ol>
<p>if-Unmodified-Since: 从字面上看, 就是说: 从某个时间点算起, 是否文件没有被修改</p>
<ol>
<li>如果没有被修改:则开始&#96;继续’传送文件: 服务器返回: 200 OK</li>
<li>如果文件被修改:则不传输,服务器返回: 412 Precondition failed (预处理错误)</li>
</ol>
<p>这两个的区别是一个是修改了才下载一个是没修改才下载。 Last-Modified 说好却也不是特别好，因为如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为 Last-Modified 时间匹配不上而返回了整个实体给客户端（即使客户端缓存里有个一模一样的资源）。为了解决这个问题，HTTP1.1 推出了 Etag。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5eb7f811f265da7bbc7cc5bd">图解 HTTP 缓存</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5a1d4e546fb9a0450f21af23">HTTP—-HTTP 缓存机制</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5a6c87c46fb9a01ca560b4d7">缓存详解</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.ligoudan.cn/pages/4a4c02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/ligoudan.png">
      <meta itemprop="name" content="李狗蛋">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LIGOUDAN">
      <meta itemprop="description" content="天气不错哇，你看这大冰雹下得">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LIGOUDAN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/pages/4a4c02/" class="post-title-link" itemprop="url">Tomcat 快速入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-17 22:34:30" itemprop="dateCreated datePublished" datetime="2022-02-17T22:34:30+08:00">2022-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-12 10:02:52" itemprop="dateModified" datetime="2024-12-12T10:02:52+08:00">2024-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JavaEE/" itemprop="url" rel="index"><span itemprop="name">JavaEE</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JavaEE/%E6%9C%8D%E5%8A%A1%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">服务器</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/JavaEE/%E6%9C%8D%E5%8A%A1%E5%99%A8/Tomcat/" itemprop="url" rel="index"><span itemprop="name">Tomcat</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>21k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>19 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Tomcat-快速入门"><a href="#Tomcat-快速入门" class="headerlink" title="Tomcat 快速入门"></a>Tomcat 快速入门</h1><blockquote>
<p>🎁 版本说明</p>
<p>当前最新版本：Tomcat 8.5.24</p>
<p>环境要求：JDK7+</p>
</blockquote>
<h2 id="1-Tomcat-简介"><a href="#1-Tomcat-简介" class="headerlink" title="1. Tomcat 简介"></a>1. Tomcat 简介</h2><h3 id="1-1-Tomcat-是什么"><a href="#1-1-Tomcat-是什么" class="headerlink" title="1.1. Tomcat 是什么"></a>1.1. Tomcat 是什么</h3><p>Tomcat 是由 Apache 开发的一个 Servlet 容器，实现了对 Servlet 和 JSP 的支持，并提供了作为 Web 服务器的一些特有功能，如 Tomcat 管理和控制平台、安全域管理和 Tomcat 阀等。</p>
<p>由于 Tomcat 本身也内含了一个 HTTP 服务器，它也可以被视作一个单独的 Web 服务器。但是，不能将 Tomcat 和 Apache HTTP 服务器混淆，Apache HTTP 服务器是一个用 C 语言实现的 HTTP Web 服务器；这两个 HTTP web server 不是捆绑在一起的。Tomcat 包含了一个配置管理工具，也可以通过编辑 XML 格式的配置文件来进行配置。</p>
<h3 id="1-2-Tomcat-重要目录"><a href="#1-2-Tomcat-重要目录" class="headerlink" title="1.2. Tomcat 重要目录"></a>1.2. Tomcat 重要目录</h3><ul>
<li><strong>&#x2F;bin</strong> - Tomcat 脚本存放目录（如启动、关闭脚本）。 <code>*.sh</code> 文件用于 Unix 系统； <code>*.bat</code> 文件用于 Windows 系统。</li>
<li><strong>&#x2F;conf</strong> - Tomcat 配置文件目录。</li>
<li><strong>&#x2F;logs</strong> - Tomcat 默认日志目录。</li>
<li><strong>&#x2F;webapps</strong> - webapp 运行的目录。</li>
</ul>
<h3 id="1-3-web-工程发布目录结构"><a href="#1-3-web-工程发布目录结构" class="headerlink" title="1.3. web 工程发布目录结构"></a>1.3. web 工程发布目录结构</h3><p>一般 web 项目路径结构</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">|<span class="string">-- webapp                         # 站点根目录</span></span><br><span class="line"><span class="string">    </span>|<span class="string">-- META-INF                   # META-INF 目录</span></span><br><span class="line"><span class="string">    </span>|<span class="string">   `-- MANIFEST.MF            # 配置清单文件</span></span><br><span class="line"><span class="string">    </span>|<span class="string">-- WEB-INF                    # WEB-INF 目录</span></span><br><span class="line"><span class="string">    </span>|<span class="string">   </span>|<span class="string">-- classes                # class文件目录</span></span><br><span class="line"><span class="string">    </span>|<span class="string">   </span>|<span class="string">   </span>|<span class="string">-- *.class            # 程序需要的 class 文件</span></span><br><span class="line"><span class="string">    </span>|<span class="string">   </span>|<span class="string">   `-- *.xml              # 程序需要的 xml 文件</span></span><br><span class="line"><span class="string">    </span>|<span class="string">   </span>|<span class="string">-- lib                    # 库文件夹</span></span><br><span class="line"><span class="string">    </span>|<span class="string">   </span>|<span class="string">   `-- *.jar              # 程序需要的 jar 包</span></span><br><span class="line"><span class="string">    </span>|<span class="string">   `-- web.xml                # Web应用程序的部署描述文件</span></span><br><span class="line"><span class="string">    </span>|<span class="string">-- &lt;userdir&gt;                  # 自定义的目录</span></span><br><span class="line"><span class="string">    </span>|<span class="string">-- &lt;userfiles&gt;                # 自定义的资源文件</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>webapp</code>：工程发布文件夹。其实每个 war 包都可以视为 webapp 的压缩包。</p>
</li>
<li><p><code>META-INF</code>：META-INF 目录用于存放工程自身相关的一些信息，元文件信息，通常由开发工具，环境自动生成。</p>
</li>
<li><p><code>WEB-INF</code>：Java web 应用的安全目录。所谓安全就是客户端无法访问，只有服务端可以访问的目录。</p>
</li>
<li><p><code>/WEB-INF/classes</code>：存放程序所需要的所有 Java class 文件。</p>
</li>
<li><p><code>/WEB-INF/lib</code>：存放程序所需要的所有 jar 文件。</p>
</li>
<li><p><code>/WEB-INF/web.xml</code>：web 应用的部署配置文件。它是工程中最重要的配置文件，它描述了 servlet 和组成应用的其它组件，以及应用初始化参数、安全管理约束等。</p>
</li>
</ul>
<h3 id="1-4-Tomcat-功能"><a href="#1-4-Tomcat-功能" class="headerlink" title="1.4. Tomcat 功能"></a>1.4. Tomcat 功能</h3><p>Tomcat 支持的 I&#x2F;O 模型有：</p>
<ul>
<li>NIO：非阻塞 I&#x2F;O，采用 Java NIO 类库实现。</li>
<li>NIO2：异步 I&#x2F;O，采用 JDK 7 最新的 NIO2 类库实现。</li>
<li>APR：采用 Apache 可移植运行库实现，是 C&#x2F;C++ 编写的本地库。</li>
</ul>
<p>Tomcat 支持的应用层协议有：</p>
<ul>
<li>HTTP&#x2F;1.1：这是大部分 Web 应用采用的访问协议。</li>
<li>AJP：用于和 Web 服务器集成（如 Apache）。</li>
<li>HTTP&#x2F;2：HTTP 2.0 大幅度的提升了 Web 性能。</li>
</ul>
<h2 id="2-Tomcat-入门"><a href="#2-Tomcat-入门" class="headerlink" title="2. Tomcat 入门"></a>2. Tomcat 入门</h2><h3 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1. 安装"></a>2.1. 安装</h3><p><strong>前提条件</strong></p>
<p>Tomcat 8.5 要求 JDK 版本为 1.7 以上。</p>
<p>进入 <a target="_blank" rel="noopener" href="https://tomcat.apache.org/download-80.cgi">Tomcat 官方下载地址</a> 选择合适版本下载，并解压到本地。</p>
<p><strong>Windows</strong></p>
<p>添加环境变量 <code>CATALINA_HOME</code> ，值为 Tomcat 的安装路径。</p>
<p>进入安装目录下的 bin 目录，运行 startup.bat 文件，启动 Tomcat</p>
<p><strong>Linux &#x2F; Unix</strong></p>
<p>下面的示例以 8.5.24 版本为例，包含了下载、解压、启动操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载解压到本地</span></span><br><span class="line">wget http://mirrors.hust.edu.cn/apache/tomcat/tomcat-8/v8.5.24/bin/apache-tomcat-8.5.24.tar.gz</span><br><span class="line">tar -zxf apache-tomcat-8.5.24.tar.gz</span><br><span class="line"><span class="comment"># 启动 Tomcat</span></span><br><span class="line">./apache-tomcat-8.5.24/bin/startup.sh</span><br></pre></td></tr></table></figure>

<p>启动后，访问 <code>http://localhost:8080</code> ，可以看到 Tomcat 安装成功的测试页面。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/tools/tomcat/tomcat.png" alt="img"></p>
<h3 id="2-2-配置"><a href="#2-2-配置" class="headerlink" title="2.2. 配置"></a>2.2. 配置</h3><p>本节将列举一些重要、常见的配置项。详细的 Tomcat8 配置可以参考 <a target="_blank" rel="noopener" href="http://tomcat.apache.org/tomcat-8.5-doc/config/index.html">Tomcat 8 配置官方参考文档</a> 。</p>
<h4 id="2-2-1-Server"><a href="#2-2-1-Server" class="headerlink" title="2.2.1. Server"></a>2.2.1. Server</h4><blockquote>
<p>Server 元素表示整个 Catalina servlet 容器。</p>
<p>因此，它必须是 <code>conf/server.xml</code> 配置文件中的根元素。它的属性代表了整个 servlet 容器的特性。</p>
</blockquote>
<p><strong>属性表</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>className</td>
<td>这个类必须实现 org.apache.catalina.Server 接口。</td>
<td>默认 org.apache.catalina.core.StandardServer</td>
</tr>
<tr>
<td>address</td>
<td>服务器等待关机命令的 TCP &#x2F; IP 地址。如果没有指定地址，则使用 localhost。</td>
<td></td>
</tr>
<tr>
<td>port</td>
<td>服务器等待关机命令的 TCP &#x2F; IP 端口号。设置为-1 以禁用关闭端口。</td>
<td></td>
</tr>
<tr>
<td>shutdown</td>
<td>必须通过 TCP &#x2F; IP 连接接收到指定端口号的命令字符串，以关闭 Tomcat。</td>
<td></td>
</tr>
</tbody></table>
<h4 id="2-2-2-Service"><a href="#2-2-2-Service" class="headerlink" title="2.2.2. Service"></a>2.2.2. Service</h4><blockquote>
<p>Service 元素表示一个或多个连接器组件的组合，这些组件共享一个用于处理传入请求的引擎组件。Server 中可以有多个 Service。</p>
</blockquote>
<p><strong>属性表</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>className</td>
<td>这个类必须实现<code>org.apache.catalina.Service</code>接口。</td>
<td>默认 <code>org.apache.catalina.core.StandardService</code></td>
</tr>
<tr>
<td>name</td>
<td>此服务的显示名称，如果您使用标准 Catalina 组件，将包含在日志消息中。与特定服务器关联的每个服务的名称必须是唯一的。</td>
<td></td>
</tr>
</tbody></table>
<p><strong>实例 - <code>conf/server.xml</code> 配置文件示例</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Server</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">shutdown</span>=<span class="string">&quot;SHUTDOWN&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Service</span> <span class="attr">name</span>=<span class="string">&quot;xxx&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Server</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-3-Executor"><a href="#2-2-3-Executor" class="headerlink" title="2.2.3. Executor"></a>2.2.3. Executor</h4><blockquote>
<p>Executor 表示可以在 Tomcat 中的组件之间共享的线程池。</p>
</blockquote>
<p><strong>属性表</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>className</td>
<td>这个类必须实现<code>org.apache.catalina.Executor</code>接口。</td>
<td>默认 <code>org.apache.catalina.core.StandardThreadExecutor</code></td>
</tr>
<tr>
<td>name</td>
<td>线程池名称。</td>
<td>要求唯一, 供 Connector 元素的 executor 属性使用</td>
</tr>
<tr>
<td>namePrefix</td>
<td>线程名称前缀。</td>
<td></td>
</tr>
<tr>
<td>maxThreads</td>
<td>最大活跃线程数。</td>
<td>默认 200</td>
</tr>
<tr>
<td>minSpareThreads</td>
<td>最小活跃线程数。</td>
<td>默认 25</td>
</tr>
<tr>
<td>maxIdleTime</td>
<td>当前活跃线程大于 minSpareThreads 时,空闲线程关闭的等待最大时间。</td>
<td>默认 60000ms</td>
</tr>
<tr>
<td>maxQueueSize</td>
<td>线程池满情况下的请求排队大小。</td>
<td>默认 Integer.MAX_VALUE</td>
</tr>
</tbody></table>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Service</span> <span class="attr">name</span>=<span class="string">&quot;xxx&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Executor</span> <span class="attr">name</span>=<span class="string">&quot;tomcatThreadPool&quot;</span> <span class="attr">namePrefix</span>=<span class="string">&quot;catalina-exec-&quot;</span> <span class="attr">maxThreads</span>=<span class="string">&quot;300&quot;</span> <span class="attr">minSpareThreads</span>=<span class="string">&quot;25&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-4-Connector"><a href="#2-2-4-Connector" class="headerlink" title="2.2.4. Connector"></a>2.2.4. Connector</h4><blockquote>
<p>Connector 代表连接组件。Tomcat 支持三种协议：HTTP&#x2F;1.1、HTTP&#x2F;2.0、AJP。</p>
</blockquote>
<p><strong>属性表</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>asyncTimeout</td>
<td>Servlet3.0 规范中的异步请求超时</td>
<td>默认 30s</td>
</tr>
<tr>
<td>port</td>
<td>请求连接的 TCP Port</td>
<td>设置为 0,则会随机选取一个未占用的端口号</td>
</tr>
<tr>
<td>protocol</td>
<td>协议. 一般情况下设置为 HTTP&#x2F;1.1,这种情况下连接模型会在 NIO 和 APR&#x2F;native 中自动根据配置选择</td>
<td></td>
</tr>
<tr>
<td>URIEncoding</td>
<td>对 URI 的编码方式.</td>
<td>如果设置系统变量 org.apache.catalina.STRICT_SERVLET_COMPLIANCE 为 true,使用 ISO-8859-1 编码;如果未设置此系统变量且未设置此属性, 使用 UTF-8 编码</td>
</tr>
<tr>
<td>useBodyEncodingForURI</td>
<td>是否采用指定的 contentType 而不是 URIEncoding 来编码 URI 中的请求参数</td>
<td></td>
</tr>
</tbody></table>
<p>以下属性在标准的 Connector(NIO, NIO2 和 APR&#x2F;native)中有效:</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>acceptCount</td>
<td>当最大请求连接 maxConnections 满时的最大排队大小</td>
<td>默认 100,注意此属性和 Executor 中属性 maxQueueSize 的区别.这个指的是请求连接满时的堆栈大小,Executor 的 maxQueueSize 指的是处理线程满时的堆栈大小</td>
</tr>
<tr>
<td>connectionTimeout</td>
<td>请求连接超时</td>
<td>默认 60000ms</td>
</tr>
<tr>
<td>executor</td>
<td>指定配置的线程池名称</td>
<td></td>
</tr>
<tr>
<td>keepAliveTimeout</td>
<td>keeAlive 超时时间</td>
<td>默认值为 connectionTimeout 配置值.-1 表示不超时</td>
</tr>
<tr>
<td>maxConnections</td>
<td>最大连接数</td>
<td>连接满时后续连接放入最大为 acceptCount 的队列中. 对 NIO 和 NIO2 连接,默认值为 10000;对 APR&#x2F;native,默认值为 8192</td>
</tr>
<tr>
<td>maxThreads</td>
<td>如果指定了 Executor, 此属性忽略;否则为 Connector 创建的内部线程池最大值</td>
<td>默认 200</td>
</tr>
<tr>
<td>minSpareThreads</td>
<td>如果指定了 Executor, 此属性忽略;否则为 Connector 创建线程池的最小活跃线程数</td>
<td>默认 10</td>
</tr>
<tr>
<td>processorCache</td>
<td>协议处理器缓存 Processor 对象的大小</td>
<td>-1 表示不限制.当不使用 servlet3.0 的异步处理情况下: 如果配置 Executor,配置为 Executor 的 maxThreads;否则配置为 Connnector 的 maxThreads. 如果使用 Serlvet3.0 异步处理, 取 maxThreads 和 maxConnections 的最大值</td>
</tr>
</tbody></table>
<h4 id="2-2-5-Context"><a href="#2-2-5-Context" class="headerlink" title="2.2.5. Context"></a>2.2.5. Context</h4><blockquote>
<p>Context 元素表示一个 Web 应用程序，它在特定的虚拟主机中运行。每个 Web 应用程序都基于 Web 应用程序存档（WAR）文件，或者包含相应的解包内容的相应目录，如 Servlet 规范中所述。</p>
</blockquote>
<p><strong>属性表</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>altDDName</td>
<td>web.xml 部署描述符路径</td>
<td>默认 &#x2F;WEB-INF&#x2F;web.xml</td>
</tr>
<tr>
<td>docBase</td>
<td>Context 的 Root 路径</td>
<td>和 Host 的 appBase 相结合, 可确定 web 应用的实际目录</td>
</tr>
<tr>
<td>failCtxIfServletStartFails</td>
<td>同 Host 中的 failCtxIfServletStartFails, 只对当前 Context 有效</td>
<td>默认为 false</td>
</tr>
<tr>
<td>logEffectiveWebXml</td>
<td>是否日志打印 web.xml 内容(web.xml 由默认的 web.xml 和应用中的 web.xml 组成)</td>
<td>默认为 false</td>
</tr>
<tr>
<td>path</td>
<td>web 应用的 context path</td>
<td>如果为根路径,则配置为空字符串(“”), 不能不配置</td>
</tr>
<tr>
<td>privileged</td>
<td>是否使用 Tomcat 提供的 manager servlet</td>
<td></td>
</tr>
<tr>
<td>reloadable</td>
<td>&#x2F;WEB-INF&#x2F;classes&#x2F; 和&#x2F;WEB-INF&#x2F;lib&#x2F; 目录中 class 文件发生变化是否自动重新加载</td>
<td>默认为 false</td>
</tr>
<tr>
<td>swallowOutput</td>
<td>true 情况下, System.out 和 System.err 输出将被定向到 web 应用日志中</td>
<td>默认为 false</td>
</tr>
</tbody></table>
<h4 id="2-2-6-Engine"><a href="#2-2-6-Engine" class="headerlink" title="2.2.6. Engine"></a>2.2.6. Engine</h4><blockquote>
<p>Engine 元素表示与特定的 Catalina 服务相关联的整个请求处理机器。它接收并处理来自一个或多个连接器的所有请求，并将完成的响应返回给连接器，以便最终传输回客户端。</p>
</blockquote>
<p><strong>属性表</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>defaultHost</td>
<td>默认主机名，用于标识将处理指向此服务器上主机名称但未在此配置文件中配置的请求的主机。</td>
<td>这个名字必须匹配其中一个嵌套的主机元素的名字属性。</td>
</tr>
<tr>
<td>name</td>
<td>此引擎的逻辑名称，用于日志和错误消息。</td>
<td>在同一服务器中使用多个服务元素时，每个引擎必须分配一个唯一的名称。</td>
</tr>
</tbody></table>
<h4 id="2-2-7-Host"><a href="#2-2-7-Host" class="headerlink" title="2.2.7. Host"></a>2.2.7. Host</h4><blockquote>
<p>Host 元素表示一个虚拟主机，它是一个服务器的网络名称（如“<a target="_blank" rel="noopener" href="http://www.mycompany.com”)与运行/">www.mycompany.com”）与运行</a> Tomcat 的特定服务器的关联。</p>
</blockquote>
<p><strong>属性表</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>名称</td>
<td>用于日志输出</td>
</tr>
<tr>
<td>appBase</td>
<td>虚拟主机对应的应用基础路径</td>
<td>可以是个绝对路径, 或${CATALINA_BASE}相对路径</td>
</tr>
<tr>
<td>xmlBase</td>
<td>虚拟主机 XML 基础路径,里面应该有 Context xml 配置文件</td>
<td>可以是个绝对路径, 或${CATALINA_BASE}相对路径</td>
</tr>
<tr>
<td>createDirs</td>
<td>当 appBase 和 xmlBase 不存在时,是否创建目录</td>
<td>默认为 true</td>
</tr>
<tr>
<td>autoDeploy</td>
<td>是否周期性的检查 appBase 和 xmlBase 并 deploy web 应用和 context 描述符</td>
<td>默认为 true</td>
</tr>
<tr>
<td>deployIgnore</td>
<td>忽略 deploy 的正则</td>
<td></td>
</tr>
<tr>
<td>deployOnStartup</td>
<td>Tomcat 启动时是否自动 deploy</td>
<td>默认为 true</td>
</tr>
<tr>
<td>failCtxIfServletStartFails</td>
<td>配置为 true 情况下,任何 load-on-startup &gt;&#x3D;0 的 servlet 启动失败,则其对应的 Contxt 也启动失败</td>
<td>默认为 false</td>
</tr>
</tbody></table>
<h4 id="2-2-8-Cluster"><a href="#2-2-8-Cluster" class="headerlink" title="2.2.8. Cluster"></a>2.2.8. Cluster</h4><p>由于在实际开发中，我从未用过 Tomcat 集群配置，所以没研究。</p>
<h3 id="2-3-启动"><a href="#2-3-启动" class="headerlink" title="2.3. 启动"></a>2.3. 启动</h3><h4 id="2-3-1-部署方式"><a href="#2-3-1-部署方式" class="headerlink" title="2.3.1. 部署方式"></a>2.3.1. 部署方式</h4><p>这种方式要求本地必须安装 Tomcat 。</p>
<p>将打包好的 war 包放在 Tomcat 安装目录下的 <code>webapps</code> 目录下，然后在 bin 目录下执行 <code>startup.bat</code> 或 <code>startup.sh</code> ，Tomcat 会自动解压 <code>webapps</code> 目录下的 war 包。</p>
<p>成功后，可以访问 <code>http://localhost:8080/xxx</code> （xxx 是 war 包文件名）。</p>
<blockquote>
<p><strong>注意</strong></p>
<p>以上步骤是最简单的示例。步骤中的 war 包解压路径、启动端口以及一些更多的功能都可以修改配置文件来定制 （主要是 <code>server.xml</code> 或 <code>context.xml</code> 文件）。</p>
</blockquote>
<h4 id="2-3-2-嵌入式"><a href="#2-3-2-嵌入式" class="headerlink" title="2.3.2. 嵌入式"></a>2.3.2. 嵌入式</h4><h5 id="2-3-2-1-API-方式"><a href="#2-3-2-1-API-方式" class="headerlink" title="2.3.2.1. API 方式"></a>2.3.2.1. API 方式</h5><p>在 pom.xml 中添加依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.5.24<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>添加 SimpleEmbedTomcatServer.java 文件，内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.startup.Tomcat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleTomcatServer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">8080</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONTEXT_PATH</span> <span class="operator">=</span> <span class="string">&quot;/javatool-server&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 设定 profile</span></span><br><span class="line">        Optional&lt;String&gt; profile = Optional.ofNullable(System.getProperty(<span class="string">&quot;spring.profiles.active&quot;</span>));</span><br><span class="line">        System.setProperty(<span class="string">&quot;spring.profiles.active&quot;</span>, profile.orElse(<span class="string">&quot;develop&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Tomcat</span> <span class="variable">tomcat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tomcat</span>();</span><br><span class="line">        tomcat.setPort(PORT);</span><br><span class="line">        tomcat.getHost().setAppBase(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        tomcat.addWebapp(CONTEXT_PATH, getAbsolutePath() + <span class="string">&quot;src/main/webapp&quot;</span>);</span><br><span class="line">        tomcat.start();</span><br><span class="line">        tomcat.getServer().await();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getAbsolutePath</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">folderPath</span> <span class="operator">=</span> SimpleEmbedTomcatServer.class.getProtectionDomain().getCodeSource().getLocation().getPath()</span><br><span class="line">                .substring(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (folderPath.indexOf(<span class="string">&quot;target&quot;</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            path = folderPath.substring(<span class="number">0</span>, folderPath.indexOf(<span class="string">&quot;target&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成功后，可以访问 <code>http://localhost:8080/javatool-server</code> 。</p>
<blockquote>
<p><strong>说明</strong></p>
<p>本示例是使用 <code>org.apache.tomcat.embed</code> 启动嵌入式 Tomcat 的最简示例。</p>
<p>这个示例中使用的是 Tomcat 默认的配置，但通常，我们需要对 Tomcat 配置进行一些定制和调优。为了加载配置文件，启动类就要稍微再复杂一些。这里不想再贴代码，有兴趣的同学可以参考：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/dunwu/JavaStack/tree/master/codes/javatool/server"><strong>示例项目</strong></a></p>
</blockquote>
<h5 id="2-3-2-2-使用-maven-插件启动（不推荐）"><a href="#2-3-2-2-使用-maven-插件启动（不推荐）" class="headerlink" title="2.3.2.2. 使用 maven 插件启动（不推荐）"></a>2.3.2.2. 使用 maven 插件启动（不推荐）</h5><p>不推荐理由：这种方式启动 maven 虽然最简单，但是有一个很大的问题是，真的很久很久没发布新版本了（最新版本发布时间：2013-11-11）。且貌似只能找到 Tomcat6 、Tomcat7 插件。</p>
<p><strong>使用方法</strong></p>
<p>在 pom.xml 中引入插件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">port</span>&gt;</span>8080<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">path</span>&gt;</span>/$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uriEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">uriEncoding</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>运行 <code>mvn tomcat7:run</code> 命令，启动 Tomcat。</p>
<p>成功后，可以访问 <code>http://localhost:8080/xxx</code> （xxx 是 ${project.artifactId} 指定的项目名）。</p>
<h4 id="2-3-3-IDE-插件"><a href="#2-3-3-IDE-插件" class="headerlink" title="2.3.3. IDE 插件"></a>2.3.3. IDE 插件</h4><p>常见 Java IDE 一般都有对 Tomcat 的支持。</p>
<p>以 Intellij IDEA 为例，提供了 <strong>Tomcat and TomEE Integration</strong> 插件（一般默认会安装）。</p>
<p><strong>使用步骤</strong></p>
<ul>
<li>点击 Run&#x2F;Debug Configurations &gt; New Tomcat Server &gt; local ，打开 Tomcat 配置页面。</li>
<li>点击 Confiure… 按钮，设置 Tomcat 安装路径。</li>
<li>点击 Deployment 标签页，设置要启动的应用。</li>
<li>设置启动应用的端口、JVM 参数、启动浏览器等。</li>
<li>成功后，可以访问 <code>http://localhost:8080/</code>（当然，你也可以在 url 中设置上下文名称）。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/tools/tomcat/tomcat-intellij-run-config.png" alt="img"></p>
<blockquote>
<p><strong>说明</strong></p>
<p>个人认为这个插件不如 Eclipse 的 Tomcat 插件好用，Eclipse 的 Tomcat 插件支持对 Tomcat xml 配置文件进行配置。而这里，你只能自己去 Tomcat 安装路径下修改配置文件。</p>
</blockquote>
<p>文中的嵌入式启动示例可以参考<a target="_blank" rel="noopener" href="https://github.com/dunwu/JavaStack/tree/master/codes/javatool/server"><strong>我的示例项目</strong></a></p>
<h2 id="3-Tomcat-架构"><a href="#3-Tomcat-架构" class="headerlink" title="3. Tomcat 架构"></a>3. Tomcat 架构</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20201113193431.png" alt="img"></p>
<p>Tomcat 要实现 2 个核心功能：</p>
<ul>
<li><strong>处理 Socket 连接</strong>，负责网络字节流与 Request 和 Response 对象的转化。</li>
<li><strong>加载和管理 Servlet</strong>，以及<strong>处理具体的 Request 请求</strong>。</li>
</ul>
<p>为此，Tomcat 设计了两个核心组件：</p>
<ul>
<li><strong>连接器（Connector）</strong>：负责和外部通信</li>
<li><strong>容器（Container）</strong>：负责内部处理</li>
</ul>
<h3 id="3-1-Service"><a href="#3-1-Service" class="headerlink" title="3.1. Service"></a>3.1. Service</h3><p>Tomcat 支持的 I&#x2F;O 模型有：</p>
<ul>
<li>NIO：非阻塞 I&#x2F;O，采用 Java NIO 类库实现。</li>
<li>NIO2：异步 I&#x2F;O，采用 JDK 7 最新的 NIO2 类库实现。</li>
<li>APR：采用 Apache 可移植运行库实现，是 C&#x2F;C++ 编写的本地库。</li>
</ul>
<p>Tomcat 支持的应用层协议有：</p>
<ul>
<li>HTTP&#x2F;1.1：这是大部分 Web 应用采用的访问协议。</li>
<li>AJP：用于和 Web 服务器集成（如 Apache）。</li>
<li>HTTP&#x2F;2：HTTP 2.0 大幅度的提升了 Web 性能。</li>
</ul>
<p>Tomcat 支持多种 I&#x2F;O 模型和应用层协议。为了实现这点，一个容器可能对接多个连接器。但是，单独的连接器或容器都不能对外提供服务，需要把它们组装起来才能工作，组装后这个整体叫作 Service 组件。Tomcat 内可能有多个 Service，通过在 Tomcat 中配置多个 Service，可以实现通过不同的端口号来访问同一台机器上部署的不同应用。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20201111093124.png" alt="img"></p>
<p><strong>一个 Tomcat 实例有一个或多个 Service；一个 Service 有多个 Connector 和 Container</strong>。Connector 和 Container 之间通过标准的 ServletRequest 和 ServletResponse 通信。</p>
<h3 id="3-2-连接器"><a href="#3-2-连接器" class="headerlink" title="3.2. 连接器"></a>3.2. 连接器</h3><p>连接器对 Servlet 容器屏蔽了协议及 I&#x2F;O 模型等的区别，无论是 HTTP 还是 AJP，在容器中获取到的都是一个标准的 ServletRequest 对象。</p>
<p>连接器的主要功能是：</p>
<ul>
<li>网络通信</li>
<li>应用层协议解析</li>
<li>Tomcat Request&#x2F;Response 与 ServletRequest&#x2F;ServletResponse 的转化</li>
</ul>
<p>Tomcat 设计了 3 个组件来实现这 3 个功能，分别是 <strong><code>EndPoint</code><strong>、</strong><code>Processor</code></strong> 和 **<code>Adapter</code>**。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20201111101440.png" alt="img"></p>
<p>组件间通过抽象接口交互。这样做还有一个好处是<strong>封装变化。</strong>这是面向对象设计的精髓，将系统中经常变化的部分和稳定的部分隔离，有助于增加复用性，并降低系统耦合度。网络通信的 I&#x2F;O 模型是变化的，可能是非阻塞 I&#x2F;O、异步 I&#x2F;O 或者 APR。应用层协议也是变化的，可能是 HTTP、HTTPS、AJP。浏览器端发送的请求信息也是变化的。但是整体的处理逻辑是不变的，EndPoint 负责提供字节流给 Processor，Processor 负责提供 Tomcat Request 对象给 Adapter，Adapter 负责提供 ServletRequest 对象给容器。</p>
<p>如果要支持新的 I&#x2F;O 方案、新的应用层协议，只需要实现相关的具体子类，上层通用的处理逻辑是不变的。由于 I&#x2F;O 模型和应用层协议可以自由组合，比如 NIO + HTTP 或者 NIO2 + AJP。Tomcat 的设计者将网络通信和应用层协议解析放在一起考虑，设计了一个叫 ProtocolHandler 的接口来封装这两种变化点。各种协议和通信模型的组合有相应的具体实现类。比如：Http11NioProtocol 和 AjpNioProtocol。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20201027091819.png" alt="img"></p>
<h4 id="3-2-1-ProtocolHandler-组件"><a href="#3-2-1-ProtocolHandler-组件" class="headerlink" title="3.2.1. ProtocolHandler 组件"></a>3.2.1. ProtocolHandler 组件</h4><p><strong>连接器用 ProtocolHandler 接口来封装通信协议和 I&#x2F;O 模型的差异</strong>。ProtocolHandler 内部又分为 EndPoint 和 Processor 模块，EndPoint 负责底层 Socket 通信，Proccesor 负责应用层协议解析。</p>
<h5 id="3-2-1-1-EndPoint"><a href="#3-2-1-1-EndPoint" class="headerlink" title="3.2.1.1. EndPoint"></a>3.2.1.1. EndPoint</h5><p>EndPoint 是通信端点，即通信监听的接口，是具体的 Socket 接收和发送处理器，是对传输层的抽象，因此 EndPoint 是用来实现 TCP&#x2F;IP 协议的。</p>
<p>EndPoint 是一个接口，对应的抽象实现类是 AbstractEndpoint，而 AbstractEndpoint 的具体子类，比如在 NioEndpoint 和 Nio2Endpoint 中，有两个重要的子组件：Acceptor 和 SocketProcessor。</p>
<p>其中 Acceptor 用于监听 Socket 连接请求。SocketProcessor 用于处理接收到的 Socket 请求，它实现 Runnable 接口，在 Run 方法里调用协议处理组件 Processor 进行处理。为了提高处理能力，SocketProcessor 被提交到线程池来执行。而这个线程池叫作执行器（Executor)。</p>
<h5 id="3-2-1-2-Processor"><a href="#3-2-1-2-Processor" class="headerlink" title="3.2.1.2. Processor"></a>3.2.1.2. Processor</h5><p>如果说 EndPoint 是用来实现 TCP&#x2F;IP 协议的，那么 Processor 用来实现 HTTP 协议，Processor 接收来自 EndPoint 的 Socket，读取字节流解析成 Tomcat Request 和 Response 对象，并通过 Adapter 将其提交到容器处理，Processor 是对应用层协议的抽象。</p>
<p>Processor 是一个接口，定义了请求的处理等方法。它的抽象实现类 AbstractProcessor 对一些协议共有的属性进行封装，没有对方法进行实现。具体的实现有 AJPProcessor、HTTP11Processor 等，这些具体实现类实现了特定协议的解析方法和请求处理方式。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20201113185929.png" alt="img"></p>
<p>从图中我们看到，EndPoint 接收到 Socket 连接后，生成一个 SocketProcessor 任务提交到线程池去处理，SocketProcessor 的 Run 方法会调用 Processor 组件去解析应用层协议，Processor 通过解析生成 Request 对象后，会调用 Adapter 的 Service 方法。</p>
<h4 id="3-2-2-Adapter"><a href="#3-2-2-Adapter" class="headerlink" title="3.2.2. Adapter"></a>3.2.2. Adapter</h4><p><strong>连接器通过适配器 Adapter 调用容器</strong>。</p>
<p>由于协议不同，客户端发过来的请求信息也不尽相同，Tomcat 定义了自己的 Request 类来适配这些请求信息。</p>
<p>ProtocolHandler 接口负责解析请求并生成 Tomcat Request 类。但是这个 Request 对象不是标准的 ServletRequest，也就意味着，不能用 Tomcat Request 作为参数来调用容器。Tomcat 的解决方案是引入 CoyoteAdapter，这是适配器模式的经典运用，连接器调用 CoyoteAdapter 的 Sevice 方法，传入的是 Tomcat Request 对象，CoyoteAdapter 负责将 Tomcat Request 转成 ServletRequest，再调用容器的 Service 方法。</p>
<h3 id="3-3-容器"><a href="#3-3-容器" class="headerlink" title="3.3. 容器"></a>3.3. 容器</h3><p>Tomcat 设计了 4 种容器，分别是 Engine、Host、Context 和 Wrapper。</p>
<ul>
<li><strong>Engine</strong> - Servlet 的顶层容器，包含一 个或多个 Host 子容器；</li>
<li><strong>Host</strong> - 虚拟主机，负责 web 应用的部署和 Context 的创建；</li>
<li><strong>Context</strong> - Web 应用上下文，包含多个 Wrapper，负责 web 配置的解析、管理所有的 Web 资源；</li>
<li><strong>Wrapper</strong> - 最底层的容器，是对 Servlet 的封装，负责 Servlet 实例的创 建、执行和销毁。</li>
</ul>
<h4 id="3-3-1-请求分发-Servlet-过程"><a href="#3-3-1-请求分发-Servlet-过程" class="headerlink" title="3.3.1. 请求分发 Servlet 过程"></a>3.3.1. 请求分发 Servlet 过程</h4><p>Tomcat 是怎么确定请求是由哪个 Wrapper 容器里的 Servlet 来处理的呢？答案是，Tomcat 是用 Mapper 组件来完成这个任务的。</p>
<p>举例来说，假如有一个网购系统，有面向网站管理人员的后台管理系统，还有面向终端客户的在线购物系统。这两个系统跑在同一个 Tomcat 上，为了隔离它们的访问域名，配置了两个虚拟域名：<code>manage.shopping.com</code>和<code>user.shopping.com</code>，网站管理人员通过<code>manage.shopping.com</code>域名访问 Tomcat 去管理用户和商品，而用户管理和商品管理是两个单独的 Web 应用。终端客户通过<code>user.shopping.com</code>域名去搜索商品和下订单，搜索功能和订单管理也是两个独立的 Web 应用。如下所示，演示了 url 应声 Servlet 的处理流程。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20201113192022.jpg" alt="img"></p>
<p>假如有用户访问一个 URL，比如图中的<code>http://user.shopping.com:8080/order/buy</code>，Tomcat 如何将这个 URL 定位到一个 Servlet 呢？</p>
<ol>
<li><strong>首先，根据协议和端口号选定 Service 和 Engine。</strong></li>
<li><strong>然后，根据域名选定 Host。</strong></li>
<li><strong>之后，根据 URL 路径找到 Context 组件。</strong></li>
<li><strong>最后，根据 URL 路径找到 Wrapper（Servlet）。</strong></li>
</ol>
<p>这个路由分发过程具体是怎么实现的呢？答案是使用 Pipeline-Valve 管道。</p>
<h4 id="3-3-2-Pipeline-Value"><a href="#3-3-2-Pipeline-Value" class="headerlink" title="3.3.2. Pipeline-Value"></a>3.3.2. Pipeline-Value</h4><p>Pipeline 可以理解为现实中的管道，Valve 为管道中的阀门，Request 和 Response 对象在管道中经过各个阀门的处理和控制。</p>
<p>Pipeline-Valve 是责任链模式，责任链模式是指在一个请求处理的过程中有很多处理者依次对请求进行处理，每个处理者负责做自己相应的处理，处理完之后将再调用下一个处理者继续处理。Valve 表示一个处理点，比如权限认证和记录日志。</p>
<p>先来了解一下 Valve 和 Pipeline 接口的设计：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/tools/tomcat/Pipeline%E4%B8%8EValve.png" alt="img"></p>
<ul>
<li>每一个容器都有一个 Pipeline 对象，只要触发这个 Pipeline 的第一个 Valve，这个容器里 Pipeline 中的 Valve 就都会被调用到。但是，不同容器的 Pipeline 是怎么链式触发的呢，比如 Engine 中 Pipeline 需要调用下层容器 Host 中的 Pipeline。</li>
<li>这是因为 Pipeline 中还有个 getBasic 方法。这个 BasicValve 处于 Valve 链表的末端，它是 Pipeline 中必不可少的一个 Valve，负责调用下层容器的 Pipeline 里的第一个 Valve。</li>
<li>Pipeline 中有 addValve 方法。Pipeline 中维护了 Valve 链表，Valve 可以插入到 Pipeline 中，对请求做某些处理。我们还发现 Pipeline 中没有 invoke 方法，因为整个调用链的触发是 Valve 来完成的，Valve 完成自己的处理后，调用 <code>getNext.invoke()</code> 来触发下一个 Valve 调用。</li>
<li>Valve 中主要的三个方法：<code>setNext</code>、<code>getNext</code>、<code>invoke</code>。Valve 之间的关系是单向链式结构，本身 <code>invoke</code> 方法中会调用下一个 Valve 的 <code>invoke</code> 方法。</li>
<li>各层容器对应的 basic valve 分别是 <code>StandardEngineValve</code>、<code>StandardHostValve</code>、 <code>StandardContextValve</code>、<code>StandardWrapperValve</code>。</li>
<li>由于 Valve 是一个处理点，因此 invoke 方法就是来处理请求的。注意到 Valve 中有 getNext 和 setNext 方法，因此我们大概可以猜到有一个链表将 Valve 链起来了。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/tools/tomcat/%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B.png" alt="img"></p>
<p>整个调用过程由连接器中的 Adapter 触发的，它会调用 Engine 的第一个 Valve：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connector.getService().getContainer().getPipeline().getFirst().invoke(request, response);</span><br></pre></td></tr></table></figure>

<h2 id="4-Tomcat-生命周期"><a href="#4-Tomcat-生命周期" class="headerlink" title="4. Tomcat 生命周期"></a>4. Tomcat 生命周期</h2><h3 id="4-1-Tomcat-的启动过程"><a href="#4-1-Tomcat-的启动过程" class="headerlink" title="4.1. Tomcat 的启动过程"></a>4.1. Tomcat 的启动过程</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20201118145455.png" alt="img"></p>
<ol>
<li>Tomcat 是一个 Java 程序，它的运行从执行 <code>startup.sh</code> 脚本开始。<code>startup.sh</code> 会启动一个 JVM 来运行 Tomcat 的启动类 <code>Bootstrap</code>。</li>
<li><code>Bootstrap</code> 会初始化 Tomcat 的类加载器并实例化 <code>Catalina</code>。</li>
<li><code>Catalina</code> 会通过 Digester 解析 <code>server.xml</code>，根据其中的配置信息来创建相应组件，并调用 <code>Server</code> 的 <code>start</code> 方法。</li>
<li><code>Server</code> 负责管理 <code>Service</code> 组件，它会调用 <code>Service</code> 的 <code>start</code> 方法。</li>
<li><code>Service</code> 负责管理 <code>Connector</code> 和顶层容器 <code>Engine</code>，它会调用 <code>Connector</code> 和 <code>Engine</code> 的 <code>start</code> 方法。</li>
</ol>
<h4 id="4-1-1-Catalina-组件"><a href="#4-1-1-Catalina-组件" class="headerlink" title="4.1.1. Catalina 组件"></a>4.1.1. Catalina 组件</h4><p>Catalina 的职责就是解析 server.xml 配置，并据此实例化 Server。接下来，调用 Server 组件的 init 方法和 start 方法，将 Tomcat 启动起来。</p>
<p>Catalina 还需要处理各种“异常”情况，比如当我们通过“Ctrl + C”关闭 Tomcat 时，Tomcat 将如何优雅的停止并且清理资源呢？因此 Catalina 在 JVM 中注册一个“关闭钩子”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1. 如果持有的 Server 实例为空，就解析 server.xml 创建出来</span></span><br><span class="line">    <span class="keyword">if</span> (getServer() == <span class="literal">null</span>) &#123;</span><br><span class="line">        load();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 如果创建失败，报错退出</span></span><br><span class="line">    <span class="keyword">if</span> (getServer() == <span class="literal">null</span>) &#123;</span><br><span class="line">        log.fatal(sm.getString(<span class="string">&quot;catalina.noServer&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 启动 Server</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        getServer().start();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并注册关闭钩子</span></span><br><span class="line">    <span class="keyword">if</span> (useShutdownHook) &#123;</span><br><span class="line">        <span class="keyword">if</span> (shutdownHook == <span class="literal">null</span>) &#123;</span><br><span class="line">            shutdownHook = <span class="keyword">new</span> <span class="title class_">CatalinaShutdownHook</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(shutdownHook);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用 await 方法监听停止请求</span></span><br><span class="line">    <span class="keyword">if</span> (await) &#123;</span><br><span class="line">        await();</span><br><span class="line">        stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么需要关闭钩子？</p>
<p>如果我们需要在 JVM 关闭时做一些清理工作，比如将缓存数据刷到磁盘上，或者清理一些临时文件，可以向 JVM 注册一个“关闭钩子”。“关闭钩子”其实就是一个线程，JVM 在停止之前会尝试执行这个线程的 <code>run</code> 方法。</p>
<p>Tomcat 的“关闭钩子”—— <code>CatalinaShutdownHook</code> 做了些什么呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">class</span> <span class="title class_">CatalinaShutdownHook</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (getServer() != <span class="literal">null</span>) &#123;</span><br><span class="line">                Catalina.<span class="built_in">this</span>.stop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Tomcat 的“关闭钩子”实际上就执行了 <code>Server</code> 的 <code>stop</code> 方法，<code>Server</code> 的 <code>stop</code> 方法会释放和清理所有的资源。</p>
<h4 id="4-1-2-Server-组件"><a href="#4-1-2-Server-组件" class="headerlink" title="4.1.2. Server 组件"></a>4.1.2. Server 组件</h4><p>Server 组件的具体实现类是 StandardServer，Server 继承了 LifeCycleBase，它的生命周期被统一管理，并且它的子组件是 Service，因此它还需要管理 Service 的生命周期，也就是说在启动时调用 Service 组件的启动方法，在停止时调用它们的停止方法。Server 在内部维护了若干 Service 组件，它是以数组来保存的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addService</span><span class="params">(Service service)</span> &#123;</span><br><span class="line"></span><br><span class="line">    service.setServer(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (servicesLock) &#123;</span><br><span class="line">        <span class="comment">// 创建一个长度 +1 的新数组</span></span><br><span class="line">        Service results[] = <span class="keyword">new</span> <span class="title class_">Service</span>[services.length + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将老的数据复制过去</span></span><br><span class="line">        System.arraycopy(services, <span class="number">0</span>, results, <span class="number">0</span>, services.length);</span><br><span class="line">        results[services.length] = service;</span><br><span class="line">        services = results;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动 Service 组件</span></span><br><span class="line">        <span class="keyword">if</span> (getState().isAvailable()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                service.start();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 触发监听事件</span></span><br><span class="line">        support.firePropertyChange(<span class="string">&quot;service&quot;</span>, <span class="literal">null</span>, service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Server 并没有一开始就分配一个很长的数组，而是在添加的过程中动态地扩展数组长度，当添加一个新的 Service 实例时，会创建一个新数组并把原来数组内容复制到新数组，这样做的目的其实是为了节省内存空间。</p>
<p>除此之外，Server 组件还有一个重要的任务是启动一个 Socket 来监听停止端口，这就是为什么你能通过 shutdown 命令来关闭 Tomcat。不知道你留意到没有，上面 Caralina 的启动方法的最后一行代码就是调用了 Server 的 await 方法。</p>
<p>在 await 方法里会创建一个 Socket 监听 8005 端口，并在一个死循环里接收 Socket 上的连接请求，如果有新的连接到来就建立连接，然后从 Socket 中读取数据；如果读到的数据是停止命令“SHUTDOWN”，就退出循环，进入 stop 流程。</p>
<h4 id="4-1-3-Service-组件"><a href="#4-1-3-Service-组件" class="headerlink" title="4.1.3. Service 组件"></a>4.1.3. Service 组件</h4><p>Service 组件的具体实现类是 StandardService。</p>
<p>【源码】StandardService 源码定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StandardService</span> <span class="keyword">extends</span> <span class="title class_">LifecycleBase</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="comment">// 名字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Server 实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Server</span> <span class="variable">server</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接器数组</span></span><br><span class="line">    <span class="keyword">protected</span> Connector connectors[] = <span class="keyword">new</span> <span class="title class_">Connector</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">connectorsLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对应的 Engine 容器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Engine</span> <span class="variable">engine</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 映射器及其监听器</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">Mapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mapper</span>();</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">MapperListener</span> <span class="variable">mapperListener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapperListener</span>(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StandardService 继承了 LifecycleBase 抽象类。</p>
<p>StandardService 维护了一个 MapperListener 用于支持 Tomcat 热部署。当 Web 应用的部署发生变化时，Mapper 中的映射信息也要跟着变化，MapperListener 就是一个监听器，它监听容器的变化，并把信息更新到 Mapper 中，这是典型的观察者模式。</p>
<p>作为“管理”角色的组件，最重要的是维护其他组件的生命周期。此外在启动各种组件时，要注意它们的依赖关系，也就是说，要注意启动的顺序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 触发启动监听器</span></span><br><span class="line">    setState(LifecycleState.STARTING);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 先启动 Engine，Engine 会启动它子容器</span></span><br><span class="line">    <span class="keyword">if</span> (engine != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (engine) &#123;</span><br><span class="line">            engine.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 再启动 Mapper 监听器</span></span><br><span class="line">    mapperListener.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 最后启动连接器，连接器会启动它子组件，比如 Endpoint</span></span><br><span class="line">    <span class="keyword">synchronized</span> (connectorsLock) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Connector connector: connectors) &#123;</span><br><span class="line">            <span class="keyword">if</span> (connector.getState() != LifecycleState.FAILED) &#123;</span><br><span class="line">                connector.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从启动方法可以看到，Service 先启动了 Engine 组件，再启动 Mapper 监听器，最后才是启动连接器。这很好理解，因为内层组件启动好了才能对外提供服务，才能启动外层的连接器组件。而 Mapper 也依赖容器组件，容器组件启动好了才能监听它们的变化，因此 Mapper 和 MapperListener 在容器组件之后启动。组件停止的顺序跟启动顺序正好相反的，也是基于它们的依赖关系。</p>
<h4 id="4-1-4-Engine-组件"><a href="#4-1-4-Engine-组件" class="headerlink" title="4.1.4. Engine 组件"></a>4.1.4. Engine 组件</h4><p>Engine 本质是一个容器，因此它继承了 ContainerBase 基类，并且实现了 Engine 接口。</p>
<h3 id="4-2-Web-应用的部署方式"><a href="#4-2-Web-应用的部署方式" class="headerlink" title="4.2. Web 应用的部署方式"></a>4.2. Web 应用的部署方式</h3><p>注：catalina.home：安装目录;catalina.base：工作目录;默认值 user.dir</p>
<ul>
<li>Server.xml 配置 Host 元素，指定 appBase 属性，默认$catalina.base&#x2F;webapps&#x2F;</li>
<li>Server.xml 配置 Context 元素，指定 docBase，元素，指定 web 应用的路径</li>
<li>自定义配置：在$catalina.base&#x2F;EngineName&#x2F;HostName&#x2F;XXX.xml 配置 Context 元素</li>
</ul>
<p>HostConfig 监听了 StandardHost 容器的事件，在 start 方法中解析上述配置文件：</p>
<ul>
<li>扫描 appbase 路径下的所有文件夹和 war 包，解析各个应用的 META-INF&#x2F;context.xml，并 创建 StandardContext，并将 Context 加入到 Host 的子容器中。</li>
<li>解析$catalina.base&#x2F;EngineName&#x2F;HostName&#x2F;下的所有 Context 配置，找到相应 web 应 用的位置，解析各个应用的 META-INF&#x2F;context.xml，并创建 StandardContext，并将 Context 加入到 Host 的子容器中。</li>
</ul>
<p>注：</p>
<ul>
<li>HostConfig 并没有实际解析 Context.xml，而是在 ContextConfig 中进行的。</li>
<li>HostConfig 中会定期检查 watched 资源文件(context.xml 配置文件)</li>
</ul>
<p>ContextConfig 解析 context.xml 顺序：</p>
<ul>
<li>先解析全局的配置 config&#x2F;context.xml</li>
<li>然后解析 Host 的默认配置 EngineName&#x2F;HostName&#x2F;context.xml.default</li>
<li>最后解析应用的 META-INF&#x2F;context.xml</li>
</ul>
<p>ContextConfig 解析 web.xml 顺序：</p>
<ul>
<li>先解析全局的配置 config&#x2F;web.xml</li>
<li>然后解析 Host 的默认配置 EngineName&#x2F;HostName&#x2F;web.xml.default 接着解析应用的 MEB-INF&#x2F;web.xml</li>
<li>扫描应用 WEB-INF&#x2F;lib&#x2F;下的 jar 文件，解析其中的 META-INF&#x2F;web-fragment.xml 最后合并 xml 封装成 WebXml，并设置 Context</li>
</ul>
<p>注：</p>
<ul>
<li>扫描 web 应用和 jar 中的注解(Filter、Listener、Servlet)就是上述步骤中进行的。</li>
<li>容器的定期执行：backgroundProcess，由 ContainerBase 来实现的，并且只有在顶层容器 中才会开启线程。(backgroundProcessorDelay&#x3D;10 标志位来控制)</li>
</ul>
<h3 id="4-3-LifeCycle"><a href="#4-3-LifeCycle" class="headerlink" title="4.3. LifeCycle"></a>4.3. LifeCycle</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20201118105012.png" alt="img"></p>
<h4 id="4-3-1-请求处理过程"><a href="#4-3-1-请求处理过程" class="headerlink" title="4.3.1. 请求处理过程"></a>4.3.1. 请求处理过程</h4><div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/tools/tomcat/请求处理过程.png" width="600">
</div>

<ol>
<li>根据 server.xml 配置的指定的 connector 以及端口监听 http、或者 ajp 请求</li>
<li>请求到来时建立连接,解析请求参数,创建 Request 和 Response 对象,调用顶层容器 pipeline 的 invoke 方法</li>
<li>容器之间层层调用,最终调用业务 servlet 的 service 方法</li>
<li>Connector 将 response 流中的数据写到 socket 中</li>
</ol>
<h3 id="4-4-Connector-流程"><a href="#4-4-Connector-流程" class="headerlink" title="4.4. Connector 流程"></a>4.4. Connector 流程</h3><div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/tools/tomcat/connector.png" width="600">
</div>

<h4 id="4-4-1-阻塞-IO"><a href="#4-4-1-阻塞-IO" class="headerlink" title="4.4.1. 阻塞 IO"></a>4.4.1. 阻塞 IO</h4><div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/tools/tomcat/阻塞IO.png" width="600">
</div>

<h4 id="4-4-2-非阻塞-IO"><a href="#4-4-2-非阻塞-IO" class="headerlink" title="4.4.2. 非阻塞 IO"></a>4.4.2. 非阻塞 IO</h4><div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/tools/tomcat/非阻塞IO.png" width="600">
</div>

<h4 id="4-4-3-IO-多路复用"><a href="#4-4-3-IO-多路复用" class="headerlink" title="4.4.3. IO 多路复用"></a>4.4.3. IO 多路复用</h4><div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/tools/tomcat/IO多路复用.png" width="600">
</div>

<p>阻塞与非阻塞的区别在于进行读操作和写操作的系统调用时，如果此时内核态没有数据可读或者没有缓冲空间可写时，是否阻塞。</p>
<p>IO 多路复用的好处在于可同时监听多个 socket 的可读和可写事件，这样就能使得应用可以同时监听多个 socket，释放了应用线程资源。</p>
<h4 id="4-4-4-Tomcat-各类-Connector-对比"><a href="#4-4-4-Tomcat-各类-Connector-对比" class="headerlink" title="4.4.4. Tomcat 各类 Connector 对比"></a>4.4.4. Tomcat 各类 Connector 对比</h4><div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/tools/tomcat/Tomcat各类Connector对比.jpg" width="500">
</div>

<ul>
<li>JIO：用 java.io 编写的 TCP 模块，阻塞 IO</li>
<li>NIO：用 java.nio 编写的 TCP 模块，非阻塞 IO，（IO 多路复用）</li>
<li>APR：全称 Apache Portable Runtime，使用 JNI 的方式来进行读取文件以及进行网络传输</li>
</ul>
<p>Apache Portable Runtime 是一个高度可移植的库，它是 Apache HTTP Server 2.x 的核心。 APR 具有许多用途，包括访问高级 IO 功能（如 sendfile，epoll 和 OpenSSL），操作系统级功能（随机数生成，系统状态等）和本地进程处理（共享内存，NT 管道和 Unix 套接字）。</p>
<p>表格中字段含义说明：</p>
<ul>
<li>Support Polling - 是否支持基于 IO 多路复用的 socket 事件轮询</li>
<li>Polling Size - 轮询的最大连接数</li>
<li>Wait for next Request - 在等待下一个请求时，处理线程是否释放，BIO 是没有释放的，所以在 keep-alive&#x3D;true 的情况下处理的并发连接数有限</li>
<li>Read Request Headers - 由于 request header 数据较少，可以由容器提前解析完毕，不需要阻塞</li>
<li>Read Request Body - 读取 request body 的数据是应用业务逻辑的事情，同时 Servlet 的限制，是需要阻塞读取的</li>
<li>Write Response - 跟读取 request body 的逻辑类似，同样需要阻塞写</li>
</ul>
<p><strong>NIO 处理相关类</strong></p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/tools/tomcat/NIO处理相关类.jpg" width="500">
</div>

<p>Poller 线程从 EventQueue 获取 PollerEvent，并执行 PollerEvent 的 run 方法，调用 Selector 的 select 方法，如果有可读的 Socket 则创建 Http11NioProcessor，放入到线程池中执行；</p>
<p>CoyoteAdapter 是 Connector 到 Container 的适配器，Http11NioProcessor 调用其提供的 service 方法，内部创建 Request 和 Response 对象，并调用最顶层容器的 Pipeline 中的第一个 Valve 的 invoke 方法</p>
<p>Mapper 主要处理 http url 到 servlet 的映射规则的解析，对外提供 map 方法</p>
<h3 id="4-5-Comet"><a href="#4-5-Comet" class="headerlink" title="4.5. Comet"></a>4.5. Comet</h3><p>Comet 是一种用于 web 的推送技术，能使服务器实时地将更新的信息传送到客户端，而无须客户端发出请求<br>在 WebSocket 出来之前，如果不适用 comet，只能通过浏览器端轮询 Server 来模拟实现服务器端推送。<br>Comet 支持 servlet 异步处理 IO，当连接上数据可读时触发事件，并异步写数据(阻塞)</p>
<p>Tomcat 要实现 Comet，只需继承 HttpServlet 同时，实现 CometProcessor 接口</p>
<ul>
<li>Begin：新的请求连接接入调用，可进行与 Request 和 Response 相关的对象初始化操作，并保存 response 对象，用于后续写入数据</li>
<li>Read：请求连接有数据可读时调用</li>
<li>End：当数据可用时，如果读取到文件结束或者 response 被关闭时则被调用</li>
<li>Error：在连接上发生异常时调用，数据读取异常、连接断开、处理异常、socket 超时</li>
</ul>
<p>Note：</p>
<ul>
<li>Read：在 post 请求有数据，但在 begin 事件中没有处理，则会调用 read，如果 read 没有读取数据，在会触发 Error 回调，关闭 socket</li>
<li>End：当 socket 超时，并且 response 被关闭时也会调用；server 被关闭时调用</li>
<li>Error：除了 socket 超时不会关闭 socket，其他都会关闭 socket</li>
<li>End 和 Error 时间触发时应关闭当前 comet 会话，即调用 CometEvent 的 close 方法<br>Note：在事件触发时要做好线程安全的操作</li>
</ul>
<h3 id="4-6-异步-Servlet"><a href="#4-6-异步-Servlet" class="headerlink" title="4.6. 异步 Servlet"></a>4.6. 异步 Servlet</h3><div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/tools/tomcat/传统Servlet处理流程.png" >
</div>

<p>传统流程：</p>
<ul>
<li>首先，Servlet 接收到请求之后，request 数据解析；</li>
<li>接着，调用业务接口的某些方法，以完成业务处理；</li>
<li>最后，根据处理的结果提交响应，Servlet 线程结束</li>
</ul>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/tools/tomcat/异步Servlet处理流程.png" >
</div>

<p>异步处理流程：</p>
<ul>
<li>客户端发送一个请求</li>
<li>Servlet 容器分配一个线程来处理容器中的一个 servlet</li>
<li>servlet 调用 request.startAsync()，保存 AsyncContext, 然后返回</li>
<li>任何方式存在的容器线程都将退出，但是 response 仍然保持开放</li>
<li>业务线程使用保存的 AsyncContext 来完成响应（线程池）</li>
<li>客户端收到响应</li>
</ul>
<p>Servlet 线程将请求转交给一个异步线程来执行业务处理，线程本身返回至容器，此时 Servlet 还没有生成响应数据，异步线程处理完业务以后，可以直接生成响应数据（异步线程拥有 ServletRequest 和 ServletResponse 对象的引用）</p>
<p><strong>为什么 web 应用中支持异步？</strong></p>
<p>推出异步，主要是针对那些比较耗时的请求：比如一次缓慢的数据库查询，一次外部 REST API 调用, 或者是其他一些 I&#x2F;O 密集型操作。这种耗时的请求会很快的耗光 Servlet 容器的线程池，继而影响可扩展性。</p>
<p>Note：从客户端的角度来看，request 仍然像任何其他的 HTTP 的 request-response 交互一样，只是耗费了更长的时间而已</p>
<p><strong>异步事件监听</strong></p>
<ul>
<li>onStartAsync：Request 调用 startAsync 方法时触发</li>
<li>onComplete：syncContext 调用 complete 方法时触发</li>
<li>onError：处理请求的过程出现异常时触发</li>
<li>onTimeout：socket 超时触发</li>
</ul>
<p>Note :<br>onError&#x2F; onTimeout 触发后，会紧接着回调 onComplete<br>onComplete 执行后，就不可再操作 request 和 response</p>
<h2 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5. 参考资料"></a>5. 参考资料</h2><ul>
<li><p><strong>官方</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="http://tomcat.apache.org/">Tomcat 官方网站</a></li>
<li><a target="_blank" rel="noopener" href="http://wiki.apache.org/tomcat/FrontPage">Tomcat Wiki</a></li>
<li><a target="_blank" rel="noopener" href="http://tomee.apache.org/">Tomee 官方网站</a></li>
</ul>
</li>
<li><p><strong>文章</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/basic_app_embedded_tomcat/basic_app-tomcat-embedded.html">Creating a Web App with Bootstrap and Tomcat Embedded</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/58eb5fdda0bb9f00692a78fc">Tomcat 组成与工作原理</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/index.html">Tomcat 工作原理</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat2/index.html?ca=drs-">Tomcat 设计模式分析</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/12/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/47/">47</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/14/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备2021160229号 </a>
  </div>
  <div class="copyright">
    &copy; 2015 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">李狗蛋</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">3.5m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">53:28</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/yiyirushi/" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.1/dist/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  




<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>

</body>
</html>
